window.DOMPurifyCopy = window.DOMPurify ? window.DOMPurify : undefined;!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.ZWAF=t()}(this,function(){"use strict";function e(e,t,n,r,o,i,a){if(r||!(t in e))return Object.defineProperty&&function(){try{return Object.defineProperty({},"x",{}),1}catch(e){return}}()?(o=!0===o,i=!0===i,a=!0===a,Object.defineProperty(e,t,{value:n,writable:o,configurable:i,enumerable:a})):(e[t]=n,e)}function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var t=(function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e}(n,[{key:"debug",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&this.level===this.LEVELS.DEBUG){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).debug.apply(e,n.concat([performance.now()]))}}},{key:"info",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.INFO)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).log.apply(e,n.concat([performance.now()]))}}},{key:"warn",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.WARN)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).warn.apply(e,n.concat([performance.now()]))}}},{key:"error",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.ERROR)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).error.apply(e,n.concat([performance.now()]))}}}]),n);function n(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),this.LEVELS={NONE:-1,DEBUG:0,INFO:1,WARN:2,ERROR:3},e===this.LEVELS.NONE||e===this.LEVELS.DEBUG||e===this.LEVELS.INFO||e===this.LEVELS.WARN||e===this.LEVELS.ERROR?this.level=e:this.level=this.LEVELS.ERROR}var o=window&&window.ZWAF?window.ZWAF:{version:"7.0.0"},i=new t;o.defineProperty||(o.defineProperty=e),o.logger||(o.logger=i),o["7_0_0"]||(o["7_0_0"]={version:"7.0.0",defineProperty:e,logger:i});var a=!1,t={log:function(){if(window&&window.console&&window.console.log&&window.navigator&&window.navigator.userAgent&&!a){var e=window.navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(a=!0,e&&e[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;");window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}}};function B(e,t){if(e instanceof Object)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function H(e,t){var n;(n=Array.prototype.splice).call.apply(n,[e,e.length,0].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t)))}function V(e,t){if(!e||e.constructor===Object)return e;for(var n={},r=0;r<e.length;r++){var o=e[r];n[o[t]]=o}return n}function W(e){if(e&&e.constructor===String)return e.toLowerCase();if(e.constructor===Array)for(var t=0;t<e.length;t++)e[t]=W(e[t]);return e}function z(e,t,n,r){if(Array.isArray(e))for(var o=0,i=e.length;o<i;o++)l(e,t,o,n);else for(var a in e)r&&-1!==r.indexOf(a)||l(e,t,a,n);return t}function l(e,t,n,r){var o;r?(o=e[n],Array.isArray(o)?(t[n]||(t[n]=[]),z(o,t[n],r)):o instanceof Object?(t[n]||(t[n]={}),z(o,t[n],r)):t[n]=o):t[n]=e[n]}function c(e,t,n){var r=2<arguments.length&&void 0!==n?n:{},r=Object.assign({path:"/",SameSite:"lax","max-age":864e7},r);if(encodeURIComponent){var o,i=encodeURIComponent(e)+"="+encodeURIComponent(t);for(o in r){i+="; "+o;var a=r[o];!0!==a&&(i+="="+a)}document.cookie=i}}function s(e,t){c(e,"",{path:1<arguments.length&&void 0!==t?t:"/","max-age":-1})}function u(e){return!!function(e){e+="=";var t=document.cookie,r=void 0;return t.split("; ").forEach(function(t){if(void 0===r){var n=void 0;try{decodeURIComponent&&(n=decodeURIComponent(t))}catch(e){n=t,ZWAF&&ZWAF.logger&&ZWAF.logger.warn&&ZWAF.logger.warn("Error while trying to decode Cookie value!")}0===n.indexOf(e)&&(r=n.substring(e.length))}}),r}(e)}"7.0.0"!==o.version||o.Console||o.defineProperty(o,"Console",t,!0,!1,!1,!0),o["7_0_0"].Console||o.defineProperty(o["7_0_0"],"Console",t,!0,!1,!1,!0);["_zcsr_tmp","com_chat_owner","com_avcliq_owner","wms.agent"].some(u)&&o&&o["7_0_0"]&&o["7_0_0"].Console&&o["7_0_0"].Console.log();var d="_zwaf_ua",i={init:function(){s(d);var e=!!window.ulaa,t=navigator&&navigator.brave&&"function"==typeof navigator.brave.isBrave;e?c(d,"Ulaa"):t?c(d,"Brave"):window&&window.addEventListener("load",function(){window.setTimeout(function(){window.getComputedStyle(window.document.documentElement).getPropertyValue("--arc-palette-background")&&c(d,"Arc")},1e3)})},disable:function(){s(d)}};"7.0.0"!==o.version||o.UAIdentification||o.defineProperty(o,"UAIdentification",i,!0,!1,!1,!0),o["7_0_0"].UAIdentification||o.defineProperty(o["7_0_0"],"UAIdentification",i,!0,!1,!1,!0),o&&o["7_0_0"]&&o["7_0_0"].UAIdentification&&o["7_0_0"].UAIdentification.init();var f,p=Object.hasOwnProperty,m=Object.setPrototypeOf,A=Object.isFrozen,T=Object.getPrototypeOf,_=Object.getOwnPropertyDescriptor,je=Object.freeze,t=Object.seal,E=Object.create,i="undefined"!=typeof Reflect&&Reflect,h=(h=i.apply)||function(e,t,n){return e.apply(t,n)},je=je||function(e){return e},t=t||function(e){return e},N=(N=i.construct)||function(e,t){return new(Function.prototype.bind.apply(e,[null].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t))))},Xe=g(Array.prototype.forEach),Ye=g(Array.prototype.pop),Ke=g(Array.prototype.push),Qe=g(String.prototype.toLowerCase),qe=g(String.prototype.toString),Ze=g(String.prototype.match),$e=g(String.prototype.replace),Je=g(String.prototype.indexOf),et=g(String.prototype.trim),tt=g(RegExp.prototype.test),nt=(f=TypeError,function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return N(f,t)});function rt(e){return"number"==typeof e&&isNaN(e)}function g(o){return function(e){for(var t=arguments.length,n=Array(1<t?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return h(o,e,n)}}function ot(e,t,n){n=n||Qe,m&&m(e,null);for(var r=t.length;r--;){var o,i=t[r];"string"!=typeof i||(o=n(i))!==i&&(A(t)||(t[r]=o),i=o),e[i]=!0}return e}function it(e){var t=E(null),n=void 0;for(n in e)!0===h(p,e,[n])&&(t[n]=e[n]);return t}function at(e,t){for(;null!==e;){var n=_(e,t);if(n){if(n.get)return g(n.get);if("function"==typeof n.value)return g(n.value)}e=T(e)}return function(e){return null}}var lt=je(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),ct=je(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),st=je(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),ut=je(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),dt=je(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),ft=je(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),pt=je(["#text"]),mt=je(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),At=je(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),Tt=je(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),_t=je(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),Et=t(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ht=t(/<%[\w\W]*|[\w\W]*%>/gm),Nt=t(/\${[\w\W]*}/gm),gt=t(/^data-[\-\w.\u00B7-\uFFFF]/),Lt=t(/^aria-[\-\w]+$/),Rt=t(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),St=t(/^(?:\w+script|data):/i),Ot=t(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),yt=t(/^html$/i),vt=t(/^[a-z][.\w]*(-[.\w]+)+$/i),It="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function wt(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var bt=function(){return"undefined"==typeof window?null:window},Dt=function(e,t){if("object"!==(void 0===e?"undefined":It(e))||"function"!=typeof e.createPolicy)return null;var n=null,r="data-tt-policy-suffix",n="dompurify"+((n=t.currentScript&&t.currentScript.hasAttribute(r)?t.currentScript.getAttribute(r):n)?"#"+n:"");try{return e.createPolicy(n,{createHTML:function(e){return e},createScriptURL:function(e){return e}})}catch(e){return null}};var i=function t(e){function u(e){return t(e)}var c=0<arguments.length&&void 0!==e?e:bt();if(u.version="2.5.4",u.removed=[],!c||!c.document||9!==c.document.nodeType)return u.isSupported=!1,u;var s=c.document,o=c.document,d=c.DocumentFragment,n=c.HTMLTemplateElement,f=c.Node,l=c.Element,r=c.NodeFilter,e=c.NamedNodeMap,i=void 0===e?c.NamedNodeMap||c.MozNamedAttrMap:e,a=c.HTMLFormElement,p=c.DOMParser,m=c.trustedTypes,e=l.prototype,A=at(e,"cloneNode"),T=at(e,"nextSibling"),_=at(e,"childNodes"),E=at(e,"parentNode");"function"!=typeof n||(g=o.createElement("template")).content&&g.content.ownerDocument&&(o=g.content.ownerDocument);var h=Dt(m,s),N=h?h.createHTML(""):"",g=o,L=g.implementation,R=g.createNodeIterator,S=g.createDocumentFragment,O=g.getElementsByTagName,y=s.importNode,g={};try{g=it(o).documentMode?o.documentMode:{}}catch(e){}var v={};u.isSupported="function"==typeof E&&L&&void 0!==L.createHTMLDocument&&9!==g;function I(e){return e instanceof RegExp||e instanceof Function}function w(e){ye&&ye===e||(e=it(e=e&&"object"===(void 0===e?"undefined":It(e))?e:{}),Re=-1===Se.indexOf(e.PARSER_MEDIA_TYPE)?"text/html":e.PARSER_MEDIA_TYPE,Oe="application/xhtml+xml"===Re?qe:Qe,B="ALLOWED_TAGS"in e?ot({},e.ALLOWED_TAGS,Oe):H,W="ALLOWED_ATTR"in e?ot({},e.ALLOWED_ATTR,Oe):z,ge="ALLOWED_NAMESPACES"in e?ot({},e.ALLOWED_NAMESPACES,qe):Le,me="ADD_URI_SAFE_ATTR"in e?ot(it(Ae),e.ADD_URI_SAFE_ATTR,Oe):Ae,fe="ADD_DATA_URI_TAGS"in e?ot(it(pe),e.ADD_DATA_URI_TAGS,Oe):pe,ue="FORBID_CONTENTS"in e?ot({},e.FORBID_CONTENTS,Oe):de,X="FORBID_TAGS"in e?ot({},e.FORBID_TAGS,Oe):{},Y="FORBID_ATTR"in e?ot({},e.FORBID_ATTR,Oe):{},b="USE_PROFILES"in e&&e.USE_PROFILES,K=!1!==e.ALLOW_ARIA_ATTR,Q=!1!==e.ALLOW_DATA_ATTR,q=e.ALLOW_UNKNOWN_PROTOCOLS||!1,Z=!1!==e.ALLOW_SELF_CLOSE_IN_ATTR,$=e.SAFE_FOR_TEMPLATES||!1,J=!1!==e.SAFE_FOR_XML,ee=e.WHOLE_DOCUMENT||!1,re=e.RETURN_DOM||!1,oe=e.RETURN_DOM_FRAGMENT||!1,ie=e.RETURN_TRUSTED_TYPE||!1,V=!1!==e.DONT_TRIM,ne=e.FORCE_BODY||!1,ae=!1!==e.SANITIZE_DOM,le=e.SANITIZE_NAMED_PROPS||!1,ce=!1!==e.KEEP_CONTENT,se=e.IN_PLACE||!1,G=e.ALLOWED_URI_REGEXP||G,he=e.NAMESPACE||Ee,j=e.CUSTOM_ELEMENT_HANDLING||{},e.CUSTOM_ELEMENT_HANDLING&&I(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(j.tagNameCheck=e.CUSTOM_ELEMENT_HANDLING.tagNameCheck),e.CUSTOM_ELEMENT_HANDLING&&I(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(j.attributeNameCheck=e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),e.CUSTOM_ELEMENT_HANDLING&&"boolean"==typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(j.allowCustomizedBuiltInElements=e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),$&&(Q=!1),oe&&(re=!0),b&&(B=ot({},[].concat(wt(pt))),W=[],!0===b.html&&(ot(B,lt),ot(W,mt)),!0===b.svg&&(ot(B,ct),ot(W,At),ot(W,_t)),!0===b.svgFilters&&(ot(B,st),ot(W,At),ot(W,_t)),!0===b.mathMl&&(ot(B,dt),ot(W,Tt),ot(W,_t))),e.ADD_TAGS&&ot(B=B===H?it(B):B,e.ADD_TAGS,Oe),e.ADD_ATTR&&ot(W=W===z?it(W):W,e.ADD_ATTR,Oe),e.ADD_URI_SAFE_ATTR&&ot(me,e.ADD_URI_SAFE_ATTR,Oe),e.FORBID_CONTENTS&&ot(ue=ue===de?it(ue):ue,e.FORBID_CONTENTS,Oe),ce&&(B["#text"]=!0),ee&&ot(B,["html","head","body"]),B.table&&(ot(B,["tbody"]),delete X.tbody),je&&je(e),ye=e)}var b,D=Et,C=ht,U=Nt,P=gt,x=Lt,k=St,M=Ot,F=vt,G=Rt,B=null,H=ot({},[].concat(wt(lt),wt(ct),wt(st),wt(dt),wt(pt))),V=!0,W=null,z=ot({},[].concat(wt(mt),wt(At),wt(Tt),wt(_t))),j=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),X=null,Y=null,K=!0,Q=!0,q=!1,Z=!0,$=!1,J=!0,ee=!1,te=!1,ne=!1,re=!1,oe=!1,ie=!1,ae=!0,le=!1,ce=!0,se=!1,ue=null,de=ot({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),fe=null,pe=ot({},["audio","video","img","source","image","track"]),me=null,Ae=ot({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),Te="http://www.w3.org/1998/Math/MathML",_e="http://www.w3.org/2000/svg",Ee="http://www.w3.org/1999/xhtml",he=Ee,Ne=!1,ge=null,Le=ot({},[Te,_e,Ee],qe),Re=void 0,Se=["application/xhtml+xml","text/html"],Oe=void 0,ye=null,ve=o.createElement("form"),Ie=ot({},["mi","mo","mn","ms","mtext"]),we=ot({},["foreignobject","annotation-xml"]),be=ot({},["title","style","font","a","script"]),De=ot({},ct);ot(De,st),ot(De,ut);var Ce=ot({},dt);ot(Ce,ft);function Ue(t){Ke(u.removed,{element:t});try{t.parentNode.removeChild(t)}catch(e){try{t.outerHTML=N}catch(e){t.remove()}}}function Pe(e,t){try{Ke(u.removed,{attribute:t.getAttributeNode(e),from:t})}catch(e){Ke(u.removed,{attribute:null,from:t})}if(t.removeAttribute(e),"is"===e&&!W[e])if(re||oe)try{Ue(t)}catch(e){}else try{t.setAttribute(e,"")}catch(e){}}function xe(e){var t=void 0,n=void 0;ne?e="<remove></remove>"+e:n=(r=Ze(e,/^[\r\n\t ]+/))&&r[0],"application/xhtml+xml"===Re&&he===Ee&&(e='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+e+"</body></html>");var r=h?h.createHTML(e):e;if(he===Ee)try{t=(new p).parseFromString(r,Re)}catch(e){}if(!t||!t.documentElement){t=L.createDocument(he,"template",null);try{t.documentElement.innerHTML=Ne?N:r}catch(e){}}return r=t.body||t.documentElement,e&&n&&r.insertBefore(o.createTextNode(n),r.childNodes[0]||null),he===Ee?O.call(t,ee?"html":"body")[0]:ee?t.documentElement:r}function ke(e){return R.call(e.ownerDocument||e,e,r.SHOW_ELEMENT|r.SHOW_COMMENT|r.SHOW_TEXT|r.SHOW_PROCESSING_INSTRUCTION|r.SHOW_CDATA_SECTION,null,!1)}function Me(e){return e instanceof a&&(void 0!==e.__depth&&"number"!=typeof e.__depth||void 0!==e.__removalCount&&"number"!=typeof e.__removalCount||"string"!=typeof e.nodeName||"string"!=typeof e.textContent||"function"!=typeof e.removeChild||!(e.attributes instanceof i)||"function"!=typeof e.removeAttribute||"function"!=typeof e.setAttribute||"string"!=typeof e.namespaceURI||"function"!=typeof e.insertBefore||"function"!=typeof e.hasChildNodes)}function Fe(e){return"object"===(void 0===f?"undefined":It(f))?e instanceof f:e&&"object"===(void 0===e?"undefined":It(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName}function Ge(e,t,n){v[e]&&Xe(v[e],function(e){e.call(u,t,n,ye)})}function Be(e){var t;if(Ge("beforeSanitizeElements",e,null),Me(e))return Ue(e),1;if(tt(/[\u0080-\uFFFF]/,e.nodeName))return Ue(e),1;var n=Oe(e.nodeName);if(Ge("uponSanitizeElement",e,{tagName:n,allowedTags:B}),e.hasChildNodes()&&!Fe(e.firstElementChild)&&(!Fe(e.content)||!Fe(e.content.firstElementChild))&&tt(/<[/\w]/g,e.innerHTML)&&tt(/<[/\w]/g,e.textContent))return Ue(e),1;if("select"===n&&tt(/<template/i,e.innerHTML))return Ue(e),1;if(7===e.nodeType)return Ue(e),1;if(J&&8===e.nodeType&&tt(/<[/\w]/g,e.data))return Ue(e),1;if(B[n]&&!X[n])return e instanceof l&&!function(e){var t=E(e);t&&t.tagName||(t={namespaceURI:he,tagName:"template"});var n=Qe(e.tagName),r=Qe(t.tagName);return ge[e.namespaceURI]&&(e.namespaceURI===_e?t.namespaceURI===Ee?"svg"===n:t.namespaceURI===Te?"svg"===n&&("annotation-xml"===r||Ie[r]):Boolean(De[n]):e.namespaceURI===Te?t.namespaceURI===Ee?"math"===n:t.namespaceURI===_e?"math"===n&&we[r]:Boolean(Ce[n]):e.namespaceURI===Ee?(t.namespaceURI!==_e||we[r])&&(t.namespaceURI!==Te||Ie[r])&&!Ce[n]&&(be[n]||!De[n]):"application/xhtml+xml"===Re&&ge[e.namespaceURI])}(e)||("noscript"===n||"noembed"===n||"noframes"===n)&&tt(/<\/no(script|embed|frames)/i,e.innerHTML)?(Ue(e),1):($&&3===e.nodeType&&(t=e.textContent,t=$e(t,D," "),t=$e(t,C," "),t=$e(t,U," "),e.textContent!==t&&(Ke(u.removed,{element:e.cloneNode()}),e.textContent=t)),Ge("afterSanitizeElements",e,null),0);if(!X[n]&&ze(n)){if(j.tagNameCheck instanceof RegExp&&tt(j.tagNameCheck,n))return;if(j.tagNameCheck instanceof Function&&j.tagNameCheck(n))return}if(ce&&!ue[n]){var r=E(e)||e.parentNode,o=_(e)||e.childNodes;if(o&&r)for(var i=o.length-1;0<=i;--i){var a=A(o[i],!0);a.__removalCount=(e.__removalCount||0)+1,r.insertBefore(a,T(e))}}return Ue(e),1}function He(e,t,n){if(ae&&("id"===t||"name"===t)&&(n in o||n in ve||"__depth"===n||"__removalCount"===n))return!1;if((!Q||Y[t]||!tt(P,t))&&(!K||!tt(x,t)))if(!W[t]||Y[t]){if(!(ze(e)&&(j.tagNameCheck instanceof RegExp&&tt(j.tagNameCheck,e)||j.tagNameCheck instanceof Function&&j.tagNameCheck(e))&&(j.attributeNameCheck instanceof RegExp&&tt(j.attributeNameCheck,t)||j.attributeNameCheck instanceof Function&&j.attributeNameCheck(t))||"is"===t&&j.allowCustomizedBuiltInElements&&(j.tagNameCheck instanceof RegExp&&tt(j.tagNameCheck,n)||j.tagNameCheck instanceof Function&&j.tagNameCheck(n))))return!1}else if(!me[t]&&!tt(G,$e(n,M,""))&&("src"!==t&&"xlink:href"!==t&&"href"!==t||"script"===e||0!==Je(n,"data:")||!fe[e])&&(!q||tt(k,$e(n,M,"")))&&n)return!1;return!0}function Ve(e){var t,n=void 0,r=void 0,o=void 0;Ge("beforeSanitizeAttributes",e,null);var i=e.attributes;if(i){for(var a={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:W,nodeName:e.nodeName.toLowerCase()},o=i.length;o--;){var l=(n=i[o]).name,c=n.namespaceURI,r="value"===l?n.value:et(n.value);if(V&&(r=n.value),t=Oe(l),a.attrName=t,a.attrValue=r,a.keepAttr=!0,a.keepElement=!0,a.forceKeepAttr=void 0,Ge("uponSanitizeAttribute",e,a),!a.keepElement)return 1;if(r=a.attrValue,!a.forceKeepAttr&&(Pe(l,e),a.keepAttr))if(Z||!tt(/\/>/i,r))if(J&&tt(/((--!?|])>)|<\/(style|title)/i,r))Pe(l,e);else{$&&(r=$e(r,D," "),r=$e(r,C," "),r=$e(r,U," "));var s=e.nodeName.toLowerCase();if(He(s,t,r)){if(!le||"id"!==t&&"name"!==t||(Pe(l,e),r="user-content-"+r),h&&"object"===(void 0===m?"undefined":It(m))&&"function"==typeof m.getAttributeType&&!c)switch(m.getAttributeType(s,t)){case"TrustedHTML":r=h.createHTML(r);break;case"TrustedScriptURL":r=h.createScriptURL(r)}try{c?e.setAttributeNS(c,l,r):e.setAttribute(l,r),Me(e)?Ue(e):Ye(u.removed)}catch(e){}}}else Pe(l,e)}return Ge("afterSanitizeAttributes",e,null),0}}function We(e){var t,n=void 0,r=ke(e);for(Ge("beforeSanitizeShadowDOM",e,null);n=r.nextNode();)Ge("uponSanitizeShadowNode",n,null),Be(n)||(t=E(n),1===n.nodeType&&(t&&t.__depth?n.__depth=(n.__removalCount||0)+t.__depth+1:n.__depth=1),(255<=n.__depth||rt(n.__depth))&&Ue(n),n.content instanceof d&&(n.content.__depth=n.__depth,We(n.content)),Ve(n)&&Ue(n));Ge("afterSanitizeShadowDOM",e,null)}var ze=function(e){return"annotation-xml"!==e&&Ze(e,F)};return u.sanitize=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=void 0,r=void 0,o=void 0,i=void 0;if("string"!=typeof(e=(Ne=!e)?"\x3c!--\x3e":e)&&!Fe(e)){if("function"!=typeof e.toString)throw nt("toString is not a function");if("string"!=typeof(e=e.toString()))throw nt("dirty is not a string, aborting")}if(!u.isSupported){if("object"===It(c.toStaticHTML)||"function"==typeof c.toStaticHTML){if("string"==typeof e)return c.toStaticHTML(e);if(Fe(e))return c.toStaticHTML(e.outerHTML)}return e}if(te||w(t),u.removed=[],se="string"!=typeof e&&se){if(e.nodeName&&(t=Oe(e.nodeName),!B[t]||X[t]))throw nt("root node is forbidden and cannot be sanitized in-place")}else if(e instanceof f)1===(t=(n=xe("\x3c!----\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===t.nodeName||"HTML"===t.nodeName?n=t:n.appendChild(t);else{if(!re&&!$&&!ee&&-1===e.indexOf("<"))return h&&ie?h.createHTML(e):e;if(!(n=xe(e)))return re?null:ie?N:""}n&&ne&&Ue(n.firstChild);for(var a,l=ke(se?e:n);r=l.nextNode();)3===r.nodeType&&r===o||Be(r)||(a=E(r),1===r.nodeType&&(a&&a.__depth?r.__depth=(r.__removalCount||0)+a.__depth+1:r.__depth=1),(255<=r.__depth||rt(r.__depth))&&Ue(r),r.content instanceof d&&(r.content.__depth=r.__depth,We(r.content)),Ve(r)?Ue(r):o=r);if(o=null,se)return e;if(re){if(oe)for(i=S.call(n.ownerDocument);n.firstChild;)i.appendChild(n.firstChild);else i=n;return i=W.shadowroot||W.shadowrootmod?y.call(s,i,!0):i}return e=ee?n.outerHTML:n.innerHTML,ee&&B["!doctype"]&&n.ownerDocument&&n.ownerDocument.doctype&&n.ownerDocument.doctype.name&&tt(yt,n.ownerDocument.doctype.name)&&(e="<!DOCTYPE "+n.ownerDocument.doctype.name+">\n"+e),$&&(e=$e(e,D," "),e=$e(e,C," "),e=$e(e,U," ")),h&&ie?h.createHTML(e):e},u.setConfig=function(e){w(e),te=!0},u.clearConfig=function(){ye=null,te=!1},u.isValidAttribute=function(e,t,n){return ye||w({}),e=Qe(e),t=Qe(t),He(e,t,n)},u.addHook=function(e,t){"function"==typeof t&&(v[e]=v[e]||[],Ke(v[e],t))},u.removeHook=function(e){if(v[e])return Ye(v[e])},u.removeHooks=function(e){v[e]&&(v[e]=[])},u.removeAllHooks=function(){v={}},u}(),j=(Object.seal||function(e){return e})(/\$\{[A-Z._]+?\}/i);function X(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var Y=Object.freeze;t={FORCE_BODY:!0,ALLOWED_URI_REGEXP:!1,REUSE_CONFIG:!1,REMOVE_ONEVENTS:!0,EXTENDS:["GLOBAL_TAGS","GLOBAL_ATTR","FORBID_TAGS","FORBID_ATTR","TAG_RULES","GLOBAL_ATTR_RULES","GLOBAL_APPEND_ATTR","ADD_DATA_URI_TAGS","ADD_URI_SAFE_ATTR"],ALLOWED_STYLE:"NONE",STYLE_RULES:{FORBID_PROPS:[],FORBID_CSSRULES:[],UNSAFE_PROP_RULES:{}}};t.GLOBAL_TAGS="a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"),t.GLOBAL_ATTR="accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"),t.FORBID_TAGS=[],t.FORBID_ATTR=[],t.GLOBAL_ATTR_RULES={},t.GLOBAL_APPEND_ATTR={},t.ADD_DATA_URI_TAGS=[],t.ADD_URI_SAFE_ATTR=[],t.TAG_RULES={a:{APPEND_ATTR:{rel:{ATTR_NAME:"rel",APPEND_ATTR_VALUE:"noopener noreferrer",SIBLING_CONDITIONS:[{ATTR_NAME:"target",CONDITIONS:[{IS_MANDATORY:"true",CONTAINS:"_blank"}]}]}}}},t.TAG_SPECIFIC_ATTRS={};i=function t(_,n){var E="GLOBAL_TAGS",h="GLOBAL_ATTR",N="GLOBAL_ATTRIBUTES",g="FORBID_TAGS",L="FORBID_ATTR",R="TAG_RULES",S="STYLE_RULES",O="GLOBAL_ATTR_RULES",y="GLOBAL_APPEND_ATTR",v="ADD_DATA_URI_TAGS",I="ADD_URI_SAFE_ATTR",e="REMOVE_ONEVENTS",o=["ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","RETURN_DOM","RETURN_DOM_FRAGMENT","IN_PLACE","DONT_TRIM","FORCE_BODY","SANITIZE_DOM","KEEP_CONTENT","ALLOWED_URI_REGEXP"],w=[];H(w,o),H(w,["EXTENDS",e,"ALLOWED_STYLE"]);var r={iframe:{ATTR_RULES:{sandbox:{FALLBACK_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin",CONDITIONS:[{NOT_CONTAINS:["allow-top-navigation","allow-popups-to-escape-sandbox"]}]}},APPEND_ATTR:{sandbox:{APPEND_ATTR_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}}},embed:{ATTR_RULES:{type:{CONDITIONS:[{EQUAL:"application/pdf",FALLBACK_VALUE:"application/pdf"}]}},APPEND_ATTR:{type:{APPEND_ATTR_VALUE:"application/pdf"},typemustmatch:{APPEND_ATTR_VALUE:"true"}}},object:{ATTR_RULES:{type:{CONDITIONS:[{EQUAL:"application/pdf",FALLBACK_VALUE:"application/pdf"}]}},APPEND_ATTR:{type:{APPEND_ATTR_VALUE:"application/pdf"},typemustmatch:{APPEND_ATTR_VALUE:"true"}}}},i=void 0,a=void 0,l=void 0,c=_.GLOBAL_TAGS,b=_.GLOBAL_ATTR,s=_.FORBID_TAGS,u=_.FORBID_ATTR,D=_.TAG_RULES,d=_.STYLE_RULES,f=_.GLOBAL_ATTR_RULES,p=_.GLOBAL_APPEND_ATTR,C=_.TAG_SPECIFIC_ATTRS,U=d.FORBID_PROPS,P=d.FORBID_CSSRULES,x=d.UNSAFE_PROP_RULES,m=U&&0!==U.length||P&&0!==P.length;function A(i){if(!i||i.constructor!==Object)return z(_,i={},!0),i;i[R]||(i[R]={}),i[O]||(i[O]={}),i[y]||(i[y]={}),i[v]||(i[v]=[]),i[I]||(i[I]=[]),i[E]||(i[E]=[]),i[h]||(i[h]=[]),i[N]||(i[N]=[]),i[g]||(i[g]=[]),i[L]||(i[L]=[]),i[S]||(i[S]={}),i[S].FORBID_CSSRULES||(i[S].FORBID_CSSRULES=[]),i[S].FORBID_PROPS||(i[S].FORBID_PROPS=[]),i[S].UNSAFE_PROP_RULES||(i[S].UNSAFE_PROP_RULES={}),i.TAG_SPECIFIC_ATTRS={};for(var e=0;e<w.length;e++){var t=w[e];void 0===i[t]&&(i[t]=_[t])}i[R]=V(i[R],"NAME"),i[O]=V(i[O],"ATTR_NAME"),i[y]=V(i[y],"APPEND_ATTR_NAME");var n=i,a=n.TAG_RULES,r=n.TAG_SPECIFIC_ATTRS,o=n.STYLE_RULES,l=n.GLOBAL_ATTR,c=n.GLOBAL_ATTRIBUTES,s=n.GLOBAL_ATTR_RULES,u=n.GLOBAL_APPEND_ATTR,d=n.EXTENDS,f=o.FORBID_CSSRULES,p=o.FORBID_PROPS,m=o.UNSAFE_PROP_RULES;B(u,function(e,t){F(t)}),B(s,function(e,t){F(t)});for(var A=function(e){var n,t,r=d[e];switch(r){case h:var o=[];H(o,b),B(C,function(e){-1<(e=o.indexOf(e))&&o.splice(e,1)}),H(l,c),H(l,o);break;case E:case g:case L:case v:case I:H(i[r],_[r]);break;case R:n=a,(t=D)&&t.constructor===Object&&B(t,function(e,t){e in n?(void 0===n[e].APPEND_ATTR&&(n[e].APPEND_ATTR=t.APPEND_ATTR),void 0===n[e].ATTR_RULES&&(n[e].ATTR_RULES=t.ATTR_RULES)):n[e]=t});break;case y:case O:B(_[r],function(e){i[r][e]||(i[r][e]={},z(_[r][e],i[r][e],!0))});break;case S:p.push.apply(p,X(U)),f.push.apply(f,X(P)),B(x,function(e){m[e]||(m[e]={},z(x[e],m[e],!0))})}},T=0;T<d.length;T++)A(T);return B(s,function(e){-1===l.indexOf(e)&&(l.push(e),r[e]&&r[e].constructor===Array||(r[e]=[]),-1===r[e].indexOf("*")&&r[e].push("*"))}),B(a,function(n,e){n=W(n),e.APPEND_ATTR||(e.APPEND_ATTR={}),e.APPEND_ATTR=V(e.APPEND_ATTR,"APPEND_ATTR_NAME"),B(e.APPEND_ATTR,function(e,t){F(t)}),e.ATTR_RULES||(e.ATTR_RULES={}),e.ATTR_RULES=V(e.ATTR_RULES,"ATTR_NAME"),B(e.ATTR_RULES,function(e,t){F(t),e=W(e),(-1===l.indexOf(e)||r[e]&&0<r[e].length)&&(-1===l.indexOf(e)&&l.push(e),r[e]&&r[e].constructor===Array||(r[e]=[]),-1===r[e].indexOf(n)&&r[e].push(n))})}),delete i.USE_PROFILES,i}function T(e,t,n){if(e.constructor===String){if(t.CASE_SENSITIVE||(e=e.toLowerCase()),t.DONT_TRIM||(e=e.trim()),t.MAX_LENGTH&&e.length>t.MAX_LENGTH)return!1;if(t.MIN_LENGTH&&e.length<t.MIN_LENGTH)return!1;if(t.REGEX&&t.REGEX.constructor===RegExp&&-1===e.search(t.REGEX))return!1;if(t.REGEX&&t.REGEX.constructor===String&&(new RegExp(t.REGEX),-1===e.search(t.REGEX)))return!1;if(t.REGEX&&t.REGEX.constructor===Array)for(var r=0;r<t.REGEX.length;r++)if(-1===e.search(t.REGEX[r]))return!1;if(t.VALIDATOR&&t.VALIDATOR.HANDLER&&!t.VALIDATOR.HANDLER(e,t.VALIDATOR.CONFIG,n))return!1;if(void 0!==t.STARTS_WITH&&0!==e.indexOf(t.STARTS_WITH))return!1;if(void 0!==t.ENDS_WITH&&e.lastIndexOf(t.ENDS_WITH)!==e.length-t.ENDS_WITH.length)return!1;if(t.CONTAINS&&t.CONTAINS.constructor===String&&-1===e.indexOf(t.CONTAINS))return!1;if(t.CONTAINS&&t.CONTAINS.constructor===Array)for(var o=0;o<t.CONTAINS.length;o++)if(-1===e.indexOf(t.CONTAINS[o]))return!1;if(t.NOT_CONTAINS&&t.NOT_CONTAINS.constructor===String&&-1<e.indexOf(t.NOT_CONTAINS))return!1;if(t.NOT_CONTAINS&&t.NOT_CONTAINS.constructor===Array)for(var i=0;i<t.NOT_CONTAINS.length;i++)if(-1<e.indexOf(t.NOT_CONTAINS[i]))return!1;if(void 0!==t.EQUAL&&e!=t.EQUAL)return!1;if(void 0!==t.NOT_EQUAL&&e==t.NOT_EQUAL)return!1}if(t.LIST&&-1===t.LIST.indexOf(e))return!1;if("INTEGER"===t.TYPE||"FLOAT"===t.TYPE){n=void 0;try{n="INTEGER"===t.TYPE?window.parseInt(e,10):window.parseFloat(e)}catch(e){return!1}if(window.isNaN(n))return!1;if(void 0!==t.GREATER_THAN&&n<=t.GREATER_THAN)return!1;if(void 0!==t.GREATER_THAN_OR_EQUAL&&n<t.GREATER_THAN_OR_EQUAL)return!1;if(void 0!==t.LESSER_THAN&&n>=t.LESSER_THAN)return!1;if(void 0!==t.LESSER_THAN_OR_EQUAL&&n>t.LESSER_THAN_OR_EQUAL)return!1;if(void 0!==t.EQUAL&&n!==t.EQUAL)return!1;if(void 0!==t.NOT_EQUAL&&n===t.NOT_EQUAL)return!1}return!0}function k(e,t,n){var r=!0;if(!t||!t.CONDITIONS||0===t.CONDITIONS.length)return{isValid:r,rule:t};n=t.ATTR_NAME||n;for(var o,i,a,l,c=0;c<t.CONDITIONS.length;c++){var s=t.CONDITIONS[c];if(o=e,i=n,l=void 0,l=!1!==(a=s).IS_MANDATORY,r=i&&!o.hasAttribute(i.toLowerCase())?a.IS_FORBIDDEN||!l:!a.IS_FORBIDDEN&&T(o=null==(o=o.getAttribute(i.toLowerCase()))?"":o,a,i),r=s.NEGATION?!r:r){if(s.NEXT)return k(e,s.NEXT,n);break}}return{isValid:r,rule:t}}function M(o){B(o,function(e,t){if(t&&t.constructor===String&&(0<U.length&&-1<U.indexOf(e)&&(o[e]="",i=!0),x[e]))for(var n=x[e],r=0;r<n.CONDITIONS.length;r++)if(T(t,n.CONDITIONS[r],e))return o[e]=void 0===n.FALLBACK_VALUE?"":n.FALLBACK_VALUE,i=!0,0})}function F(e){if(e&&(e.CONDITIONS&&0<e.CONDITIONS.length&&(e.CONDITIONS=function(e){if(!e)return e;for(var t=0;t<e.length;t++)e[t]=function(e){if(!e||e&&e.CASE_SENSITIVE)return e;for(var t=["STARTS_WITH","ENDS_WITH","CONTAINS","EQUAL","NOT_EQUAL","LIST"],n=0;n<t.length;n++){var r=t[n];e[r]&&(e[r]=W(e[r]))}return e.NEXT&&F(e.NEXT),e}(e[t]);return e}(e.CONDITIONS)),e.SIBLING_CONDITIONS&&0<e.SIBLING_CONDITIONS.length))for(var t=0;t<e.SIBLING_CONDITIONS.length;t++)F(e.SIBLING_CONDITIONS[t])}m||B(x,function(){m=!0});function G(e){return t(e=A(e),n(window))}return G.sanitize=function(e,t){t=function(n){if(!n||n.constructor!==Object)return _;var r={};return B(_,function(e,t){e in n&&-1!==o.indexOf(e)&&(!0===n[e]||!1===n[e]||n[e]&&n[e].constructor===RegExp)?r[e]=n[e]:r[e]=t}),r.SAFE_FOR_TEMPLATES&&(r.ALLOW_DATA_ATTR=!1),r.RETURN_DOM_FRAGMENT&&(r.RETURN_DOM=!0),r.KEEP_CONTENT&&r.GLOBAL_TAGS.push("#text"),r.ADD_TAGS&&delete r.ADD_TAGS,r.ADD_ATTR&&delete r.ADD_ATTR,r}(t),e=n.sanitize(e,t);return(t=G.removed).splice.apply(t,[0,G.removed.length].concat(X(n.removed))),e},H(s,["script"]),H(u,[]),d=_.ALLOWED_STYLE,n.removeAllHooks(),i=!1,-1===s.indexOf("style")&&s.push("style"),-1===u.indexOf("style")&&u.push("style"),"INLINE"!==d&&"ALL"!==d||(u.splice(u.indexOf("style"),1),-1===b.indexOf("style")&&b.push("style"),m&&n.addHook("uponSanitizeAttribute",function(e,t){var n,r;"style"===t.attrName&&(e.ownerDocument.baseURI||((r=(n=window.document).createElement("base")).href=n.baseURI,e.ownerDocument.head.appendChild(r)),i=!1,M(e.style),0!==(r=e.style.cssText).length?t.attrValue=i?r:e.getAttribute("style"):t.keepAttr=!1)})),"INTERNAL"!==d&&"ALL"!==d||(s.splice(s.indexOf("style"),1),-1===c.indexOf("style")&&c.push("style"),m&&n.addHook("uponSanitizeElement",function(e,t){var n;"style"===t.tagName&&null!==e.sheet&&(n=e.sheet.cssRules,i=!1,function e(t,n){for(var r=t.length-1;0<=r;r--){var o=t[r];0<P.length&&-1<P.indexOf(o.type)?(n.deleteRule(r),i=!0):1===o.type&&o.selectorText||8===o.type&&o.keyText?o.style&&M(o.style):4!==o.type&&7!==o.type&&12!==o.type||!o.cssRules||e(o.cssRules,o)}}(n,e.sheet),i&&(function(e,t){for(var n=t.length-1;0<=n;n--)1!==t[n].type&&3!==t[n].type&&4!==t[n].type&&7!==t[n].type&&12!==t[n].type||e.push(t[n].cssText)}(t=[],n),e.textContent=t.join("\n")))})),(f||D)&&(a={},B(r,function(n,e){a[n]={},B(e.ATTR_RULES,function(e,t){return a[n][e]=t})}),B(a,function(n,e){B(f,function(e,t){return a[n][e]=t})}),B(D,function(n,e){a[n]||(a[n]={}),B(e.ATTR_RULES,function(e,t){return a[n][e]=t})}),n.addHook("uponSanitizeAttribute",function(e,t){var n,r,o=a[t.nodeName]&&a[t.nodeName][t.attrName]||f&&f[t.attrName];o&&(r=(n=k(e,o,t.attrName)).isValid,(o=n.rule)&&o.FORCE_KEEP_ATTR&&(t.forceKeepAttr=!0),r||(n=e,r=t,"REMOVE_ELEMENT"!==(e=o).ACTION?void 0!==e.FALLBACK_VALUE?(t=e.FALLBACK_VALUE,(o=j.exec(e.FALLBACK_VALUE))&&(n=n.getAttribute(e.ATTR_NAME),"${ZWAF.URL_COMPONENT}"===o[0]&&(n=window.encodeURIComponent(n)),t=e.FALLBACK_VALUE.replace(o[0],n)),St.test(t.replace(Ot,""))?r.keepAttr=!1:r.attrValue=t):r.keepAttr=!1:r.keepElement=!1))})),(p||D)&&(l={},B(r,function(n,e){l[n]={},B(e.APPEND_ATTR,function(e,t){return l[n][e]=t})}),B(l,function(n,e){B(f,function(e,t){return l[n][e]=t})}),B(D,function(n,e){l[n]||(l[n]={}),B(e.APPEND_ATTR,function(e,t){return l[n][e]=t})}),n.addHook("afterSanitizeAttributes",function(e){var i,t=e.nodeName.toLowerCase(),n={};B(p,function(e,t){return n[e]=t}),B(l[t],function(e,t){return n[e]=t}),i=e,B(n,function(e,t){if(!i.hasAttribute(e.toLowerCase()))if(t.SIBLING_CONDITIONS&&0!=t.SIBLING_CONDITIONS.length)for(var n=0;n<t.SIBLING_CONDITIONS.length;n++){var r=(o=k(i,t.SIBLING_CONDITIONS[n])).isValid,o=o.rule;if(r)return o=(void 0!==o.APPEND_ATTR_VALUE?o:t).APPEND_ATTR_VALUE,i.setAttribute(e,o),0}else i.setAttribute(e,t.APPEND_ATTR_VALUE)})})),_[e]&&n.addHook("uponSanitizeAttribute",function(e,t){0===t.attrName.indexOf("on")&&(t.keepAttr=!1)}),C&&n.addHook("uponSanitizeAttribute",function(e,t){C[t.attrName]&&-1===C[t.attrName].indexOf(t.nodeName)&&-1===C[t.attrName].indexOf("*")&&(t.keepAttr=!1)}),_.ALLOWED_TAGS=c,_.ALLOWED_ATTR=b,_.GLOBAL_ATTRIBUTES=b,_&&!_.REUSE_CONFIG&&Y&&Y(_),G.isSupported=n.isSupported,G.version=n.version,G.removed=[],G}(t,i);return Y&&Y(i),delete window.DOMPurify,"7.0.0"!==o.version||o.HTMLPurifier||o.defineProperty(o,"HTMLPurifier",i,!0,!1,!1,!0),o["7_0_0"].HTMLPurifier||o.defineProperty(o["7_0_0"],"HTMLPurifier",i,!0,!1,!1,!0),o});
;if(window.DOMPurifyCopy) { window.DOMPurify = window.DOMPurifyCopy; window.DOMPurifyCopy = undefined; };!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):e.ZWAF=r()}(this,function(){"use strict";function e(e,r,o,n,t,i,a){if(n||!(r in e))return Object.defineProperty&&function(){try{return Object.defineProperty({},"x",{}),1}catch(e){return}}()?(t=!0===t,i=!0===i,a=!0===a,Object.defineProperty(e,r,{value:o,writable:t,configurable:i,enumerable:a})):(e[r]=o,e)}var c,u,l=(l=String.prototype.codePointAt)||function(e){if(null===this)throw new TypeError(" ");var r=String(this),o=r.length,n=e?Number(e):0;if(!((n=window.isNan(n)?0:n)<0||o<=n)){var t=r.charCodeAt(n),e=void 0;return 55296<=t&&t<=56319&&n+1<o&&56320<=(e=r.charCodeAt(n+1))&&e<=57343?1024*(t-55296)+e-56320+65536:t}},o=String.fromCodePoint;function n(e,r){for(var o=0;o<r.length;o++){var n=r[o];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}o||(c=String.fromCharCode,u=Math.floor,o=function(){for(var e=[],r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];var t=o.length,i=-1;if(!t)return"";for(var a="";++i<t;){var l=Number(o[i]);if(!isFinite(l)||l<0||1114111<l||u(l)!==l)throw new RangeError("Invalid code point: "+l);l<=65535?e.push(l):(l-=65536,e.push(55296+(l>>10),l%1024+56320)),(i+1===t||16384<e.length)&&(a+=c.apply(void 0,e),e.length=0)}return a});var r=(function(e,r,o){return r&&n(e.prototype,r),o&&n(e,o),e}(t,[{key:"debug",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&this.level===this.LEVELS.DEBUG){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).debug.apply(e,o.concat([performance.now()]))}}},{key:"info",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.INFO)){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).log.apply(e,o.concat([performance.now()]))}}},{key:"warn",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.WARN)){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).warn.apply(e,o.concat([performance.now()]))}}},{key:"error",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.ERROR)){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).error.apply(e,o.concat([performance.now()]))}}}]),t);function t(e){!function(e,r){if(!(e instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t),this.LEVELS={NONE:-1,DEBUG:0,INFO:1,WARN:2,ERROR:3},e===this.LEVELS.NONE||e===this.LEVELS.DEBUG||e===this.LEVELS.INFO||e===this.LEVELS.WARN||e===this.LEVELS.ERROR?this.level=e:this.level=this.LEVELS.ERROR}var i=window&&window.ZWAF?window.ZWAF:{version:"7.0.0"},a=new r;i.defineProperty||(i.defineProperty=e),i.logger||(i.logger=a),i["7_0_0"]||(i["7_0_0"]={version:"7.0.0",defineProperty:e,logger:a});var s=!1,r={log:function(){if(window&&window.console&&window.console.log&&window.navigator&&window.navigator.userAgent&&!s){var e=window.navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(s=!0,e&&e[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;");window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}}};a=Array.prototype.indexOf||function(e){if(null==this)throw new TypeError(" ");var r={},o=r.length>>>0;if(0==o)return-1;var n=0;if(0<(arguments.length<=1?0:arguments.length-1)&&(n=Number(arguments.length<=2?void 0:arguments[2]),isNaN(n)?n=0:0!==n&&n!==1/0&&n!==-1/0&&(n=(0<n||-1)*Math.floor(Math.abs(n)))),o<=n)return-1;for(var t=0<=n?n:Math.max(o-Math.abs(n),0);t<o;t++)if(t in r&&r.charAt(t)===e)return t;return-1};function d(e,r,o){var n=2<arguments.length&&void 0!==o?o:{},n=Object.assign({path:"/",SameSite:"lax","max-age":864e7},n);if(encodeURIComponent){var t,i=encodeURIComponent(e)+"="+encodeURIComponent(r);for(t in n){i+="; "+t;var a=n[t];!0!==a&&(i+="="+a)}document.cookie=i}}function f(e,r){d(e,"",{path:1<arguments.length&&void 0!==r?r:"/","max-age":-1})}function p(e){return!!function(e){e+="=";var r=document.cookie,n=void 0;return r.split("; ").forEach(function(r){if(void 0===n){var o=void 0;try{decodeURIComponent&&(o=decodeURIComponent(r))}catch(e){o=r,ZWAF&&ZWAF.logger&&ZWAF.logger.warn&&ZWAF.logger.warn("Error while trying to decode Cookie value!")}0===o.indexOf(e)&&(n=o.substring(e.length))}}),n}(e)}"7.0.0"!==i.version||i.Console||i.defineProperty(i,"Console",r,!0,!1,!1,!0),i["7_0_0"].Console||i.defineProperty(i["7_0_0"],"Console",r,!0,!1,!1,!0);["_zcsr_tmp","com_chat_owner","com_avcliq_owner","wms.agent"].some(p)&&i&&i["7_0_0"]&&i["7_0_0"].Console&&i["7_0_0"].Console.log();r={arrayIndexOf:a};Object.freeze&&Object.freeze(r),"7.0.0"!==i.version||i.util||i.defineProperty(i,"util",r,!0,!1,!1,!0),i["7_0_0"].util||i.defineProperty(i["7_0_0"],"util",r,!0,!1,!1,!0);var h="_zwaf_ua",a={init:function(){f(h);var e=!!window.ulaa,r=navigator&&navigator.brave&&"function"==typeof navigator.brave.isBrave;e?d(h,"Ulaa"):r?d(h,"Brave"):window&&window.addEventListener("load",function(){window.setTimeout(function(){window.getComputedStyle(window.document.documentElement).getPropertyValue("--arc-palette-background")&&d(h,"Arc")},1e3)})},disable:function(){f(h)}};"7.0.0"!==i.version||i.UAIdentification||i.defineProperty(i,"UAIdentification",a,!0,!1,!1,!0),i["7_0_0"].UAIdentification||i.defineProperty(i["7_0_0"],"UAIdentification",a,!0,!1,!1,!0),i&&i["7_0_0"]&&i["7_0_0"].UAIdentification&&i["7_0_0"].UAIdentification.init();a={};function g(e){for(var r=[],o=0;o<e.length;o++)r.push(e[o].charCodeAt(0));return r}for(var m=r.arrayIndexOf,w={HTML:g([",",".","-","_"," "]),HTMLATTR:g([",",".","-","_"]),CSS:g([]),JAVASCRIPT:g([",",".","_"])},v={},y=(y="34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams").split("|"),E=0;E<y.length;E++){var A=y[E].split("=");v[A[0]]=A[1]}for(var b=[],S=0;S<255;S++)b[S]=48<=S&&S<=57||65<=S&&S<=90||97<=S&&S<=122?null:S.toString(16);function _(e){return e<256?b[e]:e.toString(16)}function L(e,r){if(-1!==m.call(e,r))return o(r);e=_(r);if(null===e)return o(r);if(r<=31&&9!=r&&10!=r&&13!=r||127<=r&&r<=159||32===r)return"&#x20;";r=v[r];return void 0!==r?r+";":"&#x"+e+";"}function O(e,r){if(-1!==m.call(e,r))return String.fromCharCode(r);if(null===_(r))return String.fromCharCode(r);e=r.toString(16);return r<256?"\\x"+"00".substr(e.length)+e.toUpperCase():"\\u"+"0000".substr(e.length)+e.toUpperCase()}function C(e,r){if(-1!==m.call(e,r))return o(r);e=_(r);return null===e?o(r):"\\"+e+" "}function N(e,r,o,n){if(null==r||"string"!=typeof r)return r;for(var t,i="",a=0;a<r.length;a++)n?(i+=o(e,t=l.call(r,a),n),65535<t&&a++):i+=o(e,r.charCodeAt(a));return i}return a.encodeForHTML=function(e){return N(w.HTML,e,L,!0)},a.encodeForHTMLAttribute=function(e){return N(w.HTMLATTR,e,L,!0)},a.encodeForJavaScript=function(e){return N(w.JAVASCRIPT,e,O,!1)},a.encodeForCSS=function(e){return N(w.CSS,e,C,!0)},Object.freeze&&Object.freeze(a),"7.0.0"!==i.version||i.Encoder||i.defineProperty(i,"Encoder",a,!0,!1,!1,!0),i["7_0_0"].Encoder||i.defineProperty(i["7_0_0"],"Encoder",a,!0,!1,!1,!0),i});
window.ZSEC = window.ZWAF;/*Polyfills for functions not available in other browsers. */

/*Polyfill for Node.after
//Not supported out of the box in IE and Edge. 
//from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md */
(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty('after')) {
      return;
    }
    Object.defineProperty(item, 'after', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function after() {
        var argArr = Array.prototype.slice.call(arguments),
          docFrag = document.createDocumentFragment();
        
        argArr.forEach(function (argItem) {
          var isNode = argItem instanceof Node;
          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
        });
        
        this.parentNode.insertBefore(docFrag, this.nextSibling);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);


/*Polyfill for replaceWith. 
//Not supported out of the box for IE and Edge. */
function ReplaceWith(Ele) {
    var parent = this.parentNode,
        i = arguments.length,
        firstIsNode = +(parent && typeof Ele === 'object');
    if (!parent){
        return;
    } 
    
    while (i-- > firstIsNode){
      if (parent && typeof arguments[i] !== 'object'){
        arguments[i] = document.createTextNode(arguments[i]);
      } if (!parent && arguments[i].parentNode){
        arguments[i].parentNode.removeChild(arguments[i]);
        continue;
      }
      parent.insertBefore(this.previousSibling, arguments[i]);
    }
    if (firstIsNode){
        parent.replaceChild(this, Ele);
    } 
}
if (!Element.prototype.replaceWith){
    Element.prototype.replaceWith = ReplaceWith;
}
if (!CharacterData.prototype.replaceWith){
    CharacterData.prototype.replaceWith = ReplaceWith;
}
if (!DocumentType.prototype.replaceWith) {
    DocumentType.prototype.replaceWith = ReplaceWith;
}

/*Polyfill for startsWith
//Not supported out of the box for  IE */
if(!String.prototype.startsWith) {
      String.prototype.startsWith = function(searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

/*Polyfill for endsWith
//Not supported out of the box for  IE */
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}


window.Lyte = {
    version : "3.4.1",
    $ : {
        consoleTime : []
    },
    registeredMixins : {},
    registeredServices : {},
    requiredServices : {},
    toBeInjectedServices : {},
    _registeredComponents : {},
    _keywords : {
      "component" : ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
      "adapter" : ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
      "serializer" : ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
      "route" : ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith","actions"],
      "is" : function(key, scope){
        var arr = ["component", "adapter", "serializer", "route"];
        if(scope){
          arr = [scope];
        }
        var len = arr.length;
        for(var i=0;i<len;i++){
          var keyArr = this[arr[i]];
          if(keyArr){
            var res = keyArr.indexOf(key);
            if(res != -1){
              return true;
            }
          }
        }
        return false;
      }
    },
    Mixin : {},
    Service : {},
    debug : false,
    performance : false,
    toBeRegistered : [],
    browser : {},
    registeredCustomComponent : {},
    Globals : {}
  };
(function(){
  var userAgent = Lyte.$.userAgent = window.userAgent = navigator.userAgent;
    //temporary fix for IE 11
  if (userAgent.match(/rv:11\.0/) && navigator.userAgent.match(/Trident/)) {
    Lyte.browser.ie = true;
    window.action = function () {
      return;
    };
  }
  if (userAgent.match('Edge')) {
    var s = createElement("div");
    s.innerHTML = "<template><div>c</div></template>";
    if (s.querySelector("template").childNodes.length) {
      Lyte.browser.ie = true;
    } else {
      Lyte.browser.edge = true;
    }
    s.remove();
  }
Object.defineProperty(Lyte, "__gl", {
  value : {}
});

Lyte.Globals.set = function(scope,value){
  Lyte.Component.set(Lyte.__gl,scope,value);    
};

Lyte.Globals.get = function(scope){
  return Lyte.Component._get(Lyte.__gl, scope);
};
  
  Lyte.$.assetsDiv = document.createElement("div");
  Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
  Lyte.assetsDivContainer = document.head;
  
  Lyte.domContentLoaded = function(callback) {
    if(document.readyState === "complete" || document.readyState === "interactive") { 
      callback();
    } else {
      window.addEventListener('DOMContentLoaded', function() {
        callback();
      });
    }
  }
  
  Lyte.createApplication = function(name, obj){
      if(obj.init){
          obj.init.apply(Lyte);
      }
  }
  
  Lyte.registerErrorCodes = function(obj) {
    Object.assign(Lyte.errorCodes, obj);
  }
  
  Lyte.establishObserverBindings  = function(observers,fromStore,properties,model) {
    var scope = this;
    var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
    if(fromStore){
      scope = fromStore;      
    }
    for(var i=0;i<observers.length;i++) {
      var props = observers[i].properties;
      var obsAttr = {},obsDuplicate=false;
      var Jpath={}
        for(var j=0;j<props.length;j++) {
            var actProp;
            var isArrayObserver = false;
            if(typeof props[j] == "string"){
              if(props[j].search(/^\$\./g)!=-1){
         
                var JsonPath = props[j];
      
                var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0]
                if(CmpPropertyPath.search(/\[[0-9*]\]/g)!=-1){
                  CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
                }
                if(watchProps[CmpPropertyPath]==undefined){
                  watchProps[CmpPropertyPath]=[];
                }
      
                if(Jpath[CmpPropertyPath] == undefined){
                  Jpath[CmpPropertyPath]=[];
                }
                
                var JSONPATH ;
                var reg = "^\\$\\."+CmpPropertyPath+"\\.?"
                reg = new RegExp(reg);
                JSONPATH = props[j].replace(reg,"$.")
                if(!watchProps[CmpPropertyPath].includes(JSONPATH)){
                  watchProps[CmpPropertyPath].push(JSONPATH)
                }
                
                if(!Jpath[CmpPropertyPath].includes(JSONPATH)){
                  Jpath[CmpPropertyPath].push(JSONPATH)
                }
      
      
                CmpPropertyPath =CmpPropertyPath+".*";
                if(!obsAttr.hasOwnProperty(CmpPropertyPath)){
                  actProp= Lyte.getProperty.call(this,CmpPropertyPath,fromStore,properties)
                  obsAttr[CmpPropertyPath]=true;
                  obsDuplicate = false;
                }
                else{
                  obsDuplicate = true;
                }
              }
              else if(props[j].indexOf('.[]') !== -1) {
                  isArrayObserver = true;
                  actProp = Lyte.getProperty.call(this,props[j].substring(0, props[j].indexOf('.[]')),fromStore,properties);
              } else {
              if(props[j].indexOf('.*') !== -1) {
                var prop = props[j].split(".")[0];
                var isDeepObs = (!fromStore && this.component.__data[prop] && this.component.__data[prop].watch) || (fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch) ? true : false;
                if(!isDeepObs){
                  continue;
                }
              } 
                actProp = Lyte.getProperty.call(this,props[j],fromStore,properties);
              }
              if(!obsDuplicate){
                if(!actProp._observers) {
                  Object.defineProperty(actProp, '_observers', {
                      value : new Set(),
                      enumerable: false, 
                      writable: true,
                      configurable: true
                  });
                }
              actProp._observers.add({callee : scope, observer: observers[i], isArrayObserver : isArrayObserver});
              }
          }else{
            Lyte.warn("ERR27",JSON.stringify(props[j]),observers[i].fnName,this.tagName);
          }
        }
        observers[i].Jpath  = Jpath;
        obsAttr={};
    }
  }
  
  Lyte.getProperty = function(key,fromStore,properties) {
      let arr = key.match(/([^[\].]+|\[\])/g);
      let property = this;
      if(fromStore){
          property = properties;
          if(!properties[arr[0]]){
              properties[arr[0]] = {};
          }
          property = properties[arr[0]];
      }
      else {                      
          if(!property._properties[arr[0]]) {
              property._properties[arr[0]] = {};
          } 
          property = property._properties[arr[0]];
      }
  
      Object.defineProperty(property, '_path', {enumerable: false, value : arr[0]});
      for(let i=1;i<arr.length;i++) {
        if (arr[i].startsWith("'") || arr[i].startsWith('"')) {
          arr[i] = arr[i].substring(1, arr[i].length -1);
        }
          if(!property[arr[i]]) {
              property[arr[i]] = {};
              Object.defineProperty(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
          }
          property = property[arr[i]];
      }
      return property;
  }
  
  Lyte.getErrorMessage = function(code) {
    var args = Array.from(arguments).slice(1);
    if(Lyte.errorCodes[code]) {
        return Lyte.errorCodes[code].replace(/{(\d+)}/g, function(t, i) {
            return args[i]
        });
    } else {
        return code;
    }
  }
  
  Lyte.error = function () {
    var errorObj = arguments[0],
    parse = errorObj.stack;
    errorObj = parse ? errorObj : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
    if (Lyte.onerror) {
        Lyte.onerror.call(this, errorObj,arguments[1]);
    }
    Lyte.triggerEvent("error", errorObj,arguments[1]);
    var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1
    if (parse && !safari) {
        errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
    }
    if(arguments[1]) {
        console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message,arguments[1]);
    } else {
        console.error(errorObj.stack ? (safari ? errorObj : errorObj.stack) : errorObj.message);    
    }
    
  };
  
  Lyte.warn = function () {
    var errorObj = arguments[0];
    errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
    console.warn(errorObj.stack ? (errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "") : errorObj) : errorObj.message);
  };
  
  var requiredMixins  = {};
  var fnProto = Function.prototype;
	if(!fnProto.on){
		fnProto.on = function(){
			Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
		};
	}
	if(!fnProto.observes){
		fnProto.observes = function(){
			Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
		};
	}
	if(!fnProto.computed){
		fnProto.computed = function(){
			Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "computed", "value": this, "properties": arguments };
		};
	}
  Lyte._onObj = function(){
    return {"type": "callBack", "value":(this.type === "observer") ? this.value:this , "properties":arguments, "observes":(this.type === "observer" ? this: undefined)}
  }
  Lyte._observesObj = function() {
      return {"type" : "observer", "value" : this, "properties" : arguments, "on": Lyte._onObj, "lyteOn" : Lyte._onObj}
  }
  Lyte._computedObj = function() {
      return {"type" : "computed", "value" : this, "properties" : arguments}
  }
  Lyte._preRegister = function(){
    Lyte._actualFnProtoOn = Function.prototype.on;
    Lyte._actualFnProtoObserves = Function.prototype.observes;
    Lyte._actualFnProtoComputed = Function.prototype.computed;
    let fnProto = Function.prototype;
    fnProto.on = fnProto.lyteOn = Lyte._onObj;
    fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
    fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
  }
  Lyte._postRegister = function(){
    let fnProto = Function.prototype;
    fnProto.on = Lyte._actualFnProtoOn;
    fnProto.observes = Lyte._actualFnProtoObserves;
    fnProto.computed = Lyte._actualFnProtoComputed;
  }
  Object.defineProperty(Lyte.Mixin,"register",{
    get : function(){
        Lyte._preRegister();
        return Lyte.registerMixinWrapper;
    }
  })
  Lyte.registerMixinWrapper = function(){
    try{
      Lyte.registerMixin.apply(Lyte, arguments);
      Lyte._postRegister();
    }catch(e){
      Lyte._postRegister();
    }
  }
  Lyte.registerMixin = function (name, mixin) {
    Lyte.registeredMixins[name] = mixin;
    var req;
    if(req = requiredMixins[name]) {
      for(var key in req) {
        Lyte.$.requiredMixins[key](mixin, req[key],key);
      }
    }
  };
  
  Lyte.Mixin.get = function(name) {
  return Lyte.registeredMixins[name];
  }
  
  Lyte.Service.register = function (name, service) {
    if(Lyte.registeredServices.hasOwnProperty(name)){
      Lyte.warn('Service -'+name+' is already registered');
      return;
    }
    if(!Lyte._keywords.is(name)){
      var data = service, 
      req;
      Lyte.registeredServices[name] = data;
      var serv = Lyte.requiredServices[name];
      if(serv && serv.size) {
        serv.forEach(function(obj) {
          var toSend = data;
          if(obj.isGlobal){
            toSend = Lyte.__gS[obj.key] = Lyte.__gS[obj.key] || new service(obj.data);
          }
          obj.cB(toSend, obj.key, obj.name, name);
        });
      }
      return data;
    }
    else{
      Lyte.warn('Service name-'+name+' should not be a keyword used in Lyte');
    }
  };

  Lyte.Service.getInjected = function(key){
    if(Lyte.__gS.hasOwnProperty(key)){
      return Lyte.__gS[key];
    }
  }
  
  
  // Lyte.Service.get = function(name) {
  //   return Lyte.registeredServices[name];
  // }
  
  Lyte.$.requiredServices = function (key, serviceName, cB, type, name, isGlobal, data) {
		var reqServ = Lyte.requiredServices[serviceName];
		var req = reqServ ? reqServ : Lyte.requiredServices[serviceName] = new Map();
    var id = Lyte.$.genMapId(req);
    req.set(id, { key: key, cB: cB, type: type, name: name, serviceName:serviceName, isGlobal:isGlobal, data:data });
    return serviceName+"-"+id;
	};

  
  Lyte.$.lazyRegisterService = function(service,obj){
    var scope = obj.scope, name = obj.name , callback = scope[obj.type][name];
    if(callback){
      callback[obj.key] = service;
    }
  };
  
  Lyte.$.injectServices = {}; 
  Object.defineProperty(Lyte, "__gS", {
    value : {}
  });
	Lyte.injectServices = function (data) {
		var serv = {};
    if(!Array.isArray(data)){
      data = [data];
    }
		data.forEach(function (itm) {
			if (itm && typeof itm == 'object') {
				var key = itm.as, service = itm.service, args = itm.data;
				if (!Lyte._keywords.is(key)) {
					if (!Lyte.toBeInjectedServices.hasOwnProperty(key)) {
						Lyte.toBeInjectedServices[key] = service;
						serv[key] = {service:service, data:args};
						if(Lyte.registeredServices[service]){
							Lyte.__gS[key] = new Lyte.registeredServices[service](args);
						}
					} else {
						Lyte.warn("A service has already been injected in the key named, ", key);
					}
				} else {
					Lyte.warn("Service cannot be used in any keywords of Lyte.");
				}
			} else if (typeof itm == "string") {
				if (!Lyte.toBeInjectedServices.hasOwnProperty(itm)) {
					Lyte.toBeInjectedServices[itm] = itm;
					serv[itm] = {service:itm};
					if(Lyte.registeredServices[itm]){
						Lyte.__gS[itm] = new Lyte.registeredServices[itm]();
					}
				} else {
					Lyte.warn("A service has already been injected in the key named, ", itm);
				}
			}
      else{
        Lyte.warn("Invalid data passed to injectServices", itm);
      }
		});
		var mdlObj = Lyte.$.injectServices;
		for (var mKey in mdlObj) {
			for (var key in serv) {
				mdlObj[mKey](key, serv[key].service, mKey, Lyte.__gS[key],undefined,serv[key].data);
			}
		}
	};

  Lyte.$.genMapId = function(map){
    var id = Math.floor(Math.random()*10000000000 + 1);
    while(map.get(id)){
        id = Math.floor(Math.random()*10000000000 + 1)
    }
    return id.toString();
  }

  Lyte.$.toRemoveFromRequiredServices = function(str){
    var arr = str.split("-"), id = arr[arr.length-1], idLen = id.length, servName = str.substr(0,str.length - (idLen+1));
    var reqArr = Lyte.requiredServices[servName];
    if(reqArr){
      reqArr.delete(id);
    }
  }


	Lyte.toBeUsedServices = function (obj) {
		// var serviceToBeUsed = obj.callback ? Object.assign({}, Lyte.toBeInjectedServices) : {};
		var serviceToBeUsed = {};
		var arr = obj.services;
		if (arr) {
			arr.forEach(function (service) {
				if (typeof service == "string") {
					serviceToBeUsed[service] = service;
				} else if (service && typeof service == "object") {
					var key = service.as, serv = service.service;
					if (!Lyte._keywords.is(key, obj.type)) {
						serviceToBeUsed[key] = serv;
					} else {
						Lyte.warn("Service cannot be used in any keywords of Lyte.");
					}
				}
			});
		}
		return serviceToBeUsed;
	};

	Lyte.extendService = function (arg) {
		var servObj = Lyte.toBeUsedServices(arg),
		    name;
		for (var serv in servObj) {
			name = servObj[serv];
			// var scp = arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) : Lyte.registeredServices; 
			if ((arg.isGlobal && Lyte.__gS.hasOwnProperty(serv)) || (!arg.isGlobal && Lyte.registeredServices.hasOwnProperty(name))) {
				var ins = arg.ins,
				    service = arg.isGlobal ? Lyte.__gS[serv] : new Lyte.registeredServices[name]();
				if (!Array.isArray(ins)) {
					ins = [arg.ins];
				}
				ins.forEach(function (insObj) {
					insObj[serv] = arg.isGlobal ? Lyte.__gS[serv] : new Lyte.registeredServices[name]();
				});
			} else{
				Lyte.$.requiredServices(serv, name, arg.callback, arg.type, arg.name, arg.isGlobal, arg.data);
			}
		}
	};

  
  
  Lyte.$.requiredMixins = function(mixin,dir,type) {
  var req = requiredMixins[mixin] ? requiredMixins[mixin] : (requiredMixins[mixin] = {});
  if(!req[type]) {
    req[type] = [dir];
  } else {
    req[type].push(dir);  
  }
  }
  
  Lyte.Mixin.exists = function (name) {
  if (!Lyte.registeredMixins[name]) {
    // Lyte.error('Mixin used before being registered.');
    return false;
  }
  return true;
  };
  
  Lyte.log = function (text, src, color) {
  if (Lyte.debug) {
      if(color) {
          console.log("%c" + text,'color:' + color);
      } else {
        console.log(text);      
      }
  }
  };
  
  Lyte.time = function(fn) {
  if(Lyte.performance) {
    var index;
    if((index = Lyte.$.consoleTime.indexOf(fn)) != -1) {
      Lyte.$.consoleTime.splice(index,1);
      console.timeEnd(fn);
    } else {
      Lyte.$.consoleTime.push(fn)
      console.time(fn);
    }
  }
  }
  
  Lyte.isRecord = function(object){
  if(object && object.$ && object.$.hasOwnProperty("isModified")) {
    return true;
  }
  return false;
  }
  
  Lyte.isComponent = function(object) {
  if(object && object.$node && object.__data) {
    return true;
  }
  return false;
  }
  
  
  /* --------- lyte router v2 changes starts---- */
  Lyte.$.reqFiles = {};
  
  Lyte.injectResources = function (files, every, completed, options) {
    var successFiles = [],
        errorFiles = [];
    every = every || function () {};
    completed = completed || function () {};
    return new Promise(function (resolve, reject) {
      processRequirements(files, function () {
        if (options && options.defer) {
          options.defer({
            injectJS: injectJS,
            files: files,
            errorFiles: errorFiles
          });
          resolve();
        } else {
          injectJS(files, function () {
            completed(successFiles, errorFiles);
            if (errorFiles.length) {
              reject(successFiles, errorFiles);
            } else {
              resolve(successFiles, errorFiles);
            }
          });
        }
      }.bind(this));
    });
  
    function injectJS(files, resolve, execFiles) {
      execFiles = execFiles || [];
      if (!files) {
        resolve(successFiles, errorFiles);
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve(successFiles, errorFiles);
        }
        var len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            var type = getFileExtn(file);
            if (type && (type == ".js" || type == ".css") && execFiles.indexOf(file) == -1) {
              execFiles.push(file);
              createScript(file, function () {
                loaded();
              });
            } else {
              loaded();
            }
          } else if (Array.isArray(file)) {
            injectJS(file,function () {
              loaded();
            })
          } else {
            len--;
            injectJS(file.parent, function() {
              injectJS(file.child,function() {
                  loaded();
              })
              loaded();
          })
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve(successFiles, errorFiles);
        }
      }
    }
  
    function createScript(file, resolve) {
      var ev = Lyte.injectResources.respObj[file];
      if (!Lyte.injectResources.availableTags[file] || Lyte.injectResources.availableTags[file].tag.getAttribute("rel") == "preload") {
        var type = getFileExtn(file),
        tag;
        if(type == ".js") {
          tag = document.createElement('script');
          tag.setAttribute('type', "text/javascript");
          tag.setAttribute('src', file);
        } else if(type == ".css") {
          tag = document.createElement('link');
          tag.setAttribute('type', "text/css");
          tag.setAttribute('rel', "stylesheet");
          tag.setAttribute('href', file);
        }
        ev.getAttributeNames().forEach(function (attr) {
          if (["href", "as", "rel"].indexOf(attr) == -1) {
            tag.setAttribute(attr, ev.getAttribute(attr));
          }
        });
        delete Lyte.injectResources.respObj[file];
        tag.onerror = tag.onload = function (event) {
          if (event.type == "error") {
            errorFiles.push(event);
          } else {
            successFiles.push(event);
          }
          Lyte.injectResources.availableTags[file].tag.remove();
          Lyte.injectResources.availableTags[file] = { tag: tag, event : event, type : event.type == "error" ? "error" : "load"  };
          resolve();
          tag.onerror = tag.onload = undefined;
        };
        Lyte.$.assetsDiv.appendChild(tag);
      } else {
        var t = Lyte.injectResources.availableTags[file];
        if(t.type == "error") {
          errorFiles.push(t.event)
        } else {
          successFiles.push(t.event);
        }
        resolve();
      }
    }
  
    function processRequirements(files, resolve) {
      if (!files) {
        resolve();
      } else {
        if (!Array.isArray(files)) {
          files = [files];
        }
        if (!files.length) {
          resolve();
        }
        var len = -files.length;
        files.forEach(function (file) {
          if (typeof file == "string") {
            requestFile(file, Lyte.injectResources.availableTags[file], function () {
              loaded();
            });
          } else if (Array.isArray(file)) {
            new Promise(function (r) {
              processRequirements(file, r);
            }).then(function () {
              loaded();
            });
          } else {
            len--;
            new Promise(function (r) {
              processRequirements(file.parent, r);
            }).then(function () {
              loaded();
            });
            new Promise(function (r) {
              processRequirements(file.child, r);
            }).then(function () {
              loaded();
            });
          }
        });
      }
  
      function loaded() {
        len++;
        if (len == 0) {
          resolve();
        }
      }
  
      function requestFile(file, cached, resolve) {
        if (Lyte.$.reqFiles[file]) {
          Lyte.$.reqFiles[file].push(resolve);
        } else {
          Lyte.$.reqFiles[file] = [resolve];
          if (cached && cached.event.type != "error") {
            if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
              Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
            }
            fileLoaded.call(cached.tag, file, cached.event, true);
            resolve();
          } else {
            makeRequest(file, function (event) {
              Lyte.injectResources.respObj[file] = this;
              Lyte.$.reqFiles[file].forEach(function (resolve) {
                resolve();
              });
              // filesObj[file] = this;
              fileLoaded.call(this, file, event);
              every.call(this, event);
            });
          }
        }
      }
  
      function fileLoaded(file, event, cached) {
        delete Lyte.$.reqFiles[file];
        if (!cached) {
          if (Lyte.injectResources.availableTags[file]) {
            Lyte.injectResources.availableTags[file].tag.remove();
            delete Lyte.injectResources.respObj[file];
          }
          Lyte.injectResources.availableTags[file] = { tag: this, event: event, type: event.type};
        }
      }
    }
  
    function makeRequest(file, callBack) {
      var tag,
      ev = every.internal || {},
      type = getFileExtn(file);
      ev.file = file;
      if (type == null) {
        Lyte.error('Type of file is not specified in injectResources.');
        return;
      }
      tag = document.createElement('link');
      tag.setAttribute('href', file);
      ev.tag = tag;
      if (type == '.css') {
        tag.setAttribute('as', "style");
      } else {
        tag.setAttribute('as', "script");
      }
      tag.setAttribute('rel', "preload");
      tag.onerror = tag.onload = function (event) {
        callBack.call(this, event);
        this.onerror = this.onload = undefined;
      };
      Lyte.triggerEvent("onBeforeInject", ev);
      Lyte.$.assetsDiv.appendChild(tag);
    };
  };

   function getFileExtn(file) {
    return file.match(/\.[a-zA-Z]+(?=\?|$)/);
  }
  
  Lyte.injectResources.availableTags = [];
  Lyte.injectResources.respObj = [];


  function getFileExtn(file) {
    return file.match(/\.[a-zA-Z]+(?=\?|$)/);
  }
  
  Lyte.$.replaceOldInjectResource = function() {
    Lyte.injectResources = function (files, every, completed) {
      var successFiles = [],
      errorFiles = []; 
      every = every || function() {};
      completed = completed || function() {};
      return new Promise(function(resolve) {
        processRequirements(files, resolve);   
      }).then(function() {
        completed(successFiles,errorFiles);  
      });
    
      function processRequirements(files, resolve) {
        if(!files) {
          resolve();
        } else {
          if(!Array.isArray(files)) {
            files = [files];
          }
          if(!files.length) {
            resolve();
          }
          var len = -(files.length);
          files.forEach(function(file) {
            if(typeof file == "string"){
              requestFile(file, Lyte.injectResources.availableTags[file], function() {
                loaded();
              });  
            } else if(Array.isArray(file)) {
              new Promise(function(r){
                processRequirements(file, r);
              }).then(function(){
                loaded();
              })
            } else {
              new Promise(function(r){
                processRequirements(file.parent, r);
              }).then(function(){
                new Promise(function(r1){
                  processRequirements(file.child, r1)
                }).then(function(){
                  loaded();
                })
              })
            }
          })
        }
    
        function loaded() {
          len++;
          if(len == 0) {
            resolve();
          }
        }
        
        function requestFile(file,cached,resolve) {
          if(Lyte.$.reqFiles[file]) {
            Lyte.$.reqFiles[file].push(resolve)
          } else {
            Lyte.$.reqFiles[file] = [resolve];
            if(cached && cached.event.type != "error") {
              if(Lyte.removeFromCache.arr.indexOf(file) != -1) {
                Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file),1);
              }
              fileLoaded.call(cached.tag,cached.event,true);
              resolve();
            } else {
              makeRequest(file,
                function(event) {
                  Lyte.$.reqFiles[file].forEach(function(resolve) {
                    resolve();
                  });
                  fileLoaded.call(this,event);
                  every.call(this,event);
                }
              );
            }
          }
        }
    
        function fileLoaded(event,cached) {
          var file = this.getAttribute('src') || this.getAttribute('href');
          delete Lyte.$.reqFiles[file];
          if(!cached) {
            if(Lyte.injectResources.availableTags[file]) {
              Lyte.injectResources.availableTags[file].tag.remove();
            }
            this.onerror = this.onload = undefined;
            Lyte.injectResources.availableTags[file] = {tag : this, event : {type : event.type}};
          }
        }
      }
    
      function makeRequest(file,callBack) {
        var tags = { ".js": 'script', ".css" : 'link' },
        type = getFileExtn(file);
        tag = document.createElement(tags[type]);
        if (!type) {
          Lyte.error('Type of file is not specified in injectResources.');
          return;
        } else if (type == '.css') {
          tag.setAttribute('href', file);
          tag.setAttribute('type', "text/css");
          tag.setAttribute('rel', "stylesheet");
        } else {
          tag.setAttribute('src', file);
        }
        tag.onerror = tag.onload = function (event) {
          if(event.type == "error") {
            errorFiles.push(event);  
          } else {
            successFiles.push(event);
          }
          if(callBack) {
            callBack.call(this,event);
          }
        };
        var ev = every.internal || {};
        ev.file = file;
        ev.tag = tag;
        Lyte.triggerEvent("onBeforeInject", ev);
        Lyte.$.assetsDiv.appendChild(tag);
      };
    };
  
    Lyte.injectResources.availableTags = [];
    Lyte.injectResources.respObj = [];
  }
  
  Lyte.removeFromCache = function (arr) {
    Lyte.removeFromCache.assign(arr);
    if (Lyte.removeFromCache.arr.length) {
      Lyte.removeFromCache.arr.forEach(function (file) {
        if (Lyte.injectResources.availableTags[file]) {
          Lyte.injectResources.availableTags[file].tag.remove();
          delete Lyte.injectResources.availableTags[file];
          delete Lyte.injectResources.respObj[file];
        }
      });
      Lyte.removeFromCache.arr = [];
    }
  };
  
  Lyte.removeFromCache.arr = [];
  
  Lyte.removeFromCache.assign = function (arr) {
    arr = arr == "*" ? Object.keys(Lyte.injectResources.availableTags) : Array.isArray(arr) ? arr : [arr];
    Lyte.removeFromCache.arr = Lyte.removeFromCache.arr.concat(arr);
    return;
  };

    Lyte.$.prefetchSupport = false;
    try {
        if(!Lyte.browser.ie) {
          var link = document.createElement('link');
          Lyte.$.prefetchSupport = link.relList.supports('prefetch') && link.relList.supports('preload');
        }
    } catch(e) {
    }
    if(!Lyte.$.prefetchSupport) {
        console.log("Prefetch is not supported. Falling back to old implementation")
        Lyte.$.replaceOldInjectResource();
    }
  
  /* --------- lyte router v2 changes ends ---- */
  
  Lyte.checkProperty = function(property, dataVal, key, fieldVal,field, record, type, name ,init){
    var exts = "extends";
    switch(property){
      case "type" : 
      if (Lyte.Transform.hasOwnProperty(fieldVal) && dataVal !== undefined && dataVal !== null) {
        var _fld = Lyte.Transform[fieldVal], _ret = true;
        if (Array.isArray(dataVal)) {
          if (Lyte.Transform[fieldVal][exts] != "array") {
            return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
          }
          if(_fld.hasOwnProperty("items")){
            _ret = Lyte.checkProperty("items", dataVal, key, _fld.items);
    
          }
        }else if(typeof dataVal === "object" && Lyte.Transform[fieldVal][exts] == "object" && _fld.hasOwnProperty("properties")){
          _ret = Lyte.checkProperty("properties", dataVal, key, _fld.properties);
        } 
        else if (Lyte.Transform[fieldVal][exts] != typeof dataVal) {
          return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
        }
        if(_ret !== true){
          return _ret;
        }
      }
        else if(dataVal !== undefined && dataVal !== null){
          if(Array.isArray(dataVal)){
             if(fieldVal != "array"){
                return {code : "ERR03", message : Lyte.errorCodes.ERR03, expected : fieldVal};
             }
          }
          else if(fieldVal != (typeof dataVal)){
            return {code : "ERR03", message : Lyte.errorCodes.ERR03, expected : fieldVal};
          }
        }
        break;
      case "mandatory":
          let validateFlag = fieldVal;
          if(typeof fieldVal == "object"){
            if(init && fieldVal.skipValidationOnInit == true){
              validateFlag = false;
            }
          }
          if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
            return { code: "ERR02", message: Lyte.errorCodes.ERR02 };
          }
          break;
      case "maximum" :
        if((typeof dataVal == "number") && dataVal > fieldVal){
          return {code : "ERR04", message : Lyte.errorCodes.ERR04, expected : fieldVal};
        }
        break;
      case "minimum" :
        if((typeof dataVal == "number") && dataVal < fieldVal){
          return {code : "ERR05", message : Lyte.errorCodes.ERR05, expected : fieldVal};
        }
        break;
      case "maxLength" :
      case "maxItems" :
        if(dataVal && dataVal.length > fieldVal){
          return {code : "ERR06", message : Lyte.errorCodes.ERR06, expected : fieldVal};
        }
        break;
      case "minLength" :
      case "minItems" :
        if(dataVal && dataVal.length < fieldVal){
          return {code : "ERR07", message : Lyte.errorCodes.ERR07, expected : fieldVal};
        }
        break;
      case "pattern" :
        if( typeof dataVal == "string" && !(new RegExp(fieldVal).test(dataVal))){
          return {code : "ERR08", message : Lyte.errorCodes.ERR08, expected : fieldVal};
        }
        break;
      case "uniqueItems" :{
        if(Array.isArray(dataVal) && fieldVal){
          var newArr = [];
          for(var i=0; i<dataVal.length; i++){
            var val = dataVal[i];
            if(newArr.indexOf(val) != -1){
              return {code : "ERR09", message : Lyte.errorCodes.ERR09};
            }
            newArr.push(val);
          }         
        }
        break;        
      }
      case "constant" :
        if(Array.isArray(dataVal)){
          var resp = dataVal.length==fieldVal.length && dataVal.every(function(v,i) { return v === fieldVal[i]});
          if(!resp){
            return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
          }
        }
        else if(typeof dataVal == "object"){
          var resp = store.adapter.$.compareObjects(dataVal, fieldVal);
          if(!resp){
            return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
          }
        }
        else if(dataVal && dataVal != fieldVal){
          return {code : "ERR10", message : Lyte.errorCodes.ERR10, expected : fieldVal};
        }
        break;
      case "items" :{
        if (Array.isArray(dataVal)) {
          for (var i = 0; i < dataVal.length; i++) {
            if(!(fieldVal.any && Array.isArray(fieldVal))){
              fieldVal = [fieldVal];
            }
            var fldLen = fieldVal.length, _ret = true;
            for(var j=0; j<fldLen; j++){
              var _fld = fieldVal[j];
              for (var property in _fld) {
              var resp = Lyte.checkProperty(property, dataVal[i], i, _fld[property], _fld);
              if (resp !== true) {
                if(_ret === true){
                resp.path = resp.path ? i + "." + resp.path : resp.path;
                _ret = resp;
                }
                break;
              }
              }
            }
            if(_ret !== true){
              return _ret;
            }
            }
        }
        break;        
      }
      case "properties" :
        if (typeof dataVal == "object" && !Array.isArray(dataVal)) {
					for (var key in dataVal) {
						if(fieldVal.hasOwnProperty(key)){
						  var fld = fieldVal[key];
						  if(!(fld.any && Array.isArray(fld))){
							  fld = [fld];
						  }
						  var fldLen = fld.length, _ret = true;
						  for(var i=0; i<fldLen; i++){
							var _fld = fld[i];
							for (var property in _fld) {
							  var resp = Lyte.checkProperty(property, dataVal[key], key, _fld[property], _fld);
							  if (resp != true) {
								if(_ret === true){
								resp.path = resp.path ? key + "." + resp.path : key.toString();
								_ret = resp;
								}
								break;
							  }
							}
						  }
						  if(_ret !== true){
							return _ret;
						  }
						}
						// else if(field.exact){
						// 	return { code : "ERR29", message: Lyte.errorCodes.ERR29, property: key };
						// }
					} 
				}
        break;
      case "validation" :{
        var resp =  Lyte.customValidator[fieldVal].apply(record, [key, dataVal, name]);
        if(resp != true){
          return resp;
        }
        break;
      }
      case "instanceof":{
        if(typeof dataVal === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)){
          return { code: "ERR30", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal};
        }
      }        
    }
    return true;
    }

    Lyte.checkNestedProp = function(id,path,dtype,wobj,object,property,value,check,fromStore){
      if (Lyte.Transform[dtype.type]){
        dtype = Lyte.Transform[dtype.type];
        dtype.type = dtype.extends;
      }
      if(path.length!=0){
          if(dtype.type == 'array'){
              if(dtype.items && !isNaN(path[0]) && typeof(dtype.items)=='object'){
                path= path.slice(1);
                Lyte.checkNestedProp(id,path,dtype.items,wobj,object,property,value,check,fromStore)
              }
          }
          else if( dtype.type == "object"){
              if(dtype.properties && dtype.properties.hasOwnProperty(path[0])){
                var k = path[0];
                path = path.slice(1);
                Lyte.checkNestedProp(id,path,dtype.properties[k],wobj,object,property,value,check,fromStore);
              }
          }
      }
      else {
        var err;
        if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
          var component = {};component.__data = {};
          if (dtype.properties) {
            component.__data[property] = dtype.properties[property];
        } else if (dtype.items && wobj.index) {
            component.__data[wobj.index] = dtype;
        } else {
            component.__data[property] = dtype.items;
        }
          var cp = Lyte.validate(object, property, value, component);
          var errKey = wobj.attr ? wobj.attr : wobj.key,_path = wobj.path.split(".");
          var PathWay = wobj.index == undefined && property? wobj.path+(wobj.path!="" ?".":"")+property : wobj.index !=undefined ? wobj.path+(wobj.path!="" ?".":"")+wobj.index : wobj.path;
          if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof(cp)) == "object" && cp.code) {
              cp.value = value;
              cp.path = wobj.path !=""?wobj.path:property;
              if(wobj.isRec && fromStore && wobj.key ==  undefined && wobj.path!=""){
                  errKey = wobj.path.split(".")[0]
                  _path.shift();
                  _path = (_path.length == 1 && _path[0] == property) ? [] : _path;
              }
              // wobj.Error ? true : wobj.Error = {}
              wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
              wobj.Error[errKey].code = "ERR34"
              wobj.Error[errKey].message = Lyte.errorCodes.ERR34;
              err = wobj.Error[errKey].nested;
              wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey]={};
              wobj._cmpErr[errKey].code = "ERR34";
              wobj._cmpErr[errKey].message = Lyte.errorCodes.ERR34;
              var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [] ;
              if(wobj.path !=""){
                  _path.forEach(function (k) {
                      if (err && !err[k]) {
                          err = err[k] = {};
                      } else {
                          err = err[k];
                      }
                  });
              }
              wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
              if(!cmpErrPath.includes(PathWay)){
                cmpErrPath.push(PathWay)
              }
              wobj._cmpErr[errKey].path = cmpErrPath;
          } else{
              if(wobj.isRec && fromStore && wobj.key ==  undefined){
                  errKey = wobj.path.split(".")[0]
                  _path.shift();
                  _path = (_path.length == 1 && _path[0] == property) ? [property] : _path;
              }
              err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
              var cmpErr = wobj._cmpErr[errKey] || undefined;
              if(cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)){
                var ind = cmpErr.path.indexOf(PathWay)
                cmpErr.path.splice(ind,1)
              }
              //var p = object.$.error[property];
              if(err){
                  var key = wobj.index || property; 
                  var flag = true,
                  p = PathWay.split(".");
                  p.forEach(function (r) {
                      if (err[r] && err[r].code) {
                          delete err[r];
                          if(err && Object.keys(err).length == 0){
                              flag = true;
                          }
                          else{
                              flag = false;
                          }
                      }
                      else{
                        err = err[r]
                      }
                  });
                  if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
                      delete wobj.Error[errKey];
                      delete wobj._cmpErr[errKey]
                  }
              }
    
          }
          if((check.value && check.value.hasOwnProperty("code") && cp.code) || !check.value){
              check.value = cp;
          }
      }
    }
      wobj.index && delete wobj.index; 
    }
  
  Lyte.types = ["string", "object", "number", "boolean", "array"];
  
  Lyte.attr = function(type, opts){
  var obj = {};
  obj.type = type;
  if(opts == undefined){
    opts = {};
  }
  if(this.types.indexOf(type) == -1 && !Lyte.Transform.hasOwnProperty(type)){
    throw new Error("Not a valid field type - "+type);
  }
  Object.assign(obj,opts);
  return obj;
  }
  
  Lyte.defineRelation = function(name,type,opts){
  var relation = {type : "relation", relType : type, relatedTo : name};
  if(opts){
    relation.opts = opts;
  }
  return relation;
  }
  
  Lyte.belongsTo = function(name,opts){
  return this.defineRelation(name,"belongsTo",opts);
  }
  
  Lyte.hasMany = function(name,opts){
  return this.defineRelation(name,"hasMany",opts);
  }

  
  Lyte.Transform = {};
  
  Lyte.customValidator = {};
  
  Lyte.registerDataType = function(fieldTypeName, properties){
  var exts = "extends";
  if(this.Transform.hasOwnProperty(fieldTypeName)){
    Lyte.warn("Custom Field Type - "+fieldTypeName+" -  already exists.");
    return;
  }
  if(properties[exts] == undefined || Lyte.types.indexOf(properties[exts]) == -1){
    Lyte.error("Not a valid field type - "+properties[exts]);
    return;
  }
  this.Transform[fieldTypeName] = properties;
  }
  
  Lyte.registerValidator = function(customValidatorName, func){
  if(this.customValidator.hasOwnProperty(customValidatorName)){
    Lyte.warn("Custom Validator with name - "+customValidatorName+" - already exists");
    return;
  }
  this.customValidator[customValidatorName] = func;
  }
  
  Lyte.patterns = {
  email : /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
  url : /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
  ampm : /^(AM|PM|am|pm)$/,
  hour : /^(0?[0-9]|1[0-9]|2[0-4])$/,
  minute : /^(0?[0-9]|[1-5][0-9]|60)$/,
  boolean : /^(true|false|TRUE|FALSE)$/,
  alphaNumeric : /([a-zA-Z0-9])+/,
  alphabetsOnly : /([a-zA-Z])+/,
  numeric : /([0-9])+/,
  phoneNo : /^[0-9a-zA-Z+.()\-;\s]+$/
  }

  Lyte.validate = function (object, key, value, component, init) {
		var definition = component.__data[key];
		var isError = false;
		var type = definition ? definition.type : undefined;
		var _def = definition;
		if(_def){
		  if(!(_def.any && Array.isArray(_def))){
			  _def = [_def];
		  }
		  var defLen = _def.length, _ret = true;
		  for(var i=0; i<defLen; i++){
			  var _d = _def[i];
			  for (var defKey in _d) {
				  isError = Lyte.checkProperty(defKey, value, key, _d[defKey], _d, object, type, undefined, init);
				  if (isError !== true) {
					  if(_ret === true){
						  _ret = isError;
					  }
				  }
			  }
		  }
		  if(_ret !== true){
			  return _ret;
		  }
		}
		return false;
	  };
    
  
  Lyte.registerPattern = function(patternName, pattern){
  this.patterns[patternName] = pattern;
  }
  
  Lyte.errorCodes = {
    ERR01 : "Primary key cannot be modified", ERR02 : "Mandatory field cannot be empty", ERR03 : "Type of value does not match the specified data type", ERR04 : "Value is greater than the maximum value allowed",
    ERR05 : "Value is less than the minimum value allowed", ERR06 : "Length of string/array is greater than the maximum limit allowed", ERR07 : "Length of string/array is less than the minimum limit allowed",
    ERR08 : "String does not match the specified pattern", ERR09 : "Values in array are not unique", ERR10 : "Value is not equal to the specified constant", ERR11 : "Model of related field is not defined",
    ERR12 : "Model of backward relation is not defined", ERR13 : "Record not found", ERR14 : "Model does not match the related field model", ERR15 : "Error in creating a record as a relation",
    ERR16 : "Record with primary key already exists", ERR17 : "Value cannot be changed because record has been deleted", ERR18 : "Action not defined", ERR19 : "Model not defined",
    ERR20 : "Key not specified", ERR21 : "'belongsTo' relationship expects a single object/id", ERR22 : "Type not specified for polymorphic relation", ERR23: "Primary Key value not present", ERR24: "Error while relating record", ERR25: "Backward relation not present", ERR26: "Primary key value cannot be undefined or null",
    ERR27 : "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
    ERR28 : "Unloaded record cannot be saved",
    ERR29: "Property not defined in the object",
    ERR30:"Error in variables declaration for Query",ERR31: "Query not registered for the Model",
    ERR32: "Property not defined in the object",
    ERR33: "Property's value is not an instanceof the mentioned class",
    ERR34: "Type definition for nested properties / items does not match with the value" ,
    ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
  }
  
  Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
  Lyte.triggerEvent = function() {
   var args = Array.prototype.slice.call(arguments, 1)
   var eventName = arguments[0];
   var stopEvent = false;
   var s = this.__lyteRegisteredEvents[eventName];
     if(!s) {
       s = this.__lyteRegisteredEvents[eventName] = {"listeners" : []};
     } else {
       for(var i=0;i<s.listeners.length;i++) {
         var func = s.listeners[i];
         if(func) {
            var ret = func.apply(this, args);
            if(ret === false) {
              stopEvent = true;
              break;
            }
         }
       }
     }
     var customEvent = new CustomEvent(eventName, {"detail" : args});
     if(!stopEvent) {
      document.dispatchEvent(customEvent); 
     } 
  }
  
  Lyte.addEventListener = function(eventName, func) {
   if(typeof func !== "function") {
       Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
       return;
   }
   var s = this.__lyteRegisteredEvents[eventName];
   if(!s) {
     s = this.__lyteRegisteredEvents[eventName] = {"listeners" : []};
   }
   var d = s.listeners.push(func);
   return eventName + "-" + (d - 1);
  }
  
  Lyte.removeEventListener = function(id) {
    let lastIndex;
   if(!id || (lastIndex = id.lastIndexOf("-")) == -1) {
     Lyte.error("listener unique id not specified / invalid");
     return;
   }
   var eventName = id.substring(0,lastIndex);
   var eventId = id.substring(lastIndex + 1);
   var s = this.__lyteRegisteredEvents[eventName];
   if(!s || !s.listeners[eventId]) {
       Lyte.error("No such listener registered");
       return;
   }
   s.listeners[eventId] = null;
  }

  
  Lyte.extendEventListeners = function(scp){
    if(scp && typeof scp == "object" && !scp.hasOwnProperty("__lyteRegisteredEvents")){
        Object.defineProperties(scp, {
            __lyteRegisteredEvents : {
                value : {}
            },
            addEventListener : {
                value : Lyte.addEventListener
            },
            removeEventListener : {
                value : Lyte.removeEventListener
            },
            triggerEvent : {
                value : Lyte.triggerEvent
            }
        });
    }
  }
  
  Lyte.deepCopyObject = function( obj )  {
  var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  var current, copies = [{source : obj, target : targetVal}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
  var cloneObject = copies[0].target, targetReferences = [cloneObject];
  while(current = copies.shift()){
    keys = Object.keys(current.source);
    for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
        descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
        if(!descriptor){
            continue;
        }
        if(!descriptor.value || typeof descriptor.value != "object"){
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
        }
        nextSource = descriptor.value;
        descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
        indexOf = sourceReferences.indexOf(nextSource);
        if(indexOf != -1){
            descriptor.value = targetReferences[indexOf];
            Object.defineProperty(current.target, keys[propertyIndex], descriptor);
            continue;
        }
        sourceReferences.push(nextSource);
        targetReferences.push(descriptor.value);
        Object.defineProperty(current.target, keys[propertyIndex], descriptor);
        copies.push({source : nextSource, target : descriptor.value});
    }
    if(Lyte.isRecord(current.source)){
      Object.defineProperty(current.target, "$", {
        value: {}
      });
      current.target.$.isNew = current.source.$.isNew;
      current.target.$.isModified = current.source.$.isModified;
      current.target.$.isDeleted = current.source.$.isDeleted;
      current.target.$.pK = current.source.$.pK;
      current.target.$._attributes = current.source.$._attributes;
      current.target.$.isCloned = true;
      current.target.$.model = { _name : current.source.$.model._name };
      if(current.source.$.hasOwnProperty("deepNest")){
        current.target.$.deepNest = current.source.$.deepNest;
      }
      if(current.source.$.hasOwnProperty("partialType")){
        current.target.$.partialType = current.source.$.partialType;
      }
    }
    if(Array.isArray(current.source)){
      if(current.source.partial){
        Object.defineProperty(current.target, "partial", {
          value: current.source.partial
        });
      }
    }
  }
  return cloneObject;
  }
  
  Lyte.nestScpId = 1;
  Lyte.nestScp = {};
  Lyte.__nestRef__ = {};
  // Lyte.__nestScp__ = {};
  Lyte.__nestScp__ = new Map();
  // Lyte.__nestScp1__ = new Map();
  Lyte.establishObjectBinding = function (data, attr, fromStore, update,storeRecord,watch) {
    var model, fld, nestObj;
    var checkAttrs=data.__component__ && data.__component__.component.__data?data.__component__.component.__data[attr]:undefined;
    if (fromStore) {
      if(data && !data.$ && data._scp){
        var keys = Array.from(data._scp.keys());
        keys.forEach(function(id){
            var recObj = Lyte.nestScp[id];
            model = store.modelFor(recObj.model);
        })
      }else{
        model = data.$.model;
      }
       fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr)? model.fieldList[attr] : {};
       var _checkDtype = false;
       if(fld){
        var _dtype = Lyte.Transform[fld.type];
        if(_dtype && (_dtype.hasOwnProperty("properties") || _dtype.hasOwnProperty("items"))){
          _checkDtype = true;
        }
       }
        if (fld && (fld.type !== "relation" && fld.watch) || _checkDtype){
            checkAttrs=fld;
        }
      else{
         if(data._scp){
            var keys = Array.from(data._scp.keys());
             keys.forEach(function (id) {
               var _mpObj = data._scp.get(id), 
               mpObj = _mpObj.paths;
               var _dtype = Lyte.nestScp[id] || undefined;
               watch = _dtype && _dtype["watch"]?_dtype["watch"]:watch;
                 for (var key in mpObj) {
                     var path = key ? key.split(".") : [];
                     path.push(attr);
                     Lyte.bindObj(data, attr, id, path, new Map(),undefined,checkAttrs,watch,true);
                 }
            });
         }
        return;
      }
    }
    if (update && data._scp && data._scp.size) {
        var keys = Array.from(data._scp.keys());
        keys.forEach(function (id) {
          var _mpObj = data._scp.get(id), 
          mpObj = _mpObj.paths;
          var _dtype = Lyte.nestScp[id] || undefined;
          watch = _dtype && _dtype["watch"]?_dtype["watch"]:watch;
            for (var key in mpObj) {
                var path = key ? key.split(".") : [];
                path.push(attr);
                Lyte.bindObj(data, attr, id, path, new Map(),undefined,checkAttrs,watch,true);
            }
        });
    }
    var customDtype = false;
    if (checkAttrs && Lyte.Transform[checkAttrs.type]) {
      var dtype = Lyte.Transform[checkAttrs.type];
      if(dtype.hasOwnProperty("properties") || dtype.hasOwnProperty("items")){
        checkAttrs = Lyte.Transform[checkAttrs.type];
        customDtype = true;
      }
    }
    if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
      var _scpObj, kmpKey;
        if (data && data.__component__) {
            data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
                value: {}
            });
            kmpKey = data.__component__;
            _scpObj = data.__component__.__scpObj;
        } else if (Lyte.isRecord(data)) {
            data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
                value: {}
            });
            kmpKey = data;
            _scpObj = data.$.__scpObj;
        }
        var obj = _scpObj,
        id;
        if (_scpObj) {
            var __nestScp1Set__ = false, __nestScp2Set__ = false;
            if (fromStore) {
                if(data[attr] && !Lyte.__nestScp__.has(data[attr])){
                    nestObj = { model: model._name, attr: attr, pK: data.$.pK , Error : {} };
                    __nestScp1Set__ = true;
                }
                else{
                  // var kmp = Lyte.__nestScp__[kid] = Lyte.__nestScp__[kid] || new Map();
                  // data ? kmp.set(data, true) : undefined;
                  var __nId = Lyte.__nestScp__.get(data[attr])
                  var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
                  var refMpId = Lyte.$.genMapId(refMp);
                  refMp.set(refMpId, true);
                  Lyte.setRecBindMap(Lyte.nestScp[__nId], {model:model._name, attr: attr, pK: data.$.pK , Error : {}});
                  obj[attr] = __nId+"_"+refMpId;
                }
            } else {
              if(data[attr] && !Lyte.__nestScp__.has(data[attr])){
                var ErrMap = [],cmpDataKeys = {};
                cmpDataKeys.key=attr;
                cmpDataKeys.dtype = data.__component__.component.__data[attr];
                cmpDataKeys._cmpErr = data.errors;
                cmpDataKeys.Error={};
                ErrMap.push(cmpDataKeys);
                nestObj = { data: data[attr], PropsInfo : ErrMap };
                if(cmpDataKeys.dtype.watch){
                  nestObj.watch = true;
                }
                __nestScp2Set__ = true;
              }
              else{
                  var __nId = Lyte.__nestScp__.get(data[attr])
                  var scope = Lyte.nestScp[__nId];
                   if(scope){
                     var errMp = scope.PropsInfo;
                     var cmpDataKeys = {};
                     cmpDataKeys.key=attr;
                     cmpDataKeys.Error = {};
                     cmpDataKeys._cmpErr = data.errors;
                     cmpDataKeys.dtype = data.__component__.component.__data[attr];
                     if(cmpDataKeys.dtype.watch){
                       scope.watch = true;
                     }
                     errMp.push(cmpDataKeys);
                   }
                  var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
                  var refMpId = Lyte.$.genMapId(refMp);
                  refMp.set(refMpId, true);
                  obj[attr] = __nId+"_"+refMpId;
              }
          }
          if(nestObj){
            var nestScpId = Lyte.nestScpId++;
            var refMp = Lyte.__nestRef__[nestScpId] = Lyte.__nestRef__[nestScpId] || new Map();
            var refMpId = Lyte.$.genMapId(refMp);
            refMp.set(refMpId, true);
            // var kmp = Lyte.__nestScp__[nestScpId] = Lyte.__nestScp__[nestScpId] || new Map();
            // kmp.set(kmpKey, true);
            Lyte.__nestScp__.set(data[attr], nestScpId);
            if(__nestScp1Set__){
                Lyte.nestScp[nestScpId] = {};
                Lyte.setRecBindMap(Lyte.nestScp[nestScpId], nestObj);
                Lyte.nestScp[nestScpId].Error = nestObj.Error
                //     Lyte.setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
            }
            if(__nestScp2Set__){   
                Lyte.nestScp[nestScpId] = nestObj;                 
            //     Lyte.__nestScp2__.set(data[attr], nestScpId);
            }
            Lyte.nestScp[nestScpId]._data = data[attr];
            obj[attr] = obj[attr] || nestScpId+"_"+refMpId;
            var path = [];
            // fromStore ? path.push(attr) : undefined;
            Lyte.bindObj(data, attr, nestScpId, path, new Map(), undefined, checkAttrs,watch);
          }
      }
  }
};

Lyte.removeNestScp2Bind = function(mp, mdlObj){
var mp = mp.model;
if (mp.has(mdlObj.model)) {
    var mp1 = mp.get(mdlObj.model);
    if (mp1.has(mdlObj.pK)) {
        var mp2 = mp1.get(mdlObj.pK);
        if (mp2.has(mdlObj.attr)) {
            mp2.delete(mdlObj.attr);
        }
        !mp2.size ? mp1.delete(mdlObj.pK) : undefined; 
    }
    !mp1.size ? mp.delete(mdlObj.model) : undefined;
}
}

Lyte.setRecBindMap = function(obj, nestObj){
var mp = obj.model = obj.model || new Map(), modelName = nestObj.model, pK = nestObj.pK, attr = nestObj.attr;
if(modelName && !mp.has(modelName)){
    mp.set(modelName, new Map());
}
mp = mp.get(modelName);
if(pK && !mp.has(pK)){
    mp.set(pK, new Map());
}
mp = mp.get(pK);
if(attr && !mp.has(attr)){
  mp.set(attr, true);
}
}
  

Lyte.bindObj = function (data, key, id, path, mp, check, checkAttrs,watch,ignoreCyclicDelete) {
  mp = mp || new Map();
var value = key != undefined ? data[key] : data;
var cyclic = false;
if(!ignoreCyclicDelete && !path.length && Lyte.__nestScp__.get(data) === id){
  delete Lyte.nestScp[id].cyclic;
}
if (path.length > 1 && value && Lyte.nestScp[id] && Lyte.nestScp[id].hasOwnProperty("data") && Lyte.nestScp[id].data === value) {
  if(mp.get(value)){
    cyclic = true;
  }
    else{
       try{ 
          JSON.stringify(value);
       }
       catch(exp){
           cyclic = true;
       }
   }
  if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
    Lyte.estObjScp(value, id, path, cyclic);
  }
  return;
}
var attrs,nestedSCP;
if(checkAttrs){
	if((checkAttrs.hasOwnProperty("items")||checkAttrs.hasOwnProperty("properties"))){
		attrs=checkAttrs.items || checkAttrs.properties;
    nestedSCP = true;
	}
	else if(watch == undefined && checkAttrs.watch == true){
		watch = checkAttrs.watch 
	}
}
attrs=watch?undefined:attrs;
if (Array.isArray(value)) {
  if (!mp.get(value)) {
    mp.set(value, true);
    value.forEach(function (val, idx) {
      path.push(idx);
      if(watch || (checkAttrs && checkAttrs.hasOwnProperty("items") && typeof(checkAttrs.items) == "object" )){
        Lyte.bindObj(value, idx, id, path, mp,undefined,attrs,watch);
      }
      path.pop();
    });
  } else {
    cyclic = true;
  }
  if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
    var _establish;
    if(Array.isArray(watch)){
      _establish = Lyte.checkEstablishingSCP(value,path,watch)
    }
    if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP){
        Lyte.estObjScp(value, id, path, cyclic);
    }
  }
} else if (value && typeof(value) == "object") {
  var cyclic = false;
  if (!mp.get(value)) {
    mp.set(value, true);
    for (var str in value) {
      path.push(str);
      if(watch || (attrs && attrs.hasOwnProperty(str))){
        Lyte.bindObj(value, str, id, path, mp,undefined,attrs?attrs[str]:undefined,watch);
      }
      path.pop();
    }
  } else {
    cyclic = true;
  }
  if(Lyte.checkAndAddBind(value, id, path, cyclic)) {
    var _establish;
    if(Array.isArray(watch)){
      _establish = Lyte.checkEstablishingSCP(value,path,watch)
    }
    if(_establish || (typeof watch =="boolean" && watch ) || nestedSCP ){
      Lyte.estObjScp(value, id, path, cyclic);
    }
  }
}
};

  Lyte.checkAndAddBind = function(value, id, path, cyclic){
      if(!value._scp || !value._scp.size){
          return true;
      }
      if(value._scp.size){
        if(value._scp.has(id)){
            var _obj = value._scp.get(id);
            var obj = _obj.paths;
            if(obj.hasOwnProperty(path.join("."))){
              if(cyclic){
                Lyte.nestScp[id].cyclic = true;
              }                      
              return false;
            }
        }
      }
      return true;
  }   

  Lyte.estObjScp = function(value, id, path, cyclic){
    if(!value._scp){
      Object.defineProperty(value, "_scp", {
        value : new Map(),
        enumerable : false,
        configurable : true
      });
    }
    var mp = value._scp;
    if(!mp.has(id)){
      mp.set(id, {});
    }
    var obj = mp.get(id),
    path = path ? path.join(".") : path;
    var pathObj = obj.paths = obj.paths || {};
    pathObj[path] = true;
    var nestObj = Lyte.nestScp[id];
    if(!nestObj.cyclic && cyclic == true){
      nestObj.cyclic = true;
    }
  }
  
  Lyte.cmpObjs = function (obj1, obj2){
      if(Object.keys(obj1).length !== Object.keys(obj2).length){
          return false;
      }
      for(var key in obj1){
          if(!obj2.hasOwnProperty(key)){
              return false;
          }
          var ret = Lyte.cmpData(obj1[key], obj2[key]);
          if(ret == false){
              return false;
          }
      }
      return true;
  }	
  
  
  Lyte.cmpData = function(data1, data2){
    if(Array.isArray(data1)){
      if((!Array.isArray(data2)) || data1.length !== data2.length){
        return false;
      }
      if(data1 === data2){
        return true;
      }
      var len = data1.length, ret;
      for(var i=0;i <len; i++){
        ret = Lyte.cmpData(data1[i], data2[i]);
        if(ret == false){
          return false;
        }
      }
    }
    else if(data1 && data2 && typeof data1 == "object" && typeof data2 == "object"){
      if(data1 === data2){
        return true;
      }
      return Lyte.cmpObjs(data1,data2);
    }
    // else if(Lyte && Lyte.isRecord(data1) && Lyte.isRecord(data2)){
    //   if( (data1.$.model._name !== data1.$.model._name) || (Lyte.getpKVal(data1) !== Lyte.getpKVal(data2)) ){
    //     return false;
    //   }
    // }
    else if(data1 !== data2){
      return false;
    }
    return true;
  }

  Lyte.nestScpRmPath = function(obj, path){
    if(obj && obj.paths){
        obj = obj.paths;
        for(var key in obj){
            if(key.startsWith(path+".")){
                delete obj[key];
            }
        }
    }
  }
  
  Lyte.nestScpRemove = function(data, id, path){
    var mp = data._scp;
    if(mp && mp.size){
        if(path){
          Lyte.nestScpRmPath(mp.get(id), path);
          var _obj = mp.get(id); 
          var obj = _obj ? _obj.paths : undefined;
          if(obj && !Object.keys(obj).length){
              mp.delete(id);
          }  
        }
        else{
            mp.delete(id);
        }
        if(!mp.size){
          delete data._scp;
        }
    }
  }
  
  Lyte.rmNestScp = function(value, id, mp, data, path){
    if (Array.isArray(value)) {
        if (!mp.get(value)) {
            mp.set(value, true);
            value.forEach(function (val, idx) {
                Lyte.rmNestScp(val, id, mp, undefined, path);
            });
        }
        Lyte.nestScpRemove(value, id, path);
    } else if (value && typeof(value) == "object") {
        if (!mp.get(value)) {
            mp.set(value, true);
            for (var str in value) {
                Lyte.rmNestScp(value[str], id, mp, undefined, path);
            }
        }
        Lyte.nestScpRemove(value, id, path);
    }
  }

Lyte.removeNestScp = function (value, id, mpId, path, context, mp, data, recObj) {
  mp = mp || new Map();
  id = Number.parseInt(id);
  var obj = Lyte.nestScp[id], kmp = Lyte.__nestRef__[id];
  if(recObj && obj.model){
    Lyte.removeNestScp2Bind(obj, recObj);
  }
  if(context){
      if(kmp && kmp.has(mpId)){
          kmp.delete(mpId);
      }
      if(!kmp || (kmp && !kmp.size)){
          delete Lyte.__nestRef__[id];
          if(Lyte.__nestScp__.has(value)){
              Lyte.__nestScp__.delete(value);
          }
          Lyte.rmNestScp(value, id, mp, true, path);
          if(!data){
              delete Lyte.nestScp[id];
          }
      }
  }
  else{
    Lyte.rmNestScp(value, id, mp, true, path);
  }
};

  
  Lyte.resolvePromises = function(promises) {
  if(typeof promises == "string" || promises instanceof Promise) {
      return promises;
  } else {
    if(Array.isArray(promises)) {
      return promiseArray(promises);
    } else if(typeof promises == "object") {
      return promiseHash(promises);
    }    
  }
  
  function promiseHash(promiseObj) {
    var actPromKeys = [],
    promises = [],
    promiseKeys = Object.keys(promiseObj);
    promiseKeys.forEach(function(key) {
        var value = promiseObj[key];
      if(value instanceof Promise || (value && !Array.isArray(value) && typeof value == "object" && typeof value.then == "function")) {
        actPromKeys.push(key)
        promises.push(value);
      }
    });
    if(!promises.length) {
      return Promise.resolve(promiseObj);
    } else {
       var obj = {},promise = new Promise(function(resolve,reject) {
          Promise.all(promises).then(function(data) {
            promiseKeys.forEach(function(promiseKey) {
              if(actPromKeys.indexOf(promiseKey) != -1) {
                obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)]
              } else {
                obj[promiseKey] = promiseObj[promiseKey];
              }
            });
          resolve(obj);
        },function(err) {
          reject(err);
          Lyte.error('Error on resolve promises',err);
        });
      });   
     return promise;
    }
  }
  
  function promiseArray(promiseArray) {
    var array = [],
    hasPromise = false;
    promiseArray.every(function(item,i) {
        if(item instanceof Promise || (item && !Array.isArray(item) && typeof item == "object" && typeof item.then == "function")) { 
            hasPromise = true;
            return false;
        }
        return true
    });
    if(!hasPromise) {
        return Promise.resolve(promiseArray);
    }
    var promise = new Promise(function(resolve,reject) {
      Promise.all(promiseArray).then(function(data) {
        promiseArray.forEach(function(key,index){
          array[index] = data[index];
        });
        resolve(array);
      },function(err) {
        reject(err);
        Lyte.error('Error on resolve promises',err);
      });
    });   
   return promise;
  }
  };
  function domContentLoaded1() {
    Lyte.assetsDivContainer.appendChild(Lyte.$.assetsDiv);
  }
  
  if(document.readyState === "complete" || document.readyState === "interactive") {
    domContentLoaded1();
  } else {
    document.addEventListener("DOMContentLoaded", function(e){
        domContentLoaded1();
    },true);
  };
  
  
    var XHRSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(){
        var event = window.event;  
        var type, target = event ? event.target : undefined; 
        if(Lyte.getConfig("stateHandling")){
            if(event){
                type = event.type;
                /^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type,target,this) : undefined;
            }
            else{
                var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
                if(router){
                    var currentAction = router.transition ? router.transition.ev : undefined;
                    if(currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false"){
                        var mp = Lyte.__transXHRMap = Lyte.__transXHRMap || new Map();
                        mp.set(router.transition, {currentAction : currentAction, XHR:this});
                        addStateToMap(currentAction.type, currentAction.target, this);
                    }
                }
            }
        }
        XHRSend.apply(this, arguments);
    }
    
    Lyte.addEventListener("transitionStart",function(obj){
      var trans = obj.nextTrans;
      if(trans && obj.prevTrans){
          if(window.event && /^(click|dblclick)$/.test(window.event.type)){
              trans.ev = window.event;
              if(obj.prevTrans.ev){
                delete obj.prevTrans.ev;
              }
          }
          else if((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev){
              trans.ev = obj.prevTrans.ev;
              delete obj.prevTrans.ev;
          }
          
      }
    });
    
    Lyte.addEventListener("afterRouteTransition", function(obj){
        if(obj && obj.trans){
            var mp = Lyte.__transXHRMap, removeEv = false;
            if(obj.trans.state == 409 || obj.trans.state == 308){
                var ev1 = window.event, ev2 = obj.trans.ev;
                if(!ev1 || (ev1 && ev2 && ev1 != ev2 && ev1.target == ev2.target && ev1.type == ev2.type)){
                    obj.trans.nested = true;
                }
                else{
                  removeEv = true;
                }
                if(mp){
                    var mpObj = mp.get(obj.trans);
                    if(mpObj){
                        removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
                        mp.delete(obj.trans);
                    }
                }
            }
            else if(obj.trans.state == 200){
                mp ? mp.delete(obj.trans) : undefined;
                removeEv = true;
            }
            if(removeEv){
              obj.trans.ev ? delete obj.trans.ev : undefined;
            }
        }
    });
    
    Lyte.addEventListener("beforeRouteTransition", function(obj){
        if(obj && obj.prevTrans && obj.prevTrans.nested){
            obj.trans.ev = obj.prevTrans.ev;
            delete obj.prevTrans.ev;
            obj.trans.fromPrevTrans = true; // temp check
        }
    });
    
    function addStateToMap(event, target, XHR, stateName){
        var mp = Lyte.__nodeXHRMap = Lyte.__nodeXHRMap || new Map();
        var nodeMap = mp.get(target);
        if(!nodeMap){
            mp.set(target, new Map());
        }
        nodeMap = mp.get(target);
        var sr = target.lyteState = target.lyteState || [], type = stateName || XHR;
        if(sr.indexOf(type) == -1){
            sr.push(type);
        }
        target.setAttribute("lyte-state", "");
        var evMap = nodeMap.get(event);
        if(!evMap){
            nodeMap.set(event, []);
            evMap = nodeMap.get(event);
        }
        if(stateName){
            evMap.push({state:stateName});
            return {target: target, event: event};        
        }
        else{
            evMap.push({isXHR:true, xhr:XHR});
            var callback = function(arg){
                if(XHR.readyState == 4){
                    removeStateFromMap(XHR, event, target);
                    XHR.removeEventListener("readystatechange", callback);
                }
            }
            XHR.addEventListener("readystatechange", callback);
        }
    }
    function removeStateFromMap(type, event, target){
        var mp = Lyte.__nodeXHRMap; 
        var nodeMap = mp.get(target);
        if(!nodeMap){
            return;
        }
        var evMap = nodeMap.get(event);
        if(!evMap){
            return;
        }
        if(evMap){
            var arr = evMap;
            var ind = -1;
            arr.every(function(itm, idx){
                if((itm && itm.isXHR && itm.xhr == type)|| (typeof type == "string" && itm.state == type)){
                    ind = idx;
                    return false;
                }
                return true;
            });
            if(ind != -1){
                arr.splice(ind,1);
                var sind = target.lyteState.indexOf(type);
                target.lyteState.splice(sind, 1);
                if(!arr.length){
                    nodeMap.delete(event);
                    var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1; 
                    tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
                    if(target && target.lyteState && target.lyteState.length == 0){
                        target.lyteState = null;
                        target.removeAttribute("lyte-state");
                    } 
                }
                if(!nodeMap.size){
                    mp.delete(target);
                }
            }
        }
    }
    
    Lyte.setState = function(str){
        if(!str){
            console.error("Please provide a state name");
        }
        var evnt = window.event;
        if(/^(click|dblclick)$/.test(evnt.type)){
            var target = evnt.target;
            if(Lyte.getConfig("stateHandling") == true &&  target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false"){
                var state = target.getAttribute("lyte-state");
                if(!state){
                    var mp = Lyte.__stateMap = Lyte.__stateMap || new Map();
                    var mpobj = mp.get(str);
                    if(!mpobj){
                        var obj = addStateToMap(evnt.type, target, undefined, str);
                        mp.set(str, obj);
                    }
                    else{
                        console.error("There is already a open state by the name",str);
                    }
                }
            }        
        }
    }
    
    Lyte.removeState = function(str){
        if(!str){
            console.error("Please provide a state name");
        }
        var mp = Lyte.__stateMap;
        if(mp){
            var obj = mp.get(str);
            if(obj){
                mp.delete(str);
                removeStateFromMap(str, obj.event, obj.target);
            }
        }
    }
    Lyte.setConfig = function(key, value){
        var configObj = Lyte.__config = Lyte.__config || {};
        configObj[key] = value;
    }
    Lyte.getConfig = function(key){
        var configObj = Lyte.__config;
        if(configObj){
            return configObj[key];
        }
    }
    Lyte.establishWatchScope=function(watchProps,model){
      var scope = this,object;
      for (var v in watchProps){
        var property = v;
        var watch = watchProps[v]
        if(scope.component && scope.component.__data && scope.component.__data[property]){
          object = scope.getData(property);
          watch = scope.component.__data[property].watch ? true : watch;
          if(typeof object == "object"){
            Lyte.establishObjectBinding(scope.component.data,v,false,undefined,undefined,watch)
          }
          var dataDef = scope.component.__data;
          if( Lyte.nestScp[Lyte.__nestScp__.get(object)]){
            // nestScp[__nestScp__.get(object)].dtype.watch = watch;
            dataDef[v].watch = watch;        
          }
        }
        else{
          if(model){
            var fieldList = model.fieldList;
            if(fieldList[v] && fieldList[v].watch == undefined){
              fieldList[v].watch = watch ;
              model._fldGrps.watch[v] = fieldList[v];
            }
          }
        }
      }
    }

    Lyte.checkEstablishingSCP = function(value,path,watch){
      if(Array.isArray(watch)){
          var _path ='';
          _path = path.join(".")
          if(Lyte.checkWatchPath(_path,watch,true) && typeof value != "object"){
              return true
          }
          var _key = Object.keys(value);
          for(var i_scp =0 ; i_scp<_key.length ; i_scp++){
              var spiePath = _key[i_scp];
             var finalaUth =  _path == ""?spiePath : _path+"."+spiePath;
              if(Lyte.checkWatchPath(finalaUth,watch,true)){
                  return true
              }
          }
      }
    }
    Lyte.checkWatchPath=function(actualPath,watchArr,establishBind){
      if(typeof watchArr == "boolean" && watchArr === true){
          return true
      }
      else if(Array.isArray(watchArr)){
          for(var i_watch=0; i_watch < watchArr.length ; i_watch++){
              var path = watchArr[i_watch];
              path =path.replace(/ /g,"");
              path = path.replace(/\$\.\./g,"..");
              path = path.replace(/\$\./g,"")
              var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g)!=-1 ? true : false || path.includes("*");
              if(actualPath == path){
                  return true;
              }
              else if (weirdPath){
                  if(establishBind){
                    if(path.search(/\.\./) != -1 ){
                      path = path.replace(/\.\.\S+/g,"..*")
                      if(path == "..*"){
                        return true;
                      }
                    } 
                  }
                  path = path.search(/\[/) == 0? path.replace("[",""):path;
                  path = path.search(/\.\.\[/)==0 ? path.replace("..[",".."):path
                  path = path.replace(/\.*\[/g,".");
                  path = path.replace(/\]/g,"");
                  var _watchPath = Lyte.checkWeirdPath(path,actualPath);
                  if(_watchPath){
                      return true
                  }
              }
          }
      }
    }
    Lyte.checkWeirdPath=function(watchPath,actualPath){
      if(actualPath == watchPath){
          return true;
      }
      else if(watchPath.includes("..") || watchPath.includes("*")) {
          var cmpPath = watchPath;
          cmpPath = cmpPath.replace(/\*/g, "$$")
          cmpPath = cmpPath.replace(/\.\./g,"::")
          // cmpPath = cmpPath.replace("[","\\[")
          cmpPath = cmpPath.replace(/\./g,"\\.")
          cmpPath=cmpPath.replace(/\:\:/g,"\\.?.*\\.?");
          cmpPath=cmpPath.replace(/\$/g,".*");
          var _wildCard = watchPath.split(".")
          var _wClenght = _wildCard.length;
          if(_wildCard[_wClenght-2] == "" && _wildCard[_wClenght-1]!="*"){
            cmpPath = cmpPath+"$";
          }
          var regularExp = new RegExp(cmpPath);
          if(regularExp.test(actualPath)){
              return true;
          }
          return false;
      }
    }
})();
;(function(window) { //latest
	function Router(routes) {
	  /*-----------string declaration starts------------*/
		var functionStr = "function",
		routeStr = "route",
		TransitionStr = "Transition",
		pendingStr = "pending",
		completedStr = "completed",
		abortedStr = "aborted",
		TransitionAbortedStr = TransitionStr+" "+abortedStr+".",
		TransitionResumedStr = TransitionStr+" resumed.",
		TransitionPausedStr = TransitionStr+" paused.",
		TransitionComletedStr = TransitionStr+" "+completedStr+".",
		parseRouteMappingStr = "parseRouteMapping",
		constructRunLoopStr = "constructRunLoop",
		RouteTransitionStr = "Route"+TransitionStr,
		getDependenciesStr = "getDependencies",
		getResourcesStr = "getResources",
		beforeStr = "before",
		afterStr = "after",
		beforeModelStr = beforeStr+"Model",
		modelStr = "model",
		afterModelStr = afterStr+"Model",
		redirectStr = "redirect",
		renderTemplateStr = "renderTemplate",
		afterRenderStr = afterStr+"Render",
		beforeExitStr = beforeStr+"Exit",
		didDestroyStr = "didDestroy",
		willTransitionStr = "will"+TransitionStr,
		didTransitionStr = "did"+TransitionStr,
		onErrorStr = "onError",
		beforeLoadStr = "beforeLoad",
		onBeforeLoadStr = "onBeforeLoad",
		beforeRouteTransitionStr = beforeStr+"Route"+TransitionStr,
		afterRouteTransitionStr = afterStr+"Route"+TransitionStr,
		beforeTemplateDestroyStr = beforeStr+"TemplateDestroy",
		resourcesStr = "resources",
		dependenciesStr = "dependencies",
		ltPropStr = "lt-prop",
		pReplace = ltPropStr+"-replace",
		startHFromStr = "start-from",
		pStartFrom = ltPropStr+"-"+startHFromStr,
		pRoute = ltPropStr+"-"+routeStr,
		pFragment = ltPropStr+"-fragment",
		pDp = ltPropStr+"-dp",
		pQp = ltPropStr+"-qp",
		pTd = ltPropStr+"-td",
		pTrans = ltPropStr+"-trans",
		refreshHRouteStr = "refresh-"+routeStr,
		pRefreshRoute = ltPropStr+"-"+refreshHRouteStr,
		linktoStr = "link-to",
		LINKTOStr = "LINK-TO",
		stateChangeStr = "stateChange",
		dependencyRequestLog = 'Requesting files in '+getDependenciesStr+' will stall execution of route till download completes. Please validate files '+beforeStr+' requesting.',
		renderTemplateWarning = renderTemplateStr+" hook should return either component or HTML. Rendering of HTML directly into the DOM within the "+renderTemplateStr+" hook is deprecated.",
		addRoutesWarning = "addRoutes function will be deprecated from next version",
		ltPropWarning = "Error while parsing ltProp in "+linktoStr,
		/*-----------string declaration ends------------*/
		fontColor = 'MediumOrchid',
		newTransInfo,
		newTransInfoClone,
		newTransInfoTimer,
		t = Lyte.time,
		log = Lyte.log,
		parse = JSON.parse,
		LR = this,
		d = document,
		dloc = d.location,
		config = {
			routeHash : {},
			urlCache : {},
			stickyRoutes : {},
			allLinks : {},
			activeLinkTags : []
		},
		trans,
		prevTrans,
		newTrans,
		visibleTrans,
		historyObj,
		initialLoad = true,
		allowHistoryChange = false,
		historyLength = getMeta() ? getMeta().index : 0,
		fromHistoryGo = false,
		routeParser,
		processedDispatch,
		Processed,
		
		emptyFn = function() {},
		run = {},
		reqestedType = {
			getResources : resourcesStr,
			getDependencies : dependenciesStr
		};

		run[getDependenciesStr] = 
		run[getResourcesStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
			callback = this.R[index][hook];
			routeInstance.__lp[reqestedType[hook]+'Loaded'] = true;
			if(callback && validateTransition(this)) {
				var require = callHookWithoutPromise.call(this,callback,this.routes[index],hook,index,params(index));
				if(require && require instanceof Promise) {
					return require;
				}
				routeInstance.__lp[reqestedType[hook]] = require;
				routeInstance.__lp[reqestedType[hook]+'Loaded'] = !require || !(require.length || typeof require == "object")
				if(require) {
					if(hook == getDependenciesStr) {
						console.warn(dependencyRequestLog);
					}
					routeInstance.__lp[fnType] = function() {
						routeInstance.__lp[fnType] = pendingStr;
					}
					getRequirements.call(this,{reqType : reqestedType[hook],r : routeInstance,  index : index});
				}
			}
			return callHookWithPromise();
		};

		run[beforeModelStr] = 
		run[modelStr] = 
		run[afterModelStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			callback = this.R[index][hook],
			args = [this.R[index][hook],routeInstance,params(index)];
			if(hook == afterModelStr) {
				args.splice(2,0,routeInstance.currentModel);
			}
			if(callback) {
				callback.then = {success : setDataIns, failure : setDataIns};
				function setDataIns(data) {
					routeInstance.$[hook] = data;
					if(hook == modelStr) {
						routeInstance.currentModel = data;
					}
					delete callback.then;
				}
			}
			return callHookWithPromise.apply(this,args);
		};

		run[redirectStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			args = [this.R[index][hook],routeInstance,params(index)];
			args.splice(2,0,routeInstance.currentModel);
			return callHookWithPromise.apply(this,args);
		};

		run[onErrorStr] = function(hook,index,err,state,options) {
			setPendingResume.call(trans,trans.prom);
			trans._trans.triggerEvent(onErrorStr,{error : err,hook : hook});
			var errIns = this.routes[index];
			for(; index >= 0 && !this.aborted && this.paused; index--) {
				var instance = this.routes[index];
				log(onErrorStr+" of "+ instance.routeName,routeStr,fontColor);
				if(callAction.call(this,onErrorStr,index,[err,this._trans,params(index),hook]) == false) {
					break;
				}  
			}
			consoleErrorFromCallback(err,hook,errIns.routeName,state,options);
		};

		run[willTransitionStr] = function(hook,index) {
			if(callAction.call(prevTrans,hook,index,[trans._trans]) == false) {
				removeHook(trans.runLoop.previous,hook);
			}
			return callHookWithPromise();
		};

		run[beforeRouteTransitionStr] = function() {
			if(validateTransition(this)) {
				var pt;
				if(pt = prevTrans && prevTrans._trans) {
					delete pt.abort;
					delete pt.pause;
				}
				var obj = {
					prevTrans : pt,
					trans : trans._trans,
					history : LR.history
				};
				LR[beforeRouteTransitionStr](obj.prevTrans, obj.trans , obj.history);
				trans._trans.triggerEvent(beforeRouteTransitionStr,obj);
				Lyte.triggerEvent(beforeRouteTransitionStr, obj);
			}
			return callHookWithPromise();	
		};

		run[afterRouteTransitionStr] = function(_trans) {
			LR[afterRouteTransitionStr](_trans);
			trans._trans.triggerEvent(afterRouteTransitionStr, {trans : _trans});
			Lyte.triggerEvent(afterRouteTransitionStr, {trans : _trans});
		};

		run[beforeLoadStr] = function(hook,index) {
			var route = this.routes[index],
			loadingTemplate = callHookWithoutPromise.call(this,this.R[index][hook],this.routes[index],hook,index,params(index)),
			outlet;
			if(loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet,route.parent))) {
				if(outlet.childNodes[0]) {
					triggerTemplateDestroy({outlet,route},false);
				}
				if(loadingTemplate.component) {
					var component = d.createElement(loadingTemplate.component);
					setDataInComponent.call(this,component,loadingTemplate.data,routeInstance,hook,index);
					outlet.innerHTML = '';
					outlet.appendChild(routeInstance.component = component);
				} else if(renderTemplate.html) {
					routeInstance.component = undefined;
					outlet.innerHTML = renderTemplate.html;
					var scripts = outlet.getElementsByTagName('script');
					if(scripts.length) {
						scriptExecution(Array.from(scripts),outlet);
					}
				}
			}
			return callHookWithPromise();
		};

		run[onBeforeLoadStr] = function() {
			return new Promise(function(resolve,reject) {
				for(var len = trans.matched.route.length, i=1; i <= len && validateTransition(trans); i++) {
					var l = len-i;
					if(trans.R[l].actions && trans.R[l].actions.onBeforeLoad) {
						console.log(onBeforeLoadStr +' action is depricated. Use beforeLoad callback');
					}
					if((callAction.call(trans,onBeforeLoadStr,l,[params(l)]) == false) || (i == len)) {
						resolve();
						break;
					}
				}
			});
		};

		run[afterRenderStr] =
		run[didTransitionStr] = function(hook,index) {
			return new Promise(function(resolve, reject) {
				var st = setTimeout(function() {
					if(hook == afterRenderStr) {
						var routeInstance = this.routes[index];
						routeInstance.__ltp.rendered =  true;
						callHookWithPromise.call(this,this.R[index][hook],routeInstance,routeInstance.currentModel,params(index),routeInstance.component)
						.then(function(data) {
							if(!trans.routes[index+1]) {
								trans._trans.triggerEvent(afterRenderStr);
							}
							resolve(data);
						}, function(data) {
							reject(data);
						});
					} else {
						run.removeTemplate.call(this);
						if(callAction.call(this,hook,index,[params(index),trans._trans]) == false) {
							removeHook(trans.runLoop.current,hook);
							index = 0;
						}
						resolve();
						if(index == 0) {
							transitionCompleted({state : 200});
						}
					}
				}.bind(this,hook,index),0);
				this.fns.push(st);          
			}.bind(this));
		};

		run[beforeExitStr] = function(hook,index) {
			var prevTransRouteInstance = prevTrans.routes[index],
			callback = prevTrans.R[index][hook];
			return callHookWithPromise.call(this,callback,prevTransRouteInstance,prevTransRouteInstance.currentModel,params(index,prevTrans));
		};

		run[renderTemplateStr] = function(hook,index) {
			var routeInstance = this.routes[index],
			r = this.R[index];
			if(r[hook]) {
				run.removeTemplate.call(this);
				var renderTemplate = callHookWithoutPromise.call(this,r[hook],routeInstance,hook,index,routeInstance.currentModel,params(index));
				if(validateTransition(this)) {
					if(renderTemplate && (routeInstance.outletName = renderTemplate.outlet)) {
						var data = routeInstance.currentModel,
						outlet;
						if(routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet,routeInstance.parent)) {
							var  obj = {
								outlet : renderTemplate.outlet,
								route : routeInstance
							};
							if(renderTemplate.component) {
								if(routeInstance.component && !renderTemplate.reRender && (routeInstance.component.tagName.toLocaleLowerCase() == renderTemplate.component) && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {
									setDataInComponent.call(this,routeInstance.component,data,routeInstance,hook,index);
								} else {
									triggerTemplateDestroy(obj,false);
									var component = d.createElement(renderTemplate.component);
									component._route = routeInstance.__lp.objPath;
									setDataInComponent.call(this,component,data,routeInstance,hook,index);
									outlet.innerHTML = '';
									outlet.appendChild(routeInstance.component = component);
								}
							} else if(renderTemplate.html) {
								routeInstance.component = undefined;
								triggerTemplateDestroy(obj,false);
								outlet.innerHTML = renderTemplate.html;
								var scripts = outlet.getElementsByTagName('script');
								if(scripts.length) {
									scriptExecution(Array.from(scripts),outlet);
								}
							}
						}
					} else {
						Lyte.warn(renderTemplateWarning);
					}
				}  
			} else if(validateTransition(this) && this.runLoop.templateToRemove && this.R.length == index+1) {
				run.removeTemplate.call(this);
			}
			return callHookWithPromise();
		};

		function setDataInComponent(component,data,routeInstance,hook,index) {
			if(data) {
				if(typeof data == "object" && !Array.isArray(data)) {
				component.setData(data);
				} else {
					processError.call(this,{stopTrans : true, err :Error(getError(203)).stack,instance :routeInstance,hook : hook,index : index});
				}   
			}
		}
		
		function getOutlet(outlet,parent) {
			var _outlet;
			if(parent) {
				_outlet =  parent.outlet ? parent.outlet.querySelector(outlet) : undefined;
				if(!_outlet) {
				return getOutlet(outlet,parent.parent);
				}
			} else if(!(_outlet = d.querySelector(outlet))) {
				consoleError(428,outlet);
			}
			return _outlet;
		}

		function scriptExecution(scriptNode) {
			for(var i=0,currentScript;currentScript = scriptNode[i];i++) {
				var parent = currentScript.parentNode,
				s = d.createElement("script");
				for(var j = 0,attributes;attributes = currentScript.attributes[j]; j++) {
				s.setAttribute(attributes.name, attributes.value);
				}
				s.innerHTML = currentScript.innerHTML;
				parent.appendChild(s);
				parent.removeChild(currentScript);
			}
		}
		
		run.removeTemplate = function() {
			var arr = this.runLoop.templateToRemove;
			if(!this.cleared) {
				if(prevTrans && arr) {
				templateDelete(arr);
				}
				this.cleared = true;
				if(visibleTrans != this) {
					visibleTrans = this;
				}
				delete this.runLoop.templateToRemove;
				Lyte.removeFromCache();
			}
		};

		function params(index,t) {
			t = t || trans;
			var routeInstance = t.routes[index];
			return {
				queryParams : routeInstance.__ltp.queryParams, 
				dynamicParam : routeInstance.__ltp.dynamicParam
			};
		}

		function validateTransition(trans) {
			return !trans.aborted && !trans.paused;
		}
		
		function addToHistory(obj) {
			var type = obj.replace ? "replaceState" : "pushState",
			url = config.history ? _delimit(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? _delimit(obj.url) : (obj.url[0] == "/" && obj.url.length > 1 ? obj.url.substring(1,obj.url.length) : obj.url));
			obj.title = obj.title || d.title;
			/* support for windows, undefined is appended to url */
			var args = [obj.state, obj.title];
			if(url) {
				args.push(url);
			}
			window.history[type].apply(history, args);
		}

		function getMeta() {
			return history.state && history.state.meta;
		}

		function getData() {
			return history.state && history.state.data;
		}

		function getHistoryState(obj) {
			/* 
				state data which needs to be pushed to history. 
				- Matched object is added to process url directly with history back and forward.
				- Index is used to detect browser back or forward.
			*/

			return {
				meta : {
					matched : obj.matched,
					url : obj.url,
					index : obj.fromHistory ? (getMeta() ? getMeta().index : historyLength) : ((obj.replace && getMeta()) ? getMeta().index : (historyLength = historyLength+1))
				},
				data : obj.data
			};
		}

		function getHistoryObj(obj) {
			/* parses history state to history object. */
			if(!LR.history) {
				historyRegistration();
			}
			LR.history.index = obj.state.meta.index;
			LR.history.fromHistory = obj.fromHistory ? (prevTrans ? (prevTrans.stateObj.meta.index < trans.stateObj.meta.index ? 'forward' : 'back') : 'reload') : false;
			allowHistoryChange = true;
			LR.history.state = getData() || {};
			LR.history.initial = initialLoad;
			return LR.history;
		}

		this.configureDefaults = function(options) {
			options = options || {};
			config.history = options.history == "html5";
			config.baseURL = options.baseURL;
			config.slashAfterHash = options.slashAfterHash == undefined ? true : options.slashAfterHash;
			config.deferInit = options.deferInit || false;
			config.preserveUrlOnBrowserNavigation = options.preserveUrlOnBrowserNavigation;
			config.linkActiveClass = options.hasOwnProperty("linkActiveClass") ? options.linkActiveClass : "";
			config.cipher = options.cipher;
			config.queryParamOptions = {
				sticky : options.queryParamOptions && options.queryParamOptions.hasOwnProperty('sticky') ?  options.queryParamOptions.sticky : true
			};
			if(!Lyte.$.prefetchSupport || options.execRouteRequirementsOnDemand == false) {
				Lyte.$.replaceOldInjectResource && Lyte.$.replaceOldInjectResource();
				config.execRouteRequirementsOnDemand = false;
			} else {
				config.execRouteRequirementsOnDemand = true;
			}
			
			this.__lp.config = config;
		}; 

		this.__lp = {
			version : "3.2.7",
			pendingReg : [],
			getDefinition : function(arr,def) {
				if(arr == "*") {
				return config.routes;
				} else {
				def = def || config.routes;
				def = _getObj(arr,def);
				return def && def.__lp && def.__lp.def || undefined;  
				}
			}
		};

		this.configureRoutes = function (map) {
			if(!this.__lp.config) {
				this.configureDefaults();
			}
			parseRouteMapping.call(this, map);
			for(var i = 0,l = this.__lp.pendingReg.length; i < l; i++) {
				registerRoute.apply({},this.__lp.pendingReg[i]);
			}
			this.__lp.pendingReg = [];
			Lyte.domContentLoaded(init);
			this.__lp.routesConfigured = true;
		};

		function init () {
			if(!config.deferInit && LR.init) {
				LR.init();
			}  
		}

		this.init = function(r) {
			delete this.init;
			this.popstate = function(onChangeEvent) {
			   var goValue,
			   url;
			   if(config.preserveUrlOnBrowserNavigation) {
				   if(fromHistoryGo) {
					   fromHistoryGo = false;
					   return;
				   }
				   if(getMeta() && prevTrans && (prevTrans.stateObj.meta.index != getMeta().index)) {
					   fromHistoryGo = true
					   url = getUrlFromMeta(onChangeEvent)
					   goValue = prevTrans.stateObj.meta.index - getMeta().index;
					   history.go(goValue);
				   }
			   }
			   url = url || getUrlFromMeta(onChangeEvent)
			   historyObj = {
				   fromHistory : true,
				   url : url,
				   goValue : goValue
			   };
			   if(onChangeEvent && history.state) {
				   historyObj.data = history.state;
			   }
			   if(trans && !trans.aborted) {
					console.log("aborting from dispatch")
				   trans.abort({state : 308, iAbort : true});
			   }
			   dispatch(url);
		   }
			 window.addEventListener('popstate', this.popstate);
			if(config.history) {
				this.popstate();
			} else {
				historyObj = {
					fromHistory : true,
					url : getLocation()
				};
				dispatch(historyObj.url);
			}
			linkToRegistration();
			return this;
		};

		function getUrlFromMeta(onChangeEvent) {
			var url;
			if(!(getMeta() && (url = getMeta().url))) {
				if(config.history) {
					url = getLocation();
				} else {
					var newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;
					url = checkForEmptyPath(newURL.replace(/.*#/, ''));
				}  
			}
			return url;
		}
		
		this.beforeScroll = this[beforeRouteTransitionStr] = this[afterRouteTransitionStr] = emptyFn;

		function setRouteDef(dir, value) {
			var cache = config.routes,
			len = dir.length,
			dirLen = len - 1;
			for(var i = 0, key; i < len; i++) {
				key = dir[i];
				if (dirLen === i) {
					var obj = cache[key];
					if (obj && obj.__lp) {
						obj.__lp.def = value;
					} else if (obj) {
						obj.__lp = { def: value };
					} else {
						cache[key] = { __lp: { def: value } };
					}
				} else if (!cache[key]) {
					cache[key] = {};
				}
				cache = cache[key];
			}
		}

	
		function linkToRegistration() {
			class LinkTo extends HTMLElement {
				static get observedAttributes() {
					return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-data-tabindex', 'lt-prop-data-tabindex', 'lt-prop-tabindex','lt-prop-aria-label', 'lt-prop-aria-attributes','lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target'];
				}
				attributeChangedCallback(attr, oldValue, newValue) {
					if(this.matched && this.hasAttribute("lyte-rendered")) {
						let aTag = this.getElementsByTagName('A')[0];
						//If attr is ltProp
						if(aTag) {
							if(attr === ltPropStr) {
								this.handleLtProp();
								if(!this.hasAttribute("lt-prop-custom")) {
									this.setCustomAttributes(aTag, true);
								}
								this.constructHref(aTag);
							} else if(/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {
								//if it is a route transition attribute
								this.getMatchedObject();
								this.constructHref(aTag, attr, oldValue, newValue);
							} else if(!this.hasAttribute('lt-prop-custom')) {
								//for rest of the attributes
								aTag.setAttribute(attr.substring(8), newValue);
							}
						}
					}
				}

				connectedCallback() {
					this.ltProp = this.ltProp || {};
					this.handleLtProp();
					if(this.hasAttribute("lyte-rendered")) {
						if(this.getElementsByTagName('A')[0] && !this.matched) {
							this.getMatchedObject();
						}
						return;
					} 
					var isCustom = this.hasAttribute("lt-prop-custom") || this.ltProp.custom,
					aTag;
					if(isCustom) {
						if(aTag = this.getElementsByTagName('A')[0]) {
							this.getMatchedObject();
							this.constructHref(aTag);
						}
					} else {
						aTag = d.createElement("a");
						while(this.childNodes[0]) {
							aTag.appendChild(this.childNodes[0]);
						}
						this.setCustomAttributes(aTag);
						this.getMatchedObject();
						this.constructHref(aTag);
						this.appendChild(aTag);
					}
					if(Lyte.Component) {
						this._linkToEventId = Lyte.Component.addLyteEventListener(this, "click", function(event) {
							linkToEventListener(event, this);
						}, this);
					} else {
						this.addEventListener("click", linkToEventListener);
					}
					this.setAttribute("lyte-rendered", "");
				}

				modifyLinkToTagsInRoute(remove) {
					var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,
					allLinks = config.allLinks[strRoute];
					if(remove) {
						if(allLinks) {
							let pos = allLinks.indexOf(this);
							if(pos != -1) {
								allLinks.splice(pos,1);
							}
						}
					} else {
						if(allLinks) {
							allLinks.push(this);
						} else {
							config.allLinks[strRoute] = [this];
						}
					}
					if(config.stickyRoutes[strRoute]) {
						let routesObj = config.routes,
						routes;
						if(remove) {
							if(this.matched) {
								routes = remove;
							} else {
								return;
							}
						} else {
							routes = this.matched.route;
						}
						if(!routes) {
							return;
						} 
						routes = Array.isArray(routes) ? routes : dotSerperator(routes);
						for(var i = 0,l = routes.length,r; i < l; i++) {
							r = routes[i];
							routesObj =  _getObj(r,routesObj);
							if(!routesObj || !routesObj.__lp) {
								consoleError(422,routes,i);
								return false;
							}
							var def = routesObj.__lp.def.__lp;
							if(remove) {
								let pos = def.stickyLinks.indexOf(this);
								if(pos !== -1) {
									def.stickyLinks.splice(pos,1);
								}
							} else if(def.qpdef) {
								def.stickyLinks.push(this);  
							}
						}
					}
				}

				disconnectedCallback() {
					let m = this.modifyLinkToTagsInRoute.bind(this);
					if(!Lyte.Component.shouldIgnoreDisconnect()) {
						if(this.matched && this.matched.route) {
							m(this.matched.route);
						}
						if(this._linkToEventId) {
							Lyte.Component.removeLyteEventListener(this, this._linkToEventId);
						}
					}
				}
				
				handleLtProp() {
					var ltProp = this.getAttribute(ltPropStr);
					if(ltProp) {
						try{
							this.ltProp = parse(ltProp);
						} catch(e) {
							Lyte.warn(ltPropWarning);
						}
					}
				}

				setCustomAttributes(linkTag, onlyLtProp) {
					for(let key in this.ltProp) {
						if(/^(id|class|style|target)$/.test(key)) {
							linkTag.setAttribute(key, this.ltProp[key]);
						}
					}
					if(!onlyLtProp) {
						for(let i=0,attr,attrName; attr = this.attributes[i]; i++) {
							if((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {
								linkTag.setAttribute(attrName.substring(8), attr.nodeValue);
							}
						}
					}
				}

				constructHref(linkTag, attr, oldValue) {
					var href,
					m = this.modifyLinkToTagsInRoute.bind(this);
					if(href = LR.getURL.call(this,this.matched)) {
						linkTag.setAttribute("href", href); 
						if(attr === pRoute) {
							m(oldValue);
							m();
						} else {
							m();
						}
					}
				}
			}

			LinkTo.prototype.getMatchedObject = function() {
				var matched = this.matched || {},
				ga = this.getAttribute.bind(this),
				dynamicParams = ga(pDp) || this.ltProp.dp || [],
				queryParams = ga(pQp) || this.ltProp.qp || {};
				if(!(dynamicParams instanceof Array)) {
					try {
						dynamicParams = parse(dynamicParams);  
					} catch(e) {
						consoleError(498,"dynamicParams",this.outerHTML);
						return;
					}
				}
				if(!(queryParams instanceof Object)) {
					try{
						queryParams = parse(queryParams);
						if(Array.isArray(queryParams)) {
							consoleError(498,"queryParams",this.outerHTML);
							return;
						}
					} catch(e) {
						consoleError(498,"queryParams",this.outerHTML);
						return;
					}
				}
				matched.route = ga(pRoute) || this.ltProp.route;
				matched.fragment = ga(pFragment) || this.ltProp.fragment;
				matched.dynamicParams = dynamicParams || [];
				matched.queryParams = queryParams || {};
				matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];
				matched.refreshRoute = (matched.refreshRoute == "" || matched.refreshRoute == 'true') ? matched.route : matched.refreshRoute;
				matched.startFrom = ga(pStartFrom) || this.ltProp[startHFromStr];
				return this.matched = matched;
			};
			customElements.define(linktoStr, LinkTo);
		}
	
		function linkToEventListener(event, linkTo) {
			if(event.button == 2 || event.defaultPrevented) {
				return;
			}
			var targetElem = linkTo || event.currentTarget;
			if(targetElem.children[0].tagName === "A" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || (targetElem.children[0].hasAttribute("target") && targetElem.children[0].getAttribute("target") !== "_self")) ) {
				return;  
			}
			event.preventDefault();
			if(!targetElem.matched) {
				targetElem.getMatchedObject();
			}
			var matched = Object.assign({},targetElem.matched);
			matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;
			var replace = targetElem.ltProp.replace  || targetElem.hasAttribute(pReplace),
			transitionInstance = LR[replace && replace != "false" ? "replaceWith" : "transitionTo"](targetElem.matched);
			var transObj = {},
			transProp;
			if(transProp = targetElem.getAttribute(pTrans)) {
				try{
					transObj = parse(transProp);  
				} catch(e) {
					consoleError(498, pTrans, linkTo.outerHTML);
				}
			}
			let transitionData = targetElem.getAttribute(pTd);
			if(transitionData = (transitionData || transObj.data)) {
				if(typeof transitionData === "string") {
					try {
						transitionData = parse(transitionData);
					} catch(e) {
						consoleError(498, pTd , linkTo.outerHTML);
					}
				}
				transObj.data = transitionData;
			}
			for(var key in transObj) {
				transitionInstance[key] = transObj[key];
			}
		}
	
		this.checkIfSameRoute = function(transInfo1, transInfo2) {
			if(transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams,transInfo2.queryParams)) {
				return checkIfSameDp(transInfo1.dynamicParams, transInfo2.dynamicParams)
			}
			return false;
		};

		function checkIfSameDp(dp1, dp2) {
			if(dp1.length) {
				for(var i = 0,dp; dp = dp1[i]; i++) {
					if(dp != dp2[i]){
						return false;
					}
				}
			}
			return true;
		}

		function convertMatchedObjToRouteInfo(matched) {
			var info = {
				route : matched.route.join("."),
				fragment : matched.fragment,
				dynamicParams : matched.dynamicParams.filter(_arrayClean),
				queryParams : matched.queryParams

			};
			return info;
		}
	
		this.addRoutes = function(map, route) { 
			var clr = setInterval(function() {
				if(Lyte.Router.__lp.routesConfigured) {
					clearInterval(clr);
					Lyte.warn(addRoutesWarning);
					var routeArr = route ? route.split(".") : [],
					routes = _getObj(routeArr, config.routes);
					if(!routes) {
						console.error(route+" is not specified in router map.");
						return;
					}
					Object.assign(routes,parseRouteMapping.call(routeParser,map));
				}
			},0);
		};
	
		function dotSerperator(str) {
			return str.split('.').filter(function(s) {return s != "";});
		}
		
		function _arrayClean(e) {
			return e != undefined;
		}
	
		function parseRouteMapping(map) {
			t(parseRouteMappingStr);
			var routesObj = config.routes ? config.routes : (config.routes = {}),
			mapObj = {}, 
			pathStringArr = [], 
			routeStringArr = [];
			routeParser = {
			route : function(routeName,obj,nestedFn) {
				if(typeof obj == "object") {
				if(!obj.path) {
					obj.path = _delimit(routeName);
				} else {
					if(_presence(obj.path,"?")) {
					var split = obj.path.split('?');
					obj.defQP = frameQueryParams(split[1]);
					obj.path = split[0] || "/";
					}  
				}
				if(obj.queryParams) {
					obj.defQP = obj.queryParams;
				}
				} else {
				if(typeof obj == functionStr) {
					nestedFn = obj;
				}
				obj = {path : _delimit(routeName)};  
				}
				mapObj = _getObj(pathStringArr,config.routeHash)[obj.path] = {__lp : {}};
				if(obj.path == '/') {
				pathStringArr.push('/');
				} else {
				var trimedPath = obj.path;
				if(dynamicRouteCheck(trimedPath) || wildcardRouteCheck(trimedPath)) {
					_splitPath(trimedPath).every(function(seg,index,arr) {
					if(dynamicRouteCheck(seg) || wildcardRouteCheck(seg)) {
						var dkey;
						if(dynamicRouteCheck(seg)) {
						dkey = seg.replace(":","");
						} else  {
						dkey = seg.replace("*","");
						obj.wildcard = mapObj.__lp.wildcard = true;
						obj.sufix = mapObj.__lp.sufix = [];
						for(var i = index+1,j; j = arr[i]; i++) {
							mapObj.__lp.sufix.push(j);
						}
						}
						obj.dkey = mapObj.__lp.dkey = dkey;
						obj.dIndex = mapObj.__lp.dIndex = index;
						return false;
					}
					return true;
					});
				} 
				pathStringArr.push(trimedPath);
				}
				var routes = _getObj(routeStringArr,routesObj) || routesObj;
				routeStringArr.push(routeName);
				mapObj.__lp.route = Array.from(routeStringArr);
				routes[routeName] ? (Object.assign(routes[routeName].__lp,obj)) : (routes[routeName] = {__lp : obj});
				if(nestedFn) {
				nestedFn.call(this,{});
				}
				routeStringArr.pop();
				pathStringArr.pop();
			}
			};
			map.call(routeParser,{});
			t(parseRouteMappingStr);
			return routesObj;
		}
	
		this.replaceWith = function() {
			var args = normalizeMatchedObj.call(this,normalizeTransitionParams.apply(this,arguments));
			if(args) {
			args.matched.replace = true;
			return routeTransition(args);   
			}
		};
	
		this.transitionTo = function() {
			var processed;
			if(processed = normalizeMatchedObj.call(this,normalizeTransitionParams.apply(this,arguments))) {
			return routeTransition(processed);  
			}
		};
	
		this.getURL = function (matched) {
			if(matched) {
				if(!matched.route) {
					matched = normalizeTransitionParams.apply(this,arguments)
				} else if(!matched.queryParams) {
					matched.queryParams = {}
				}
				var url,
				l,
				linkTo = this.tagName == LINKTOStr,
				cache = config.urlCache,
				matchedCache,
				sticky = config.queryParamOptions.sticky;
				if(!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {
					url = matchedCache.url;
					if(l = matched.dynamicParams && matched.dynamicParams.length) {
						for(var i = 0; i < l; i++) {
							url = url.replace('<<dp>>',matched.dynamicParams[i]);	
						}
					} else if(url.indexOf('<<dp>>') != -1) {
						consoleError(499,matched.route,linkTo ? this : undefined);
					}
					for(var key in matchedCache.defQP) {
						if(!matched.queryParams[key] && matchedCache.defQP[key]) {
							matched.queryParams[key] = matchedCache.defQP[key];
						}
					}
					url = appendQueryParamsAndFrag(url,matched);
				} else {
					if(linkTo) {
						url = constructURLFromRoute.apply(this,arguments);
					} else {
						url = constructURLFromRoute.call(this,matched);
					}
				}
				if(url) {
					url = config.history ? shiftBaseURL(url, true) : '#'+url;
					return url;
				}
			}
		};
	
		this.getRoute = function(url) {
			var matched = traverse(shiftBaseURL(url),true);
			if(matched) {
			matched.dynamicParams = matched.dynamicParams.filter(_arrayClean);
			matched.route = matched.route.join('.');
			}
			return matched;  
		};
	
		function routeTransition(processed) {
			if(LR.init) {
				consoleError(405);
				return 
			}
			var matched = processed.matched,
			currRoute;
			processed.currRoute = currRoute = matched.route.join('.');
			matched.refreshRoute && currRoute == prevTrans.info.route;
			newTransInfo = {
				replace : matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched),convertMatchedObjToRouteInfo(prevTrans.matched)) ? true :  matched.replace),
				title : trans ? trans.title : d.title,
				fromHistory : false
			};
			var url = dispatchTransition(processed);
			if(url && newTrans) {
				log('Transitioning to '+currRoute+' '+url,routeStr);
				return newTrans._trans;  
			} else {
				log('Transition failed')
				return {};
			}
		}
	
		function getLocation() { 
			if(config.history) {
				var path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || ""));
				path = shiftBaseURL(path);
				return _delimit(path);  
			} else {
				return _delimit(checkForEmptyPath(dloc.hash.replace('#','')));
			}
		}
	
		function checkForEmptyPath(path) {
			if(!path) {
				path = '/'
			}
			return path;
		}
	
		function shiftBaseURL(path,append) {
			var baseURL;
			if((baseURL = config.baseURL) && path) {
			baseURL = _delimit(baseURL);
			if(path.indexOf(baseURL) == 0 && !append) {
				return path.replace(baseURL,'');
			} else if(append && path.indexOf(baseURL) != 0) {
				return baseURL+path;
			} 
			} 
			return path;
		}
	
		function constructURLFromRoute(matched) {
			if(matched && matched.route) {
				var strRoute;
				if(!Array.isArray(matched.route)) {
					matched.route = dotSerperator(strRoute = matched.route);
				} else {
					strRoute = matched.route.join('.')
				}
				matched.queryParams = matched.queryParams || {};
				matched.dynamicParams = matched.dynamicParams || [];
				matched.refreshModel = false;
				var url,
				sameRoute = !!trans,
				dynamicPos = matched.dynamicParams.length != matched.route.length,
				dynamicParamPos = 0,
				linkTo = this.tagName == LINKTOStr,
				routeObj = config.routes,
				templateUrl = url = '',
				defQPTemp = {},
				route;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					if(sameRoute && trans.matched.route[i] != route) {
						sameRoute = false;
					}
					routeObj = _getObj(route,routeObj);
					if(!routeObj && !routeObj.__lp && routeObj.__lp.path) {
						consoleError(422,matched.route,i);
						return false;
					}
					var def = routeObj.__lp.def;
					if(!def && !linkTo) {
						consoleError(422,matched.route,i);
					}
					var path = routeObj.__lp.path,
					defaultQP;
					if(!def || !def.__lp) {
						if(defaultQP = routeObj.__lp.defQP) {
							for(var key in defaultQP) {
								if(matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {
									matched.queryParams[key] = defaultQP[key];
								} 
							}
						}
					} else if(def.queryParams) {
						defaultQP = routeObj.__lp.defQP;
						var qpdef = def.__lp.qpdef;
						for(var key in qpdef) {
							if(!matched.queryParams.hasOwnProperty(key)) {
								if(sameRoute && qpdef[key].sticky) {
									matched.queryParams[key] = trans.routes[i].__ltp.queryParams[key];
								} else if(defaultQP && defaultQP.hasOwnProperty(key)) {
									defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
								}
							}
							if(constructURLFromRoute.caller.name != "pathProcessor" && qpdef[key].cipher && config.cipher.encryptor) {
								matched.queryParams[key] = config.cipher.encryptor(matched.queryParams[key]);
							}
							if(!linkTo && !matched.refreshModel && qpdef[key].refreshModel) {
								matched.refreshModel = true;
							}
						}
					}
					if(routeObj.__lp.dkey) {
						var dynamicPathSplit = _splitPath(path),
						dynamicPathSplitTemp = _splitPath(path),
						pos = dynamicPos ? dynamicParamPos : i;
						if(!matched.dynamicParams || !matched.dynamicParams[pos]) {
						consoleError(499,route,linkTo ? this : undefined);
						return false;   
						} else {
							dynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);
							dynamicPathSplitTemp[routeObj.__lp.dIndex] = _delimit('<<dp>>');
							templateUrl += _delimit(dynamicPathSplitTemp.join('/')); 
							url += _delimit(dynamicPathSplit.join('/')); 
							dynamicParamPos++;
						} 
					} else {
						templateUrl += _delimit(path);
						url += _delimit(path);
					}
				}
				if(!config.stickyRoutes[strRoute]) {
					config.urlCache[strRoute] = {url : validateURL(templateUrl), defQP : defQPTemp};
				}
				return appendQueryParamsAndFrag(url,matched);
			}
		}
		
		function appendQueryParamsAndFrag(url,matched) {
			url = url[url.length-1] == '/' && url.length != 1 ? url.slice(0,-1) : url;
			if(matched.queryParams) {
				var ques = true;
				for(var key in matched.queryParams) {
					if(matched.queryParams[key] != undefined) {
						if(ques) {
							url += '?';
							ques = false
						} else {
							url += '&';
						}
						url+= key+'='+encodeURIComponent(matched.queryParams[key]);  
					}
				}
			}
			if(config.history && matched.fragment) {
			url = url+"#"+matched.fragment;
			}
			return validateURL(url);
		}
	
		function historyRegistration() {
			LR.history = new History();
			function History() {
			return this;
			}
	
			Object.defineProperty(History.prototype, 'state', {
			get : function() {
				return getData();
			},
			set : function(data) {
				if(allowHistoryChange) {
				allowHistoryChange = false;
				} else {
				Lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');
				}
				return data;
			}
			});
	
			History.prototype.replaceState = function() {
				stateChange.apply(Array.from(arguments).push(true));
			};
	
			History.prototype.pushState = function() {
				stateChange.apply(Array.from(arguments));
			};
	
			function stateChange(data,title,url,replace) {
				if(!replace) {
					getMeta().index++;
				}
				addToHistory({
					state : {
						meta : getMeta(),
						data : data
					},
					title: title, 
					url: url
				});
			}
		}  
	
		var invokeRunLoop;
		function dispatch(path, processed, data) {
			t(RouteTransitionStr);
			if(path && config.baseURL && d.location.pathname.indexOf(config.baseURL) == -1) {
				consoleError(400);
				return;
			}
			processed = processed || (!initialLoad && getMeta() && getMeta().matched && getMeta().url == getLocation() ? normalizeMatchedObj(getMeta().matched) : traverse(path));
			if(processed && processed.matched.route.length) {
			clearTimeout(invokeRunLoop);
			processed.prevTrans = processed.prevTrans || Lyte.Router.__lp.prevTrans;
			processed.path = processed.path || path;
			processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
			invoke(Processed = processed);
			Lyte.triggerEvent("transitionStart", {prevTrans : prevTrans && prevTrans._trans, nextTrans : newTrans._trans});
			invokeRunLoop = setTimeout(function() {
				Processed = undefined;
				if(trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info,trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._trans.data)) {
					if(trans.iPause == true) {
						trans.resume();    
					}
					return;
				} else if(trans && trans.state == 102) {
					trans.abort({state : 409}); 
				}
				trans = newTrans;
				trans._data = trans._trans.data ? Lyte.deepCopyObject(trans._trans.data) : undefined;
				processed.previous = true;
				trans.transComp = processed.transComp;
				// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
				trans.runLoop = constructRunLoop(processedDispatch = processed);
				if(trans._trans.data) {
					newTransInfo.data = trans._trans.data;
				}
				newTransInfo.state = trans.stateObj = getHistoryState({
					replace : newTransInfo.replace,
					data : newTransInfo.data,
					url : trans.url,
					matched : trans.matched,
					fromHistory : newTransInfo.fromHistory
				});
				getHistoryObj(newTransInfo);
				trans.run();
			},0);
			} 
		}
	
		function getTransitionDiffernce(prevTrans, matched, R) {
			var like = true,
			similar = true,
			rendered = [],
			common = [],
			unRendered = [],
			templateToRemove,
			currRoute = matched.route.join('.'),
			r,
			tar = "";   
	
			if(prevTrans) {
				var prevMatched = prevTrans.matched,
				route,
				startFrom = matched.refreshRoute && currRoute == prevTrans.info.route ?  matched.refreshRoute : matched.startFrom;
				for(var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					tar = tar + (tar ? "." : "") + route;
					if(similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {
						r = R ? R[i] : LR.__lp.getDefinition(route.slice(0,i));
						if(like && compareRoute(r,i,prevMatched,matched)) {
							common.push(route);
							if(prevTrans.routes[i].__ltp.rendered) {
								rendered.push(route);  
							} else {
								// like = false; dont change this code. It is commented for decideTransition function
								unRendered.push(route);  
							}
						} else {
							like = false;
							unRendered.push(route);
						}
					} else {
						similar = false;
						if(templateToRemove == undefined && prevTrans.routes[i] && prevTrans.routes[i].__ltp.rendered && prevTrans.routes[i].outlet) {
							templateToRemove = i;
						}
						unRendered.push(route);
					}
				}
				if(prevMatched.route.length > matched.route.length) {
					var index = matched.route.length;
					if(templateToRemove == undefined && prevTrans.routes[index].__ltp.rendered /* && prevTrans.routes[i].outlet */) {
						templateToRemove = index;
					}
				}
			} else {
				unRendered = unRendered.concat(matched.route);
			}
			return {
			rendered : rendered,
			unRendered : unRendered,
			common : common,
			templateToRemove : templateToRemove
			};
		}
	
		function compareRoute(r,index,prevMatched,matched) {
			var same = true,
			routeObj = _getObj(r.__lp.objPath,config.routes);
			if(!r.queryParams && !routeObj.__lp.dkey) {
				return true;
			}
			if(routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {
				return false;
			} else if(r.queryParams && matched.refreshModel) {
				r.queryParams.every(function(key) {
					if(same && r.__lp.qpdef[key].refreshModel && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {
					return same = false;
					} else {
					return true;
					} 
				});
			}
			return same;
		}
	
		var basicHooks = [beforeModelStr,modelStr,afterModelStr,redirectStr,renderTemplateStr,afterRenderStr];
		function constructRunLoop(processed) {
			t(constructRunLoopStr);
			var transComp = processed.transComp,
			runLoop = [],
			forceFetch = {},
			beforeLoad = [],
			req = [],
			b4Exit = [],
			willTransit = [],
			didTransit = [];
	
			if (processed.previous) {
				var b4RouteTrans = [{hook : beforeRouteTransitionStr}];
				if(prevTrans) {
					for(var i = prevTrans.matched.route.length-1,r;r = prevTrans.matched.route[i]; i--) {
						var r1 = trans.matched._routes[i];
						if(!r1 || (r1.join('.') != prevTrans.matched._routes[i].join('.'))) {
							b4Exit.push({hook : beforeExitStr, index : i});
						}
						willTransit.push({hook : willTransitionStr, index : i});
					}
					t(constructRunLoopStr);
					return {previous : willTransit.concat(b4RouteTrans).concat(b4Exit) ,current : b4Exit};
				}
				t(constructRunLoopStr);
				return {previous : b4RouteTrans};
			}
			if(transComp.rendered && transComp.rendered.length) {
				transComp.rendered.forEach(function(hook,index) {
					trans.routes[index].__ltp.rendered = true;
					runLoop.push({hook : redirectStr,index : index});
					didTransit.push({hook : didTransitionStr,index : trans.matched.route.length-index-1});
				});
			}
			if(transComp.unRendered && transComp.unRendered.length) {
				// beforeLoad.push({hook : beforeLoadStr, index : transComp.rendered.length});
				transComp.unRendered.forEach(function(hook,orgIndex) {
					var index = transComp.rendered.length+orgIndex;
					if(!transComp.redirected || (transComp.redirected && transComp.redirected.index != index)) {
						beforeLoad.push({hook : beforeLoadStr, index});
						req = req.concat([{hook : getDependenciesStr, index},{hook : getResourcesStr, index }]);
					}
					var routeInstance = trans.routes[index];
					if(typeof routeInstance.forceFetch == functionStr ? callHookWithoutPromise.call(this,routeInstance.forceFetch,routeInstance,"forceFetch",index,params(index)) : routeInstance.forceFetch) {
						forceFetch[index] = [
							{hook : beforeModelStr, index : index},
							{hook : modelStr, index : index},
							{hook : afterModelStr, index : index}
						];
						newTrans.routes[index].__ltp.fetchStatus = pendingStr;
						[redirectStr,renderTemplateStr,afterRenderStr].forEach(function(h) {
							runLoop.push({hook : h,index : index});
							if(h == renderTemplateStr && transComp.unRendered[orgIndex+1]) {
								runLoop.push({hook : beforeLoadStr,index : index+1});
							}
						});
					} else {
						basicHooks.forEach(function(h) {
							if(transComp.redirected && transComp.redirected.index == index && h != redirectStr) {
								if([beforeModelStr,modelStr,afterModelStr].indexOf(h) == -1) {
									runLoop.push({hook : h,index : index});
								}
								if(h == renderTemplateStr && transComp.unRendered[orgIndex+1]) {
									runLoop.push({hook : beforeLoadStr,index : index+1});
								}
							} else {
								runLoop.push({hook : h,index : index});
								if(h == renderTemplateStr && transComp.unRendered[orgIndex+1]) {
									runLoop.push({hook : beforeLoadStr,index : index+1});
								}
							}
						});  
					}
					didTransit.push({hook : didTransitionStr,index : trans.matched.route.length-index-1});
				});
			}
			
			runLoop = {
				previous : [],
				current : [{hook : onBeforeLoadStr}].concat(beforeLoad).concat(req.concat(runLoop).concat(didTransit)),
				forceFetch : forceFetch
			};
			runLoop.templateToRemove = (prevTrans && prevTrans.runLoop.templateToRemove) ? prevTrans.runLoop.templateToRemove : [];
			if(transComp.templateToRemove != undefined) {
			runLoop.templateToRemove.push({index : transComp.templateToRemove, routes : visibleTrans.routes});
			}
			t(constructRunLoopStr);
			return runLoop;
		}
	
		function invoke(processed) {
			newTrans = new Transition(processed);
			newTrans.url = processed.path;
			newTrans.runLoop = {};
			newTrans._trans = limitTransition(newTrans);
			Lyte.extendEventListeners(newTrans._trans);
			newTrans.routes = initRoute(processed);
			if(historyObj) {
				newTransInfo = historyObj;
				newTransInfo.url = processed.path;
				newTrans._trans.data = getData() || {};
				newTransInfo.replace = true;
				historyObj = undefined;
			} else if(newTrans._trans.data) {
				LR.history.replaceState(newTrans._trans.data);
			}
		}
	
		function _getObj(arr,obj) {
			if(!obj) {
			return;
			} else if(!arr) {
			return obj;
			} else if(!Array.isArray(arr) && typeof arr == 'string') {
			arr = dotSerperator(arr);
			}
			arr.every(function(key)  {
			if(obj && obj[key]) {
				obj = obj[key];
				return true;
			}
			return obj = false;
			});
			return obj;
		}
	
		function abortRunningPromises(trans) {
			if(trans.runningProm) {
				trans.runningProm.reject(abortedStr);  
			}
			if(trans.fRunningProm) {
				trans.fRunningProm.reject(abortedStr);   
			}
		}
	
		var transId = 0;
		function Transition(processed) {
			this.transId = transId = transId+1;
			this.matched = processed.matched;
			this.target = processed.matched.target;
			this.fns = [];
			this.pending = {
				dependencies : new Set(),
				resources : new Set(),
				forceFetch : new Set()
			};
			this.info = {
				route : processed.matched.target,
				queryParams : processed.matched.queryParams,
				dynamicParams : processed.matched.dynamicParams.filter(_arrayClean)
			};
			if(processed.matched.fragment) {
				this.info.fragment = processed.matched.fragment;
			}
			this.R = processed.R;
			this.running = this.aborted = this.paused = false;
			this.abort = function(obj) {
				if(newTransInfo && newTransInfo.goValue) {
					fromHistoryGo = false;
				}
				this.abort = emptyFn;
				abortRunningPromises(this);
				this.aborted = true;
				if(!obj) {
					obj = {state : 308};
				} 
				if(this.running) {
					log(TransitionAbortedStr,routeStr);
				}
				// if(this.running && newTransInfo && !newTransInfo.replace) {
				// 	historyLength--;
				// }
				if(!obj.iAbort) {
					delete this.runLoop.templateToRemove;
					// if(prevTrans && prevTrans.url != getLocation() && this.state == 201) {
					// if(prevTrans && visibleTrans && prevTrans.url != getLocation() && trans != visibleTrans) {
						// fromHistoryGo = true;
						// if(getMeta() && getMeta().index != undefined && getMeta().index+1 == history.length) {
						// 	history.go(1);
						// } else {
						// 	history.go(-1);
						// }
					// }  
				}
				transitionCompleted(obj);
			}.bind(this);
			this.pause = function (obj) {
			log(TransitionPausedStr, routeStr);
			if (obj && obj.iPause) {
				this.iPause = true;
			} else {
				this.iPause = false;
				this.state = this._trans.state = 307;
				this._trans.triggerEvent(stateChangeStr,this.state);
			}
			this.paused = trans.prom || true;
			this.resume = this._trans.resume = function (t) {
				t = t || this;
				if (t.prom != t.eProm) {
					if (!t.pendingResume) {
						t.pendingResume = t.resume;
						delete t._trans.resume;
						delete t.resume;
					}
					return;
				}
				delete t._trans.resume;
				delete t.resume;
				log(TransitionResumedStr, routeStr);
				if (t.paused) {
					var state,
					prom = t.prom;
					if(t.paused != true) {
						state = t.paused.state;
					}
					if (t.runLoop[state]) {
						if(state == "forceFetch") {
							var newProm = t.runLoop.forceFetch[prom.index];
							if(newProm[0] && prom.hook == newProm[0].hook) {
								newProm.splice(0, 1);
							}
						} else if(t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {
							removeHook(t.runLoop[state], t.paused.hook, t.paused.index);
						}
					}
					t.iPause = t.paused = false;
					t.state = t._trans.state = 102;
					this._trans.triggerEvent(stateChangeStr,t.state);
					if(this.forceFetchRunning) {
						if(t.runLoop.forceFetch[prom.index][0]) {
							t.run(t.runLoop.forceFetch[prom.index][0]);
						} else {
							t.routes[prom.index].__ltp.fetchStatus = completedStr;
							if (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {
								delete t.pending.waitingForFF;
								t.run();
							}
						}
					} else {
						if(state && state == "forceFetch" && !t.runLoop.forceFetch[prom.index][0]) {
							t.routes[prom.index].__ltp.fetchStatus = completedStr;
						} 
						t.run();  
					}
				}
			}.bind(this);
			return this._trans;
			}.bind(this);
		}

		function debugLog() {
			if(Lyte.debug) {
				console.log.apply(this,Array.from(arguments));
			}
		}
		
		function getRequirements(object) {
			/* download files that are returned from getResources and getDependencies */
			var every = function() {};
			every.internal = {};
			var r = object.r,
			reqType = object.reqType,
			index = object.index,
			ins = r.__lp,
			hook = every.internal.hook = trans.prom.hook;
			every.internal.route = ins.objPath;
			debugLog(reqType+' before inject',this.transId,ins.objPath);
			Lyte.injectResources(ins[reqType],every,function(successFiles,errorFiles) {
				if(!config.execRouteRequirementsOnDemand) {			
					if(!trans.aborted || (ins.objPath == this.routes[index].__lp.objPath && (trans.transComp.redirected && index <= trans.transComp.common.length-1) || (Processed && Processed.transComp.redirected && index <= Processed.transComp.common.length - 1))) {
						if(trans.aborted) {
							trans = !LR.__lp.trans.aborted ? !LR.__lp.trans.aborted : newTrans;
							ins = trans.routes[index].__lp;
						}
						var fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources";
						var errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources";
						if(trans.pending[reqType].has(index)) {
							ins = trans.routes[index].__lp;
							ins[reqType+'Loaded'] = true;
							delete ins[fnType];
							trans.pending[reqType].delete(index);
							if(!errorFiles.length) {
								debugLog(reqType+' inject completed','success',trans.transId,ins.objPath);
								if(trans.pending.forceFetch.has(index)) {
									trans.pending.forceFetch.delete(index);
									nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
								} else {
									nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
								}
							} else {
								debugLog(reqType+' inject completed','failure',trans.transId);
								if(!trans.paused) {
									trans.pause({iPause : true});  
								}
								run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
							}
						} else {
							trans.routes[index].__lp[fnType] = function() {
								if(errorFiles.length) {
										debugLog(reqType+' inject completed','failure',trans.transId,this.objPath);
										trans.routes[index].__lp[reqType+'Loaded'] = true;
										delete trans.routes[index].__lp[fnType];
										// ins[reqType+'Loaded'] = true;
										// delete this[fnType];
										if(!trans.paused) {
											trans.pause({iPause : true});  
										}
										run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424); 
										return false;
								} else {
									trans.routes[index].__lp[reqType+'Loaded'] = true;
									delete trans.routes[index].__lp[fnType];
									// this[reqType+'Loaded'] = true;
									// delete this[fnType];
								}
							}
						}
						// if(!errorFiles.length) {
						// 	ins[reqType+'Loaded'] = true;
						// 	delete ins[fnType];
						// 	debugLog(reqType+' inject completed','success',trans.transId)
						// 	var pos = trans.pending[reqType].indexOf(index);
						// 	if(pos != -1) {
						// 		delete trans.pending[reqType].splice(pos,1);
						// 		if(trans.pending.forceFetch != undefined && trans.pending.forceFetch == index) {
						// 			delete trans.pending.forceFetch;
						// 			nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
						// 		}
						// 		nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
						// 	}
						// } else {
						// 	ins[fnType] = function() {
						// 		debugLog(reqType+' inject completed','failure',trans.transId);
						// 		ins[reqType+'Loaded'] = true;
						// 		delete ins[fnType];
						// 		if(!trans.paused) {
						// 			trans.pause({iPause : true});  
						// 		}
						// 		run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
						// 	}
						// }
					}
				}
			}.bind(trans),{
				defer : function(opt) {
					// if(!this.aborted) {
					var injectJS = opt.injectJS,
					files = opt.files,
					// errorFiles = opt.errorFiles,
					fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
					errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources",
					completed = function(errorFiles) {
						/* completed callback */
						trans.routes[index].__lp[reqType+'Loaded'] = true;
						if(!errorFiles.length) {
							debugLog(reqType+' inject completed','success',trans.transId,ins.objPath)
							if(trans.pending[reqType].has(index)) {
								trans.pending[reqType].delete(index);
								if(trans.pending.forceFetch.has(index)) {
									trans.pending.forceFetch.delete(index);
									nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
								} else {
									nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
								}
							}
						} else {
							debugLog(reqType+' inject completed','failure',trans.transId,ins.objPath);
							if(!trans.paused) {
								trans.pause({iPause : true});  
							}
							run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
						}
					};
					if(ins[fnType] == 'pending') {
						if(!trans.aborted || (trans.transComp.redirected && index <= trans.transComp.common.length-1)) {
							injectJS(files, function(successFiles,errorFiles) {
								debugLog(reqType+' after inject',trans.transId,this.objPath);
								// delete this[fnType];
								delete trans.routes[index].__lp[fnType];
								completed(errorFiles);
							});
						}
					} else {
						ins[fnType] = function() {
							injectJS(files, function(successFiles,errorFiles) {
								debugLog(reqType+' after inject',trans.transId,this.objPath);
								delete trans.routes[index].__lp[fnType];
								completed(errorFiles);
							});
						};
					}
					// }
				}.bind(trans)
			});
		}

		var requirements = {
			get : function(ins,type) {
				var status = ins.__lp[type+'Loaded'] == true;
				var fnType = type == dependenciesStr ? "loadDependencies" : "loadResources";
				if(!ins.__lp[fnType] || typeof ins.__lp[fnType] != 'function' || status) {
					return status;
				} else {
					var err = ins.__lp[fnType]();
					return err == false ? false : ins.__lp[type+'Loaded'] == true;
				}
			}
		};
	
		function templateDelete(arr) {
		/* clears outlet, from parent to child */
			for(var i = 0,l = arr.length,obj; i < l; i++) {
				obj = arr[i];
				for (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {
					inst = obj.routes[j];
					// delete inst.__lp.rendered;  
					if (inst.outlet) {
						triggerTemplateDestroy({outlet : inst.outletName, route : inst},true)
						inst.outlet.innerHTML = "";
						if(!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {
							callDidDestroy.call(this,inst,j,obj);
						}
					}
				}
			}
		}
		
		function triggerTemplateDestroy(obj, bool) {
			// if(!obj.route.__lp.triggeredTemplateDestroy) {
				Lyte.triggerEvent(beforeTemplateDestroyStr,obj);
				// obj.route.__lp.triggeredTemplateDestroy = bool;
			// }
		}

		function callDidDestroy(inst,index,obj) {
			log(didDestroyStr+" of "+ inst.routeName,routeStr,fontColor);
			callHookWithoutPromise.call(this,inst.didDestroy,inst,didDestroyStr,index,inst.currentModel,params(index,obj));
		} 
	
		var stoppableHooks = [getDependenciesStr,getResourcesStr,beforeModelStr,modelStr,afterModelStr]; 
		// error in these hooks should pause transition and call onerror action
		function errorStoppableHook(hook) {
			return _presence(stoppableHooks,hook);
		}
	
		function callHookWithPromise(callback,instance) {
			/* executes route hooks which will returns promise */
			if(callback) { 
				var args = arguments,
				resp,
				t = trans,
				prom = trans.prom,
				hook = prom.hook,
				index = prom.index,
				stopTrans = errorStoppableHook(hook),
				self = this;
				return new Promise(function(resolve,reject) {
					try {
						var result = callback.apply(instance,Array.from(args).slice(2));
						if(stopTrans && result) {
							result = Lyte.resolvePromises(result);
						}
						resp = Promise.resolve(result);
					} catch(err) {
						processError.call(self,{hook : hook, index : index,stopTrans : stopTrans, err : err,instance : instance, promise : {resolve : resolve, reject : reject}});
						return;
					}
					resp.then(function(data) {
						if(prom.state != "previous" && trans._trans != instance.transition) {
							reject("old transition's promise rejected")
						} else {
							resolve(data);
							callback.then && callback.then.success.apply(this,arguments);
						}
					},function(err) {
						t.prom = prom;
						reject(err)
						callback.then && callback.then.failure.apply(this,arguments)
						processError.call(self,{hook : hook, index : index,stopTrans : stopTrans,err : err,instance : instance, PR : true});

					});  
				});
			} else {
				return Promise.resolve();
			}
		}
	
		function callHookWithoutPromise(callback,instance,hook,index) {
			/* executes route hooks which wont return promise  */
			if(callback) {
				var stopTrans = errorStoppableHook(hook);
				try {
					return callback.apply(instance,Array.from(arguments).slice(4));
				} catch(err) {
					processError.call(this,{hook : hook, index : index, stopTrans : stopTrans,err : err,instance : instance});
					return;
				}  
			}
		}
	
		function callAction(hook,index,args) {
			/* executes route's actions  */
			var action,
			routeInstance = this.routes[index];
			if(routeInstance.actions && (action = routeInstance.actions[hook])) {
			try {
				if(action.apply(routeInstance,args) == false) {
				return false;
				}
			} catch(e) {
				consoleErrorFromCallback(e,hook,routeInstance.routeName);
				return false;
			} 
			}
		}

		function consoleErrorFromCallback(err,hook,routeName,state,options) {
			if(typeof err == "string" || (typeof err == "object" && err.stack && !err.$)) {
				if(!err.stack) {
					err = Error(err);
				}
				err.$ = true;
				var internalErr = getError(state || 420,hook,routeName);
				err.stack = err.stack.replace(err.message,err.message = err.message+"\n\t"+internalErr);
				consoleError(err);
			} else {
				consoleError(state,hook,routeName,err,options && options.PR);
			}
		}
	
		function processError(options) {
			/* handles error in hooks */
			var instance = options.instance,
			stopTrans = options.stopTrans,
			err = options.err,
			hook = options.hook,
			index = options.index;
			if(stopTrans) {
				trans.pause();
				run[onErrorStr].call(this,hook,index,err,420,options);
			} else {
				consoleErrorFromCallback(err,hook,instance.routeName);
				// if(_presence([willTransitionStr,didTransitionStr,beforeExitStr,redirectStr],hook)) {
					if(options.promise) {
						options.promise.resolve();
					}
				// } else {
					// trans.abort({state : 4, iAbort : true});
				// }
			}  
		}
	
		function runLoopPromise(fn,fnName,loop,success,failure) {
			success = success || emptyFn;
			failure = failure || function(error) {
				if(error != abortedStr) {
					consoleError(error);
				}
			};
			new Promise(function(resolve,reject) {
				if(fnName == "nestedForcedPromises" ) {
					this.fRunningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop.forceFetch,resolve);
				} else {
					this.runningProm = {resolve : resolve, reject : reject};
					fn.call(this,this.runLoop,loop,resolve);  
				}
			}.bind(this)).then(success,failure);
		}
	
		Transition.prototype.run = function (pausedForcedProm) {
			if(pausedForcedProm) {
			nestedForcedPromises.call(this, this.runLoop.forceFetch , this.fRunningProm.resolve ,pausedForcedProm);
			return;
			}
			processRunLoop.call(this);
			d.title = this.title = this.routes[this.routes.length-1].title || d.title;
		};
	
		function processRunLoop() {
			runLoopPromise.call(this,nestedPromises,"nestedPromises",'previous',function() {
			if(processedDispatch && !trans.running && !trans.aborted ) {
				trans.state = trans._trans.state = 102;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(newTransInfo) {
					if(config.preserveUrlOnBrowserNavigation) {
						if(newTransInfo.fromHistory && !!newTransInfo.goValue) {
							fromHistoryGo = true;
							history.go(-(newTransInfo.goValue));
						}
						newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						newTransInfoClone = Lyte.deepCopyObject(newTransInfo);
						trans.stateObj = newTransInfo.state;
						var newTransInfoTimer = setInterval(function() {
							if(!newTransInfoClone) {
								clearInterval(newTransInfoTimer);
								return;
							}
							if(!fromHistoryGo) {
								clearInterval(newTransInfoTimer);
								addToHistory(newTransInfoClone);
								newTransInfoClone = undefined;
								
							}
						},0)
					} else {
						newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
						addToHistory(newTransInfo);
						trans.stateObj = newTransInfo.state;
					}
				}
				LR.__lp.trans = trans;            
				processedDispatch.previous = false;
				trans.runLoop = constructRunLoop(processedDispatch);
				setParamsInInst(processedDispatch, trans.info);
				processedDispatch = newTransInfo = undefined;
				trans.running = true;
			}
			runLoopPromise.call(this,nestedPromises,"nestedPromises",'current');
			}.bind(this));
		}
	
		function setPendingResume(promise) {
			trans.eProm = promise;
			if (this.pendingResume) {
			var resume = this.pendingResume;
			delete this.pendingResume;
			resume();
			}
		}
	
		function nestedForcedPromises(forcedLoop, resolve, promise) {
			if (validateTransition(this) && forcedLoop) {
				if(!promise) {
					for(var key in forcedLoop) {
						var routeLoop = forcedLoop[key],
						p = routeLoop[0];
						if(p) {
							if(!p.running) {
								nestedForcedPromises.call(this, forcedLoop, resolve,p);    
							}
						}
					}
					return;
				}
				var r = this.R[promise.index],
				routeInstance = this.routes[promise.index];
				promise.state = "forceFetch";
				trans.prom = promise;
				if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
					this.pending.dependencies.add(promise.index);
					this.pending.forceFetch.add(promise.index)
					return;
					// var fn = r.__lp.loadDependencies;
					// r.__lp.loadDependencies = 'pending';
					// if(fn) {
					// 	fn();
					// 	// delete r.__lp.loadDependencies;
					// }
					// if(r.__lp.loadDependencies) {
					// 	this.pausedRunloop = true;
					// 	return;
					// }
				}
				logCallbacks(promise);
				forcedLoop[promise.index][0].running = true;
				forcedLoop[promise.index].splice(0, 1);
				run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
					setPendingResume.call(trans, trans.prom);
					if(promise.hook == afterModelStr) {
						routeInstance.__ltp.fetchStatus = completedStr;
						if (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {
							delete this.pending.waitingForFF;
							nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
						}
					} else if(promise.hook == modelStr) {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					} else {
						if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
						}
					}
				}.bind(this),function() {debugger;});
			} else {
				this.forceFetchRunning = false;
			}
		}
	
		function logCallbacks(promise) {
			if(Lyte.debug) {
				var hook = promise.hook,
				index = promise.index;
				if([beforeRouteTransitionStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {
					log(hook,routeStr,fontColor);
					return;  
				}
				var route = promise.state == "previous" ? prevTrans.R[index] : trans.R[index];
				log(hook +' of route '+route.routeName,routeStr,fontColor);    
			}
		}
	
		function nestedPromises(loop,state,resolve) {
			if(validateTransition(this)) {
				var runLoop = loop[state];
				if(runLoop && runLoop.length) {
					var promise = runLoop[0],
					r = this.R[promise.index],
					routeInstance = this.routes[promise.index];
					var cond;
					if(promise.hook == beforeModelStr) {
						cond = requirements.get(routeInstance,dependenciesStr);
					}
					if(promise.hook == beforeModelStr && !cond) {
						this.pending.dependencies.add(promise.index);
						return;
						// this.pending.dependencies.push(promise.index);
						// var fn = r.__lp.loadDependencies;
						// r.__lp.loadDependencies = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadDependencies
						// } 
						// if(r.__lp.loadDependencies) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if(promise.hook == renderTemplateStr && !requirements.get(routeInstance,resourcesStr)) {
						this.pending.resources.add(promise.index);
						return;
						// this.pending.resources.push(promise.index);
						// var fn = r.__lp.loadResources;
						// r.__lp.loadResources = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadResources
						// } 
						// if(r.__lp.loadResources) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if(promise.hook == redirectStr && r.forceFetch && routeInstance.__ltp.fetchStatus == pendingStr) {
						if(!this.forceFetchRunning) {
							this.forceFetchRunning = true;
							runLoopPromise.call(this,nestedForcedPromises,"nestedForcedPromises");
						}
						this.pending.waitingForFF = promise.index;
						return;
					} else {
						promise.state = state;
						trans.prom = promise;
						logCallbacks(promise);
						t(promise.hook+promise.index);
						run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
							setPendingResume.call(trans,trans.prom);
							t(promise.hook+promise.index);
							if(this.runningProm.resolve == resolve) {
							removeHook(loop[state],promise.hook,promise.index);
							nestedPromises.call(this,loop,state,resolve);  
							}
						}.bind(this));
					}
				} else if(resolve) {
					resolve();
				}
			} else if(this.paused && this.runningProm) {
				this.runningProm.reject(abortedStr);  
			}
		}
	
		function removeHook(loop,hook,index) {
			for(var i = 0,obj;obj = loop[i]; i++) {
				if(obj.hook == hook) {
					if(index != undefined) {
						if(index == obj.index) {
							loop.splice(i,1);
							break;
						}
					} else {
						loop.splice(i,1);
						i--;
					}
				}
			}
		}
	
		function frameQueryParams(url) {
			if(url) {
				var qp = {},
				split,
				params = _presence(url,"?") ? url.split("?")[1] : url;
				params = _presence(params,"&") ? params.split(/&/g) : [params];
				for(var i = 0,l = params.length; i < l; i++) {
					qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];
				}
				return qp;
			} 
		}
	
		function frameDynamicParams(url,matched) {
			var routesObj = config.routes,
			dynamicParam,
			fdp,
			framedDP = [],
			urlSplit = _splitPath(url.split('?')[0]);
			for(var i = 0,l = matched.route.length,r; i < l; i++) {
				r = matched.route[i];
				routesObj = _getObj([r],routesObj);
				var routeObj =  routesObj.__lp;
				if(routeObj.wildcard) {
					if(routeObj.sufix.length) {
					var dp = urlSplit.slice(0,urlSplit.indexOf(routeObj.sufix[0]));
					fdp = decodeURI(dp.join('/'));
					_pop(dp.concat(routeObj.sufix),urlSplit);
					} else {
					fdp = decodeURI(urlSplit.join('/'));
					}
				} else if(routeObj.dkey) {
					dynamicParam = urlSplit[routeObj.dIndex];
					_pop(_splitPath(routeObj.path),urlSplit);
					fdp = decodeURI(dynamicParam);
				} else {
					_pop(_splitPath(routeObj.path),urlSplit);
					fdp = undefined;
				}
				framedDP.push(fdp);
			};
			return framedDP;
		}
		
	
		function _pop(path,urlSplit) {
			for(var i = 0,l = path.length; i < l; i++) {
				urlSplit.shift();
			};
		}
	
		function _presence(str,char) {
			return str.indexOf(char) != -1;
		}
	
		function transitionCompleted(obj) {
			/* called after a atransition is completed or aborted*/
			if(trans.running) {
				if(trans == newTrans) {
					newTrans = undefined;  
				}
				if(newTransInfoClone) {
					clearInterval(newTransInfoTimer);
					addToHistory(newTransInfoClone);
					newTransInfoClone = undefined;
				}
				setActiveClassForLink(trans.info)
				for(var i = 0,l = trans.fns.length; i < l; i++) {
					clearTimeout(trans.fns[i]);
				};
				trans.pendingResume = undefined;
				trans.running = false;
				trans.state = trans._trans.state = obj.state;
				trans._trans.triggerEvent(stateChangeStr,trans.state);
				if(initialLoad || trans.state == 200) {
					LR.__lp.prevTrans = prevTrans =  trans;
					t(RouteTransitionStr);
					log(TransitionComletedStr,routeStr);
					if(config.history && trans.info.fragment) {
						var elem;
						if((elem = d.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && (LR.beforeScroll(trans._trans) != false)) {
							elem.scrollIntoView();
						}
					}
					run[afterRouteTransitionStr](trans._trans);
				} else if(obj.iAbort || visibleTrans == trans) {
					LR.__lp.prevTrans = prevTrans = trans;
					if (trans.state && trans.state != 201) {
					run[afterRouteTransitionStr](trans._trans);
					}
				} else {
					if (trans.state && trans.state != 201) {
						run[afterRouteTransitionStr](trans._trans);
					}
					LR.__lp.trans = trans = prevTrans;  
				}
				if(initialLoad) {
					initialLoad = false;
				}
			} else if(prevTrans){
				LR.__lp.trans = trans = prevTrans;
			}
		}
	
		function _delimit(seg) {
			return seg[0] == "/" ? seg : "/"+seg;
		}
	
		function _splitPath(path) {
			return path.match(/[^/?]+/g) || [];
		}
	
		function validateURL(url) {
			url = url.replace(/\/\//g,'/');
			url = url.replace(/\/\?/g,'?');
			return url;
		}
	
		function getError() {
			var args = arguments,
			error;
			switch(args[0]) {
				case 400 :
					error = args[1] ? "url '"+args[1]+"' is not defined in router." : "Base path of url is not specified.";
					break;
				case 405 :
					error = "Method not allowed before router initialization.";
					break;
				case 422 :
					error = "There is no route definition for the route "+(args[1].splice(0,args[2]+1).join('.'))+".";
					break;
				case 424 : 
					error = "File not loaded in "+args[1]+ " of route "+args[2]+".\n"+args[3][0].target.outerHTML;
					break;
				case 498: 
					error = "Invalid argument " + args[1] + (args[2] ? " provided in "+args[2] : ".");
					break;
				case 499 : 
					error = args[1] ? ("Dynamic params for the route "+args[1]+" is not provided" + (args[2] && args[2].outerHTML  ? " in "+args[2].outerHTML : ".")) : "Transition tried without arguments.";
					break;
				case 420 : 
					error = (args[3]? "Promise rejected" : "Error")+" in "+args[1]+" of route "+args[2]+".";
					break;
				case 428 : 
					error = "There is no outlet named "+args[1]+".";
					break;
				case 203 :
					error =  "Data provided for component is not valid.";
					break;
			}
			return 'LR '+args[0]+': '+error;
		}
	
		function consoleError() {
			Lyte.error(arguments[0].stack ? arguments[0] : getError.apply(this,arguments),arguments[3]);
		}
	
		function traverse(path,get) {
			if(!path) {
				consoleError(400,'');
				return;
			}
			var selectedPaths = [],
			fragment;
			if(config.history) {
				var fragSplit = path.split('#');
				if(fragment = fragSplit[1]) {
					path = fragSplit[0];
				}
			}
			var pathSplit = path.split('?');
			path = decodeURI(pathSplit[0]);
			if(path == '/') {
				if(_getObj(['/'],config.routeHash)) {
					selectedPaths.push([path]);  
				} else {
					consoleError(400,path);
					return;
				}
			} else {
				var params = pathSplit[1],
				pathSplitArr = _splitPath(path);
				var pathLevel = 0,
				pathArrLevel = [0],
				exactMatch,
				matchedPath = [];
				matchedPath.dynamicParams = [];
				findPossibleMatch(config.routeHash);
	
				function findPossibleMatch(mapObj) {
					for(var mapPath in mapObj) {
					if(!exactMatch) {
						var pathObj = mapObj[mapPath],
						innerLevel;
						if(mapPath != "__lp") {
						var mapPathSplit = _splitPath(mapPath);
						if(mapPathSplit) {
							if((innerLevel = checkArrayMatch(mapPathSplit,pathSplitArr,pathLevel,pathObj,matchedPath)) !== false) {
							pathArrLevel.push(innerLevel);
							pathLevel = pathArrLevel[pathArrLevel.length-1];
							if(pathSplitArr.length == pathLevel) {
								var path = Array.from(matchedPath.concat(mapPath));
								if(pathObj["/"]) {
								path = path.concat('/');
								}
								selectedPaths.push(path);
								if(pathObj.__lp.wildcard || pathObj.__lp.dkey) {
								pathArrLevel.pop();
								pathLevel = pathArrLevel[pathArrLevel.length-1];
								} else {
								if(!/[:*]/.test(path.join(''))) {
									exactMatch = path;  
								}
								return;  
								}
							} else {
								var innerRoutes = Object.keys(pathObj);
								matchedPath.push(mapPath);
								if(pathSplitArr[pathLevel]) {
								if(pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {
									var wildcard= Array.from(matchedPath);
									if(pathObj["/"]) {
									wildcard = wildcard.concat('/');
									}
									selectedPaths.push(wildcard);
								} else if(innerRoutes.length > 1) {
									findPossibleMatch(pathObj);    
								}
								} 
								matchedPath.pop();
								pathArrLevel.pop();
								pathLevel = pathArrLevel[pathArrLevel.length-1];
							}
							}
						}
						}
					}
					}
				}
			}
			if(exactMatch) {
				return pathProcessor(get,exactMatch,path,params,fragment);
			} else if(selectedPaths.length == 1) {
				return pathProcessor(get,selectedPaths[0],path,params,fragment);
			} else if(selectedPaths.length) {
				return pathProcessor(get,getBestMatch(getStaticMatches(selectedPaths),selectedPaths),path,params,fragment);
	
				function getBestMatch(staticMatches, selectedPaths, position) {
					position = position || 0;
					var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),
					maxStaticSeg = Math.max(...traversedStaticMatch[position]),
					duplicatePos;
					while(duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {
						position = position+1;
						var newSelectedPaths = [],
						newStaticMatches = [];
						for(var i = 0,l = duplicatePos.length; i < l; i++) {
							newSelectedPaths.push(selectedPaths[i]);
							newStaticMatches.push(staticMatches[i]);
						}
						var newSelectedPathsFiltered = [],
						newStaticMatchesFiltered = [];
						for(var i = 0,l = newStaticMatches.length; i < l; i++) {
							if(newStaticMatches[i][position] != undefined) {
								newSelectedPathsFiltered.push(newSelectedPaths[i]);
								newStaticMatchesFiltered.push(newStaticMatches[i]);
							}
						}
						if(!newSelectedPathsFiltered.length) {
							return newSelectedPaths[0];
						} else if(newSelectedPathsFiltered.length == 1) {
							return newSelectedPathsFiltered[0];
						}
						return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);
					}
					return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];
				}
	
				function getStaticMatches(selectedPaths) {
					var staticSegmentsInMatch = [];
					for(var i = 0,l = selectedPaths.length; i < l; i++) {
						var arr = Array.from(selectedPaths[i]),
						staticPath = 0,
						result = [];
						if(arr[0] == "/") {
							arr.shift();
						}
						if(arr[arr.length-1] == "/") {
							arr.pop();
						}
						var counter = -1;
						arr.every(function(seg,i) {
							var noWildcard = true;
							_splitPath(seg).every(function(innerSeg,j) {
							counter++;
							if(innerSeg == pathSplitArr[counter]) {
								staticPath++;
								if(arr.length == i+1){
								result.push(staticPath);
								}
								return true;
							} else if(innerSeg.indexOf(':') != -1) {
								result.push(staticPath);
								staticPath = 0;
								return true;
							} else {
								if(innerSeg.indexOf('*') != -1) {
								noWildcard = false;
								}
								result.push(staticPath);
								return false;
							}
							});  
							return noWildcard;
						});
						staticSegmentsInMatch.push(result);
					}
					return staticSegmentsInMatch;
				}
			} else {
				consoleError(400,path);
			}
		}
	
		function checkArrayMatch(arr1,arr2,l,pathObj,matchedPath) {
			if(!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {
			var prevObj;
			if(prevObj = _getObj(matchedPath,config.routeHash).__lp) {
				if(prevObj.wildcard) {
				var pathArr = arr2.slice(l);
				if(!(l += pathArr.indexOf(arr1[0]))) {
					return false;
				}  
				}
			}
			}
			for(var i = 0,a1;a1 = arr1[i]; i++,l++) {
			if(a1 != arr2[l] && !dynamicRouteCheck(a1)) {
				if(wildcardRouteCheck(a1)) {
				if(pathObj.__lp.sufix.length) {
					l = arr2.indexOf(pathObj.__lp.sufix[0])-1; 
				}
				} else if(arr1[l] == '/') {
				l--;
				} else {
				return false;  
				}
			}
			}
			return l;
		}
	
		function checkForArrayDuplicates(arr, value, selectedPaths, staticMatches) {
			var pos = [];
			for(var i = 0,l = arr.length;i < l; i++) {
				if(arr[i] == value) {
					pos.push(i);
				}
			}
			return pos.length == 1 ? false : pos;
		}
	
		function traverseArray(arr) {
			var res = [],
			maxArrLen = 0;
			for(var i = 0,l = arr.length; i < l; i++) {
				var a = arr[i];
				maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;
			}
			for(var i=0,a ;a = arr[i]; i++) {
				for(var j=0; j<maxArrLen; j++) {
					res[j] = res[j] || [];    
					res[j][i] = a[j];
				} 
			}
			return res;
		}
	
		function pathProcessor(get,selectedPath,path,params,fragment) {
			var newURL,
			orgMatched,
			newMatched,
			matched = {
			route : _getObj(selectedPath,config.routeHash).__lp.route,
			queryParams : params ? frameQueryParams(params) : {}
			};
			if(config.history) {
				matched.fragment = fragment;
			}
			matched.dynamicParams = frameDynamicParams(path,matched);
			if(get) {return matched;}
			matched.dpProcessed = true;
			var transInfo = normalizeMatchedObj(matched);
			if(transInfo != false) {
				orgMatched = Lyte.deepCopyObject(transInfo.matched);
				newMatched = Lyte.deepCopyObject(transInfo.matched);
				if(!transInfo.matched.hasOwnProperty('refreshModel')) {
					constructURLFromRoute(transInfo.matched);
				}
				newURL = constructURLFromRoute(newMatched);
				if(!_compareObj(newMatched.queryParams,orgMatched.queryParams)) {
					addToHistory({replace : true,state : window.history.state,url : newURL,fromHistory : true});
					transInfo.path = newURL;
				}  
			}
			return transInfo;
		}
	
		function setParamsInInst(processed, transInfo) {
			if(config.linkActiveClass) {
				config.activeLinkTags.forEach(function(tag) {
					tag.classList.remove(config.linkActiveClass);
				});
			}
			config.activeLinkTags = [];
			var R,
			r,
			matched = processed.matched;
			try {
				function linkTagPush(tag) {
					if(tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {
						activeLinkTags.push(tag);
					}
				}
				function pushQP(key) {
					r.__ltp.queryParams[key] = R.__lp.qpdef[key].cipher && config.cipher.decryptor ? config.cipher.decryptor(matched.queryParams[key]) : matched.queryParams[key];
				}
				for(var i = 0,l = trans.R.length; i < l; i++) {
					R = trans.R[i];
					r = trans.routes[i];
					if(R.queryParams) {
						R.queryParams.forEach(pushQP);
					}
					r.__ltp.dynamicParam = matched.dynamicParams[i];
					if(i+1 == l) {
						R.__lp.linkTags.forEach(linkTagPush);
					}
				}
				setActiveClassForLink(transInfo )
			} catch(e) {
				consoleError(e);
			}
			return;
		}

		function setActiveClassForLink(transInfo) {
			if(config.linkActiveClass && config.allLinks[transInfo.route]) {
				config.allLinks[transInfo.route].forEach(function(tag) {
					var tagDp = tag.getAttribute(pDp)
					if(checkIfSameDp(transInfo.dynamicParams,(tagDp ? JSON.parse(tagDp) : []))) {
						tag.classList.add(config.linkActiveClass);
						config.activeLinkTags.push(tag);
						var aTag = tag.getElementsByTagName('A')[0]
						if(aTag) {
							aTag.setAttribute("href", LR.getURL(tag.getMatchedObject())); 
						}
					}
				});
			}
		}
	
		function assignMixin(options,fns,dir,lazyload) {
			if(options && options.mixins) {
			if(!Array.isArray(options.mixins)) {
				options.mixins = [options.mixins];
			}
			options.mixins.forEach(function(mixin) {
				if(Lyte.registeredMixins[mixin]) {
					mixin = Lyte.registeredMixins[mixin];
					if(lazyload) {
						var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
						transRouteInstance = LR.getRouteInstance(dir,trans),
						newTransInstance = newTrans && LR.getRouteInstance(dir,newTrans);
						if(prevTransRouteInstance || transRouteInstance) {
							prevTransRouteInstance = prevTransRouteInstance ||  {};
							transRouteInstance = transRouteInstance ||  {};
							setMixinPropInDefandIns(mixin,fns,prevTransRouteInstance,transRouteInstance,newTransInstance);
						} else {
						setMixinPropInDef(mixin,fns);
						}
					} else {
						setMixinPropInDef(mixin,fns);
					}
				} else if(!lazyload) {
					Lyte.$.requiredMixins(mixin,dir,"router");
				}
			});
			}
		}

		// function setServicePropInDef(dir) {
		// 	var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
		// 	transRouteInstance = LR.getRouteInstance(dir,trans);
		// 	if(prevTransRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: prevTransRouteInstance});
		// 	}
		// 	if(transRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: transRouteInstance});	
		// 	}
		// }
	
		Lyte.$.requiredMixins.router = function(mixin,dir) {
			dir.forEach(function(d) {
			var fns = LR.__lp.getDefinition(d);
			if(mixin && fns) {
				assignMixin(fns.__lp.options,fns,d,true);  
			}
			});
		};

		Lyte.$.injectServices.router = function(key, name, type, ins, cIns, data) {
			var obj = {};
			obj.as = key;
			obj.service = name;
			// Lyte.extendService({services : [obj], type:"route", ins: arr});
			includeServices({services : [obj]},undefined,undefined,getDefinitionArr(),true,data)
		}

		function includeServices(options,fns,dir,def,isGlobal,data) {
			if(options && options.services){
				var toBeUsed = [], laterToBeUsed = [];
				options.services.forEach(function(itm){
					if(typeof itm == "string"){
						toBeUsed.push(itm);
					}
					else if(itm && typeof itm == "object"){
						if( isGlobal || !itm.scope || (itm.scope && itm.scope == "static")){
							toBeUsed.push(itm);
						}
						else{
							laterToBeUsed.push(itm);
						}
					}
				});
			}
			if(toBeUsed && toBeUsed.length){
				assignService(toBeUsed,fns,dir,def,isGlobal,data);
			}
			if(laterToBeUsed && laterToBeUsed.length){
				var arr = getFnsAndIns(dir,fns);
				arr.forEach(function(itm){
					if(itm && itm.__lp){
						itm.__lp.toBeUsed = laterToBeUsed;
					}
				});
			}
		}

		function assignService(servArr,fns,dir,def,isGlobal,data){
			var arr = getFnsAndIns(dir,fns);
			Lyte.extendService({services : servArr || [], type:"route", ins: def || arr, isGlobal:isGlobal, data:data, callback : function(serv, key, aName, serName){
				var obj = {};
				obj.as = key;
				obj.service = serName;
				Lyte.extendService({services : [obj], type:"route", isGlobal:isGlobal, ins: dir ? getFnsAndIns(dir,fns) : getDefinitionArr()});
			}});
		}

		function getFnsAndIns(dir,fns) {
			var arr = [fns],
			ins;
			[prevTrans, newTrans,trans].forEach(function(t) {
				if(t && (ins = LR.getRouteInstance(dir,t))) {
					arr.push(ins)	
				}
			}); 
			// var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
			// transRouteInstance = LR.getRouteInstance(dir,trans);
			// if(prevTransRouteInstance) {
			// 	arr.push(prevTransRouteInstance)
			// }
			// if(transRouteInstance) {
			// 	arr.push(transRouteInstance)
			// }
			return arr;
		}

		function getDefinitionArr(def,arr) {
			var parent = !def;
			def = def || config.routes;
			arr = arr || [];
			for(var key in def) {
				if(key == "__lp") {
					if(def.__lp.def) {
						arr.push(def.__lp.def);
					}
				} else {
					getDefinitionArr(def[key],arr);
				}
			}
			if(parent) {
				if(prevTrans && prevTrans != trans) {
					arr = arr.concat(prevTrans.routes)
				}
				if(trans) {
					arr = arr.concat(trans.routes)
				}
				return arr;
			}
		}
	
		function setMixinPropInDef(mixin,fns) {
			for(var key in mixin) {
				if(key == "actions") {
					fns.actions = Object.assign(fns.actions || {}, mixin.actions);
				} else if(key == "queryParams") {
					fns[key] = Lyte.deepCopyObject(mixin[key]);
				} else {
					fns[key] = mixin[key];  
				}
			} 
		}
	
		function setMixinPropInDefandIns(mixin,fns,prev,curr,newTrans) {
			for(var key in mixin) {
				if(key == "actions") {
					if(!fns.actions) {
						curr.actions = prev.actions = fns.actions = {};
					}
					prev.actions = curr.actions = Object.assign(fns.actions,mixin.actions);
					if(newTrans) {
						newTrans.actions = prev.actions
					}
				} else {
					prev[key] = curr[key] = fns[key] = mixin[key];  
					if(newTrans) {
						newTrans[key] = prev[key];
					}
				}
			} 
		}

		this.registerRoute = function() {
			if(config.routes) {
				registerRoute.apply({},arguments);
			} else {
				this.__lp.pendingReg.push(arguments);
			}
		};
		
		function registerRoute(dir,fns,options) {
			assignMixin(options,fns,dir);
			fns.__lp = {
				options : options,
				objPath : dir.replace(/\//g,'.'),
				stickyLinks : [],
				linkTags : []
			};
			includeServices(options,fns,dir);
			if(Lyte.toBeInjectedServices){
				var tbServ = Lyte.toBeInjectedServices, arr = [];
				for(var key in tbServ){
					arr.push({as:key, service: tbServ[key]});
				}
				includeServices({services:arr},fns,dir, undefined,true);
			}

			var sticky = config.queryParamOptions.sticky;
			if(fns.queryParams) {
				fns.__lp.qpdef = {};
				fns.queryParams.forEach(function(qp,i) {
					if(typeof qp == "string") {
					fns.__lp.qpdef[qp] = {
						sticky : sticky,
						refreshModel : true
					};
					if(config.stickyRoutes[dir] == undefined && sticky) {
						config.stickyRoutes[dir] = sticky
					}
				} else if(typeof qp == "object") {
					for(var key in qp) {
						fns.__lp.qpdef[key] = {
							cipher : qp[key].cipher,
							sticky : qp[key].hasOwnProperty('sticky') ? qp[key].sticky : sticky,
							refreshModel : qp[key].hasOwnProperty('refreshModel') ? qp[key].refreshModel : true
						};
						if(!config.stickyRoutes[dir] && fns.__lp.qpdef[key].sticky) {
							config.stickyRoutes[dir] = true
						}
					}
					fns.queryParams[i] = key;
					}
				});  
			}
			dir = dotSerperator(dir);
			fns.routeName = dir[dir.length -1];
			setRouteDef(dir,fns);
		}
	
		var transPredefined = ['runLoop','running','paused','R','routes',abortedStr,'prom','run',pendingStr,'matched','fns'];
	
		function limitTransition(int) {
			var _trans = new transition(int);
			int.state = _trans.state = 201;
			return _trans;
		}
	
		function dummy() {
			/*
			Dont delete this function.
			This one is to avoid function to be merged during minification.
			*/
			var _trans = new transition(int);
		}
	
		function transition(int) {
			for(var prop in int) {
			if(transPredefined.indexOf(prop) == -1) {
				if(prop == 'info') {
				this.info = Lyte.deepCopyObject(int[prop]);
				} else {
				this[prop] = int[prop];
				}
			}
			}
		}
	
		function dynamicRouteCheck(route) {
			return _presence(route,":");
		}
	
		function wildcardRouteCheck(route) {
			return _presence(route,"*");
		}
		
		function _compareObj(obj1,obj2) {
			var obj1keys = Object.keys(obj1),
			obj2keys = Object.keys(obj2);
			if(obj1keys.length != obj2keys.length) {
			return false;
			} else {
			for(var key in obj1) {
				if(obj1[key] != obj2[key]) {
				return false;
				}
			}
			return true;
			}
		}
	
		this.getRouteInstance = function(routeName,t) {
			var newTrans;
			if(LR && !LR.init && (newTrans = (t || (LR.__lp && LR.__lp.trans) || trans)) && newTrans.routes) {
				var routeLen = newTrans.routes.length;
				if(!routeName) {
					return newTrans.routes[routeLen-1];
				} else if(routeName == "*") {
					return newTrans.routes;
				} else {
					var reqRouteLen = routeName.split('.').length-1,
					reqRoute = newTrans.routes[reqRouteLen];
					return reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;
				}
			}
		};

		function normalizeTransitionParams(obj) {
			// To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.
			var params;
			if(typeof obj == "object") {
			params = obj;
			} else {
			params = {
				queryParams : {},
				dynamicParams : []
			};
			Array.from(arguments).forEach(function(arg,index) {
				if(Array.isArray(arg)) {
					consoleError(498,JSON.stringify(arg));
					return;
				} else {
				if(index == 0) {
					params.route = arg;
				} else if(arg && typeof arg == "object") {
					params.queryParams = Lyte.deepCopyObject(arg);
				} else {
					params.dynamicParams.push(arg);
				}  
				}
			});
			}
			return params;
		}
	
		function normalizeMatchedObj(obj) {
			// To construct dynamic params array.
			if(obj.route) {
				var routesObj = config.routes,
				matched,
				def,
				R = [],
				errorCheck = function(route,i) {
					routesObj = _getObj(route,routesObj);
					if(!routesObj) {
						throw Error(getError(400,matched.target));
					}
					if(!(def = routesObj.__lp.def)) {
						throw Error(getError(422,matched.route,i));
					}
					R.push(def)
				};
				if(obj._routes) {
					matched = obj;
				} else {
					var matched = {
						route : Array.isArray(obj.route) ? obj.route : dotSerperator(obj.route),
						queryParams : obj.queryParams || {},
						dynamicParams : [],
						fragment : obj.fragment,
						target : "",
						refreshRoute : obj.refreshRoute,
						startFrom : obj.startFrom,
						_routes : []
					};
					if(obj.dynamicParams) {
						if(obj.dpProcessed) {
							matched.dynamicParams = Array.from(obj.dynamicParams);
						} else {
							var dynamicParams =  Array.from(obj.dynamicParams);
						}
					}
				}
				try {
					matched.route.forEach(obj._routes ? errorCheck : function(route,i) {
						matched.target = matched.target ? matched.target+'.'+route : route;
						matched._routes.push(dotSerperator(matched.target));
						errorCheck(route,i)
						if(dynamicParams) {
							matched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);
						}
					});
					if(dynamicParams && dynamicParams.length) {
						Lyte.error('Extra dynamic params found. Provide exact numbers dynamic params required for the transition '+ JSON.stringify(dynamicParams));
					}
				} catch(e) {
					consoleError(e);
					return false;
				}
				return { 
					matched : matched,
					R : R
				};
			} else {
				if(this.tagName == LINKTOStr) {
					consoleError(498,pRoute,this.outerHTML);
				} else {
					consoleError(499);  
				}
			}
		}
	
		function initRoute(processed) {
			var routeObj,
			matched = processed.matched,
			routes = [],
			refMatch = processed.prevTrans,
			similarRoute = true;
	
			for(var i=0,route; route = matched.route[i];i++) {
				routeObj = LR.__lp.getDefinition(newTrans.matched._routes[i]);
				if(!routeObj) {return false;}
				if(refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {
					routes.push(new Route(routes, routeObj,i,processed,refMatch.routes[i]));
				} else {
					routes[i] = new Route(routes, routeObj,i,processed);
					similarRoute = false;
				}
			}
			refMatch = undefined;
			return routes;
		}
	
		var routePredefined = [getDependenciesStr,getResourcesStr,beforeModelStr,modelStr,afterModelStr,redirectStr,renderTemplateStr,afterRenderStr,beforeExitStr],
		Route = function(routes, fns,index,processed,prevInstance)  {
			var self = this;
			var src = prevInstance || fns;
			for(var key in src) {
				if(prevInstance || !_presence(routePredefined,key)) {
					if(key == "__lp") {
						this.__lp = Lyte.deepCopyObject(src.__lp);
					} else {
						this[key] = src[key];
					}
				} 
			}
			if(processed.transComp && !processed.transComp.rendered[index] && processed.transComp.redirected && processed.transComp.redirected.index < index) {
				delete this.__lp.loadDependencies;
				delete this.__lp.loadResources;
				this.$ = {};
				delete this.currentModel;
			} 
			this.__ltp = {
				queryParams : {}
			};
			if(this.__lp && this.__lp.toBeUsed && this.__lp.toBeUsed.length){
				var self = this;
				Lyte.extendService({services : this.__lp.toBeUsed || [], type:"route", ins: this, callback : function(serv, key, aName, serName){
					var obj = {};
					obj.key = key;
					obj.service = serName;
					Lyte.extendService({services : [obj], type:"route", ins: self});
				}});
			}
			this.transition = newTrans._trans;
			this.parent = routes[index-1];
			if(!prevInstance) {
				this.$ = {};
				if(this.init) {this.init();}
				this.throwEvent = typeof Lyte.Component !== "undefined" && Lyte.Component.throwEvent;
			}
			this.replaceWith = LR.replaceWith;
			this.transitionTo = LR.transitionTo;
			this.removeFromCache = function(arr) {
				Lyte.removeFromCache.assign(arr);
			};
			this.refresh = function(obj) {
				var refreshFrom = dotSerperator(this.__lp.objPath).length-1,
				route = Array.from(trans.matched.route),
				processed = {
					matched : trans.matched,
					R : trans.R,
					transComp : {
						unRendered : route.splice(refreshFrom),
						rendered : route
					}
				};
				trans.abort({state : 308, iAbort : true});
				newTransInfo = {replace : true,data : trans.data,fromHistory : false,url : trans.url};
				dispatch(trans.url,processed);
				if(obj && obj.refreshTemplate) {
					for(var i = refreshFrom,r; r = newTrans.routes[i]; i++) {
						delete r.component;
					}
				}
				return newTrans._trans;
			};
			this.setTitle = function(title) {
				d.title = this.title = title;
			};
			this.getQueryParams = function() {
				return this.__ltp.queryParams || {};
			};
			this.getDynamicParam = function() {
				return this.__ltp.dynamicParam;
			};
			Object.defineProperty(self,'$lg', {
				value : Lyte.__gl
			});
			this.getRouteInstance = function(routeName) {
				return LR.getRouteInstance(routeName);
			};
			this.setDynamicParam = function(value) {
				if(value && this.__ltp.dynamicParam && this.__ltp.dynamicParam != value) {
					var dynamicParams = Array.from(trans.matched.dynamicParams);
					dynamicParams.splice(this.__lp.objPath.split(".").length-1, 1, value);
					return paramChangeTrans(cloneMatchedObj(trans.matched,{dynamicParams : dynamicParams}));
				}
				return trans._trans;
			};
			function paramChangeTrans(matched) {
				var url = constructURLFromRoute(matched),
				processed = {
					matched : matched,
					R : trans.R
				};
				newTransInfo = {
					data: trans.data,
					url: url,
					fromHistory: false
				};
				dispatch(url, decideTransition(processed));
				return newTrans._trans;
				}
				this.setQueryParams = function(key,value,options)  {
				var obj = {},
				refresh;
				if(typeof key == "object") {
					obj = key;
					options = value;
				} else {
					obj[key] = value;
				}
				if(typeof options == "object") {
					refresh = options.refresh;
				}
				refresh = options;
				var matched = cloneMatchedObj(trans.matched,{queryParams : Object.assign({},trans.matched.queryParams,obj)});
				if(!_compareObj(trans.matched.queryParams,matched.queryParams)) {
					matched.refreshModel = matched.refreshModel == undefined ? refresh : matched.refreshModel;
					return paramChangeTrans(matched);
				}
				return trans._trans;
			};
		};
	
		function cloneMatchedObj(matched, data) {
			var obj = Object.assign({},matched);
			obj.route = data.route || Array.from(matched.route);
			obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);
			obj.queryParams = data.queryParams || Object.assign(matched.queryParams);
			return obj;
		}
	
		function dispatchTransition(processed) {
			// processed = setParamsInDef(newMatch);
			var url = constructURLFromRoute(processed.matched);
			if(url) {
				processed.path = newTransInfo.url = url;
				dispatch(url,decideTransition(processed));
			}
			return url;
		}
	
		var allHooks = [getDependenciesStr,getResourcesStr,beforeModelStr,modelStr,afterModelStr,redirectStr,renderTemplateStr,afterRenderStr];
		function decideTransition(processed) {
			/* determines which transition to consider as previous transition */
			if(trans) {
				if(trans.running) {
					var matched = processed.matched;
					if(trans.state == 102 && trans.prom && trans.prom.hook == redirectStr) {
						var transComp = getTransitionDiffernce(trans,matched,processed.R),
						transitioningRoute = allHooks.indexOf(trans.prom.hook) <= 5 ? trans.prom.index : trans.prom.index+1,
						visibleTransComparison = getTransitionDiffernce(visibleTrans,matched,processed.R);
						if(transComp.common.length < visibleTransComparison.common.length) {
							if(transComp.rendered.length < visibleTransComparison.rendered.length) {
								processed.prevTrans = visibleTrans;
								if(trans.runLoop.templateToRemove.length) {
									trans.runLoop.templateToRemove.pop();
								}
							}
							transComp = visibleTransComparison;
							if(trans.prom.index <= visibleTransComparison.common.length -1) {
								transComp.redirected = trans.prom;
							}
						} else if(transComp.common.length-1 >= transitioningRoute) {
							if(trans.prom.index <= transComp.common.length -1) {
								processed.prevTrans = trans;
								transComp.redirected = trans.prom;
							}
						}  
					}
					var info = {
						route : matched.target,
						queryParams : matched.queryParams,
						dynamicParams : matched.dynamicParams.filter(_arrayClean)
					};
					if(LR.checkIfSameRoute(trans.info,info) && !trans.aborted) {
						trans.pause({iPause : true});  
					} else {
						trans.abort({state : 409, iAbort : true});
					}
					processed.transComp = transComp;
				} else if(trans && !trans.aborted) {
					trans.abort({state : 409, iAbort : true});
				}
			}
			return processed;
		}

		// function getRequirements(object) {
		// 	/* download files that are returned from getResources and getDependencies */
		// 	var every = function() {};
		// 	every.internal = {};
		// 	var reqType = object.reqType,
		// 	r = object.r,
		// 	index = object.index,
		// 	hook = every.internal.hook = trans.prom.hook,
		// 	errorType = reqType == dependenciesStr ? "errorDependencies" : "errorResources",
		// 	self = this;
		// 	every.internal.route = r.__lp.objPath;
		// 	Lyte.injectResources(
		// 	r.__lp[reqType],
		// 	every,
		// 	function(successFiles,errorFiles) {
		// 		/* completed callback */
		// 		r.__lp[reqType+'Loaded'] = true;
		// 		if(!errorFiles.length) {
		// 			var pending;
		// 			if(trans.pending && (pending = trans.pending[reqType]) != undefined && pending == index) {
		// 				delete trans.pending[reqType];
		// 				if((pending = trans.pending.forceFetch) != undefined && pending == index && trans.forceFetchRunning) {
		// 					delete trans.pending.forceFetch;
		// 					nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
		// 				}
		// 				nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
		// 			}
		// 		} else {
		// 			if(!self.aborted) {
		// 				if(!self.paused) {
		// 					self.pause({iPause : true});  
		// 				}
		// 				run[onErrorStr].call(self,hook,index, (r.__lp[errorType] = errorFiles), 424);  
		// 		}
		// 		}         
		// 	}
		// 	);
		// }
		
		// function nestedPromises(loop,state,resolve) {
		// 	if(validateTransition(this)) {
		// 	var runLoop = loop[state];
		// 	if(runLoop && runLoop.length) {
		// 		var promise = runLoop[0],
		// 		r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		if(promise.hook == beforeModelStr && !requirements.get(r,dependenciesStr)) {
		// 		this.pending[dependenciesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == renderTemplateStr && !requirements.get(r,resourcesStr)) {
		// 		this.pending[resourcesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == redirectStr && r.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {
		// 		if(!this.forceFetchRunning) {
		// 			this.forceFetchRunning = true;
		// 			runLoopPromise.call(this,nestedForcedPromises,"nestedForcedPromises");
		// 		}
		// 		this.pending.forceFetch = promise.index;
		// 		return;
		// 		} else {
		// 		promise.state = state;
		// 		trans.prom = promise;
		// 		logCallbacks(promise);
		// 		t(promise.hook+promise.index);
		// 		run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
		// 			setPendingResume.call(trans,trans.prom);
		// 			t(promise.hook+promise.index);
		// 			// if(promise.hook == modelStr) {
		// 			// 	routeInstance.currentModel = data;
		// 			// }
		// 			if(this.runningProm.resolve == resolve) {
		// 			removeHook(loop[state],promise.hook,promise.index);
		// 			nestedPromises.call(this,loop,state,resolve);  
		// 			}
		// 		}.bind(this));
		// 		}
		// 	} else if(resolve) {
		// 		resolve();
		// 	}
		// 	} else if(this.paused && this.runningProm) {
		// 	this.runningProm.reject(abortedStr);  
		// 	}
		// }

		// function nestedForcedPromises(forcedLoop, resolve, promise) {
		// 	if (validateTransition(this) && forcedLoop) {
		// 		if(!promise) {
		// 			for(var key in forcedLoop) {
		// 			var routeLoop = forcedLoop[key],
		// 			p = routeLoop[0];
		// 			if(p) {
		// 				if(requirements.get(this.R[p.index],dependenciesStr)) {
		// 				if(!routeLoop[0].running) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,routeLoop[0]);    
		// 				}
		// 				} else {
		// 				this.pending[dependenciesStr] = p.index;
		// 				} 
		// 			}
		// 			}
		// 			return;
		// 		}
		// 		var r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		promise.state = "forceFetch";
		// 		trans.prom = promise;
		// 		if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
		// 			this.pending[dependenciesStr] = promise.index;
		// 			return;
		// 		}
		// 		logCallbacks(promise);
		// 		forcedLoop[promise.index][0].running = true;
		// 		forcedLoop[promise.index].splice(0, 1);
		// 		run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
		// 			setPendingResume.call(trans, trans.prom);
		// 			if(promise.hook == afterModelStr) {
		// 				routeInstance.__lp.fetchStatus = completedStr;
		// 				if (this.pending.forceFetch != undefined && this.pending.forceFetch == promise.index) {
		// 				delete this.pending.forceFetch;
		// 				nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
		// 				}
		// 			} else if(promise.hook == modelStr) {
		// 				routeInstance.currentModel = data;
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			} else {
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			}
		// 		}.bind(this));
		// 	} else {
		// 	this.forceFetchRunning = false;
		// 	}
		// }

		return this;
	}
	Lyte.Router = new Router();
})(window);
(function(window) {
// For minification
var _Lyte = Lyte;
//security
_Lyte.Security = {
    "_ourSanitizerInstance_" :{},
    "_userSanitizerInstance_":{}, 
    "_eM" : {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;',
        '=': '&#x3D;'
      }, 
    "_eR" : /[&<>"'`=]/g,
    "_eF" : function(str) {
        return this._eM[str];
    }, 
    "escape" : function(string) {
        if (typeof string !== 'string') {
            string = '' + string;
        }
        return string.replace(this._eR, this._eF.bind(this));
    }
};
var sec = { "GLOBAL_TAGS": [], "GLOBAL_ATTRIBUTES": [],"FORBID_TAGS":[],"FORBID_ATTR":[] , REUSE_CONFIG : true};
_Lyte.Security._ourSanitizerInstance_ = ZWAF['7_0_0'].HTMLPurifier(sec);
_Lyte.Security._ourSanitizerInstance_._GLOBAL_TAGS = sec.GLOBAL_TAGS;
_Lyte.Security._ourSanitizerInstance_._GLOBAL_ATTRIBUTES = sec.GLOBAL_ATTRIBUTES;
sec.GLOBAL_ATTRIBUTES.push("is","yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title");
sec.GLOBAL_TAGS.push("link-to");
_Lyte.Security._ourSanitizerInstance_._FORBID_TAGS = sec.FORBID_TAGS;
_Lyte.Security._ourSanitizerInstance_._FORBID_ATTR = sec.FORBID_ATTR;
_Lyte.Security.createSanitizer = function (obb) {
  if (!obb.GLOBAL_ATTRIBUTES) {
		obb.GLOBAL_ATTRIBUTES = [];
	}
	if (!obb.FORBID_TAGS) {
		obb.FORBID_TAGS = [];
	}
	if (!obb.FORBID_ATTR) {
		obb.FORBID_ATTR = [];
	}
	if (!obb.GLOBAL_TAGS) {
		obb.GLOBAL_TAGS = [];
  }
  obb.REUSE_CONFIG = true;
  obb.GLOBAL_ATTRIBUTES.push("is","yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title");
  obb.GLOBAL_TAGS.push("link-to");
    var globalTagArr = Array.from(obb.GLOBAL_TAGS);
    var attr = [];
    for(var a=0; a<globalTagArr.length; a++){
      if(_LC._registeredComponents[globalTagArr[a]]){
        attr = _LC._registeredComponents[globalTagArr[a]].observedAttributes;
      }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){
        attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
      }
      for(var i=0; i<attr.length; i++){
        if(obb.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
          obb.GLOBAL_ATTRIBUTES.push(attr[i]);
        }
      }
    }
	_Lyte.Security._userSanitizerInstance_ = ZWAF['7_0_0'].HTMLPurifier(obb);
	_Lyte.Security._userSanitizerInstance_._GLOBAL_TAGS = obb.GLOBAL_TAGS;
	_Lyte.Security._userSanitizerInstance_._GLOBAL_ATTRIBUTES = obb.GLOBAL_ATTRIBUTES;
	_Lyte.Security._userSanitizerInstance_._FORBID_TAGS = obb.FORBID_TAGS;
	_Lyte.Security._userSanitizerInstance_._FORBID_ATTR = obb.FORBID_ATTR;
	return _Lyte.Security._userSanitizerInstance_;
};
//var toArrayLyte = "toArrayLyte";
//var bindStr = "_bindings";
//var compStr = "component";
//var forHelperStr = "_forHelpers";
//var dynamicNodesStr = "_dynamicNodes";
//var calleeStr = "_callee";
//var getAttributeStr = "getAttribute";
//var hasAttributeStr = "hasAttribute";
//var removeAttributeStr ="removeAttribute";
//var setAttributeStr = "setAttribute";
//var parentNodeStr = "parentNode";
//var nodeNameStr = "nodeName";
//var ownerElementStr = "ownerElement";
var globalDOMEvents = ["focus","focusin","focusout","resize","scroll","click","dblclick","mousedown","mouseup","mousemove","mouseover","mouseout","change","select","submit","keydown","keypress","keyup","contextmenu"];
var registerHelperStr = "registerHelper";
var delStr = "delete";

function defProp() {
	Object.defineProperty.apply(Object, arguments);
}

function makeSet(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : new Set(),
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}
function addBindings(bindings, property) {
    bindings.add(property);
}

function makeArray(obj, key) {
	if(!obj[key]) {
		defProp(obj, key, {
			value : [],
			enumerable : false,
			writable : true,
			configurable : true
		})
	}
}

function createDocFragment() {
	return document.createDocumentFragment();
}

function createElement(elm) {
	return document.createElement(elm);
}

function insertBefore(parent, newNode, refNode) {
	parent.insertBefore(newNode, refNode);
}

function deleteBindingCheckSize(obj, key, valToDelete) {
	obj[key][delStr](valToDelete);
	if(!obj[key].size) {
		delete obj[key];
	}
}
_Lyte.registerErrorCodes({
    "LC001" : "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
    "LC002" : "{0} Component is not compiled. Please compile using Lyte CLI",
    "LC003" : "Helper named {0} is not defined",
    "LC004" : "Action named {0} doesn't exists",
    "LC005" : "Lyte.objectUtils doesn't support {0} function", 
    "LC006" : "Lyte.arrayUtils doesn't support {0} function", 
    "LC007" : "Component name not specified in Lyte.Component.render", 
    "LC008" : "Specified outlet {0} doesn't exists - Lyte.Component.render", 
    "LC009" : "Method named {0} doesn't exists in {1} component",
    "LC010" : "Parent Node / reference Node not provided for insertBefore method"
});

/*	IE Browser
	_Lyte._ie 
	Edge Browser
	_Lyte._ed 
	Replace with needed;
	_Lyte._rwpf 
	IE / Edge Browser
	_Lyte._ms
*/

let userAgent = navigator.userAgent;
//temporary fix for IE 11
if(userAgent.match(/rv:11/)) {
	_Lyte._ie = true;
    window.action = function() {
        return;
    }
}
if(userAgent.match('Edge')) {
    var s = createElement("div");
    s.innerHTML= "<template><div>c</div></template>";
    if(s.querySelector("template").childNodes.length) {
        _Lyte._ie = true;
    } else {
        _Lyte._ed = true;    
    }
    s.remove()
}

class Test extends HTMLElement {
    constructor() {
        super();
        if(!this.attributes.t) {
            _LC.frSpecial = true;
        }
    }
}

if(_Lyte._ie || _Lyte._ed) {
	var doc = createDocFragment();
	doc.appendChild(document.createTextNode("  dummy "));
	doc.childNodes[0].replaceWith(document.createTextNode("changed"));
	if(doc.childNodes[0].textContent !== "changed") {
		_Lyte._rwpf = true;
	}
	_Lyte._ms = true;
}

_Lyte.Component = {};
Lyte.Compile = {};
var _LyteComponent = _Lyte.Component;

_Lyte.arrayUtils =  function() {
	//arrayFunctions
    return _LC.aF.apply(_LC, arguments);
};
_Lyte.objectUtils =  function() {
	//objectFunctions
    return _LC.oF.apply(_LC, arguments);
}
Object.defineProperty(_LyteComponent,"register",{
    get : function(){
        Lyte._preRegister();
        return _LC.registerComponentWrapper;
    }
})
_LyteComponent.getComponentClass = function(compName){
    return _LC._registeredComponents[compName];
}
_LyteComponent.registerHelper = function() {
    _LC.registerHelper.apply(_LC, arguments);
}
_LyteComponent.set = function() {
    _LC.set.apply(_LC, arguments);
}
_LyteComponent.registeredHelpers = {};
_LyteComponent.registeredComponents = {};
function noop() {

}
_LyteComponent.registerCustomPropHandler = function(propName) {
    let dasherized = _LC.String.dasherize(propName);
    propName = _LC.String.toCamelCase(propName);
    if(_LC.customPropHandlers.indexOf(propName) === -1) {
        _LC.customPropHandlers.push(propName);
        customElementPrototype.prototype[propName] = function() {
            let argsLength = arguments.length;
            let arg0 = arguments[0];
            let options = arguments[2];
            let compData = this.component.data;
            if(!arg0) {
                //Read all the values
                let obj = {};
                for(let key in compData) {
                    if(key.startsWith(propName)) {
                        let objKey = key.substring(propName.length);
                        objKey = _LC.String.lowerCaseFirstLetter(objKey);
                        obj[objKey] = compData[key];
                    }
                }
                return obj;
                
            } else if(typeof arg0 === "string") {
                if(argsLength > 1) {
                    //Set a value
                    this.set(propName+ _LC.String.upperCaseFirstLetter(arg0), arguments[1] ,options);
                } else {
                    //Read a value
                    let actKey = propName + _LC.String.upperCaseFirstLetter(arg0);
                    return compData[actKey];
                }
            } else if(typeof arg0 === "object") {
                //Write a set of values
                for(let key in arg0) {
                    let objKey = propName + _LC.String.upperCaseFirstLetter(key);
                    this.set(objKey, arg0[key], arguments[1]);
                }
            }
        }
        _LC.customPropRegex = new RegExp("^(" + _LC.customPropHandlers.join("|")+ ")");
    }
}
_LyteComponent.unregisterComponent = function(componentName) {
    if(_LyteComponent.registeredComponents[componentName]) {
        var comp = _LC._registeredComponents[componentName];
        if(comp.activeInstances > 0) {
            _Lyte.warn("There are active instances of the component " + componentName + " and hence cannot be unregistered");
        } else {
            //Do the unregisteration here
            comp._properties = {};
            comp.component = comp._mixins = comp._actions = comp._template = comp._dynamicNodes = null;            
            comp._callBacks = {};
            comp._observers = [];
            comp._data = undefined;
            comp._methods = {};
            comp.prototype.get = noop;
            comp.prototype.set = noop;
            // delete comp.prototype.setData;
            // delete comp.prototype.getData;
            Object.defineProperty(comp.prototype, "setData", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initProperties = this._initProperties || {};
                    if(typeof arg0 === "string") {
                        this._initProperties[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initProperties[key] = arg0[key];
                        }
                    }
                }
            });

            Object.defineProperty(comp.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    this._initMethods = this._initMethods || {};
                    if(typeof arg0 === "string") {
                        this._initMethods[arg0] = arg1
                    } else if(typeof arg0 === "object") {
                        for(let key in arg0) {
                            this._initMethods[key] = arg0[key];
                        }
                    }
                }
            });

            delete _LyteComponent.registeredComponents[componentName];
            var template = document.querySelector("template[tag-name="+componentName+ "]")
            if(template) {
                template.remove();
            }
            // lyteht -> lyteHelperTemplates
            var helperTemplate = comp._helperTemplate;
            if(helperTemplate) {
                helperTemplate.remove();
            }
            if(comp._depthTemp) {
                comp._depthTemp.remove();    
            }
        }
    } else {
        _Lyte.warn("Component "+ componentName + " not yet registered");
    }
}
Lyte.createCustomElement = function (customElementName, definition) {
    var constructor = definition.constructor;
    delete definition.constructor;
    var connectedCallback = definition.connectedCallback;
    delete definition.connectedCallback;
    var attributeChangedCallback = definition.attributeChangedCallback;
    delete definition.attributeChangedCallback;
    var disconnectedCallback = definition.disconnectedCallback;
    delete definition.disconnectedCallback;
  
    this.defProperty = function(obj, key, val) {
      var obj1 = {};
      if(val.get) {
        obj1.get = val.get
      }
      if(val.set) {
        obj1.set = val.set
      }
      Object.defineProperty(obj, key, obj1);
    }
    class classDef extends HTMLElement {
      constructor() {
        super();
        if(this.isNewComp(customElementName)){
          this.executeCallbacks(constructor,arguments);
        }else{
          this.__lyteIgnore = true;
        }
      }
      connectedCallback(){
        if(this.__lyteIgnore || this.hasAttribute("lyte-rendered-ce")) {
          return;
        }
        this.executeCallbacks(connectedCallback,arguments);
        this.setAttribute("lyte-rendered-ce", "");
      }
      attributeChangedCallback(){
        if(!this.__lyteIgnore) {
          this.executeCallbacks(attributeChangedCallback,arguments);
        }
      }
      disconnectedCallback(){
        if(!LyteComponent.ignoreDisconnect && !this.__lyteIgnore) {
          this.executeCallbacks(disconnectedCallback,arguments);
        }
      }
      executeCallbacks(callBack,argArr){
        if(callBack) {
          callBack.apply(this, Array.from(argArr));
        }
      }
      isNewComp(customElementName){
        if(this.hasAttribute("lyte-rendered-ce")) {
          return false;
        }
        return true;
      }
    }
    var staticDef = definition.static;
    if(staticDef) {
      for(var key in staticDef) {
        if(typeof staticDef[key] === "object") {
          this.defProperty(classDef, key, staticDef[key]);
        } else {
          Object.defineProperty(classDef, key, {
            value : staticDef[key]
          });
        }
      }
      delete definition.static;
    }
    for(var key in definition) {
      if(typeof definition[key] === "object") {
        this.defProperty(classDef.prototype, key, definition[key]);
      } else {
        Object.defineProperty(classDef.prototype, key, { writable: true, value : definition[key]});
      }
    }
    definition.static = staticDef;
    definition.constructor = constructor;
    definition.connectedCallback = connectedCallback;
    definition.attributeChangedCallback = attributeChangedCallback;
    definition.disconnectedCallback = disconnectedCallback;
    if (document.readyState === "complete" || document.readyState === "interactive") {     
      // document is already ready to go
      customElements.define(customElementName,classDef);
    }
    else{
      LyteComponent.toBeRegistered.push({name:customElementName, def: classDef});
    }
    Lyte.registeredCustomComponent[customElementName] = classDef;
}
var elementPrototype = typeof HTMLElement !== "undefined" ? HTMLElement : Element;

_Lyte.appendTemplateDiv = function() {
    document.body.appendChild(_LC.tDiv);
    document.body.appendChild(_LC.h1Div);
}

function onDomContentForLyte() {
    // document.head.appendChild(Lyte.$.assetsDiv);
    if(!_Lyte._ie){
    	document.body.appendChild(_LC.lyteComponentsDiv);
        //document.body.appendChild(_LC.tDiv);
    }
    document.body.appendChild(_LC.hDiv);
    let bodyEvents = globalDOMEvents;    
    for(let i=0; i<bodyEvents.length; i++){    
        var evnt = bodyEvents[i];    
        document.body.addEventListener(evnt,globalEventHandler, true);    
    }    
    
    let comp = _LC.toBeRegistered;    
    if(comp.length){    
        for(let j=0; j<comp.length;j++){
            customElements.define(comp[j].name, comp[j].def);    
        }    
        _LC.toBeRegistered = [];    
    }
    if(/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        var style = createElement("style");
        style.innerHTML = "* { cursor : pointer}";
        document.head.appendChild(style);
    }
}

document.addEventListener("change", function(event) {
	var target = event.target || event.srcElement;
	if(!target._attributeDetails) {
		return;
	}
	var attributeName = "value";
	if(target.type === "checkbox" || target.type=== "radio") {
		attributeName = "checked";
	}
	let contextSwitchArray = [];
	var attrNode ;
	var attrDetail = target._attributeDetails[attributeName]
	if(!attrDetail || !attrDetail.isLbind) {
		return;
	}
	//attrNode = (attributeName === "checked") ? target._attributeDetails[attributeName].bindedNode : target.getAttributeNode(attributeName);
	var callee = target;
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee;
		}
	}
	let self = target._callee;
	if(target) {
		_LC.adCx(target, contextSwitchArray);
	}
    let obj = _LC.getNew(self.component.data, attrDetail.dynamicValue);
    if(!obj.context){
        return;
    }
    let lastKeyIndex = +obj.lastKey;
    if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
        let callReplaceAt = lastKeyIndex < obj.context.length;
        if(obj.context[lastKeyIndex] !== target[attributeName] || !callReplaceAt){
            _LC.aF(obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, target[attributeName]);
        }
    } else {
        _LC.set(obj.context, obj.lastKey, target[attributeName]);
    }
	// _LC.set(obj.context, obj.lastKey, target[attributeName]);
	if(target) {
		_LC.rmCx(target, contextSwitchArray);
	}		
});
var globalEventHandler = function(ev){
	var evnt = ev.type;
    var target = ev.target,toRemove;
    if(/^(click|dblclick)$/.test(evnt) && target.getAttribute && target.getAttribute("lyte-state") != null){
        ev.preventDefault();
		return;
	}
    if(ev.currentTarget !== document.body) {
        target = ev.currentTarget;
    }
	if(!window.event){
		toRemove = true;
		window.event = ev;
	}
    let eventStopped = false;
	while(target && target.getAttribute && (!target.getAttribute(evnt) || (target.hasAttribute("disabled") && evnt != "blur")) && target.tagName != "BODY"){
		if(_LC.hasLyteEvents(target, evnt)) {
            eventStopped = _LC.handleLyteEvents(target, ev);
            if(eventStopped) {
                break;
            }
        }
        target = target.parentNode;
	}
    if(eventStopped || !target) {
        return;
    }
 	var callee = target;
	if(!target._callee){
		while(callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
			if(callee.tagName === "BODY") {
				callee = null;
				break;
			}
			callee = callee.parentNode;
		}
		if(callee && callee.tagName === "LYTE-YIELD"){
			target._callee = callee._registerYield._callee;
		} else {
			target._callee = callee === target ? undefined : callee;
		}
	}
	if(target._evBoundEvents && target._evBoundEvents[evnt]) {
        //Not needed - but check and remove
		let actions = target._callee? target._callee.constructor._actions : target.constructor._actions ;
        //let actions = target.constructor._actions;
		let actObj = target._evBoundEvents[evnt];
        let cloneActObj = _Lyte.deepCopyObject(actObj);
        _LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target,target,evnt,cloneActObj, undefined, undefined, target, ev, undefined, true);
	} else if(target.getAttribute && target.getAttribute(evnt) && target._boundEvents && target._boundEvents[evnt]){
		let actions = target._callee.constructor._actions;
        let func = target.getAttribute(evnt).split(" => ")[1];
        let actObj = target._boundEvents[evnt];
		let cloneActObj = _Lyte.deepCopyObject(actObj);
		_LC.skipArgProcessing(cloneActObj, ev, target);
		_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, target, ev);
	}
	if(target.tagName === "LABEL"){
		var input = target.querySelector("input");
		if(input && input.getAttribute(evnt)){
			let actions = target._callee.constructor._actions;
			let func = input.getAttribute(evnt).split(" => ")[1];
			//	let actObj = target._callee.constructor.getHelper(func);
            let actObj = target._boundEvents[evnt];
            let cloneActObj = _Lyte.deepCopyObject(actObj);
			_LC.skipArgProcessing(cloneActObj, ev, target);
			_LC.throwAction.call(target._callee,target._callee,evnt,cloneActObj, undefined, undefined, input,ev);
		}
	}
	if(toRemove){
		window.event = undefined;
	}
}

class LyteYield extends HTMLElement{
    connectedCallback() {
        this._callee = this._callee || _LC.getCallee(this.parentNode, this);
        if(!this._registerYield && this._callee) {
            var yieldName;
            if(this._callee._fR && this._callee._fR._yieldCallee) {
                this._registerYield = {"_callee" : this._callee._fR._yieldCallee.component.$node};
            } else if(this._callee._yields &&  (yieldName=this.attributes["yield-name"]) && (yieldName = yieldName.nodeValue) && this._callee._yields[yieldName]) {
                this._registerYield = {"_callee" : this._callee._yields[yieldName]._callee};
            }
        }
    }
	disconnectedCallback(){
		if(_LC.ignoreDisconnect || this._deleted) {
		    return;
        }
        this._deleted = true;
        if(!this._properties) {
            return;
        }
		var nodeContextSwitchArray = [];
		_LC.adCx(this, nodeContextSwitchArray);
		_LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
		let node = this._registerYield;
		if(!node) {
            _LC.rmCx(this, nodeContextSwitchArray);
        return;
		}
		var toAppendContextSwitchArray = [];
		//newContext not needed
        var del = "delete";//for ie 11.0
		_LC.adCx(node, toAppendContextSwitchArray);
		for(let key in this._dynamicProperty) {
			if(this._dynamicProperty[key].isActualNode) {
				this._dynamicProperty[key].isActualNode._helperNodes[del](this);
			}else {
                let helperNodes = node._callee.getProperty(key)._helperNodes;
				if(helperNodes) {
					helperNodes[del](this);
				}
			}
		}
        this._dynamicProperty = {};
		for(let i=0;i<this._helpers.length;i++) {
			node._callee.removeHelpers(this._helpers[i]);
		}
		this._helpers = [];
		_LC.rmCx(node, toAppendContextSwitchArray);
		_LC.rmCx(this, nodeContextSwitchArray);
        // var self = this;
        // setTimeout(function() {
        //     self._registerYield = null
        //     self._callee = null;
        // },0);
	}
	getProperty(key) {
            var arr = key.match(/([^[\].]+|\[\])/g);
        	let property = this;
        	if(!property._properties[arr[0]]) {
            		property._properties[arr[0]] = {};
       	 	} 
       	 	property = property._properties[arr[0]];
        
        	defProp(property, '_path', {enumerable: false, value : arr[0]});
        	for(let i=1;i<arr.length;i++) {
                if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
                    arr[i] = arr[i].substring(1, arr[i].length -1);
                }
            		if(!property[arr[i]]) {
                		property[arr[i]] = {};
                		defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
           	 	}
            	property = property[arr[i]];
       	 	}
       		return property;
    	}
}

customElements.define("lyte-yield", LyteYield);

class customElementPrototype extends elementPrototype{
    constructor() {
        super();
        if(this.hasAttribute("lyte-rendered")  || this._ccCalled) {
            this.__lyteIgnore = true;
        	return;
        } else if(!_LyteComponent.registeredComponents[this.localName]){
            this.__lyteIgnore = true;
            var origClass = _LC._registeredComponents[this.localName];
            origClass._pendingComponents = origClass._pendingComponents || [];
            origClass._pendingComponents.push(this);
            return;
        }
        this.actualConstructor();
    }

    actualConstructor() {
        this.constructor.activeInstances++; 
        let fastRenderIndex;
        let lytePropAttr = this.attributes._lyteprop;
        lytePropAttr = lytePropAttr ? lytePropAttr.nodeValue : undefined;
        let fastRenderedProp = (fastRenderIndex = lytePropAttr) ? _LC.fRP[fastRenderIndex] : undefined;
        let compInstance = this.component = fastRenderedProp ? fastRenderedProp.component : new this.constructor.component();
        this._properties = {};
        // compInstance.methods = {};
        // this._methods = compInstance.methods;
        
        compInstance._config = this.constructor._config;
//        this.component.data = this.constructor._data ? this.constructor._data() : {};
        let compData;
        //comment the following two when return cli update is done.
        
        var act = compInstance.actions;
        Object.defineProperty(compInstance,"actions",{
            get : function() {
        		Lyte.warn("Accessing actions directly is deprecated. Move the required common code from action block to a common function and access it.");
        		return act;
        	}   
        });
        if(!fastRenderedProp) {
            compData = compInstance.data = {};
            let data = this.constructor._data ? this.constructor._data.apply(compInstance) : {};
            var def = "default";
            defProp(compData, '__component__', {
                value : this,
                configurable : true,
                writable: true,
                enumerable : false
            });
            compData.errors = {};
            compInstance.__data = data;
            for(let key in data) {
                var obj = data[key];
                compData[key] = obj[def];
                var customDtype;
                if( Lyte.Transform[obj.type]){
                    var customDataType = Lyte.Transform[obj.type]
                    if(/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))){
                        customDtype=true;
                    }
                }
                if((/^(object|array)$/.test(obj.type) && obj.watch) || customDtype ){
                    Lyte.establishObjectBinding(compData, key, false,undefined,undefined,obj.watch?true:undefined);
                }
            }
            if(this.constructor._serviceToBeUsed){
                for(var serKey in this.constructor._serviceToBeUsed){
                    var serName = this.constructor._serviceToBeUsed[serKey];
                    if(Lyte.registeredServices.hasOwnProperty(serName)){
                        this.component[serKey] = new Lyte.registeredServices[serName]();
                    } 
                    else{
                        this.__toRemoveLazy = this.__toRemoveLazy || {}; 
                        var self = this;
                        var id = Lyte.$.requiredServices(serKey,serName,function(serviceData,serviceKey,_sname,servName){
                            self.component[serviceKey] = new serviceData();
                            var  _toRemove = self.__toRemoveLazy[servName];
                            _toRemove.forEach(function(id){
                                Lyte.$.toRemoveFromRequiredServices(id);
                            });
                            delete self.__toRemoveLazy[servName];
                        });
                        this.__toRemoveLazy[serName] = this.__toRemoveLazy[serName] || [];
                        this.__toRemoveLazy[serName].push(id);
                    }
                }
            }
        }
        
        // for(let key in this.constructor._methods) {
        //     compInstance.methods[key] = this.constructor._methods[key];
        // }
        // var met = compInstance.methods;
        // Object.defineProperty(compInstance,"methods",{
        //     get : function() {
        // 		Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
        // 		return met;
        // 	},
        //     set : function(value){
        //         met = value
        //     }   
        // });
        if(compInstance.$node) {
            for(var key in compInstance.$node) {
                if(key != "localName"){
                    this[key] = compInstance.$node[key];
                }
            }
        }
        this.initializeMethod(this, this.constructor._methods);
        compInstance.$node = this;
        let _config_flag;
        if( compInstance._config ){
            _config_flag = compInstance._config.clientLifeCycleHooks == true || ( typeof compInstance._config.clientLifeCycleHooks == 'object' ? compInstance._config.clientLifeCycleHooks.includes('constructor') : false );
        }
        let _overrides;
        
        if(!fastRenderedProp) {
            this.callback("constructor");
            this._actions = this._actions ? this._actions : {};
            this._callee = this._callee || this.getCallee(this.parentNode);
    
                //check if it is called from server || to ssr bind
                
                //check if it has ssr contructor for ssr
                //ssrcode_client              
                if( _config_flag || !this.hasAttribute( 'server-rendered' ) ){
                    if( _overrides && _overrides.constructor && this.serverCall ){
                        _overrides.constructor.apply( this );
                    }else{
                        this.callback("constructor");
                    }
                }          

            //checking lyte.attr ytpe and given default value type
            for (var key in compData) {
                var error = _LC.handleValidation(compData, key, compData[key], compInstance ,true);
                if (error) {
                    compData[key] = undefined;
                }
            }
        } else {
            this._fR = fastRenderedProp;
            delete _LC.fRP[fastRenderIndex];
            // _LC.pushFrc(fastRenderIndex);
        }
    }

    getMethods(arg0) {
        return this.component.getMethods(arg0);
    }
    hasAction(arg0) {
        return this.component.hasAction(arg0);
    }
    setActions(arg0,arg1){
        return this.component.setActions(arg0,arg1);
    }
    setMethods(arg0, arg1) {
        return this.component.setMethods(arg0, arg1);
    }
    // getData(arg0) {
    //     return this.component.getData(arg0);
    // }
    // setData(arg0, arg1 ,options) {
    //     return this.component.setData(arg0, arg1, options);
    // }
    getCallee(callee){
        return _LC.getCallee(callee, this);
    }
    afterConnected(fastRenderProp,ssrBind) {
        let constr = this.constructor;
        //initProperties is used because, we may have cases where the component wouldn't have been registered but 
        //it would be in dom already with some attributes. In those cases we can store the data in _initProperties as key, value.
        //These properties would then be applied to the component, once it gets instantiated. 
        
        //This is done, in order to solve when on a string value update of an if helper, the binding in the true or false case must be established. 
        //Without this, we won't establish the _properties in the component to the actual Data. 
        if(this.getAttribute("_lyteprop")) {
        	return "";
        }
        let obsattr = constr._observedAttributes;
        for(let i=0;i<obsattr.length;i++){
            let key = obsattr[i];
            let prop = this.getProperty(key);
            defProp(prop, '__fromComponent', {
            	value : true,
                enumerable : false
            });
        }
        this.getProperty("errors");
        var $lg = Lyte.__gl, 
        compInstance = this.component,
        compData = compInstance.data;
        compData.$lg=$lg;
        if(this._initProperties) {
            let initProperties = this._initProperties;
            for(let key in initProperties) {
                let actVal;
                let field = compInstance.__data[key]; 
                if(field && field.type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || field.type === "boolean")) {
                    actVal = _LC.typeCast(initProperties[key], compInstance.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                // if(field){
                    let error = _LC.handleValidation(compData, key, actVal, compInstance ,true);
                    if(!error) {
                        compData[key] = actVal;
                        var customDtype;
                        if( field && Lyte.Transform[field.type]){
                            var customDataType = Lyte.Transform[field.type]
                            if(/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))){
                                customDtype=true;
                            }
                        }    
                        if((field && /^(object|array)$/.test(field.type) && field.watch ) || customDtype){
                            Lyte.establishObjectBinding(compData, key, undefined,undefined,undefined,field.watch?true:undefined);
                        }
                    }    
                // }
            }
            this._initProperties = undefined;
        }
        // if(compData.errors && Object.keys(compData.errors).length){
        //     Lyte.error("Error in data passed to component-"+this.component.$node.localName+" for the properties-"+Object.keys(this.component.data.errors).toString());
        // }
        if(this._initMethods) {
            let initMethods = this._initMethods;
            for(let key in initMethods) {
                compInstance.$node._methods[key] = initMethods[key];
            }
            this._initMethods = undefined;
        }
    
        let _config_flag;
        if( compInstance._config ){
            if( compInstance._config.clientLifeCycleHooks != undefined ){
                _config_flag = compInstance._config.clientLifeCycleHooks == true || ( typeof compInstance._config.clientLifeCycleHooks == 'object' ? compInstance._config.clientLifeCycleHooks.includes('init') : false );
            }
        }   
        let _overrides;      
        
        //ssrcode client
        ssrBind && this.cmpBind(fastRenderProp);        
        if( _config_flag || !this.hasAttribute( 'server-rendered' ) )
        {
            if( _overrides && _overrides.init && this.serverCall ){
                _overrides.init.apply( this );
            }else{        
                this.callback('init');
            }
            this.onCallBack('init');
        }
        this.registerYields();
        if(compData.lyteUnbound) {
        	_LC.unbound = true;
        }
        let content = "";
        let unboundBeta = compData.lyteFastRender;
    
        //to bind in ssr
        
        if(!unboundBeta) {
            content = this.renderNodes(constr._template, constr._dynamicNodes,undefined,undefined, undefined, undefined, this.constructor._tC);
        } else {
            content = this.renderFast(constr._dynamicNodes, constr._sta, compInstance);
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.callCC();
                });
            });
        }
        return content;
    }
    initializeMethod(node,actMethods){
        let compInstance;
        if(node.component){
            compInstance = node.component;
        }else{
            compInstance = node;
            node = compInstance.$node;
        }
        compInstance.methods = {};
        node._methods = compInstance.methods;
        for(let key in actMethods) {
            compInstance.methods[key] = actMethods[key];
        }
        var met = compInstance.methods;
        Object.defineProperty(compInstance,"methods",{
            get : function() {
        		Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
        		return met;
        	},
            set : function(value){
                met = value
            }   
        });
    }
    renderComponent(dynNode, preDefObj) {
    	var componentName = dynNode.componentName;
    	var staticAttrs = dynNode.staticAttrs;
        var constr = LyteComponent._registeredComponents[componentName];
        if(!constr) {
          return "";
        }
    	var component =  new constr.component();
    	preDefObj.component = component;
    	component.data = {};
    	let data = constr._data ? constr._data.apply(component) : {};
    	var def = "default";
    	for(let key in data) {
            component.data[key] = data[key][def];
        }
        component.data.errors = {};
        component.__data = data;
        // if(component.constructor) {
        // 	component.constructor.apply(component);
        // }
        var obsAttrs = LyteComponent._registeredComponents[componentName]._observedAttributes;
        preDefObj.data = preDefObj.data || {};
		for(var key in staticAttrs) {
			if(obsAttrs.indexOf(key) !== -1) {
				preDefObj.data[key] = staticAttrs[key];
			}
		}
		let initProperties = preDefObj.data;
        if(initProperties) {
            for(let key in initProperties) {
                let actVal;
                if(component.__data[key] && component.__data[key].type !== _LC.getDataType(initProperties[key]) && (initProperties[key] !== undefined  || component.__data[key].type === "boolean")) {
                    actVal = _LC.typeCast(initProperties[key], component.__data[key].type);
                } else {
                     actVal = initProperties[key];
                }
                let error = _LC.handleValidation(component.data, key, actVal, component);
                if(!error) {
                    component.data[key] = actVal;    
                }
            }
        }
        if(true) {
            // component.methods = {};
			// for(var key in constr._methods) {
			//     component.methods[key] = constr._methods[key];
            // }
            // // debugger;
            // component._methods = component.methods;
            // component.constructor._methods = constr._methods;
            component.$node = {"querySelector" : noop, "localName" : componentName};
            this.initializeMethod(component, constr._methods);
        	if(component.init) {
            	component.init.apply(component);
            }
            let initCallbacks;
            if(constr._callBacks && (initCallbacks = constr._callBacks.init)) {
			    for(let i=0;i<initCallbacks.length;i++) {
			        initCallbacks[i].value.apply(component);
			    }
			}
            preDefObj.unbound = true;
            delete component.$node.querySelector;
        	return this.renderFast(LyteComponent._registeredComponents[componentName]._dynamicNodes, LyteComponent._registeredComponents[componentName]._sta, component, preDefObj);
        }
		return "";
    }

    renderFast(dynamicNodes, arr, comp, compPreDef) {
        var fastRenderIndex;
        var prevComp;
        if(comp) {
            prevComp = this.component;
            this.component = comp;
        }
        var compData = this.component.data;
        var str = "";
        var dynamicCompile = arr;
        var dynamicCompileNodes = arr.cc;
        let removeFirstChar = false;
        for(var i=0;i<dynamicCompileNodes.length;i++) {
            if(dynamicCompileNodes[i] != undefined) {
                var inte = dynamicCompileNodes[i];
                var dynNode = dynamicNodes[inte];
                if(dynNode.dynamicValue) {
                    let locVal = _LC.getDD(compData, dynNode.newDynamicValue);
                    locVal = (locVal == undefined || locVal == null) ? "" : locVal; 
                    // str = str + ZSEC.Encoder.encodeForHTML(locVal);
                    str = str + Lyte.Security.escape(locVal);
                } else if(dynNode.helperInfo) {
                    _LC.ffr = true;
                      let helperVal = this.processHelper({name : dynNode.helperInfo.name, args : this.processArgs(this,dynNode, [], undefined, undefined, true)}, undefined);
                    _LC.ffr = false;
                     helperVal = (helperVal == undefined || helperVal == null) ? "" : helperVal;
                    //  str = str + ( (dynNode.helperInfo.name === "unescape") ? helperVal : ZSEC.Encoder.encodeForHTML(helperVal) );
                    str = str + ( (dynNode.helperInfo.name === "unescape") ? helperVal : Lyte.Security.escape(helperVal) );
                } else if(dynNode.type){
                    switch(dynNode.type) {
                        case "for" : {
                            let prevDynamic = dynamicNodes[inte-1].attr.items;
                            var items;
                            if(prevDynamic.dynamicValue) {      
                                items = _LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                items = this.processHelper({name : prevDynamic.helperInfo.name, args : this.processArgs(this,prevDynamic, [], undefined, undefined, true)}, undefined);
                            }
                            var itemKey = dynNode._args.item || "item";
                            var indexKey = dynNode._args.index || "index";
                            let renderedStr = "";
                            if(items && items.length) {
                                var initialItemValue = compData[itemKey];
                                var initialIndexValue = compData[indexKey];
                                for(var indexInd=0;indexInd<items.length;indexInd++) {
                                    let item = items[indexInd];
                                    compData[itemKey] = item;
                                    compData[indexKey] = indexInd;
                                    renderedStr += this.renderFast(dynNode.dynamicNodes, dynNode._sta, undefined, compPreDef);
                                }
                                compData[itemKey] = initialItemValue;
                                compData[indexKey] = initialIndexValue;
                            }
                            str += renderedStr;
                        }
                        break;
                        case "forIn" : {
                            let prevDynamic = dynamicNodes[inte-1].attr.object;
                            var object;
                            if(prevDynamic.dynamicValue) {
                                object = _LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                object = this.processHelper({name : prevDynamic.helperInfo.name, args : this.processArgs(this,prevDynamic, [], undefined, undefined, true)}, undefined);
                            }
                            var valueKey = dynNode._args.value || "value";
                            var keyKey = dynNode._args.key || "key";
                            let renderedStr = "";
                            let objKeys;
                            if(object && (objKeys = Object.keys(object))) {
                                var initialValueValue = compData[valueKey];
                                var initialKeyValue = compData[keyKey];
                                for(var keyIndex=0;keyIndex < objKeys.length;keyIndex++) {
                                    let key = objKeys[keyIndex];
                                    compData[valueKey] = object[key];
                                    compData[keyKey] = key;
                                    renderedStr += this.renderFast(dynNode.dynamicNodes, dynNode._sta, undefined, compPreDef);
                                }
                                compData[itemKey] = initialValueValue;
                                compData[indexKey] = initialKeyValue;
                            }
                            str += renderedStr;
                        }
                        break;
                        case "if" : 
                        case "switch" : {
                            let prevDynamic = dynamicNodes[inte-1].attr.value;
                            var value;
                            if(prevDynamic.dynamicValue) {
                                value = _LC.getDD(compData, prevDynamic.newDynamicValue);
                            } else if(prevDynamic.helperInfo) {
                                value = this.processHelper({name : prevDynamic.helperInfo.name, args : this.processArgs(this,prevDynamic, [], undefined, undefined, true)}, undefined);
                            }
                            var currentCaseName;
                            if(value) {
                                currentCaseName = dynNode.type === "if" ? "true" : value.toString();
                            } else {
                                if(dynNode.type=== "if")  {
                                    currentCaseName = "false";
                                } else {
                                    switch(value) {
                                    case undefined : 
                                        currentCaseName = "undefined";
                                        break;
                                    case null : 
                                        currentCaseName = "null";
                                        break;
                                    case false: 
                                        currentCaseName = "false";
                                        break;
                                    case "": 
                                        currentCaseName = '""';
                                        break;
                                    }
                                }
                            }
                            let scope = dynNode.cases[currentCaseName];
                            if(!scope) {
                                if((scope = dynNode.default) && scope._sta) {
                                    str += this.renderFast(scope.dynamicNodes, scope._sta, undefined, compPreDef);
                                }
                            } else {
                                while(scope) {
                                    str += this.renderFast(scope.dynamicNodes, scope._sta, undefined, compPreDef);
                                    if(scope.additional) {
                                        if(scope.additional.next) {
                                            scope = dynNode.cases[scope.additional.next];
                                        } else {
                                            scope = dynNode.default;
                                        }
                                        
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                        case "attr" : {
                            let nextDynamic;
                            let fastRenderProp;
                            let dynLength = dynamicNodes.length;
                            for(let k=inte+1;k<dynLength;k++) {
                                let locDyn = dynamicNodes[k];
                                if(locDyn.type !== "registerYield" && locDyn.type !== "componentDynamic" && locDyn.type !== "insertYield" && locDyn.type !== "component") {
                                    break;
                                } else {
                                    if(dynamicNodes[k].type === "componentDynamic" || dynamicNodes[k].type === "insertYield" || dynamicNodes[k].type === "component") {
                                        if(dynamicNodes[k].position.toString() == dynamicNodes[inte].position.toString()) {
                                            if(dynamicNodes[k].type == "componentDynamic") {
                                                if(_LyteComponent.registeredComponents[dynamicNodes[k].componentName]) {
                                                    nextDynamic = dynamicNodes[k];
                                                    break;
                                                }
                                            } else {
                                                nextDynamic = dynamicNodes[k];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            let setAttr;
                            if(nextDynamic) {
                                setAttr = nextDynamic.type !== "component";
                                fastRenderIndex = _LC.fRC++;
                                fastRenderProp = _LC.fRP[fastRenderIndex] = {"data" : {}};
                            }
                            if(!nextDynamic || nextDynamic.type !== "component") {
                                str = str.substring(0, str.length - 11);
                            }
                            let attr = dynNode.attr;
                            let actionObj = {};
                            for(var key in attr) {
                                if(attr[key].dynamicValue) {
                                    // let nodeValue = this.get(attr[key].dynamicValue);
                                    let nodeValue = attr[key].newDynamicValue ? _LC.getDD(compData, attr[key].newDynamicValue) : this.get(attr[key].dynamicValue);
                                    
                                    if(fastRenderProp) {
                                        fastRenderProp.data[attr[key].camelCase] = nodeValue;
                                        if(typeof nodeValue == "string" && setAttr) {
                                            nodeValue = this.formatValue(key, nodeValue);
                                            str = str + nodeValue + " ";
                                        }
                                    } else {
                                        nodeValue = this.formatValue(key, nodeValue);
                                        str = str + nodeValue + " ";
                                    }
                                } else if(attr[key].helperInfo) {
                                    if(attr[key].helperInfo.name === "action") {
                                        let actionName = attr[key].helperInfo.args[0];
                                        let boundName;
                                        if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                            boundName = actionName.substring(1, actionName.length - 1);
                                        } else {
                                            _Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                            boundName = actionName;
                                        }
                                        let actArgs = this.processArgs(this, attr[key], [], "__lyteEvent__", "__lyteNode__");
                                        let actualAttrName = attr[key].globalEvent ? attr[key].name : (attr[key].name.indexOf("-") !== -1)? attr[key].name : attr[key].name.substr(2);
                                        actionObj[actualAttrName] = {"name" : boundName, "args" : attr[key].helperInfo.args, "actArgs" : actArgs, "globalEvent" : attr[key].globalEvent ? true : false, "skipArgProcessing" : true};
                                    }  else if (attr[key].helperInfo.name === "method") {
                                        var methodsObj = compPreDef ? compPreDef.methods : this._methods; 
                                        if(fastRenderProp) {
                                            let methods = fastRenderProp.methods = fastRenderProp.methods || {};
                                            let parentComp = compPreDef ? compPreDef.component : this.component;
                                            let actArgs = this.processArgs(this, attr[key], [], "__lyteEvent__", "__lyteNode__");
                                            var methodFunc = function() { //eslint-disable-line no-loop-func
                                                let node = this.$node;
                                                let args = actArgs.slice(1);
                                                let functionName = actArgs[0];
                                                let customArgs = Array.from(arguments);
                                                let mainArgs = args.concat(customArgs);
                                                return parentComp.$node._methods[functionName].apply(parentComp, mainArgs);
                                            }
                                            methods[attr[key].camelCase] = methodFunc;
                                        }
                                    } else {
                                        let nodeValue = this.processHelper({name : attr[key].helperInfo.name, args : this.processArgs(this,attr[key], [], undefined, undefined, true)}, undefined);
                                        if(fastRenderProp) {
                                            fastRenderProp.data[attr[key].camelCase] = nodeValue;
                                            if(typeof nodeValue == "string" && setAttr) {
                                                nodeValue = this.formatValue(key, nodeValue);
                                                str = str + nodeValue + " ";
                                            }
                                        } else {
                                            nodeValue = this.formatValue(key , nodeValue);
                                            str = str + nodeValue + " ";                                        
                                        }
                                    }
                                }
                            }
                            if(Object.keys(actionObj).length) {
                                let locIndex = _LC.fRC++;
                                str = str + "lyteaction=" + locIndex + " ";
                                _LC.fRP[locIndex] = actionObj;
                                actionObj.componentName = this.component.$node.localName || "undefined";
                                //str = str + "lyteaction=" + ZSEC.Encoder.encodeForHTMLAttribute(JSON.stringify(actionObj)) + " ";
                            }
                            if(fastRenderProp && nextDynamic.type !== "component" && nextDynamic.type !== "insertYield") {
                                str = str + "_lyteprop=" + fastRenderIndex + " ";
                            }
                            if(!dynNode.attrHandling) {
                                dynamicCompile[i+1] = dynamicCompile[i+1].substr(1);
                                dynNode.attrHandling = true;
                            }
                        }
                        break;
                        case "insertYield" : {
                            let preDefObj = fastRenderIndex !== undefined ? _LC.fRP[fastRenderIndex] : undefined;
                            if(preDefObj) {
                                delete _LC.fRP[fastRenderIndex];
                                // _LC.pushFrc(fastRenderIndex);
                            }
                            fastRenderIndex = undefined;
                            let yieldObj;
                            let yieldName = dynNode.yieldName || preDefObj.data.yieldName;
                            if(preDefObj) {
                                delete preDefObj.data.yieldName;
                            }
                            let yieldCallee;
                            if(!compPreDef || !compPreDef.yields) {
                                yieldObj = this._yields[yieldName];
                                if(yieldObj) {
                                    yieldCallee = yieldObj._callee;
                                } else {
                                    break;
                                }
                            } else {
                                yieldObj = compPreDef.yields[yieldName];
                                yieldCallee = compPreDef._yieldCallee;
                            }
                            if(yieldObj) {
                                let parentScope;
                                let locComp;
                                if(yieldCallee instanceof HTMLElement) {
                                    parentScope = yieldCallee;
                                } else {
                                    parentScope = this;
                                    locComp = this.component;
                                    this.component = yieldCallee.component;
                                }
                                let contextSwitch = {};
                                let contextSwitchArray = [];
                                if(yieldObj._cx) {
                                    _LC.adCx(yieldObj, contextSwitchArray);
                                }
                                if(preDefObj) {
                                    for(var key in preDefObj.data) {
                                        contextSwitch[key] = parentScope.component.data[key];
                                        parentScope.component.data[key] = preDefObj.data[key];
                                    }
                                }
                                var componentScope = parentScope.component;
                                if(prevComp && prevComp.$node == yieldCallee) {
                                    componentScope = prevComp
                                }
                                // if(componentScope == this.component) {
                                //     componentScope = prevComp;
                                // }
                                str = str + parentScope.renderFast(yieldObj.dynamicNodes || yieldObj._dynamicNodes, yieldObj._sta, componentScope, yieldCallee);
                                for(let key in contextSwitch) {
                                    parentScope.component.data[key] = contextSwitch[key];
                                }
                                if(yieldObj._cx) {
                                    _LC.rmCx(yieldObj, contextSwitchArray); 
                                }
                                if(locComp) {
                                    parentScope.component = locComp;
                                }
                            }
                            //str = str + this.renderComponent(dynNode, preDefObj, compData);
                        }
                        break;
                        case "component" : {
                            if(fastRenderIndex !== undefined) {
                                let preDefObj = _LC.fRP[fastRenderIndex];
                                let componentName = preDefObj.data.componentName;
                                if(componentName) {
                                    if(_LyteComponent.registeredComponents[componentName]) {
                                        str = str + "<" + componentName + " _lyteprop="+ fastRenderIndex+">";
                                        fastRenderIndex = undefined;
                                        str = str + this.renderComponent({"componentName" : componentName}, preDefObj, compData);
                                        str = str + "</" + componentName + ">";
                                    } else {
                                        str = str + "component not registered";
                                        // Handle case where component has not been registered yet. 
                                    }   
                                }
                            }
                        }
                        break;
                        case "componentDynamic" : {
                            let preDefObj = fastRenderIndex !== undefined ? _LC.fRP[fastRenderIndex] : {};
                            fastRenderIndex = undefined;
                            str = str + this.renderComponent(dynNode, preDefObj, compData);
                        }
                        break;
                        case "registerYield" : {
                            let preDefObj;
                            if(fastRenderIndex !== undefined) {
                                preDefObj = _LC.fRP[fastRenderIndex];
                            } else {
                                fastRenderIndex = _LC.fRC++;
                                preDefObj = _LC.fRP[fastRenderIndex] = {};
                            }
                            preDefObj.yields = preDefObj.yields || {};
                            preDefObj.yields[dynNode._args["yield-name"]] = dynNode;
                            if(!preDefObj._yieldCallee) {
                                preDefObj._yieldCallee = compPreDef ? compPreDef : {"component" : this.component};
                            }
                        }
                    }
                } else {
                    str = str + dynamicCompile[i];
                }
            } else {
                str = str + dynamicCompile[i];
            }
        }
        if(comp) {
            this.component = prevComp;
        }
        return str;
    }

    formatValue(key, nodeValue) {
        let type = typeof nodeValue;
        if(nodeValue === "") {
            type = "undefined";
        }
        let retVal;
        let isSpecialAttr = (key == "src") || (key == "href");
        switch(type) {
        case "boolean" : 
            return nodeValue ? key : "";
        case "object" : 
            retVal = ((typeof Record != "undefined" && nodeValue instanceof Record) ? JSON.stringify(nodeValue.$.toJSON()) : JSON.stringify(nodeValue));
            // return key + "=" + (isSpecialAttr ? retVal : ZSEC.Encoder.encodeForHTMLAttribute(retVal));
            return key + "=\"" + (isSpecialAttr ? retVal : Lyte.Security.escape(retVal)) + "\"";
        case "undefined" : 
            return key
        default : 
            {
                // return key + "=" + (isSpecialAttr ? nodeValue : ZSEC.Encoder.encodeForHTMLAttribute(nodeValue) );
                return key + "=\"" + (isSpecialAttr ? nodeValue : Lyte.Security.escape(nodeValue) ) + "\"";
            }
        }
    }
    
    //RN
    //ssroverrides
    renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent) {
        options = options || {};
        let content;
        let constr = this.constructor;
        /*if(_Lyte._ie){
            let newFrag = toAppend.cloneNode(true, "lyte");
            this.constructor.splitTextNodes(newFrag);
            content = newFrag;
        }
        else{
            content = toAppend.cloneNode(true, "lyte");
        }*/
        let templateDepthHandlingNeeded = false;
        if (_Lyte._ms || !toAppend) {
            templateDepthHandlingNeeded = true;
            content = _LC.getContentForIE(templateContent , constr);
        } else if(toAppend.hasAttribute("depth")) {
        	templateDepthHandlingNeeded = true;
        	content = _LC.getContentForIE(toAppend , constr);
        } else {
            content = toAppend.content.cloneNode(true, "lyte");
        }
        let updateHelpers = [],processLast = [],helperFunc,stoppedNode;
                
        //to get bindings in ssr components
        
        // componentDynamic = "1" , text ="2" , attr = "3" , for = "4" , forIn = "5", component = "6" , if = "7" , switch = "8" , registeryield = "9" , insertyield = "10" , action = "A1" , method = "M2", forContent = "4C"
        let toBeInsMap = new Map();
        for(let i=0;i<dynamicNodes.length;i++) {
            let info = dynamicNodes[i], type = info.type, pos = info.position, dynamicN = content, helperInfo;
            dynamicN = getDynamicNode(dynamicN,pos);
            if(!dynamicNodes._cache){
                dynamicNodes._cache = {};
            }
            if(type ===  "componentDynamic") {
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}

                //to bind componentDynamic in ssr components
                          
            } 
            else if(type === "text"){
                 this.bindNode(dynamicN, undefined, helperNode, options, dynamicNodes[i], processLast, establishBindings,undefined,dynamicNodes._cache, type, undefined, toBeInsMap);
            }
            else if(type === "attr"){
            	dynamicN._attributeDetails = info.attr;            	
                if(dynamicN.nodeName === "LYTE-YIELD") {
                    dynamicN._callee = this;
                    dynamicN.component = {}
                    dynamicN.component.data = {};
                    defProp(dynamicN.component.data, "__component__", {
                    	value : dynamicN,
                    	configurable : true,
                    	writable : true,
                        enumerable : false
                    });
                    dynamicN._properties = {};
                    for(let j=0;j<dynamicN.attributes.length;j++) {
                        let attr = dynamicN.attributes[j];
                        if(attr.nodeName !== "is" && attr.nodeName !== "yield-name") {
                            dynamicN._properties[_LC.String.toCamelCase(attr.nodeName)] = {};
                        }
                    }
                }
                let toBeRemoved = [];
				for(let key in info.attr) {
                	let attr = info.attr[key];
                	attr._depthTemp = info._depthTemp;
                	let attrName = key;
                    if(attr && (attr.dynamicValue || attr.helperInfo)) {
                        if(options.node) {
                                dynamicN._cx = options;
                        }
                        else if(helperNode) {
                            dynamicN._cx = helperNode._cx;
                        }
                        let actionName, boundName;
                        if(attr.helperInfo && attr.helperInfo.name === "action") {
                            dynamicN._boundEvents = dynamicN._boundEvents || {};
                            actionName = attr.helperInfo.args[0];
                            if(actionName.startsWith('"') || actionName.startsWith("'")) {
                                boundName = actionName.substring(1, actionName.length - 1);
                            } else {
                                // _Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
                                boundName = actionName;
                            }
                            let actualAttrName = attr.globalEvent ? attrName : (attrName.indexOf("-") !== -1)? attrName : attrName.substr(2);
                            dynamicN._boundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args};

                                //to bind actions in ssr components
                                let id;
                                // if( dynamicN.hasAttribute( "bindId" ) ){
                                //    id = dynamicN.getAttribute( "bindId" );
                                // }else{
                                //    id = type + Math.floor( Math.random() * 1000 );
                                //    dynamicN.setAttribute( "bindId", id );
                                // }
                                id = "A1_"+Math.floor( Math.random() * 1000 ) ;
                                                       
                        }            
			            if(!attr.globalEvent) {
                            /*this.bindNode(dynamicN.getAttributeNode(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings);
                             */
                            if(!dynamicN.hasAttribute(attrName)) {
                                dynamicN.setAttribute(attrName, "{{dummy}}");
                            }
                        	var node = this.bindNode(dynamicN.attributes.getNamedItem(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings,undefined,dynamicNodes._cache, type, i);
                            if(node !== dynamicN.attributes.getNamedItem(attrName)) {
                            	dynamicN._removedAttributes = dynamicN._removedAttributes || {};
                            	dynamicN._removedAttributes[attrName] = node;
                            }
                        }
                    }
                }
                //Added now
                if(info.attr && Object.keys(info.attr).length) {
                	dynamicN._callee = this;
                }
                for(let d=0;d<toBeRemoved.length;d++) {
                    dynamicN.removeAttribute(toBeRemoved[d]);
                }
            }
            else if(/^(for|forIn|component)$/.test(type)){
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                dynamicN._dynamicNodes = info.dynamicNodes;
                if(_Lyte._ms) {
                    dynamicN._tC = info.templateContent;  
                }
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                }
                let returnVal;
                switch(type) {
                case "for" : 
                    dynamicN._ht = info._ht;
                	returnVal = this.updateForHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings, info._sta);
                	break;
                case "forIn" : 
                    dynamicN._ht = info._ht;
                	returnVal = this.updateForInHelper(dynamicN,{"type" : "default"} , options.node? options : undefined, establishBindings);
                	break;
                case "component" : 
                	returnVal = this.updateDynamicComponent(dynamicN, false, options.node ? options : undefined, establishBindings,i,helperNode);
                }
                if(returnVal) {
                	updateHelpers.push(returnVal);
                }
            }
            else if(/^(if|switch)$/.test(type)){
                var def ="default";
                dynamicN._cases = info.cases; 
                dynamicN._default = info[def];
                dynamicN._ht = info._ht;
                if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                if(info.actualTemplate) {
                    dynamicN._tC = info.actualTemplate;
                    if(!dynamicN._origTemplate) {
                    	if(_Lyte._ie) {
                    		dynamicN._origTemplate = createElement("template")
                    	} else {
        	            	dynamicN._origTemplate = info._depthTemp.cloneNode(true);
                    	}
                    	if(dynamicN.hasAttribute("value")) {
                    		dynamicN._origTemplate.setAttribute("value", dynamicN.getAttribute("value"));
                    	}
                    }
                }

                //to bind if/switch in ssr components
                let id;
                
                    
                let returnVal = this.updateSwitchHelper(type, dynamicN, options.node ? options : undefined, undefined, establishBindings, id, toBeInsMap);
                if(returnVal) {
                	updateHelpers.push(returnVal);
                	let isBreak = returnVal.toAppendMain.querySelector("template[is=break]");
                	if(isBreak) {
                		dynamicN._isStopped = "break";
                		content = Lyte.Compile.getTrimmedContent(content, info.position,undefined);
                		stoppedNode = info.position;
                		break;
                	}
                	let isContinue = returnVal.toAppendMain.querySelector("template[is=continue]");
                	if(isContinue) {
                		dynamicN._isStopped = "continue";
                		content = Lyte.Compile.getTrimmedContent(content, info.position,undefined);
//                		stoppedNode = info.position;
                		break;
                	}
                }
            } else if(type === "registerYield") {
                if(options.node) {
                    dynamicN._cx = options;
                }
                else if(helperNode) {
                    dynamicN._cx = helperNode._cx;
                }
                
                dynamicN._dynamicNodes = info.dynamicNodes;
                dynamicN._sta = info._sta;
                dynamicN._ht = info._ht;
                if(_Lyte._ms) {
                    dynamicN._tC = info.templateContent;  
                }
//                updateHelpers.push(dynamicN);
                //Added now                
                dynamicN._callee = this;
            } else if(type === "insertYield") {
            	if(options.node) {
            		dynamicN._cx = options;
            	} else if(helperNode) {
            		dynamicN._cx	= helperNode._cx;
            	}
                dynamicN.component = dynamicN.component || {"data" : {}};
                dynamicN._properties = dynamicN._properties || {};
                    //to bind insertYield in ssr components
                    
                    dynamicN.component = dynamicN.component || {"data" : {}};
                    dynamicN._properties = dynamicN._properties || {};                
                    for(let x=0; x<dynamicN.attributes.length; x++) {
                        let attrObj = dynamicN.attributes[x];
                        let attrName = attrObj.name;
                        let attrValue = attrObj.value;
                        if(attrName !== "yield-name") {
                            if(dynamicN._properties && !dynamicN._properties[attrName]){
                                dynamicN._properties[attrName] = {};
                            }
                            if(dynamicN._attributeDetails && !dynamicN._attributeDetails[attrName]){
                                dynamicN.component.data[attrName] = attrValue;
                            }
                        }
                    }
                this.updateYield(dynamicN, false, options.node? options : undefined);
            }
        }
        dynamicNodes._cache = undefined;
        for(let i=0;i<processLast.length;i++) {
             let dynamicPosition = processLast[i].dynamicPositions;
                 let processNode = dynamicPosition.initialNode;
                 let nodeValue = dynamicPosition.dynamicNodeValue;
                 let childLen = nodeValue.childNodes.length;
                 if(!childLen) {
                    nodeValue.appendChild(document.createTextNode(""));
                        childLen = 1;
                 }
                 let startingNode = nodeValue.childNodes[0];
                 if(_Lyte._rwpf && processNode.parentNode.nodeName === "#document-fragment") {
                 	while(nodeValue.childNodes.length) {
                 		insertBefore(processNode.parentNode, nodeValue.childNodes[0], processNode);
                    }
                 	processNode.remove();
                 } else {
                	 processNode.replaceWith.apply(processNode,nodeValue.childNodes);
                 }
                 processLast[i].dynamicPositions = {startingNode : startingNode, length: childLen}
        }
        if(toBeInsMap.size){
            toBeInsMap.forEach(function(val, key){
                val.pN.insertBefore(key, val.cN);
                if(val.cN.nextSibling){
                    val.pN.insertBefore(document.createElement("textend"), val.cN.nextSibling);
                }
                else{
                    val.pN.appendChild(document.createElement("textend"));
                }
            })
        }  
        if(stoppedNode) {
        	returnVal = returnVal || {};
        	returnVal.stop = true;
        }
        if(helperNode) {
            if(options.type) {
                helperNode._helpers[options.itemIndex] = updateHelpers;
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            } else {
                helperNode._helpers = helperNode._helpers || [];
                helperNode._helpers.push.apply(helperNode._helpers, updateHelpers);
                if(templateDepthHandlingNeeded) {
                    content = constr.createDocFragment1(content);  
                }
                return content;
            }
        }
        this.executeBlockHelpers(updateHelpers);
        if(templateDepthHandlingNeeded) {
            content = constr.createDocFragment1(content);  
        }
        return content;
    }

    executeBlockHelpers(updateHelpers, node) {
	    for(let i=0;i<updateHelpers.length;i++) {
            var lastNode = updateHelpers[i].lastNode;
            var parentNode = lastNode.parentNode; 
                
            if(lastNode._placeHolder) {
                lastNode = lastNode._placeHolder;
                parentNode = lastNode.parentNode;
            }
            //parentNode = updateHelpers[i].lastNode.parentNode || updateHelpers[i].lastNode._placeHolder.parentNode;
            insertBefore(parentNode, updateHelpers[i].toAppendMain, lastNode);
            updateHelpers[i] = updateHelpers[i].lastNode;
	    		// updateHelpers[i].lastNode.parentNode.insertBefore(updateHelpers[i].toAppendMain, updateHelpers[i].lastNode);
	    		// updateHelpers[i] = updateHelpers[i].lastNode;
	    		//updateHelpers[i]._parentIf = node;
//	    		if(!updateHelpers[i]._cx && node) {
//	    			updateHelpers[i]._cx = node._cx;
//	    		}
	    }	
    }
    
    updateBlockHelpers(updateHelpers,contextSwitchInfo){
        for(let i=0;i<updateHelpers.length;i++) {
            switch(updateHelpers[i].getAttribute('is')) {
            case "for" :
                this.updateForHelper(updateHelpers[i], {"type" : "default"},contextSwitchInfo);
                break;
            case "if" : 
                this.updateSwitchHelper("if",updateHelpers[i],contextSwitchInfo);
                break;
            case "forIn" : 
                this.updateForInHelper(updateHelpers[i] , {"type" : "default"},contextSwitchInfo);
                break;
            case "switch" :
                this.updateSwitchHelper("switch",updateHelpers[i],contextSwitchInfo);
                break;
            case "component" : 
                this.updateDynamicComponent(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "insertYield" : 
//              this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                break;
            case "yield" : 
            case "registerYield" : 
                if(contextSwitchInfo) {
                    updateHelpers[i]._cx = contextSwitchInfo;
                }
                break;
            default: 
                if(updateHelpers[i].tagName === "LYTE-YIELD") {
                    this.updateYield(updateHelpers[i], false, contextSwitchInfo);
                }
                
            }
         }
    }
    //AttributeChangedCallback will be called for the attributes mentioned in the this._observedAttributes array. 
    static get observedAttributes() {
    		let newArr = [];
            for(let i=0;i<this._observedAttributes.length;i++) {
                newArr[i] = _LC.String.dasherize(this._observedAttributes[i]);
            }

            _LC.customPropHandlers.forEach(function(item,index) {
                newArr.push(_LC.String.dasherize(item));
            })
            return newArr;	
    }
    
    //Callback from browser, whenever any of the observed attribute changes. 
    //We call the component set, in order to affect the related changes. 
    attributeChangedCallback(attr, oldValue, newValue) {
        let constr = this.constructor;
       	if((constr._observedMethodAttributes && constr._observedMethodAttributes[attr]) || this.__lyteIgnore) {
   		 	return;
    	}
        let actualAttr = _LC.String.toCamelCase(attr);
        let isCustomProp = _LC.customPropHandlers.indexOf(actualAttr);
        if(isCustomProp !== -1) {
            let propValue = _LC.customPropHandlers[isCustomProp];
            let lyteProps = newValue;
            if(lyteProps) {
                try{
                    lyteProps = JSON.parse(lyteProps);
                    for(let key in lyteProps) {
                        let actKey = propValue + _LC.String.upperCaseFirstLetter(key);
                        this.set(actKey, lyteProps[key]);
                    }
                } catch (e) {
                    _Lyte.error("LC001", attr);
                }
            }
            return;
        }
        if(oldValue === newValue) {
            return;
        }
        var attrNode = this.attributes.getNamedItem(attr);
        if(attrNode) {
            if(attrNode.__lyteIgnore) {
                this.attributes.getNamedItem(attr).__lyteIgnore = false;
                return;    
            }
        } else if(this["__"+attr]) {
            this["__"+attr] = false;
            return;
        }
        let compInstance = this.component;
        let dataDef = compInstance.__data[actualAttr];
        if(dataDef && dataDef.type){
            let dataType = dataDef.type;
            if(dataType !== "string") {
                let obj = {"attr" : attr, "tagName" : this.tagName};
                newValue = _LC.typeCast(newValue, dataType, obj);
                if(obj.isError) {
                    _Lyte.warn("data type of the value provided for attribute "+attr+ " of " + this.tagName + " is not valid");
                    return;
                }
            }
        }
        
        let compData = compInstance.data;
        if(compData[actualAttr] !== newValue) {
            // Null check is done because when we do a removeAttribute directly on a component, the corresponding value expected is that of undefined and not null.
            this.set(actualAttr, newValue === null ? undefined: newValue);
        } else {
            _LC.clearError(compData, actualAttr);
        }
    }
    
    //Used to remove helpers of specific index in a for helper. 
    removeHelpersSpecificIndex(node, index) {
        if(node._helpers[index]) {
            for(let j=0;j<node._helpers[index].length;j++) {
                    this.removeHelpers(node._helpers[index][j]);
            }
        }
        if(node._forContent[index]) {
            for(let i=0;i<node._forContent[index].length; i++ ) {
                node._forContent[index][i].remove();
            }
            var self = this;
            Object.keys(node._items[index]._dynamicProperty).forEach(function(key) {
                node._dynProps[key]--;  
                if(!node._dynProps[key]) {
                    let prop  = self.getProperty(key);
                    if(prop._helperNodes) {
                        prop._helperNodes[delStr](node);
                    }
                }
            });
            node._items[index] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
        }
    }
    //Used to remove all the helpers within an helper. 
    removeHelpers(node, update, direct) {
        if(!direct) {
            node.remove();
            var helpersObj = node.getAttribute("is") === "component" ? this.__dc : this.__h;
            let nodeId = node.__lyteId;
            delete helpersObj[nodeId];
        }
        
        var del = "delete";
        let parent;
        var contextSwitchArray = [];
        _LC.adCx(node, contextSwitchArray);
        if(node._forContent) {
            if(node.getAttribute("is") === "for") {
        	if(node._helpers) {
                for(let i=0;i<node._helpers.length;i++) {
                    for(let j=0;j<node._helpers[i].length;j++) {
                            this.removeHelpers(node._helpers[i][j]);
                    }
                    node._helpers[i] = [];
                }
            }
            for(let s=0;s<node._forContent.length;s++) {
                for(let i=0;i<node._forContent[s].length; i++ ) {
                    node._forContent[s][i].remove();
                }
            }
            let key = node.getAttribute("item");
            if(node._items.length) {
                let prop = node._items[0].itemProperty;
                for(let i=0;i<node._items.length;i++) {
                    let dynProp = node._items[i]._dynamicProperty;
                    for(let dP in dynProp) {
                        let property = this.getProperty(dP); 
                        if(property._helperNodes){
                            property._helperNodes[del](node);                    
                        }
                    }    
                }
                if(prop) {
                    for(let i=0;i<node._items.length;i++) {
                        this.removeBindings({[key] : node._items[i].itemProperty}, {[key] : node._attributes.items[i]});
                    }
                }
            }
            if(!update) {
            	if(node._actualBinding) {
            		if(node._attributes.items && node._attributes.items._bindings && node._actualBinding._createdBinding) {
                        node._attributes.items._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                    var multiplePrpty = node._removedAttributes.items._multipleProperty;
                    if(node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    	multiplePrpty[0].actProp._forHelpers[del](node);
                    }
            	}
            }
            node._items = [];
        } else {
        	if(node._helpers) {
                let keys = Object.keys(node._helpers);
                for(let i=0;i<keys.length;i++) {
                    for(let j=0;j<node._helpers[keys[i]].length;j++) {
                        this.removeHelpers(node._helpers[keys[i]][j]);
                    }
                    node._helpers[keys[i]] = [];
                }
            }
            for(var ind in node._forContent) {
                for(let i=0;i<node._forContent[ind].length; i++ ) {
                    node._forContent[ind][i].remove();
                }
            }
            let items = node._items;
            let key = node.getAttribute("key");
            for(let index in items){
                let item = items[index];
                let prop = item.itemProperty;
                let dynamicProp = item._dynamicProperty;
                for(let dP in dynamicProp) {
                    let property = this.getProperty(dP); 
                    if(property._helperNodes){
                        property._helperNodes[del](node);                    
                    }
                }
                if(prop) {
                    this.removeBindings({[key] : node._items[index].itemProperty}, {[key] : node._attributes.object[index]});
                }

            }
            if(!update) {
                if(node._actualBinding) {
                    if(node._attributes.object && node._attributes.object._bindings && node._actualBinding._createdBinding) {
                        node._attributes.object._bindings[del](node._actualBinding);
                    } 
                    if(node._actualBinding._forHelpers) {
                        node._actualBinding._forHelpers[del](node);
                    }
                }
                var multiplePrpty = node._removedAttributes.object._multipleProperty;
                if(node._removedAttributes.object && !node._removedAttributes.object.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
                    multiplePrpty[0].actProp._forHelpers[del](node);
                }
                if(node._propBindingObject && node._attributes.object && node._attributes.object._bindings) {
                    node._attributes.object._bindings[del](node._propBindingObject);
                }
            }
            node._items= {};
          }
        } else if(node._caseContent || node._yieldContent) {
        	if(node._helpers) {
                for(let j=0;j<node._helpers.length;j++) {
                    this.removeHelpers(node._helpers[j]);
                }
                node._helpers = [];
            }
        	if(node._caseContent){
                for(let i=0;i<node._caseContent.length; i++ ) {
                    node._caseContent[i].remove();
                }
                for(let key in node._dynamicProperty) {
                    if(node._dynamicProperty[key].isActualNode) {
                        node._dynamicProperty[key].isActualNode._helperNodes[del](node);
                    }else {
                        let helperNodes = this.getProperty(key)._helperNodes;
                        if(helperNodes) {
                            helperNodes[del](node);
                        }
                    }
                }
                node._dynamicProperty = {};
                //node._parentIf = null;
            } else {
                for(let i=0;i<node._yieldContent.length; i++ ) {
                    node._yieldContent[i].remove();
                }
                node._dynamicProperty = {};
            }
            var pve = _LC.pendingViewPortElements;
            if(node._inPve && pve.length){
                let ind = pve.indexOf(_LC.getFakeTemplate(node));
                if(ind != -1){
                    pve.splice(ind,1);
                }
            }
        } else if(node._renderedComponent) {
            for(let key in node._renderedComponent) {
                if(node._renderedComponent[key]) {
                    node._renderedComponent[key].remove();
                    node._renderedComponent[key] = null;
                }
            }
        }
          _LC.rmCx(node, contextSwitchArray);
    }
    
    updateYield(node, update, contextSwitchInfo) {
        let constr = this.constructor;
        if(!node._callee) {
            node._callee = this;
        }        
        let toAppend = node._callee._yields[node.getAttribute("yield-name")];
        if(!toAppend) {
        	return;
        }
        node._registerYield = toAppend;
        //ADded now
        let parentScope = toAppend._callee || node._callee._callee;
        if(!parentScope) {
            if(_Lyte._ms) {
                var div = createElement("div");
                div.innerHTML = toAppend.outerHTML;
                if(_Lyte._ie){
                    div.firstChild.innerHTML = toAppend.innerHTML;
                 }
                var content1 = div.childNodes[0];
                constr.splitTextNodes(content1);
                content1 = constr.createDocFragment1(content1);
                node.appendChild(content1);
            } else {
                node.appendChild(toAppend.content.cloneNode(true, "lyte"));    
            }
            
            node._helpers = [];
            return;
        }    
	    if(!toAppend._callee) {
    		toAppend._callee = parentScope;
    	} 
        node._dynamicProperty = node._dynamicProperty || {};
        //set values from child component. 
        let obj = {},contextSwitchingArray = {},self = this,contextSwitchArray = [];
        _LC.adCx(toAppend, contextSwitchArray);
        Object.keys(node._properties).forEach(function(key) {
            contextSwitchingArray[key] = {};
            contextSwitchingArray[key].value = parentScope.component.data[key];
            contextSwitchingArray[key].property = parentScope._properties[key];
            parentScope._properties[key] = node._properties[key];
            parentScope.component.data[key] = node.component.data[key];
        }); 
        // htA -> helpertemplateApplied
        if(!_Lyte._ms && toAppend._ht && !toAppend._htA) {
            toAppend._htA = true;
            toAppend.content.append(toAppend._ht.content.cloneNode(true));
        }
        let content = parentScope.renderNodes(toAppend, toAppend._dynamicNodes || [], node, {"node" : node}, true, undefined, toAppend._tC);
        if(!node.component.data.lyteUnbound) {        	
        	_LC.establishBindings(node._properties, node.component.data);
        }
        parentScope.executeBlockHelpers(node._helpers);
        Object.keys(node._properties).forEach(function(key) {
            parentScope.component.data[key] = contextSwitchingArray[key].value;
            parentScope._properties[key] = contextSwitchingArray[key].property;
        });
        _LC.rmCx(toAppend, contextSwitchArray); 
        node.appendChild(content);
    }
    
     // It constructs/updates the dynamicComponent creation
    //upddc
    updateDynamicComponent(node, update, contextSwitchInfo, establishBindings,idx,helperNode) {
    	let returnVal;
        node._callee = this;
        let keepAlive = node.hasAttribute("lyte-keep-alive");
        if(!node._renderedComponent) {
            node._renderedComponent = {};
            let id = _LC.createLyteId(this);
            this.__dc[id] = node;
            node.__lyteId = id;
        }
        
        node._cx = contextSwitchInfo || node._cx;
        node._dynamicProperty = node._dynamicProperty || {};
        let componentName = node.getAttribute("component-name") || (node._attributes ? node._attributes["component-name"] : undefined);
        if(!componentName) {
            return;
        }
        let component,newComponent = false;
        if(update) {
        	if(keepAlive) {
        		_LC.ignoreDisconnect = true;
        	}
            if(node._renderedComponent[node._currentComponent]) {
                let activeComponent = node._renderedComponent[node._currentComponent];
                keepAlive ? _LC.hDiv.content.appendChild(activeComponent) : activeComponent.remove();
            }
            _LC.ignoreDisconnect = false;
            if(!keepAlive) {
                node._dynamicProperty = {};
            }
            if(node._renderedComponent[componentName] && keepAlive) {
                component = node._renderedComponent[componentName];
            } else {
                component = createElement(componentName);
                newComponent = true;
            }
        }  else {
            component = createElement(componentName);
            newComponent = true;
        }
        if(!keepAlive && node._currentComponent) {
            node._renderedComponent[node._currentComponent] = null;
        }
        if(newComponent) {
//          let componentData = {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].name !== "is" && node.attributes[i].name !== "component-name" && node.attributes[i].name !== "lyte-keep-alive") {
                    component.setAttribute(node.attributes[i].name, node.attributes[i].value);
                }
            }
//          componentData = component._attributes;
            if(node._attributes) {
                for(var key in node._attributes) {
                	if(key!== "component-name") {
                		component.setData(_LC.String.toCamelCase(key), node._attributes[key]);
                	}
                }
            }
            let toAppend = this.renderNodes(node, node._dynamicNodes, node, undefined, establishBindings, undefined, node._tC);
            component.appendChild(toAppend);
        }
        if(newComponent) {
                component._toRegEvnts = node._toRegEvnts;
        }
        if(!update) {
        	returnVal = {"toAppendMain" : component, "lastNode" : node};
        } else {
            _LC.ignoreDisconnect = true;
            insertBefore(node.parentNode,component, node);
            _LC.ignoreDisconnect = false;
        }
        node._renderedComponent[componentName] = component;
        node._currentComponent = componentName;
	    component._callee = this;
        
	    component._actions = node._actions;
        component.setMethods(node._initMethods);
        component._attributeDetails = node._attributeDetails;
        component._boundEvents = node._boundEvents;
        component._cx = node._cx;
        return returnVal;
    }
    //updFH
    // It constructs/updates the for helper. 
    updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr) {
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
            	if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            if(_Lyte._ie) {
            	var div = createElement("div");
                div.innerHTML = node._tC;
                node._origTemplate.innerHTML = div.children[0].innerHTML;
                this.constructor.splitTextNodes(node._origTemplate);
                if(node.hasAttribute("depth")) {
                    node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
                }
            }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("item", node.getAttribute("item"));
            node._origTemplate.setAttribute("index", node.getAttribute("index"));
            
            if(node.hasAttribute("unbound")) {
                //What if unbound is dynamic attribute ? It will be set in _attributes of node._origTemplate -> So No worries (y)
                node._origTemplate.setAttribute("unbound", "true");
            }
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder);
            node = _LC.replaceWithOrigTemplate(node)
            // node = node._origTemplate;
            node.setAttribute("is", "for");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
            
        } 
        // datasumma
        else if(!node._placeHolder){
            // var emptyTextNode = document.createTextNode("");
            //node.replaceWith(emptyTextNode);
            //to bind in ssr
            var emptyTextNode,tnode;
            
                emptyTextNode = document.createTextNode("");
                
            _LC.replaceWithPf(node, emptyTextNode)
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            _LC.apdNode(node, this);
        }
        node._sta = node._sta || staticTempArr;
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentItems === node._attributes.items) {
            return {};
        }
        node._cx = contextSwitchInfo || node._cx;
        let  indexValue = node.getAttribute("index");
        if(!indexValue) {
            node.setAttribute("index", "index");
            indexValue = "index";
        }
        let itemValue = node.getAttribute("item");
        if(!itemValue) {
            node.setAttribute("item", "item");
            itemValue = "item";
        }
        let initialItemValue = callee.component.data[itemValue],initialIndexValue = callee.component.data[indexValue];
        let initialItemProp = callee._properties[itemValue],initialIndexProp = callee._properties[indexValue];
        callee._properties[itemValue] = callee._properties[indexValue] = {};
        let items = node._attributes.items,content = node.content,dynamicNodes = node._dynamicNodes,lastNode = node;
        if(!node._items) {
            node._items = [];
        }
        node._dynProps = node._dynProps || {};
        let lastIndexForIteration;
        let firstIndexForIteration;
        let firstIndex = options.firstIndex;
        let secondIndex = options.secondIndex;
        let thirdIndex = options.thirdIndex;
        var totalNodeIndex = firstIndex + secondIndex;
        var updateIndexProperty = true;
        var indexPropertyStartIndex = 0;
        if(options) {
            switch(options.type) {
            case "remove"  :{
                lastIndexForIteration = firstIndex;
                indexPropertyStartIndex = firstIndex;
                for(let i=firstIndex, v=secondIndex;v>0;v--, i++) {
                    this.removeHelpersSpecificIndex(node, i);
                }
                //ln
                /*for(let i=(firstIndex)?firstIndex-secondIndex:firstIndex;i<node._items.length;i++) {
                    let forItem = node._items[i].itemProperty;
                    if(forItem._helperNodes){
                        for (var item of forItem._helperNodes){
                            let ind = item._cx.itemIndex;
                            item._cx.itemIndex = (ind)? ind- secondIndex : ind;
                        }
                    }
                }*/
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {        
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex - secondIndex;        
                }
                node._items.splice(firstIndex, secondIndex);
                node._helpers.splice(firstIndex, secondIndex);
                node._forContent.splice(firstIndex, secondIndex);
                break;
            }
            case "insert" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                if(node._forContent[firstIndex]) {
                    lastNode = node._forContent[firstIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.push([]);
                    newObj.push({});
                    newArr1.push([]);
                }
                node._helpers.splice.apply(node._helpers, [firstIndex, 0].concat(newArr));
                node._items.splice.apply(node._items, [firstIndex, 0].concat(newObj));
                //ln
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty;
//                      for (var item of forItem._helperNodes){
//                          item._cx.itemIndex = item._cx.itemIndex + secondIndex;
//                      }
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex;
                }
                node._forContent.splice.apply(node._forContent, [firstIndex, 0].concat(newArr1));
            }
                break;
            case "replace" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                this.removeHelpersSpecificIndex(node, firstIndex);
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+1]) {
                    lastNode = node._forContent[firstIndex+1][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.push([]);
                    newArr1.push([]);
                    newObj.push({});
                }
                node._helpers.splice.apply(node._helpers,[firstIndex, 1].concat(newArr));
                node._items.splice.apply(node._items, [firstIndex, 1].concat(newObj));
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - 1;
                }
                node._forContent.splice.apply(node._forContent, [firstIndex, 1].concat(newArr1));
                if(options.secondIndex == 1){
                    updateIndexProperty = false;
                }
                break;
            }
            case "splice" : {
                firstIndexForIteration = firstIndex;
                lastIndexForIteration = secondIndex;
                indexPropertyStartIndex = firstIndex + secondIndex;
                for(let i=thirdIndex,j=0;i>0;i-- , j++) {
                    this.removeHelpersSpecificIndex(node, firstIndex + j);
                }
                let toAppendMain = createDocFragment();
                if(node._forContent[firstIndex+thirdIndex]) {
                    lastNode = node._forContent[firstIndex+thirdIndex][0];
                }
                let newArr = [], newObj = [], newArr1 = [];
                for(let v=secondIndex, k=firstIndex;v>0;v--, k++) {
                    newArr.push([]);
                    newArr1.push([]);
                    newObj.push({});
                }
                node._helpers.splice.apply(node._helpers,[firstIndex, thirdIndex].concat(newArr));
                node._items.splice.apply(node._items, [firstIndex, thirdIndex].concat(newObj));
//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
//                      let forItem = node._items[i].itemProperty._forItem;
//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
//                  }
                for(let i=firstIndex + secondIndex; i<node._items.length;i++) {
                    node._items[i]._cx.itemIndex = node._items[i]._cx.itemIndex + secondIndex - thirdIndex;
                }
                node._forContent.splice.apply(node._forContent, [firstIndex, thirdIndex].concat(newArr1));
                if(options.secondIndex == options.thirdIndex){
                    updateIndexProperty = false;
                }
                break;
            }
            break;
            case "update" : 
            {
                let key = node.getAttribute("item");
//                  this.removeHelpers(node, true);
                for(let i=0;i<node._items.length;i++) {
                    this.removeHelpersSpecificIndex(node, i);
                }
//                  if(node._attributes.items) {
//                      for(let i=0;i<node._attributes.items.length && node._items[i];i++) {
//                          _LC.removeSelectedBindingDeep(node._items[i].itemProperty[key], node._attributes.items[i]);
//                      }
//                  }
                node._items = [];
        }
            case "default" : 
            {
                node._forContent = [];
                node._helpers = [];
                firstIndexForIteration = 0;
                lastIndexForIteration = items? items.length : 0 ;
                indexPropertyStartIndex = items? items.length : 0 ;
            }
            break;
            default: 
            _Lyte.error("Error in updateForHelper");
            }
        }
        if(!lastNode) {
            lastNode = node;
        }
        if(lastNode != node && node._helpers.length > 0  && (options.type == "insert" ||"replace"|| "splice") ){
            lastNode = _LC.findLastNodeL(lastNode,totalNodeIndex,node);
        }
        let returnVal;
        var localUnbound = false;
        var initialUnbound = _LC.unbound;
        if(node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound && node._attributes.unbound !== "false") ) {
            localUnbound = true;
            _LC.unbound = true;
        }
        if(!node._fRender && (node.getAttribute("unbound") == "lyteFastRender" || (node._attributes && node._attributes.unbound == "lyteFastRender"))) {
            node._fRender = true;
        }
        node._currentItems = items;        
        if(!_Lyte._ms && (lastIndexForIteration - firstIndexForIteration) > 0) {
            if(node._ht && !node._htA) {
                node.content.append(node._ht.content.cloneNode(true));
                node._htA = true;
            }
        }
        if(options.type !== "remove") {
            var totalString = "";
            var domArr = [];
            var toAppendMain = createDocFragment();
            for(let k = firstIndexForIteration,v=lastIndexForIteration;v>0; k++, v--) {
                node._helpers[k] = [];
                node._items[k] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
                callee.component.data[itemValue] = items[k];
                callee.component.data[indexValue] = k;
                var cacheData = {};
                cacheData[itemValue]={}
                cacheData[itemValue]._data = items[k];
                cacheData[itemValue]._dyn = [itemValue];
                cacheData[indexValue]={}
                cacheData[indexValue]._data = k;
                cacheData[indexValue]._dyn = [indexValue];
                callee._properties[itemValue] = {};
                callee._properties[indexValue] = {};
                let optns = {"itemValue" : itemValue, "itemIndex" : k, "type" : "for", "node" : node, "indexValue" : indexValue};
//                  defProp(callee._properties[itemValue], '_forItem', {
//                      enumerable: false, 
//                      writable: true, 
//                      configurable: true, 
//                      value : optns
//                  });
                node._items[k]._cx = optns;
                let breakCheck = {};
                let toAppend;
                if(node._fRender) {
                    let str = this.renderFast(dynamicNodes, node._sta, this.component);
                    totalString = totalString + str;
                    // var template = document.createElement("template");
                    // template.innerHTML = str;
                    // toAppend = template.content;
                } else {
                    dynamicNodes._cache = cacheData;
                    toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, breakCheck, node._tC);
                }
    
                    //to bind in ssr components
                    
                let dynProps = Object.keys(node._items[k]._dynamicProperty);
                for(let d=0;d<dynProps.length;d++) {
                    let key = dynProps[d];
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                }
                node._items[k].itemProperty = this.getProperty(itemValue);
                node._items[k].indexProperty = this.getProperty(indexValue);    
//                  if(options.type !== "default") {
                if(!_LC.unbound) {
                	_LC.establishBindings({[itemValue] : node._items[k].itemProperty},{[itemValue]:node._attributes.items[k]});
                }
//                  }
                if(!node._fRender){
                    node._forContent[k] = Array.from(toAppend.childNodes);
                } else {
                    domArr.push(node._forContent[k] = []);
                }
                //Needs to revisit this and make sure it happen within renderNodes function itself;
//                  if(options.type !== "update") {
                this.executeBlockHelpers(node._helpers[k],node);
                if(!node._fRender) {
                    toAppendMain.appendChild(toAppend);
                }
                if(breakCheck.stop) {
                    break;
                }
            }
            if(node._fRender) {
                var s = document.createElement("template");
                s.innerHTML = totalString;
                toAppendMain.appendChild(s.content);
                _LC.processAction(toAppendMain);
                var childrenArr;
                if(_Lyte._ie) {
                    childrenArr = [];
                    var childNodes = toAppendMain.childNodes;
                    for(var i=0;i<childNodes.length;i++) {
                        if(childNodes[i].nodeType == 1) {
                            childrenArr.push(childNodes[i]);
                        }
                    }
                } else {
                    childrenArr = toAppendMain.children;
                }
                for(var i=0;i<domArr.length;i++) {
                    domArr[i].push(childrenArr[i]);
                }
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.callCC();
                    });
                });
            }
            //Provided so that before appending the component to DOM it is reset to previous value
            _LC.unbound = initialUnbound;
            if(options.type === "default") {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            } else {
                //lastNode.parentNode.insertBefore(toAppendMain, lastNode);
                if(lastNode._placeHolder) {
                	insertBefore(lastNode._placeHolder.parentNode, toAppendMain, lastNode._placeHolder);                	
                } else {
                	insertBefore(lastNode.parentNode,toAppendMain, lastNode);                
                }     
            }
            if(!localUnbound && node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && node._removedAttributes.items._multipleProperty) {
            	_LC.establishBindings({"items" : node._removedAttributes.items._multipleProperty[0].actProp}, {"items" : items});
            }
        }
        _LC.unbound = initialUnbound;
        if(updateIndexProperty){
            for(let i=indexPropertyStartIndex; i<node._items.length; i++) {
                if(node._items[i].indexProperty) {
                    _LC.affectChanges(node._items[i].indexProperty);
                }
            }
        }
        callee.component.data[itemValue] = initialItemValue;
        callee.component.data[indexValue] = initialIndexValue;
        callee._properties[itemValue] = initialItemProp;
        callee._properties[indexValue] = initialIndexProp;
        node._currentItems = items;
        return returnVal;
    }
    //It constructs/updates forIn Helper.
    //updFIH
    updateForInHelper(node, options, contextSwitchInfo, establishBindings) {
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
                if(item !== "innerHTML" && item !== "innerText") {
	                node._origTemplate[item] = node[item];            	
            	}
            });
            if(_Lyte._ie) {
            	var div = createElement("div");
                div.innerHTML = node._tC;
                node._origTemplate.innerHTML = div.children[0].innerHTML;
                this.constructor.splitTextNodes(node._origTemplate);
                if(node.hasAttribute("depth")) {
                    node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
                }
            }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            node._origTemplate.setAttribute("key", node.getAttribute("key"));
            node._origTemplate.setAttribute("value", node.getAttribute("value"));
            if(node.hasAttribute("unbound")) {
                //What if unbound is dynamic attribute ? 
                node._origTemplate.setAttribute("unbound", "true");
            }
            
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder)
            node = _LC.replaceWithOrigTemplate(node)
            // node = node._origTemplate;
            node.setAttribute("is", "forIn");
            _LC.apdNode(node, this);
            placeHolder._helper = node;
        } else if(!node._placeHolder){
            // var emptyTextNode = document.createTextNode("");
            //node.replaceWith(emptyTextNode);
            //to bind in ssr
            var emptyTextNode;
            
                emptyTextNode = document.createTextNode("");
                
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            _LC.apdNode(node, this);
            emptyTextNode._helper = node;
        }
        let callee = this;
        node._callee = this;
        node._attributes = node._attributes || {};
        if(options.type === "update" && node._currentObject === node._attributes.object) {
            return {};
        }
        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
        node._cx = contextSwitchInfo;
        let key = node.getAttribute("key");
        if(!key) {
            key = "key";
            node.setAttribute("key", "key");
        }
        let value = node.getAttribute("value");
        if(!value) {
            value = "value";
            node.setAttribute("value", "value");
        }
        let initialKeyValue = callee.component.data[key];
        let initialValueValue = callee.component.data[value];
        let initialKeyProp = callee._properties[key];
        let initialValueProp = callee._properties[value];
        callee._properties[key] = callee._properties[value] = {};
        let object = node._attributes.object;
        let content = node.content;
        let dynamicNodes = node._dynamicNodes;
        let lastNode = node;
        let keysArray = [];
        if(!node._items) {
            node._items = {};
        }
        node._dynProps = node._dynProps || {};
        if(options) {
            switch(options.type) {
            case "delete"  :{
                this.removeHelpersSpecificIndex(node, options.property);
                var delIndex = node._keysArray.indexOf(options.property);
                if(delIndex > -1) {
                  node._keysArray.splice(delIndex,1);
                }
                if(node._helpers) {
                    delete node._helpers[options.property];    
                }
                delete node._propBindingObject[options.property];
            }
            break;
            case "add" : {
                keysArray = [options.property];
                node._keysArray.push(options.property);
            }
            break;
            case "update" : 
            {
                node._keysArray.forEach(function (itemKey, index, array) {
                    this.removeHelpersSpecificIndex(node, itemKey);
                }, this);
                node._keysArray = keysArray = object ? Object.keys(object) : [];
                node._helpers = {};
                node._items = {};
                node._propBindingObject = {};
            }
            break;
            case "default" : 
            {
                node._forContent = {};
                node._helpers = {};
                node._keysArray = keysArray = object? Object.keys(object) : [];
//                  keysArray = Object.keys(object);

            }
            break;
            default: 
            _Lyte.error("Error in updateForHelper");  

            }
        }
        let returnVal;
        if(!object) {
            let toAppendMain = createDocFragment();
            if(options.type !== "default") {
            	insertBefore(lastNode.parentNode,toAppendMain, lastNode);
            } else {
                returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
            }    
        }
        let localUnbound = false;
        let initialUnbound = _LC.unbound;
        if(node.hasAttribute("unbound") || (node._attributes && node._attributes.unbound)) {
            localUnbound = true;
            _LC.unbound = true;
        }
        node._currentObject = object;
        if(!_Lyte._ms && keysArray.length && node._ht && !node._htA) {
            node.content.append(node._ht.content.cloneNode(true));
            node._htA = true;
        }
        if(object && options.type !== "remove") {
            var toAppendMain = createDocFragment();
            node._propBindingObject = node._propBindingObject || {};
            keysArray.forEach(function(itemKey, index, array) {
                node._helpers[itemKey] = [];
                node._items[itemKey] = {"_dynamicProperty" : {}, "itemProperty" : {}};
                callee.component.data[key] = itemKey;
                callee.component.data[value] = object[itemKey];
                callee._properties[key] = {};
                callee._properties[value] = {};
                var cacheData = {};
                cacheData[key] = {}
                cacheData[key]._data = itemKey;
                cacheData[key]._dyn = [key];
                cacheData[value] = {}
                cacheData[value]._data = object[itemKey];
                cacheData[value]._dyn = [value];
                let optns = {"itemIndex" : itemKey, "itemValue" : value, "keyValue" : key, "type" : "forIn", "node" : node};
                node._items[itemKey]._cx = optns;
                dynamicNodes._cache = cacheData;
                let toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, undefined, node._tC);
                Object.keys(node._items[itemKey]._dynamicProperty).forEach(function(key) {
                    node._dynProps[key] ? node._dynProps[key]++ : (node._dynProps[key] = 1);    
                })
                node._items[itemKey].itemProperty = this.getProperty(value);
                node._propBindingObject[itemKey] = node._items[itemKey].itemProperty;
                node._forContent[itemKey] = Array.from(toAppend.childNodes);
//                    this.updateBlockHelpers(node._helpers[itemKey], optns);
                this.executeBlockHelpers(node._helpers[itemKey],node);
                    
                    //to bind in ssr components
                    
                toAppendMain.appendChild(toAppend);
            }, this); 
//              if(options.type !== "update") {
            	if(!_LC.unbound) {
            		makeSet(node._attributes.object, "_bindings");
                    addBindings(node._attributes.object._bindings,node._propBindingObject);
                    _LC.establishBindings(node._propBindingObject, node._attributes.object);
            	}
//              }
				_LC.unbound = initialUnbound;
                if(options.type !== "default") {
                    //lastNode.parentNode.insertBefore(toAppendMain, lastNode);
                    if(lastNode._placeHolder) {
                    	insertBefore(lastNode._placeHolder.parentNode,toAppendMain, lastNode._placeHolder);                    
                    } else {
                    	insertBefore(lastNode.parentNode,toAppendMain, lastNode);
                    }
                } else {
                    returnVal = {"toAppendMain" : toAppendMain, "lastNode" : lastNode};
                }

        }
        _LC.unbound = initialUnbound; 
        callee.component.data[key] = initialKeyValue;
        callee.component.data[value] = initialValueValue;
        callee._properties[key] = initialKeyProp;
        callee._properties[value] = initialValueProp;
        node._currentObject = object;
        return returnVal;
    }
   //updSH
    updateSwitchHelper(type,node, contextSwitchInfo, update, establishBindings, id, toBeInsMap){
        if(!_Lyte._ms && node._ht && !node._htA) {
            node.content.append(node._ht.content.cloneNode(true));
            node._htA = true;
        }
        if(node.tagName !== "TEMPLATE") {
            Object.keys(node).forEach(function(item) {
            	if(item !== "innerHTML" && item !== "innerText") {
            		node._origTemplate[item] = node[item];
            	}
            });
            if(_Lyte._ie) {
            	var div = createElement("div");
                div.innerHTML = node._tC;
                node._origTemplate.innerHTML = div.children[0].innerHTML;
                this.constructor.splitTextNodes(node._origTemplate);
                if(node.hasAttribute("depth")) {
                    node._origTemplate.setAttribute("depth", node.getAttribute("depth"));    
                }
            }
            let placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
            //node.replaceWith(node._origTemplate._placeHolder);
            _LC.replaceWithPf(node, node._origTemplate._placeHolder);
            // node = node._origTemplate;
            node = _LC.replaceWithOrigTemplate(node)
            node.setAttribute("is", type);
            _LC.apdNode(node, this);
            placeHolder._helper = node;
        } else if(!node._placeHolder){
            var emptyTextNode;
            //node.replaceWith(emptyTextNode);
            
                emptyTextNode = document.createTextNode("");
                
            _LC.replaceWithPf(node, emptyTextNode);
            node._placeHolder = emptyTextNode;
            emptyTextNode._helper = node;
            _LC.apdNode(node, this);
        }
        let isNew = false;
        let lastNode = node;
        if(!node._callee) {
            node._callee = this;
            isNew = true;
        }
        contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
        node._cx = contextSwitchInfo;
        node._dynamicProperty = node._dynamicProperty ? node._dynamicProperty : {};
        let currentCaseName;
        let value;
        if(node.getAttribute("value")=== "" || node.getAttribute("value")) {
            value = node.getAttribute("value");
        } else if(node._attributes) {
            value = node._attributes.value;
        }
        // if(node._currentCase && value === node._currentCase){
        //     return;
        // }
        if(value) {
            currentCaseName = type === "if" ? "true" : value.toString();
        } else {
            if(type=== "if")  {
                currentCaseName = "false";
            } else {
                switch(value) {
                case undefined : 
                    currentCaseName = "undefined";
                    break;
                case null : 
                    currentCaseName = "null";
                    break;
                case false: 
                    currentCaseName = "false";
                    break;
                case "": 
                    currentCaseName = '""';
                    break;
                case 0 : 
                    currentCaseName = '0';
                }
            }
        }
        if(currentCaseName === node._currentCase) {
            return;
        }
        node._currentCase = currentCaseName;
        var nodeTemp = node._depthTemp || node;
//        let currentCase = node.content.querySelector('[case=\''+currentCaseName+'\']'),scope;
        let scope = node._cases[currentCaseName];
        let defaultContent;
        if(!scope){
            scope = node._default;
            defaultContent = (_Lyte._ms) ? scope.templateContent : nodeTemp.content.querySelector('[default]');
            if(!_Lyte._ms && scope._ht && !defaultContent._htA) {
                defaultContent._htA = true;
                defaultContent.content.append(scope._ht.content.cloneNode(true));
            }
            node._isDefault = true; 
            if(!defaultContent) {
                if(node._caseContent && node._caseContent.length) {
                    this.removeHelpers(node, undefined, true);
                }
                node._caseContent = [];
                let emptyTextNode = document.createTextNode("");
                node._caseContent.push(emptyTextNode);
                node._currentCaseName = currentCaseName;
                node._helpers = node._helpers || [];
                if(update) {
                	//lastNode.parentNode.insertBefore(emptyTextNode, node);
                    if(lastNode._placeHolder) {
                    	insertBefore(lastNode._placeHolder.parentNode,emptyTextNode, lastNode._placeHolder);                    
                    } else {
                    	insertBefore(lastNode.parentNode,emptyTextNode, node);
                    }
                	return;
                } else {
                	let toAppendMain = createDocFragment();
                	toAppendMain.append(emptyTextNode);
                	return {lastNode : lastNode, toAppendMain : toAppendMain};
                }
            }
        }
        
//        if(currentCase) {
//              if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
//                  currentCase = currentCase.content;
//              } else {
//                  let temp = createElement('template');
//                  let clone = currentCase.cloneNode(true);
//                  temp.content.appendChild(clone);
//                  currentCase.removeAttribute('slot');
//                  currentCase = temp.content;
//              }
//              scope.content = currentCase;
//        }
 
        if(node._caseContent && node._caseContent.length) {
            this.removeHelpers(node, undefined, true);
        }
        let dummyScope = scope;
        let additionalContentArr = [];
        let cnt=0;
        let dummyCaseName = currentCaseName;
        let template;
        if(defaultContent) {
            template = defaultContent
        } else {
            template = (_Lyte._ms) ? {} : nodeTemp.content.querySelector('[case=\''+_LC.cssEscape(dummyCaseName)+'\']');
        }
        let contentArr = [];
        while(dummyScope) {
            if(!_Lyte._ms && dummyScope._ht && !template._htA) {
                template._htA = true;
                template.content.append(dummyScope._ht.content.cloneNode(true));
            }
            let dynamicNodes = dummyScope.dynamicNodes;
            let processedContent = this.renderNodes(template, dynamicNodes, node, undefined, establishBindings, undefined, dummyScope.templateContent);
                
                //to bind ssr in if/switch
                
                
            contentArr.push(processedContent);
            if(dummyScope.additional) {
                if(dummyScope.additional.next) {
                    template = (_Lyte._ms) ? {} : node.content.querySelector('[case=\''+_LC.cssEscape(dummyScope.additional.next)+'\']');
                    dummyScope = node._cases[dummyScope.additional.next];
                } else {
                    template = (_Lyte._ms) ? {} : node.content.querySelector('[default]');
                    dummyScope = node._default;
                }
            } else {
                    break;
            }
        }
        node._caseContent = [];
        let toAppendMain = createDocFragment();;
        for(let i=0;i<contentArr.length;i++) {
            if(contentArr[i].nodeType == 11){
//                for(let j=0;j<contentArr[i].childNodes.length;j++) {
//                    node._caseContent.push(contentArr[i].childNodes[j]);
//                }
                node._caseContent = node._caseContent.concat(Array.from(contentArr[i].childNodes));
            }
            else{
                node._caseContent.push(contentArr[i]);
            }
                toAppendMain.append(contentArr[i]);
//            node.parentNode.insertBefore(contentArr[i], node);
        }
          this.executeBlockHelpers(node._helpers, node);
          if(update) {
        	  let returnVal;
        	  if(toAppendMain.querySelector("template[is=break]")) {
        		  returnVal = "break";
        	  } else if(toAppendMain.querySelector("template[is=continue]")) {
        		  returnVal = "continue";
        	  }
        	  //node.parentNode.insertBefore(toAppendMain, node);
              if(node._placeHolder) {
            	  insertBefore(node._placeHolder.parentNode,toAppendMain, node._placeHolder);              
              } else {
            	  insertBefore(node.parentNode,toAppendMain, node);
              }
        	  return returnVal;
          } else {
        	  return {"toAppendMain" : toAppendMain, "lastNode" : node};
          }
    }
    
    dummy(a,b) {
        let dummy = this.constructor._properties[boundValue].observer;
    }
    
    callObservers(boundValue, key) {
        let property = this.constructor._properties[boundValue];
        let observers = property?property.observer: undefined;
        if(observers) {
            for(let i=0;i<observers.length;i++) {
                if(key.indexOf('.') === -1 || observers[i].path === key) {
                    this["_"+observers[i].functionName].apply(this);
                }
            }
        }
    }
    
    static updateValue(property, path, value) {
        let pathVals = path.split('.');
        let context = property;
        for(let i=0;i<pathVals.length -1;i++) {
            context = context[pathVals[i]];
        }
        context[pathVals[i]] = value;
    }
    
//    static createDocFragment(template){
//        let childNodes = template.cloneNode(true,"lyte").childNodes;
////           let childNodes = template.childNodes;
//        let frag = document.createDocumentFragment();
//        let len = childNodes.length;
//        for(let i=0; i<len; i++){
//            frag.appendChild(childNodes[0]);
//        }
//        return frag;
//    }
    
    static createDocFragment1(template) {
        if(template.content) {
            return template.content;
        }
    	let childNodes = template.childNodes;
    	let frag = createDocFragment();
    	let len = childNodes.length;
    	for(let i=0; i<len; i++){
            frag.appendChild(childNodes[0]);
        }
    	return frag;
    }
    
    static _registerComponent(a,b) {
        let componentsDiv = _LC.lyteComponentsDiv;
        let styleDiv = _Lyte.$.assetsDiv;
        let origTemplateValue = this._template;
        var clonedDummyTemp;
        if(this._template && typeof this._template === "string"){
            this._template.replace(/\\'/g,"'");
            let div = createElement("div");
            div.innerHTML = this._template;
            while(div.firstChild){
                if(div.firstChild.nodeName === "STYLE") {
                    if(styleDiv.querySelector("style[from-component='"+a+"']")){
                        styleDiv.querySelector("style[from-component='"+a+"']").remove();
                    }
                    div.firstChild.setAttribute("from-component",a);
                    styleDiv.appendChild(div.firstChild);
                } else {
                    componentsDiv.appendChild(div.firstChild);
                }
            }
/*        } else if(document.querySelector("#" + a)) { */
        } else if(document.querySelector("template[tag-name='"+a+"']")) {
            componentsDiv.appendChild(document.querySelector("template[tag-name='"+a+"']") );
        }
        this._template = componentsDiv.querySelector("template[tag-name='"+a+"']");
        this._helperTemplate = document.createElement("template");
        this._helperTemplate.setAttribute("_lyteht", a );
        _LC.h1Div.content.appendChild(this._helperTemplate);
        if(!this._template) {
        	return;
        }
        if(_LC.needDummyComponentsDiv) {
            if(_Lyte._ie) {
                let temp = _Lyte.Compile.getTemplateFromString(origTemplateValue);
                _LC.dummyLyteComponentsDiv.appendChild(temp);
            } else {
                clonedDummyTemp = this._template.cloneNode(true);   
            }
        }
        if(this._template && !this._template.content){
//            var frag = document.createDocumentFragment();
//            let childNodes = this._template.cloneNode(true,"lyte").childNodes;
//            //let childNodes = this._template.childNodes;
//            let len = childNodes.length;
//            for(let i=0; i<len; i++){
//                frag.appendChild(childNodes[0]);
//            }
//            this._template.content = frag;
        }
        var hasUnbound = this._observedAttributes.indexOf("lyteUnbound") !== -1;
        var s = _Lyte._ie ? this._template : this._template.content;//)?this._template.content:document.createDocumentFragment(this._template);
        //This is used to split text nodes which contain multiple dynamic values 
        //Eg." Name is {{name}} and age is {{age}} "
        var newCompile;
        if(hasUnbound) {
            if(_Lyte._ie) {
                newCompile = document.createElement("div");
                newCompile.innerHTML = this._template.outerHTML;
                newCompile = newCompile.childNodes[0];
            } else {
                newCompile = this._template.cloneNode(true);
            }
        }
        this.splitTextNodes(s);
        if(hasUnbound) {
            this.splitTextNodes(newCompile);
        }
        //This is used to find the dynamicNodes and helper nodes for the given component. 
        if(!this._dynamicNodes){
            if(_Lyte.Compile.getDynamicNodes) {
                var returnVal = _Lyte.Compile.getDynamicNodes(a, undefined, _Lyte._ie ? s : undefined);
                if(returnVal.errors){
                    console.error("Error in the component",returnVal.componentName,returnVal.errors);
                    return false;
                }else{
                    this._dynamicNodes = returnVal.dynamicNodes;
                }
            } else {
                _Lyte.error("LC002", a);  
            }
	    } 
        if(this._dynamicNodes) {
        doCompile(s, this._dynamicNodes, a, this, newCompile ? (_Lyte._ie  ? newCompile : newCompile.content) : undefined);
        if(_Lyte._ed) { 
          this._tC = this._template.outerHTML;
        } else if(_Lyte._ie) {
          this._tC = s.outerHTML;
        }
        this._templateAttributes = this._templateAttributes || {type : "attr", "attr" : {}, position: []};
        var ta = [this._templateAttributes];
        doCompile(this._template, ta, a, this);
        this._templateAttributes = ta[0];
        if(this._templateAttributes && this._templateAttributes.attr) {
            var attributesT = this._template.attributes;
            try{
                for(let i=0;i<attributesT.length;i++) {
                    let attrName = attributesT[i].name;
                    if(!this._templateAttributes.attr[attrName] && attrName !== "tag-name" && attrName !== "use-strict") {
                        this._templateAttributes.attr[attrName] = {"name" : attrName, "staticValue" :  attributesT[i].value};
                        this._template.removeAttribute(attrName);
                        clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);
                        i--;
                    }
                }    
            } catch(e) {
                _Lyte.error("Error with templateAttributes. ");
            }
        }
        }
        clonedDummyTemp && _LC.dummyLyteComponentsDiv.appendChild(clonedDummyTemp);
        this._sta = newCompile ? _LC.processStatic(newCompile) : undefined;
    }
    //This is used to split text nodes which contain multiple dynamicNodes. 
    static splitTextNodes(node) {
        if(node && node.childNodes && node.childNodes.length) {
            for(let i=node.childNodes.length-1;i>=0;i--) {
                this.splitTextNodes(node.childNodes[i]);
            }
        }
        if(node.tagName === "TEMPLATE" && !_Lyte._ie) {
            this.splitTextNodes(node.content);
        }
        if(node.nodeType === node.TEXT_NODE) {
            let nodeValue = node.nodeValue;
            if(nodeValue){
                let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
                if(!mustacheValues) {
                    return;
                }
                let newNodeArray = [];
                for(let i=0;i<mustacheValues.length;i++) {
                    let mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                    let mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                    if(mustacheStartIndex) {
                            newNodeArray.push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                    }
                    newNodeArray.push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                    nodeValue = nodeValue.substring(mustacheEndIndex);
                }
                if(!(!nodeValue.trim() && node.nextSibling && node.nextSibling.nodeType === 3 && !node.nextSibling.nodeValue.trim())) {
                    newNodeArray.push(document.createTextNode(nodeValue));
                }
                //Fix for IE Edge issue with higher versions where node.replaceWith is not working when the parent is a doc fragment.
                if(_Lyte._rwpf && node.parentNode.nodeName === "#document-fragment") {
                	for(let i=0;i<newNodeArray.length;i++) {
                		insertBefore(node.parentNode,newNodeArray[i],node);
                      }
                    node.remove();
                } else {
                	node.replaceWith.apply(node, newNodeArray);
                }
            }
        }
    }
    //It registers the binding of the node with the properties with which the dynamicNode depends. 
    bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate,cache, type, idx, toBeInsMap) {
        let itemValue = options.itemValue;
        let forIndex = options.itemIndex;
        let forType = options.type;
        let indexValue = options.indexValue;
        let dynamicValue = nodeInfo.dynamicValue;
        let helperFunc = nodeInfo.helperInfo;
        let nodeValue, ownerElement = node.ownerElement;
        let dynamicValuesArray = [];
//        if(node.nodeType === 2 && _LC.isCustomElement(node.ownerElement,true) ) {
//          node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue};
//        }
        if(node.nodeType === 2) {
            node = {nodeName : node.nodeName, ownerElement : node.ownerElement, nodeType : 2, nodeValue : node.nodeValue, _attributeDetails : node._attributeDetails};
        }
        let hel_name = helperFunc?helperFunc.name:undefined; 
        //to get bindings in ssr components
        
        node._callee = this;
        let isHelper = false;
        if(helperFunc && Object.keys(helperFunc).length) {
            isHelper = true;
            let attrName = node.nodeName;
            nodeValue = node.helperValue = helperFunc;
            let helperArgs = [];
            if(helperFunc.name === "action"){
                let actName = helperFunc.args[0];
                helperFunc.args[0] = actName.startsWith("'")? actName.replace(/'/g,''):  actName;               
                actName = helperFunc.args.slice(0,1)[0];
                let args = helperFunc.args.slice(1,helperFunc.args.length), isCustom = false;
                let attrName = node.nodeName;
                if(attrName.indexOf("-") != -1){
                    isCustom = true;
                }
                helperArgs = [ownerElement,attrName,isCustom,{name:actName,args:args}];
                this.processHelper({"name" : helperFunc.name, "args" : helperArgs}, node);
                return;
            } else{
                if(helperFunc.name === "method") {
                    helperArgs = helperFunc.args;
                                   
                } else {
                    helperArgs = this.processArgs(this,{"helperInfo" : helperFunc} ,dynamicValuesArray,undefined,node,undefined,cache);    
                }
            }
            nodeValue = this.processHelper({"name" : helperFunc.name, "args" : helperArgs}, node);
            if(helperFunc.name === "unescape"){
//              let test = node.replaceWith.apply(node,nodeValue.childNodes);
                let obj = {initialNode : node, dynamicNodeValue : nodeValue};
                node = {dynamicPositions : obj, "_callee" : node._callee, helperValue : node.helperValue};
                nodeValue = undefined;
                processLast.push(node);
            }
        } else {
            helperFunc = {};
            node.syntaxValue = dynamicValue;
            let dynamicValues = [];
            nodeValue = _LC.get(this.component.data, dynamicValue, dynamicValues,cache);
            dynamicValuesArray.push(dynamicValues);
        }
        //if(node.nodeType === 2 && ( (typeof nodeValue !== "string" && (_LC.isCustomElement(node.ownerElement,true) || typeof nodeValue === "boolean") ) || _LC.isControlHelper(node.ownerElement) )) {
        //	let bindedNode = node;
            //node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue, _callee : this, syntaxValue : node.syntaxValue, helperValue : node.helperValue, _attributeDetails : node._attributeDetails};
        if(node.nodeType == 2) {
            let tagName = node.ownerElement.tagName;
            if(tagName == "INPUT" || tagName == "TEXTAREA" || (tagName == "DIV" && node.ownerElement.hasAttribute("contenteditable") )) {
                var rA = node.ownerElement._rA = node.ownerElement._rA || [];
                node.ownerElement._rA.push(node);
            }
            if(!ownerElement._origTemplate) {
                if(( ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") ) && ownerElement.tagName !== "TEMPLATE") {
                    if(_Lyte._ie) {
                        node.ownerElement = createElement("template");
                        node.ownerElement.setAttribute("is", nodeInfo._depthTemp);
                    } else {
                        node.ownerElement = nodeInfo._depthTemp.cloneNode(true);
                    }
                    ownerElement._origTemplate = node.ownerElement;
                }
            } else {
                node.ownerElement = ownerElement._origTemplate;
            }
        //	node.ownerElement._attributeDetails[node.nodeName].bindedNode = node;
        //}
        }
        let actMultiProp; 
        if(helperFunc.name !== "unbound" && !_LC.unbound) {
            let dynamicProp;
            if(helperNode) {
                dynamicProp = forType? helperNode._items[forIndex]._dynamicProperty : helperNode._dynamicProperty;
            }
            let obj, helperId;
            for(let d=0;d<dynamicValuesArray.length;d++) {
            	let dynamicValues = dynamicValuesArray[d];
                
            	for(let v=0;v<dynamicValues.length;v++) {
                        //to get binding in ssr components
                        var _nes = false;
                        
    
            		let actProperty = this.getProperty(dynamicValues[v]);
            		if(helperNode) {
            			let ind = dynamicValues[v].search(/\W/);
            			let boundValue;
            			if(ind !== -1) {
            				boundValue = dynamicValues[v].substring(0, ind);
            			} else {
            				boundValue = dynamicValues[v];
            			}
            			if(boundValue !== itemValue && boundValue !== indexValue && (!options.node || !options.node._properties || !options.node._properties[boundValue])) {
                            //to bind for in ssr
                            // obj._type = "nestedIf";
                            
                            makeSet(actProperty, "_helperNodes");
            				actProperty._helperNodes.add(
            						helperNode
            				);
            				dynamicProp[dynamicValues[v]] ? dynamicProp[dynamicValues[v]].push(node): (dynamicProp[dynamicValues[v]] = []).push(node);
            			} 
            			else {
            				node._cx = options;
//            				if(!actProperty._dynamicNodes) {
//            					actProperty._dynamicNodes = [];
//            					defProp(actProperty, '_dynamicNodes', {
//            						value: [],
//            						enumerable: false, 
//            						writable: true, 
//            						configurable: true
//            					});
//            				}
            				makeArray(actProperty, "_dynamicNodes");
            				actProperty._dynamicNodes.push(node);
            				if(boundValue !== indexValue) {
            					actMultiProp = actProperty;
            				}
            			}
            		} else {
//            			if(!actProperty._dynamicNodes) {
//            				defProp(actProperty, '_dynamicNodes', {
//            					value : [], 
//            					enumerable: false, 
//            					writable: true,
//            					configurable: true
//            				});
//            			}
            			makeArray(actProperty, "_dynamicNodes");
            			actProperty._dynamicNodes.push(node);
            		}
            		if ((ownerElement && (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin") )) || (ownerElement && ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(ownerElement.getAttribute("is")) && !isHelper)) {
            			let type= ownerElement.getAttribute("is");
            			if( (type=== "for" && node.nodeName === "items") || (type==="forIn" && node.nodeName === "object")) {
            				if(!actProperty._forHelpers) {
            					makeSet(actProperty, "_forHelpers");
            				}
                            //to bind for in ssr
                            
            				node.ownerElement._actualBinding = actProperty;
            				actProperty._forHelpers.add(node.ownerElement);
            			}
            		}
            		if(establishBindings) {
            			_LC.establishSelectedBinding(actProperty, this.component.data, this );
            		}
                    //to get ssr bindings 
                                    
            	}
            	if(dynamicValues.length > 1) {
                    
            		node._multipleProperty = node._multipleProperty || [];
            		node._multipleProperty.push({"dynamicProp" : actMultiProp ? undefined : dynamicProp, "actProp" : this.getProperty(dynamicValues[0]), "helperNode" : helperNode, "dynamicValues" : dynamicValues, index:d});
            	}
                             
            }
        }
        nodeValue = !typeof nodeValue === "boolean" && !typeof nodeValue === "number" ? (nodeValue? nodeValue : ""): nodeValue;
        if(node.nodeType === 2) {
            let parentNode = node._parentNode? node._parentNode : node.ownerElement;
            if(parentNode.tagName) {
                let is = parentNode.getAttribute("is");
            }
            let isCustomElement = _LC.isCustomElement(parentNode,true);
            if(isCustomElement) {
                 if(parentNode.set) {
                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue);
                 } else {
                    parentNode._initProperties = parentNode._initProperties || {};
                     parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] =nodeValue;
                }
            }
            let origNodeValue = nodeValue;
            //!== "string"
            if(isCustomElement && typeof nodeValue !== "string" && !isTemplate) {
                parentNode._attributes = parentNode._attributes || {};
                parentNode._attributes[node.nodeName] = nodeValue;
                if(parentNode.nodeName === "TEMPLATE" && isHelper) {
                    if((parentNode.getAttribute("is") === "for" && node.nodeName === "items") || (parentNode.getAttribute("is") === "forIn" && node.nodeName === "object") && !_LC.unbound) {
                        //node._actualBinding = {"_forHelpers" : new Set().add(parentNode)};
                        node.ownerElement._actualBinding = {"_forHelpers" : new Set().add(parentNode), "_createdBinding" : true};
                        if(nodeValue){
                            makeSet(nodeValue, "_bindings");
                            addBindings(nodeValue._bindings,node.ownerElement._actualBinding);
                        }
                    }
                }
                toBeRemoved.push(node.nodeName);
            }
            else {
                if(typeof nodeValue === "boolean") {
                    parentNode._attributes = node.ownerElement._attributes || {};
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(!nodeValue) {
//                      node.ownerElement.removeAttribute(node.nodeName);
                        toBeRemoved.push(node.nodeName);
                    } else {
                        parentNode.setAttribute(node.nodeName, "");
                    }
                } else {
                    if(nodeValue && typeof nodeValue === "object"){
                        var res;
                        if(typeof Record != "undefined" && nodeValue instanceof Record){
                            res = JSON.stringify(nodeValue.$.toJSON())
                        }
                        else{
                            try{
                                res = JSON.stringify(nodeValue)
                            }
                            catch(exp){
                                Lyte.error("Data passed for property '"+node.nodeName+"' of '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' cannot be serialized. The component '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' might not be registered before its use.");
                            }
                        }
                    }
                    else if(nodeValue== null || nodeValue == undefined){
                        res = ""
                    }
                    else{
                        res = nodeValue;
                    }
                    nodeValue = res;
                    if(_LC.isControlHelper(node.ownerElement)) {
                    	 parentNode._attributes = node.ownerElement._attributes || {};
                         parentNode._attributes[node.nodeName] = nodeValue;
                         toBeRemoved.push(node.nodeName);
                    } else {
                         let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                         //if(node.nodeName === "style") {
                         //   node.ownerElement.setAttribute("style",locNodeVal);
                         //} else {
                         //   node.nodeValue = locNodeVal;
                         //}
                         node.ownerElement.setAttribute(node.nodeName, locNodeVal);
                    }
                    
                }
            }
            if(parentNode.tagName === "LYTE-YIELD" /*parentNode.getAttribute("is") === "insertYield"*/) {
                parentNode.component.data[_LC.String.toCamelCase(node.nodeName)] = origNodeValue;
            }
            if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if (node.nodeName === "value") {
                            parentNode.value = (nodeValue === undefined) ? "" : nodeValue;
                        } else if (node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
            }
            if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                toBeRemoved.push(node.nodeName);
            }
        } 
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
	return node;
    }
    
    debounce(func, threshold) {
        var timeout;
        return function debounced() {
            var obj = this, args = arguments;
            function delayed() {
            	func.apply(obj, args);
                timeout = null;
            };
            if (timeout){
            	clearTimeout(timeout);
            }
            timeout = setTimeout(delayed, threshold || 100);
            //console.log(timeout,threshold);
        };
    }
    getProperty(key) {
        var arr = key.match(/([^[\].]+|\[\])/g);
        let property = this;
        if(!property._properties[arr[0]]) {
            property._properties[arr[0]] = {};
        } 
        property = property._properties[arr[0]];
        
        defProp(property, '_path', {enumerable: false, value : arr[0]});
        for(let i=1;i<arr.length;i++) {
            if (arr[i].startsWith("'") || arr[i].startsWith('"')) {//added check
			    arr[i] = arr[i].substring(1, arr[i].length -1);
		    }
            if(!property[arr[i]]) {
                property[arr[i]] = {};
                defProp(property[arr[i]], '_path', {enumerable: false, value : property._path + "." + arr[i]});
            }
            property = property[arr[i]];
        }
        return property;
    }
    //updN
    updateNode(node, updatePath) {
        let compInstance = this.component;
        var del = "delete";
        let multiplePropNode = [];
        let multipleProp;
        if(node._multipleProperty) {
        	for(var i=0;i<node._multipleProperty.length;i++) {
        		if(node._multipleProperty[i] && node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) > 0) {
                    multiplePropNode[i] = false;
                    multipleProp = node._multipleProperty[i];
		            let nodes;
		            if(multipleProp.dynamicProp) {
                        multiplePropNode[i] = multipleProp;
		                nodes = multipleProp.dynamicProp[multipleProp.actProp._path];
		                if(nodes) {
		                    let index = nodes.indexOf(node);
		                    nodes.splice(index, 1);
		                }
		                let helperNode = multipleProp.helperNode;
		                if(nodes.length === 0) {
		                    if(helperNode.getAttribute("is") === "if") {
		                        multipleProp.actProp._helperNodes[del](helperNode);
		                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
		                    } else {
		                        delete multipleProp.dynamicProp[multipleProp.actProp._path];
		                        if(helperNode._items) {
		                            let removeHelper = true;
		                            for(let i=0;i<helperNode._items.length;i++) {
		                                if(helperNode._items[i]._dynamicProperty && helperNode._items[i]._dynamicProperty[multipleProp.actProp._path]) {
		                                    removeHelper = false;
		                                    break;
		                                }
		                            }
		                            if(removeHelper) {
		                                multipleProp.actProp._helperNodes[del](helperNode);
		                                //console.log('for helper is removed');
		                            }
		                        }
		                    }
		                }
		            }
		            if(!multiplePropNode[i]) {
		                multiplePropNode[i] = "dynamicNodes";
		                nodes = multipleProp.actProp._dynamicNodes;
		                if(nodes) {
		                    let index = nodes.indexOf(node);
		                    nodes.splice(index, 1);
		                    if(!nodes.length) {
		                        delete multipleProp.actProp._dynamicNodes;
		                    }
		                }
		            }
		        }
			}
		}
        if(!node.syntaxValue && !node.helperValue) {
            return;
        }
        let contextSwitchInfo;
        let isYieldContext;
        if(node._cx || (node.nodeType === 2 && node.ownerElement._cx)) {
            contextSwitchInfo = node._cx || node.ownerElement._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo );
        } else if(node.tagName === "LYTE-YIELD" && node._callee._cx) {
        	isYieldContext = true;
        	contextSwitchInfo = node._callee._cx;
        	var contextSwitchArray = [];
        	_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
        }
        let nodeValue;
        let dynamicValues = [];
        var isHelper = false;
        if(node.helperValue){
            isHelper = true;
            nodeValue = node.helperValue;
                    let helperFunc = nodeValue;
                    let helperRetVal = this.processHelper({name : helperFunc.name, args : this.processArgs(this,{"helperInfo" : helperFunc} , dynamicValues, undefined, node)}, node);  
                    nodeValue = helperRetVal;
                    if(helperFunc.name === "unescape") {
                        let oldDynamicPosition = node.dynamicPositions;
                        let oldStartingNode = oldDynamicPosition.startingNode;
                        let oldChldLen = oldDynamicPosition.length;
                        while(oldChldLen > 1) {
                            let next = oldStartingNode.nextSibling;
                            oldStartingNode.remove();
                            oldStartingNode = next;
                            oldChldLen--;
                        }
                        let childLen = nodeValue.childNodes.length;
                        if(!childLen) {
                            nodeValue.appendChild(document.createTextNode(""));
                            childLen = 1;
                        }
                        let startingNode = nodeValue.childNodes[0];
                        oldStartingNode.replaceWith.apply(oldStartingNode,nodeValue.childNodes);
                        let obj = {startingNode : startingNode, length: childLen};
                        node.dynamicPositions = obj;
                        nodeValue = undefined;
                    }
        } else {
            let boundValue = node.syntaxValue;
            let path;
            if(boundValue.indexOf('.') !== -1 || boundValue.indexOf('[') !== -1) {
                path = boundValue;
                boundValue = boundValue.substring(0,boundValue.indexOf('.'));
            }
            let value = path ? _LC.get(compInstance.data, path, dynamicValues) : compInstance.data[boundValue]; 
            nodeValue = !typeof value === "boolean" && !typeof value === "number" ? (value? value : ""): value;
        }
		if(!(dynamicValues[0] instanceof Array)) {
        	dynamicValues = [dynamicValues];
		}
        
        if(multiplePropNode) {
        	for(var i=0;i<multiplePropNode.length;i++) {
        		if(multiplePropNode[i]) {
					let multipleProp = node._multipleProperty[i];
                    let dynamicValIndex = node._multipleProperty[i].index;
                    let prop = this.getProperty(dynamicValues[dynamicValIndex][0]);
                    let totalProp = this.getProperty(dynamicValues[dynamicValIndex][0].substring(0, dynamicValues[dynamicValIndex][0].indexOf('.')));
                    var value = this.getData(dynamicValues[dynamicValIndex][0].substring(0, dynamicValues[dynamicValIndex][0].indexOf('.')));                            
	                if(multiplePropNode[i] === "dynamicNodes") {
//	                    if(!prop._dynamicNodes) {
//	                        defProp(prop, '_dynamicNodes', {
//	                            value: [],
//	                            enumerable: false, 
//	                            writable: true,
//	                            configurable: true
//	                        });
//	                    }
	                	makeArray(prop, "_dynamicNodes");
	                    prop._dynamicNodes.push(node);
	                } else {
	                	makeSet(prop, "_helperNodes");
	                    prop._helperNodes.add(
	                            multipleProp.helperNode
	                    );
	                    let dynamicProp = multipleProp.dynamicProp;
	                    dynamicProp[prop._path] ? dynamicProp[prop._path].push(node): (dynamicProp[prop._path] = []).push(node);
	                }
	                if(node.ownerElement && (node.ownerElement.hasAttribute("lyte-for") || node.ownerElement.hasAttribute("lyte-if") || node.ownerElement.hasAttribute("lyte-switch") || node.ownerElement.hasAttribute("lyte-forin")) || node.ownerElement && node.ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(node.ownerElement.getAttribute("is")) && !isHelper) {
                        var type = node.ownerElement.getAttribute("is");
                        if (type === "for" && node.nodeName === "items" || type === "forIn" && node.nodeName === "object") {
                            if(multipleProp.actProp._forHelpers.has(node.ownerElement)){
                                multipleProp.actProp._forHelpers.delete(node.ownerElement);
                            }
                            if (!prop._forHelpers) {
                                makeSet(prop, "_forHelpers");
                            }
                            node.ownerElement._actualBinding = prop;
                            prop._forHelpers.add(node.ownerElement);
                        }
                    }
                    if(value != undefined){
                        _LC.establishBindings(totalProp, value);
                    }
                    node._multipleProperty[i].actProp = prop;
                    node._multipleProperty[i].dynamicValues = dynamicValues[dynamicValIndex];
	        	}
	        }
		}
        
        if(node.nodeType === 2) {
        	let parentNodes = [];
            let pN = node._parentNode ? node._parentNode :  node.ownerElement;
            if(pN.tagName === "TEMPLATE" && pN.getAttribute("is") === "component" && node.nodeName !== "component-name") {
            	let isKeepAlive = pN.hasAttribute("lyte-keep-alive");
            	if(isKeepAlive) {
            		for(var key in pN._renderedComponent) {
            			parentNodes.push(pN._renderedComponent[key]);
            		}
            	} else {
                    var compName = pN._currentComponent;
                    if(compName && pN._renderedComponent[compName]){
                        parentNodes.push(pN._renderedComponent[compName]);
                    }
            	}
            }
            parentNodes.push(pN);
            for(let i=0;i<parentNodes.length;i++) {
            	let parentNode = parentNodes[i];
            	if(parentNode.set) {
                    parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined,true);
                    } else {
                        parentNode._initProperties = parentNode._initProperties || {};
                        parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] = nodeValue;
                    }
                    if(parentNode.tagName === "LYTE-YIELD" && parentNode.component.data && node.nodeName && parentNode.component.data[node.nodeName] !== nodeValue /*parentNode.getAttribute("is") === "insertYield"*/) {
                        _LC.set(parentNode.component.data, _LC.String.toCamelCase(node.nodeName), nodeValue,undefined , undefined, parentNode);
                    }
                    parentNode._attributes = parentNode._attributes || {};
                    //!== "string"
                    if(_LC.isCustomElement(parentNode,true) && typeof nodeValue !== "string") {
                        if(node.ownerElement.nodeName === "TEMPLATE") {
                            if(node.helperValue) {
                            	if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		let newValue = nodeValue;
                            		_LC.removeSelectedBindingDeep(node.ownerElement._actualBinding, oldValue);
                            		if(newValue) {
                            			makeSet(newValue, "_bindings");
                                        addBindings(newValue._bindings,node.ownerElement._actualBinding);
                            			_LC.establishBindings(node.ownerElement._actualBinding, newValue);
                            		}
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            		//console.log("old Value ", oldValue, " new Value ", newValue);
                            	}
                            }else{
                                if((node.ownerElement.getAttribute("is") ===  "for" && node.nodeName === "items") || (node.ownerElement.getAttribute("is") ===  "forIn" && node.nodeName === "object")) {
                            		let oldValue = node.ownerElement._attributes[node.nodeName];
                            		if(node.nodeName === "object") {
                            			_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
                            		}
                            	}
                            }
                            parentNode["__"+node.nodeName] = true;
                            parentNode.removeAttribute(node.nodeName);
                        } else {
                            //Needs revisiting
                            //parentNode.removeAttribute(node.nodeName);
                        }

                    } else {
                        if(typeof nodeValue === "boolean") {
                            parentNode._attributes = parentNode._attributes || {};
                            parentNode._attributes[node.nodeName] = nodeValue;
                            if(!nodeValue) {
                                parentNode.removeAttribute(node.nodeName);
                            } else {
                                parentNode.setAttribute(node.nodeName, "");
                            }
                        } else {
                            if(nodeValue && typeof nodeValue === "object"){
                                var res;
                                if(typeof Record != "undefined" && nodeValue instanceof Record){
                                    res = JSON.stringify(nodeValue.$.toJSON())
                                }
                                else{
                                    try{
                                        res = JSON.stringify(nodeValue)
                                    }
                                    catch(exp){
                                        Lyte.error("Data passed for property '"+node.nodeName+"' of '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' cannot be serialized. The component '"+node.ownerElement.nodeName.toLocaleLowerCase()+"' might not be registered before its use.");
                                    }                                
                                }
                            }
                            else if(nodeValue== null || nodeValue == undefined){
                                res = ""
                            }
                            else{
                                res = nodeValue
                            }
                            nodeValue = res;
                            let locNodeVal = nodeValue === undefined ? "" : nodeValue;
                            // if(node.nodeName === "style") {
                            //     node.ownerElement.setAttribute("style",locNodeVal);
                            // } else {
                            //     node.nodeValue = locNodeVal;
                            // }

                            // if(node instanceof Node) {
                            //Check safari issue once
                            let oE = node.ownerElement;
                            if(oE.hasAttribute(node.nodeName)) {
                                if(oE.tagName != "INPUT" || node.nodeName != "value" || !oE.validity.badInput) {
                                    oE.setAttribute(node.nodeName, locNodeVal);
                                }
                            } else {
                                node.nodeValue = locNodeVal;                              
                            }
                        }
                    }
                    parentNode._attributes[node.nodeName] = nodeValue;
                    if(/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
                        if(node.nodeName === "value") {
                             let val = (nodeValue === undefined) ? "" : nodeValue;
                             if(parentNode.value !== val) {
                                parentNode.value = val;
                             } 
                        } else if(node.nodeName === "checked") {
                            parentNode.checked = nodeValue;
                        }
                    }
                    if(!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
                        parentNode.removeAttribute(node.nodeName);
                    }
                    let isStopped = parentNode._isStopped;
                    let result;
                    switch(parentNode.getAttribute("is")) {
                        case "for" :
                            this.updateForHelper(parentNode, {"type" : "update"});
                            break;
                        case "if" : 
                            result = this.updateSwitchHelper("if",parentNode, undefined, true, true);
                            break;
                        case "forIn" : 
                            this.updateForInHelper(parentNode , {"type" : "update"});
                            break;
                        case "switch" :
                            this.updateSwitchHelper("switch",parentNode, undefined, true, true);
                            break;
                        case "component" : 
                            if(node.nodeName === "component-name") {
                                this.updateDynamicComponent(parentNode, "update");    
                            }
                            break;
                        default:            
                    }
                	let handleBreakOptions;
                	if(isStopped &&  isStopped !== result) {
                		//console.log("new value is stopped");
                		if(!result) {
                			//console.log("new value is not stopped");
                			if(isStopped === "break") {
                				handleBreakOptions = "SM"
                			} else {
                				handleBreakOptions = "SS"
                			}
                		} else if(result === "break") {
                			handleBreakOptions = "MS";
                			//console.log("old value is continue and new value is break");
                		} else {
                			handleBreakOptions = "SM";
                			//console.log("old value is break and new value is continue");
                		}
                	} else if(result === "break") {
                		handleBreakOptions = "MS";
                		//console.log("old value not stopped and new value is break");
//                		this.handleBreak(parentNode._cx, "break");
                	} else if(result === "continue") {
                		handleBreakOptions = "SS";
                		//console.log("old value not stopped and new value is continue");
//                		this.handleBreak1(parentNode._cx , "continue");
                	}
                	if(handleBreakOptions) {
                		this.handleBreak(parentNode._cx, handleBreakOptions);
                	}
            }
        }
        else {
            node.nodeValue = nodeValue === undefined ? '' : nodeValue;
        }
        if(contextSwitchInfo) {
            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
        }
    }
    
    handleBreak(contextSwitchInfo, options) {
    	if(contextSwitchInfo) {
    		let forTemplate = contextSwitchInfo.node;
    		let breakIndex = contextSwitchInfo.itemIndex;
			let itemValue = forTemplate.getAttribute("item");
			let forContent = contextSwitchInfo.node._forContent;
			let endIndex = options[0] === "M" ? forContent.length : breakIndex + 1;
			for(let j=breakIndex;j<endIndex;j++) {
    			let currentForContent = forContent[j];
    			for(let i=0;i<currentForContent.length;i++) {
    				currentForContent[i].remove();
    				if(currentForContent[i]._forContent || currentForContent[i]._caseContent) {
    					this.removeHelpers(currentForContent[i]);
    				}
    			}	
    				forContent[j] = [];
    				_LC.removeSelectedBindingDeep(forTemplate._items[j].itemProperty, forTemplate._attributes.items[j]);
    				forTemplate._helpers[j] = [];
    				forTemplate._items[j] = {"_dynamicProperty" : {}, "itemProperty" : {}, "indexProperty": {}};
    		}
			let length = forTemplate._attributes.items.length;
			if(options[1] === "M") {
				this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : length - breakIndex, "type" : "replace"}, undefined, {});
			} else {
				this.updateForHelper(forTemplate, {firstIndex : breakIndex, secondIndex : 1, "type" : "replace"}, undefined, {});
			}
    	}
    }
    
    createCustomEvent(eventName, parentNode, actObj){
        const customEvent = new CustomEvent(eventName);
        parentNode._actions[eventName] = customEvent;
        parentNode._actions[eventName].processAction = actObj;
    }

    isEmptyString(str){
        return (!(typeof str === "string") || str === "" );
    }

    processArgs(scope,dynN,dynamicValues,event, node, newCompile,cache){
        let args = dynN.newHelperInfo && newCompile ? dynN.newHelperInfo.args : dynN.helperInfo.args;
        let helpers , j ;
        dynamicValues = dynamicValues || [];
        args = (Array.isArray(args)) ? Array.from(args) : args;
        for(let i=0; i<args.length; i++){
            if(args[i] && args[i].type){
                this.internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache);
            } else {
                if(!this.isEmptyString(args[i])) {
                    if(args[i].startsWith("'") && args[i].endsWith("'")){
                        args[i] = args[i].substr(1,args[i].length-2);       
                    } else {
                        args[i] = args[i].trim();
                        let dynamicVals = [];
                        if(args[i] === "event" && event) {
                            args[i] = event;
                        } else if(args[i] === "this" && node) {
                            args[i] = node.nodeType === 2 ? node.ownerElement : node;
                        } else {
                            args[i] = _LC.get(scope.component.data,args[i],dynamicVals,cache);
                        }
                        dynamicValues.push(dynamicVals);
                    }
                } else if(newCompile) {
                    if(args[i] instanceof Array) {
                        args[i] = _LC.getDD(scope.component.data, args[i]);
                    }
                }
            }
            
        }
        return args;
    }
    
    internalHelpers(scope,args,i,dynamicValues, event, node, newCompile,cache){
        //helperFunc = this.constructor.getHelper(args[i]);
        let helperFunc = args[i].value;
        let helperVal =  this.processHelper({"name" : helperFunc.name, "args" : this.processArgs(scope,{"helperInfo" : helperFunc},dynamicValues, event, node, newCompile,cache)});
        args[i] = helperVal;
   }
    
    processHelper(helperFunc, node){
        let args = [];
        let helperName = helperFunc.name;
        if(!_LyteComponent.registeredHelpers[helperName]){
            _Lyte.error("LC003" , helperFunc.name);
            return;
	    }
        switch(helperFunc.name){
            case "method" : 
                args.push(this, node);
                break;
            case "lbind" :
                args.push(this, node.ownerElement);
                break;
            case "lyteViewPort" :
                if(node && node.ownerElement){
                    args.push(node.ownerElement);
                    if(!helperFunc.args.length){
                        args.push(false);
                    }
                }else{
                    return false;
                }
        }
        return _LyteComponent.registeredHelpers[helperFunc.name].apply(this,args.concat(helperFunc.args));
    }
    
    getActionProperty(prop){
        let hostProp = this._properties;
        let value = (hostProp)?hostProp[prop].value:undefined;
        return value;
    }
    
    hasInternalBindings(content){
        return content.match(/[(]{1}[^)]+[)]{1}/);
    }
    
    getArgValues(argNames, properties) {
        let argValueArray = [];
        for(let i=0;i<argNames.length;i++) {
            argValueArray.push(properties[argNames[i]].value);
        }
        return argValueArray;
    }
    
    createEventListeners(node,actionType,actObj){
        let self = this;
        if(!node._callee && node !== this) {
            node._callee = this;
        }
        if(globalDOMEvents.indexOf(actionType) == -1){
            let infoAttr = actionType.substr(2);
            let infoAttrVal = node.getAttribute(infoAttr);
            // var evntListener = function(event) {
        	// 	var toRemove;
            //     if(!window.event) {
            //         window.event = event;
            //         toRemove = true;
            //     }
            //     _LC.throwAction.call(self,self,actionType.substr(2),actObj, undefined, undefined, node, event);
            //     if(toRemove) {
            //         window.event = undefined;
            //     }
            // };
            if ((_LyteComponent.registeredComponents[node.localName] && !node.component) || (node.tagName === "TEMPLATE" && node.getAttribute("is") === "component")) {
            	node._toRegEvnts = node._toRegEvnts || {};
            	node._toRegEvnts[actionType.substr(2)] = {"listener" : globalEventHandler , "attrVal" : this.tagName.toLowerCase()+" => "+actObj.name};
            } else {
            	node.setAttribute(infoAttr, this.tagName.toLowerCase()+" => "+actObj.name);
            	//Event is not in capture phase because, in capture phase, multiple event listeners in hierarchy are called from parent to child (since registration is done in that order)
            	node.addEventListener(actionType.substr(2), globalEventHandler);
            }
            if(node.hasAttribute(actionType)){
            	node[actionType] = undefined;
            }
            node.removeAttribute(actionType);
        }
    }
    registerParentYield(yieldName){
        let parentYield = this._callee._yields[yieldName]
        let locYield;
        if(parentYield){
            if(_Lyte._ie) {
                locYield = document.createElement("div");
                locYield.innerHTML = parentYield.outerHTML;
                locYield = locYield.childNodes[0];
                this.constructor.splitTextNodes(locYield);
            } else {
                locYield = parentYield.cloneNode(true);
            }
            Object.keys(parentYield).forEach(function(item) {  //eslint-disable-line no-loop-func
                locYield[item] = parentYield[item];
            });
            this._yields[yieldName] = locYield;   
        }         
    }  
    registerYields() {
        this._yields = {};
        let yields = this.querySelectorAll('template[is=registerYield],template[is=yield]');
        let lazyYields = [];
        for(let i=0;i<yields.length;i++) {
            while(yields[i].hasChildNodes()) {
                yields[i].content.appendChild(yields[i].childNodes[0]);
            }
            if(yields[i].hasAttribute("from-parent") && this._callee) {
                if(this._callee._yields){                    
                    this.registerParentYield(yields[i].getAttribute("yield-name"));
                }
                else{
                    lazyYields.push(yields[i]);
                }    
            } else {
                this._yields[yields[i].getAttribute("yield-name")] = yields[i];
            }
        }
        if(lazyYields.length && this._callee){
            var self = this;
            this.lazyYield = function(){
                if(self._callee){
                    for(let j=0;j<lazyYields.length;j++){
                        let lYield = lazyYields[j];
                        self.registerParentYield(lYield.getAttribute("yield-name"));
                    }
                    self._callee.removeEventListener("onReady", self.lazyYield);
                    delete self.lazyYield;
                }
            };
            this._callee.addEventListener("onReady", this.lazyYield);
        }
    }
    connectedCallback() {
        if(this.hasAttribute("lyte-rendered") || !_LyteComponent.registeredComponents[this.localName] || this._ccCalled) {
            return;
        }
        let fastRenderProp = this._fR;
        if(!fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        this.__h = {};
        this.__counter = 0;
        this.__dc = {};
        if(fastRenderProp) {
            let methods = fastRenderProp.methods;
            if(methods) {
                this.setMethods(methods);
            }
            _LC.ccDelay.push(this);
            this._ccCalled = true;
        } else {
            this.actualConnectedCallback();
        }
        var isViewPort;
        if(this._initProperties && this._initProperties.hasOwnProperty('lyteViewPort')){
            isViewPort = this._initProperties.lyteViewPort;
        }
        else{
            isViewPort = this.component.data.lyteViewPort;
        }
        if(isViewPort) {
            if(!_LC.isViewPortPending) {
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        _LC.executePendingViewPort();
                    });
                });
                _LC.isViewPortPending = true;
            }
            _LC.pendingViewPortElements.push(this);
        }
    }
    cmpBind(fastRenderProp){
        let compData = this.component.data;
        if(!_LC.unbound && !fastRenderProp) {
        	Lyte.establishObserverBindings.call(this,this.constructor._observers);
            Lyte.establishWatchScope.call(this,this.constructor._deepWatchProperties)
        	//this.establishObserverBindings();
        	makeSet(compData, "_bindings");
            addBindings(compData._bindings,this._properties);
        	_LC.establishBindings(this._properties, compData);
        }
    }
    actualConnectedCallback(){
        let compData = this.component.data;
        let fastRenderProp = this._fR;
        if(fastRenderProp) {
            this._callee = this._callee || this.getCallee(this.parentNode);
        }
        let templateAttributes = this.constructor._templateAttributes;
        if(templateAttributes && templateAttributes.attr) {
        	for(let key in templateAttributes.attr) {
//        		let attr = templateAttributes.attr[i];
				let attr = templateAttributes.attr[key];
        		if((!this.hasAttribute(attr.name) && !compData.hasOwnProperty(attr.name) ) || attr.globalEvent) {
        			if(attr.helperInfo && attr.helperInfo.name === "action") {
                        this._evBoundEvents = this._evBoundEvents || {};
                        let actionName = attr.helperInfo.args[0];
					    let boundName;
					    if(actionName.startsWith('"') || actionName.startsWith("'")) {
						boundName = actionName.substring(1, actionName.length - 1);
					    } else {
						//_Lyte.warn("Deprecation warning. Action name should be in quotes");
						boundName = actionName;
                        }
                        let actualAttrName = attr.globalEvent ? attr.name : (attr.name.indexOf("-") !== -1)? attr.name : attr.name.substr(2);
                        this._evBoundEvents[actualAttrName] = {"name" : boundName, "args" : attr.helperInfo.args, "from" : "component"};
                        let prevAttribute = this.getAttribute(attr.name);
                        let currentAttribute = this.constructor._template.getAttribute(attr.name);
                        //this.setAttribute("ev:"+attr.name, this.constructor._template.getAttribute(attr.name));
                        this.setAttribute(attr.name, currentAttribute + (prevAttribute ? " ; " + prevAttribute : ""));
                    }
                    if(!attr.globalEvent) {
                        attr.from = "component";
                        if(attr.staticValue) {
                            this.setAttribute(templateAttributes.attr[key].name, attr.staticValue);
                        } else {
                            this.setAttribute(templateAttributes.attr[key].name, "{{dummy}}");
							this.bindNode(this.attributes.getNamedItem(templateAttributes.attr[key].name), [], undefined, {}, templateAttributes.attr[key], undefined, undefined, true );
                        }
                    }
        			
        		}
        	}
        }
        for(let key in this._toRegEvnts) {
        	this.addEventListener(key, this._toRegEvnts[key].listener);
        	if(this.hasAttribute(key)) {
        		this.setAttribute(key, this.getAttribute(key) + " ; "+ this._toRegEvnts[key].attrVal);
        	} else {
        		this.setAttribute(key, this._toRegEvnts[key].attrVal);
        	}
        }
        this._toRegEvnts = {};
        let initialUnbound = _LC.unbound;

        let ssrBind  = this.getAttribute("ssrbindservernode")
        if(ssrBind && !this.component.data.lyteUnbound){
            this.bindServerData();
            this.removeAttribute("ssrbindservernode");
        }
        let content =  this.afterConnected(fastRenderProp,ssrBind);
        !ssrBind && this.cmpBind(fastRenderProp);

        _LC.unbound = initialUnbound;
        if(typeof content === "string") {
            if(content) {
                if(_LC.frSpecial) {
                    let temp = document.createElement("template");
                    temp.innerHTML = content;
                    this.innerHTML = "";
                    this.appendChild(temp.content);
                } else {
                    this.innerHTML = content;
                }
            }
            _LC.processAction(this);
        } else {
            if(this.component.data.lyteViewPort) {
                this._vpc = true;
                if(_Lyte._ie) {
                    for(var i=0;i<content.childNodes.length;i++) {
                        if(content.childNodes[i].tagName) {
                            this._dummyViewPortF = content.childNodes[i];
                            break;
                        }
                    }
                    for(var i=content.childNodes.length-1;i>=0;i--) {
                        if(content.childNodes[i].tagName) {
                            this._dummyViewPortL = content.childNodes[i];
                            break;
                        }
                    }
                } else {
                    this._dummyViewPortF = content.children[0];
                    this._dummyViewPortL = content.children[content.children.length - 1];
                }
            }
            this.appendChild(content);
        }
        let dataDef = this.component.__data;
        let attributes = this.attributes;
        this.__lyteIgnore = true;
        for(let i=attributes.length-1;i>-1;i--) {
            let camelCase = LyteComponent.String.toCamelCase(attributes[i].nodeName);
            if(dataDef[camelCase] && dataDef[camelCase].hideAttr) {
            this.removeAttribute(attributes[i].nodeName);
            }
        }
        this.__lyteIgnore = false;
    
        if( this._callee && this._callee.serverCall ){
            this.serverCall = true;
        }
        //to bind in ssr
        if( this.serverCall && !this.hasAttribute( "server-rendered") ){
            this.setAttribute( "server-rendered", "");
            var newData = LyteComponent.sendtoclient.call(this,this,true,this.component.__data);
            this.setAttribute("component-data", JSON.stringify( newData ) );
        }
        if( !this.hasAttribute( "server-rendered" ) )
        {        
	        this.setAttribute("lyte-rendered", "");
        }
        if(!fastRenderProp && !Lyte._ignoreOnReady) {
            this.dispatchEvent(new CustomEvent("onReady"));
        }
        let _config_flag;
        if( this.component._config ){
            if( this.component._config.clientLifeCycleHooks != undefined ){
                _config_flag = this.component._config.clientLifeCycleHooks == true || ( typeof this.component._config.clientLifeCycleHooks == 'object' ? this.component._config.clientLifeCycleHooks.includes('didConnect') : false );
            }
        }
        let _overrides = this.component._ssr ? this.component._ssr.overrides : undefined;
        if( !this.hasAttribute( "server-rendered" ) || this.serverCall ||  _config_flag ){
            if( _overrides && _overrides.didConnect && this.serverCall ){
                _overrides.didConnect.apply( this );
            }else{        
                this.callback("didConnect");
            }
            this.onCallBack("didConnect");
        }
    
        if( this.serverCall == undefined ){
            this.callback( "didRender" );
        }            
        if(fastRenderProp) {
            this.removeAttribute("_lyteprop");
        }
    }
    onCallBack(name){
        let callbacks = this.constructor._callBacks[name];
        if(callbacks){
            for(let i=0;i<callbacks.length;i++){
                try{
                    callbacks[i].value.call(this.component);    
                } catch(e) {
                    _Lyte.error(e);
                }
                
            }
        }
    }
    callback(name){
        var func = this.component[name];
        var args;
        if(func){
            if(arguments.length > 1) {
                args = Array.from(arguments);
                args.splice(0,1)
            }
            try{
                func.apply(this.component, args || []);    
            } catch(e) {
                _Lyte.error(e);
            }
        }
    }
    establishObserverBindings() {
        let observers = this.constructor._observers;
        for(let i=0;i<observers.length;i++) {
            let props = observers[i].properties;
            for(let j=0;j<props.length;j++) {
                let actProp;
                let isArrayObserver = false;
                if(props[j].indexOf('.[]') !== -1) {
                    isArrayObserver = true;
                    actProp = this.getProperty(props[j].substring(0, props[j].indexOf('.[]')));
                } else {
                    actProp = this.getProperty(props[j]);
                }
                makeSet(actProp, "_observers");
                actProp._observers.add({callee : this, observer: observers[i], isArrayObserver : isArrayObserver});
            }
        }
    }
    removeBindings(properties, actualData) {
        var del = "delete";
        for(let i in properties) {
            let actData = actualData[i];
            if(actData && actData._bindings) {
                actData._bindings[del](properties[i]);
                //Error while trying to delete _bindings from actData when actData is of type Array
                /*  if(!actData._bindings.size) {
                    delete actData._bindings;
                } */
            }
            if(typeof properties[i] === "object" && actData) {
                this.removeBindings(properties[i], actData);
            }
        }
    }
    actualDisconnected() {
        var self = this;
        if(!self.component) {
            return;
        }
        self._cx = null;
        self._callee = null;
        self.component.$node = null;
        self.component.__data = null;
        self.component.data.__component__ = null;
        self.component.data = null;
        self.component = null;
        self.__dc = self.__dc || {};
        self.__h =  self.__h || {};
        for (key in self.__dc) {
            var helper = self.__dc[key];
            //helper.remove();
            if(helper.hasAttribute("lyte-keep-alive")) {
                var objKeys = Object.keys(helper._renderedComponent);
                for(var j=0;j<objKeys.length;j++) {
                    let key = objKeys[j];
                    if(key !== helper._currentComponent) {
                        // Will remove from hDiv.
                        helper._renderedComponent[key].remove();
                    }
                }
            }
        }
        for (key in self.__h) {
            self.__h[key].remove();
        }
        self.__h = {};
        self.__dc = {};
        let yields = self._yields;
        for(var key in yields) {
            yields[key]._callee = null;
        }
        self = null;
    }
    disconnectedCallback() {
        if(_LC.ignoreDisconnect || !this.component) {
	       return;
        }
        var pve = _LC.pendingViewPortElements;
        if(this.component.data.lyteViewPort) {
            var index = pve.indexOf(this);
            if(index != -1) {
                pve.splice(index, 1);
            }
        }
        if(_LyteComponent.viewPortSettings.handlePendingItems && this._vpc) {
            _LC.executeVpe = true;
        }
        if(pve.length){
            for(let i=0; i<pve.length; i++){
                let actTemp = _LC.getActViewPortTemplate(pve[i]);
                if(actTemp && actTemp.tagName == "TEMPLATE" && actTemp.getAttribute("is") == "if" && actTemp._callee == this){
                    pve.splice(i,1);
                    i--;
                }
            }
        }
        this._destroyed = true;
        if(this.__toRemoveLazy){
            for(var __key in this.__toRemoveLazy){
                var __arr = this.__toRemoveLazy[__key];
                __arr.forEach(function(id){
                    Lyte.$.toRemoveFromRequiredServices(id);
                });
            }
            delete this.__toRemoveLazy;
        }
        this.component._bindings = null;
        var scpObj = this.__scpObj;
        if(scpObj){
            for(var key in scpObj){
                var propData = this.component.data[key], id = scpObj[key], idArr = id.split("_");
                if(propData){
                    Lyte.removeNestScp(this.component.data[key], idArr[0], idArr[1], undefined, this);
                }
            }
        }
        if(!this._fR) {
            _LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
        }
        var h = this.__h;
        for (key in h) {
            if(h[key]._actualBinding){
                this.removeHelpers(h[key]);
            }
        }
        h = {};
//      _LC.removeBindings(this._properties, this.component);
        for(let key in this._properties) {
            this._properties[key] = {};
        }
        this.callback('didDestroy');
        this.onCallBack('didDestroy');
        if(!_LC.dcc) {
            _LC.dcc = [];
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    try{
                        if(_LC.executeVpe){
                            _LyteComponent.viewPortSettings.executePendingViewPortElements();
                            _LC.executeVpe = false;
                        }
                        for(var i=0,item;item=_LC.dcc[i];i++) {
                            item.actualDisconnected();
                        }
                    }
                    catch(e) {

                    }
                    _LC.dcc = undefined;
                });
            });
        }
        _LC.dcc.push(this);
        // var self = this;
        // setTimeout(function() {
        //     self.actualDisconnected();
        // },0);
        if(this.lazyYield){
            this.removeEventListener("onReady", this.registerParentYield);
        }        
        this.constructor.activeInstances--;
    }
}

let LyteComponent = {
        "fRP" : {},
        "fRC" : 0,
        // "frcUnused" : [],
        "customPropRegex" : "",
        // "pushFrc" : function(fastRenderIndex) {
        //     this.frcUnused.push(fastRenderIndex);
        //     delete _LC.fRP[fastRenderIndex];
        // },
        // "getFrc" : function() {
        //     let frcIndex;
        //     if(this.frcUnused.length) {
        //         frcIndex = this.frcUnused.shift()
        //     } else {
        //         frcIndex = this.fRC++;
        //     }
        //     return frcIndex;
        // },
        "customPropHandlers" : [],
        "_registeredComponents" : {},
        "_reRegisteredComponents" : [],
        "toBeRegistered" : [],
        "updateCustomCrmComponent" : function(def,customCrmComponent){
            for (let key in def) {
                if (def[key] && def[key].type === "observer") {
                    def[key].fnName = key;
                    customCrmComponent._observers.push(def[key]);
                } else if (def[key] && def[key].type === "callBack") {
                    var props = def[key].properties;
                    for (var k = 0; k < props.length; k++) {
                        if (!customCrmComponent._callBacks[props[k]]) {
                            customCrmComponent._callBacks[props[k]] = [];
                        }
                        def[key].fnName = key;
                        customCrmComponent._callBacks[props[k]].push(def[key]);
                    }
                    if (def[key].observes) {
                        def[key].observes.fnName = key;
                        customCrmComponent._observers.push(def[key].observes);
                    }
                } else {
                        customCrmComponent.component.prototype[key] = def[key];
                }
            }
            return def;
        },
        "dataFromMixin" : function(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition){
            var mixinslen = mixinsToBeUsed.length;
            for(let i=0; i<mixinslen ; i++) {
                for(let item in mixinsToBeUsed[i]){
                    if(item === "actions") {
                        Object.assign(actionsFromMixin, mixinsToBeUsed[i][item]);    
                    } else if(item === "methods") {
                        Object.assign(methodsFromMixin, mixinsToBeUsed[i][item]);    
                    } else {
                        newDefinition[item] = mixinsToBeUsed[i][item];
                    }
                }
            }
            return{"actionsFromMixin":actionsFromMixin,"methodsFromMixin":methodsFromMixin,"newDefinition":newDefinition}
          },
        "throwEvent" : function(eventName){
            let self = this.$node ? this.$node : this;
            const evt = self._actions? self._actions[eventName] : undefined; 
            let customArgs = [];        
            if(arguments.length > 1){        
                for(let i=1;i<arguments.length; i++){            
                    customArgs.push(arguments[i]);                
                    }        
                }
                //wait for release
                //eventName = _LC.String.toCamelCase(eventName);
                _LC.throwAction.call(self,self._callee,eventName,undefined,true,customArgs,self);
            if(this.$node) {
                self.dispatchEvent(evt? evt : new CustomEvent(eventName, {"detail" : customArgs}));
            }
        },
        //this and scope reference should be either a node or a route.
        "throwAction" : function(scope,eventName,actObj,isCustom,customArgs, node, event, hasHandled, fromEv){
            let actionsObj;
            if(this._route && isCustom) {
                scope = _Lyte.Router.getRouteInstance(this._route);
                actionsObj = scope.actions || (scope.actions = {});
            } else if(this.routeName) {
                //process for the parent route and get the current component and proceed;
                let parentRoute = this.parent;
                if(parentRoute) {
                    if(parentRoute.component) {
                        scope = parentRoute.component;
                        actionsObj = scope.constructor._actions; 
                    } else {
                        scope = parentRoute;
                        actionsObj =  scope.actions || (scope.actions = {});            
                    }
                }
            } else if(scope){
                    actionsObj = scope.constructor._actions
            }
            if(!scope) {
                //Only warning is thrown because, we can have a eventListener for the dom directly. 
                if(!hasHandled) {
                    _Lyte.warn("Nothing handled the action "+ eventName + ".");    
                }
                return;
            }
            actObj = (actObj) ? actObj : this._actions && this._actions[eventName]? this._actions[eventName].processAction : void 0;     
            //wait for release
            /* 
            var dasherizedEventName = _LC.String.dasherize(eventName);
            actObj = (actObj) ? actObj : this._actions && this._actions[dasherizedEventName]? this._actions[dasherizedEventName].processAction : void 0;     
            */
            let args = customArgs ? customArgs : [];
            if(actObj){
            	var contextSwitchArray = [];
                if(node) {
                	_LC.adCx(node, contextSwitchArray);
                }
                let concatArgs;
                if(actObj.skipArgProcessing) {
                    // concatArgs = _Lyte.deepCopyObject(actObj.args);
                    // concatArgs.shift();
                    // var eventIndex = concatArgs.indexOf("__lyteEvent__");
                    // var nodeIndex = concatArgs.indexOf("__lyteNode__");
                    // if(eventIndex !== -1) {
                    //     concatArgs[eventIndex] = event;
                    // } 
                    // if(nodeIndex !== -1) {
                    //     concatArgs[nodeIndex] = target;
                    // }
                    concatArgs = actObj.args;
                } else {
                    concatArgs = this.processArgs(scope,{"helperInfo" : actObj}, undefined, event, node);
                }
                args.splice.apply(args, [0,0].concat(concatArgs) );
                if(node) {
                	_LC.rmCx(node, contextSwitchArray);
                }
                if(actionsObj[actObj.name]){
                    if(!isCustom){  
                        //args.unshift(window.event);
                        let parent = node.parentNode;
                        let val = actionsObj[actObj.name].apply(this.component,args);
                        if(event.currentTarget !== document.body && !fromEv) {
                            val = false;
                        }
                        hasHandled = true;
                        if(val !== false && !event.cancelBubble){
                        	if(actObj.from && node.getAttribute(event.type) && node._boundEvents && node._boundEvents[event.type]) {
                        		let actions = node._callee.constructor._actions;
                        		let actObj = node._boundEvents[event.type];
                        		let cloneActObj = _Lyte.deepCopyObject(actObj);
                                // cloneActObj.args.shift();
                                _LC.skipArgProcessing(cloneActObj, event, node);
                        		_LC.throwAction.call(node._callee,node._callee,event.type,cloneActObj, undefined, undefined, node, event, hasHandled);
                        	} else {
                                if(_LC.hasLyteEvents(node, eventName)) {
                                    let eventStopped = _LC.handleLyteEvents(node, event);
                                    val = eventStopped ? false : true;       
                                }
                                if(val === false) {
                                    return;
                                }
                        		if(_LC.isCustomElement(node)){
                        			scope = parent;
                        		}
                        		if(parent){
                                    let eventStopped;
                                    while(parent && (!parent.getAttribute(eventName) || parent.hasAttribute("disabled") ) && parent.tagName != "BODY"){
                        				if(_LC.hasLyteEvents(parent, eventName)) {
                                            eventStopped = _LC.handleLyteEvents(parent, event);
                                            if(eventStopped) {
                                                break;
                                            }
                                        }
                                        parent = parent.parentNode;
                        			}
                        			if(eventStopped || !parent || parent.tagName === "BODY"){
                        				return;
                        			}
                        			if(!parent._callee){
                        				parent._callee = parent.getCallee ? parent.getCallee(parent) : _LC.getCallee(parent);
                        			}
                        			if(parent && event.type === eventName && !event.cancelBubble){
                                       if(parent._evBoundEvents && parent._evBoundEvents[eventName]) {
                                           let actObj = parent._evBoundEvents[eventName];
                        		           let cloneActObj = _Lyte.deepCopyObject(actObj);
                                        //    cloneActObj.args.shift();
                                            _LC.skipArgProcessing(cloneActObj, event, parent);
                                           _LC.throwAction.call(parent,parent,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                       } else if(parent && parent._boundEvents && parent._boundEvents[eventName]) {
                                           let actObj = parent._boundEvents[eventName];
                        		           let cloneActObj = _Lyte.deepCopyObject(actObj);
		                                   _LC.skipArgProcessing(cloneActObj, event, parent);
                                           _LC.throwAction.call(parent._callee,parent._callee,eventName,cloneActObj,undefined,undefined,parent,event, hasHandled);  
                                       }
                        			}
                        		}
                        	}
                        }
                    }            
                    else{                
                        actionsObj[actObj.name].apply(this._callee.component,args);
                        hasHandled = true;                                             
                    } 
                }
                else{
                    _Lyte.error("LC004" , actObj.name);
                }
            } else if(isCustom) {
                var eventsObj = actionsObj[eventName]  || actionsObj[_LC.String.toCamelCase(eventName)] || actionsObj[_LC.String.dasherize(eventName)];
                if(eventsObj) {
                    var scopeS = _LC.isCustomElement(scope) ? scope.component : scope;   
                    let val = eventsObj.apply(scopeS, args);
                    //let val = eventsObj.apply(_LC.isCustomElement(scope)? scope.component : scope, args);
                    hasHandled = true;
                    if(val !== false) {
                        _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
                    }
                } else {
                    _LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
                }
            }
            
        },
        "isControlHelper" : function(ownerElement) {
        	return (ownerElement.tagName === "TEMPLATE" && ownerElement.getAttribute("is") && ownerElement.getAttribute("is") !== "component") || (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin"));
        },
        "isCustomElement" : function(node, isTemplate) {
            return node.hasAttribute && ((( node.tagName ==="TEMPLATE" || node.attributes["lyte-for"] || node.attributes["lyte-if"] || node.attributes["lyte-switch"] || node.attributes["lyte-forin"] ) && isTemplate )  || (node.nodeName && node.nodeName.indexOf('-') !== -1 && (_LyteComponent.registeredComponents[node.localName] || node.tagName === "LYTE-YIELD")));
        },
        "componentSet" : function(key, value, options, forceExecute, fromParent) {
            if(!forceExecute && this.get(key) === value) {
                _LC.clearError(this.data, key);
                return;
            }
            //temporary fix
            _LC.set(this.data, key, value, options, undefined, fromParent);
        },
        "componentGet" : function(key) {
            return key ? _LC.get(this.data, key) : this.data;
        },
        "nodeGet" : function(key) {
            return key ? this.component.get(key) : this.component.data;
        },
        "nodeSet" : function(key, value, options, fromParent) {
            this.component.set(key, value, options, undefined, fromParent);
        },
        "registerComponentWrapper" : function() {
            try{
                let rt = _LC.registerComponent.apply(_LC, arguments);
                Lyte._postRegister();
                return rt;
            }catch(e){
                Lyte._postRegister();
            }
        },
        "registerComponent" : function(componentName, definition, options) {
            if(_LC._reRegisteredComponents.indexOf(componentName) == -1 && _LyteComponent.registeredComponents[componentName]) {
            _Lyte.warn("Component "+ componentName + " already registered");
            return;
            }
            let customCrmComponent;
            let alreadyRegistered;
            if(_LC._registeredComponents[componentName]) {
            	customCrmComponent = _LC._registeredComponents[componentName];
                alreadyRegistered = true;
            } else {
            	customCrmComponent = class extends customElementPrototype {};
                customCrmComponent._properties = {};
                customCrmComponent.activeInstances = 0;
                customCrmComponent._depthTemp = document.createElement("template");
                customCrmComponent.prototype.throwAction = this.throwAction;
                customCrmComponent.compName = componentName;
            }
            // customCrmComponent.prototype.setData = function(arg0, arg1 ,options) {
            //     return this.component.setData(arg0, arg1, options);
            // }
            // customCrmComponent.prototype.getData = function(arg0) {
            //     return this.component.getData(arg0);
            // }
            Object.defineProperty(customCrmComponent.prototype, "setData", {
                configurable : true, 
                writable : true,
                value : function(arg0, arg1 ,options) {
                    return this.component.setData(arg0, arg1, options);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "getData", {
                configurable : true, 
                writable : true,
                value : function(arg0) {
                    return this.component.getData(arg0);
                }
            });

            Object.defineProperty(customCrmComponent.prototype, "setMethods", {
                configurable : true, 
                writable : true, 
                value : function(arg0, arg1) {
                    return this.component.setMethods(arg0, arg1);
                }
            })
            
            customCrmComponent.prototype.get = this.nodeGet;
            customCrmComponent.prototype.set = this.nodeSet;
            customCrmComponent._bindsIds = [];
            options = options ? options : {};
            let mixinsToBeUsed = [];
            // let serviceToBeUsed = {};
            var laterToBeUsed = {};

            let toBeUsed = {};
            // serviceToBeUsed = Object.assign({},Lyte.toBeInjectedServices);
			for (var key in options) {
				if (key == "services") {
					toBeUsed[key] = {};
					options.services.forEach(function (service) {
						if (typeof service == "string") {
							toBeUsed[key][service] = service;
						} else if (service && typeof service === "object") {
                            var srKey = service.as, srVal = service.service;
                            if (!Lyte._keywords.is(srKey, "component")) {                                
                                if(!service.scope || service.scope == "static"){
                                    toBeUsed[key][srKey] = srVal;
                                }
                                else if(service.scope == "instance"){
                                    var srKey = service.as, srVal = service.service;
                                    laterToBeUsed[key] = laterToBeUsed[key] || {};
                                    laterToBeUsed[key][srKey] = srVal;
                                }
                            }
                            else{
                                Lyte.warn("Service cannot be used in any keywords of Lyte.");
                            }
						}
					});
				}
                if (key == "mixins") {
                    toBeUsed[key] = [];
                    options.mixins.forEach(function (element) {
                        if (Lyte.Mixin.exists(element)) {
                            toBeUsed[key].push(Lyte.registeredMixins[element]);
                        } else {
                            Lyte.$.requiredMixins(element, componentName, "component");
                        }
                    });
                }
    
                if( key == "ssr"){
                    customCrmComponent._ssr = options[ key ];
                    if(options[key].config){
                        customCrmComponent._config = options[key].config;
                    }
                }        
            }
            function Component() {
                this.$ = {
                    "validate" : function() {
                        var compInstance = this._ins;
                        var data = compInstance.data;
                        for(var key in data) {
                            _LC.handleValidation(data, key, data[key], compInstance);
                        }
                    },
                    getError : function(path){
                        return _LC.getErrorStructure(this.ins,path)
                    }
                };
                this.$._ins = this;
            }
            customCrmComponent.component = Component;
            let compPrototype = Component.prototype;
            compPrototype.$lg = Lyte.__gl;
            compPrototype.set = this.componentSet;
            compPrototype.get = this.componentGet;
            if(window.requireValidateInComponent) {
                compPrototype.validate = function() {
                    var data = this.data;
                    for(var key in data) {
                        _LC.handleValidation(data, key, data[key], this);
                    }
                }
            }
            compPrototype.throwEvent = this.throwEvent;
            compPrototype.executeMethod = _LC.executeMethod;
            compPrototype.getData = _LC.componentGetData;
            compPrototype.setData = _LC.componentSetData;
            compPrototype.getMethods = _LC.componentGetMethods;
            compPrototype.setMethods = _LC.componentSetMethods;
            compPrototype.hasAction = _LC.componentHasAction;
            compPrototype.setActions = _LC.componentsetActions;
            customCrmComponent._mixins = options.mixins;
			customCrmComponent._serviceToBeUsed = laterToBeUsed ? laterToBeUsed.services : undefined;
            var actionsFromMixin = {};
            var ltInjServ = Lyte.toBeInjectedServices;
            if(ltInjServ){
                for(var injServ in ltInjServ){
                    Lyte.$.injectServices.component(injServ, ltInjServ[injServ], undefined, Lyte.__gS[injServ], customCrmComponent);
                }
            }
            for(var tKey in toBeUsed){
                if(tKey == "mixins"){
                    var aFromMixin = {}, methodsFromMixin = {},newDefinition = {};
                    _LC.dataFromMixin(toBeUsed.mixins,actionsFromMixin,methodsFromMixin,newDefinition);
                    definition = Object.assign(newDefinition, definition);
                    actionsFromMixin = Object.assign(actionsFromMixin, aFromMixin);
                }
                else if(tKey == "services"){
                    var serviceToBeUsed = toBeUsed[tKey];
                    for(var serv in serviceToBeUsed){
                        if(Lyte.registeredServices.hasOwnProperty(serviceToBeUsed[serv])){
							definition[serv] = new Lyte.registeredServices[serviceToBeUsed[serv]]();
                        }else{
                            Lyte.$.requiredServices(serv,serviceToBeUsed[serv],function(serviceData,serviceKey){
								var customCrmComponent = _LC._registeredComponents[componentName];
								customCrmComponent.component.prototype[serviceKey] = new serviceData();
                            })
                        }
                    }        
                }
            }
            customCrmComponent._actions = Object.assign({}, actionsFromMixin, definition.actions);
            customCrmComponent._template = definition._template;
            delete definition._template;
            customCrmComponent._dynamicNodes = definition._dynamicNodes;
            delete definition._dynamicNodes;
            customCrmComponent._templateAttributes = definition._templateAttributes;
            delete definition._templateAttributes;
            customCrmComponent._callBacks = {};
            customCrmComponent._observers = [];
//            let properties = definition.data ? definition.data : {};
            let properties = definition.data ? definition.data : undefined;
            let methods = Object.assign({},methodsFromMixin, definition.methods);
//            customCrmComponent._observedAttributes = Object.keys(properties);
            customCrmComponent._observedAttributes = definition._observedAttributes || [];
            customCrmComponent._observedMethodAttributes = definition._observedMethodAttributes || {};
            customCrmComponent._deepWatchProperties = definition._deepWatchProperties || {};
            delete definition._observedAttributes;
            delete definition._observedMethodAttributes;
            delete definition.data;
            delete definition.methods;
            definition = _LC.updateCustomCrmComponent(definition,customCrmComponent);
            customCrmComponent._data = properties;
            customCrmComponent._methods = methods;
            customCrmComponent._registerComponent(componentName,customCrmComponent);
            _LyteComponent.registeredComponents[componentName] = true;
            if(!_LC._registeredComponents[componentName]) {
            	if (document.readyState === "complete" || document.readyState === "interactive") {     
            		// document is already ready to go
            		customElements.define(componentName, customCrmComponent);
            	}
            	else{
            		_LC.toBeRegistered.push({name:componentName, def: customCrmComponent});
            	}
            }
            let depthTemp = customCrmComponent._depthTemp;
            if(!_LC._ie && depthTemp && depthTemp.content.childNodes.length) {
                depthTemp.setAttribute("data-id", "depthTemp_" + componentName);
                _LC.lyteComponentsDiv.appendChild(depthTemp);
            } else {
                delete customCrmComponent._depthTemp;
            }
            _LC._registeredComponents[componentName] = customCrmComponent;
            if(alreadyRegistered) {
                var pendingComps = customCrmComponent._pendingComponents || [];
                pendingComps.forEach(function(item) {
                    delete item.__lyteIgnore 
                    item.actualConstructor();
                    var arr = Array.from(item.attributes);
                    arr.forEach(function(attr) {
                        if(item.constructor.observedAttributes.indexOf(attr.name) != -1) {
                            item.attributeChangedCallback(attr.name, null, attr.value);
                        }
                        
                    });
                    item.connectedCallback();
                });
                customCrmComponent._pendingComponents = [];
            }
            return customCrmComponent;
        },
        "registerHelper" : function(name,helper){
            _LyteComponent.registeredHelpers[name] = helper;
        },
        "registerMixin" : function(name,mixin){
            _Lyte.Mixin.register.call(_Lyte, name, mixin);
        },
        "typeCast" : function(value, dataType, obj) {
        	if(value === null) {
        		return value;
        	}
        	try {
        		switch(dataType) {
            	case "string" : 
            		return typeof value === "object" ? JSON.stringify(value) : value.toString(); 	
            	break;
            	case "number" :
            		{
                    if(value == "") {
                        return undefined;
                    }
            		let val = +value;
            		if(isNaN(val)) {
            			throw "TypeCast exception";
            		} 
            		return val;
            		}
            	break;
            	case "array" : 
            	case "object" :
            		return JSON.parse(value);
            		break;
            	case "boolean" :
            		return ( (!value && value !== "") || value=== "false") ? false : true; 
            	break;
            	default : 
            		return value;
            	}
        	} catch(e) {
        		if(obj) {
        			obj.isError = true;
        		}
        		return value;
        	}    	
        },
        "sendtoclient": function(prop,server,node){
            var data = server ? prop.component.data : prop;
            var newData = {};
            var data_prop = node;
            for (var i in data){
                if(server){
                    var def = prop.component.__data[i];
                    if(i == "bindIds"){ 
                        newData[i] = {value : data[i] }
                    }
                        if(def && /^(object|array)$/.test(def.type) && prop._attributeDetails && prop._attributeDetails.hasOwnProperty(LyteComponent.String.dasherize(i))){
                            newData[i] = { "fP" : true };
                        }
                        else if(data[i] instanceof Date){
                            newData[i] = { "value" : data[i] , "type" : "Date" }
                        }
                        else if(data_prop[i]){
                            newData[i] = { "value" : data[i] , "type" : data_prop[i].type }
                        }else{
                            var type = typeof(data[i])
                            if(data[i] == undefined){
                                type = undefined;
                            }
                            newData[i] = {"value" : data[i] ,"type":type}
                        }
                }else{
                    if(data[i].type=="Date"){
                        newData[i] = new Date(data[i].value);
                    }
                    else if(!data[i].fP){
                        newData[i]= data[i].value;
                    }
                }
            }
            return newData;        	
        },
        "getDataType" : function(value) {
            var type = typeof value;
            if(type === "object") {
                if(Array.isArray(value)) {
                    return "array";
                }
            }
            return type;
        },
        "handleValidation" : function(object, property, value, component ,init) {
            let error = _Lyte.validate(object, property, value, component ,init);
            if(error) {
                _LC.set(component.data.errors, property, error);
                if(component.$node.callback) {
                    component.$node.callback("onError", property, error);
                }
            } else {
                _LC.clearError(object, property);
            }
            return error;
        },
        "clearError" : function(data, property) {
            if(data.errors && data.errors[property]) {
                _Lyte.objectUtils(data.errors, "delete", property);
            }
        },
        "createLyteId" : function(comp){
            comp.__counter++;
            return "__lyteId" + comp.__counter;
        },
        "apdNode" : function(node, comp) {
            _LC.tDiv.content.appendChild(node);
            let id = this.createLyteId(comp);
            comp.__h[id] = node;
            node.__lyteId = id;
        },
        "update":function(object, property, value, options, fromStore,oldValue,setterScope, actualProperty, fromParent,storeRecord){
        	let fromComponent = object.__component__;
        	let updateAttr = true;
            let dataType, dataDef, estObjBind = false;
        	if(!oldValue){
                oldValue = object[property];
                if(fromComponent && fromComponent.tagName !== "LYTE-YIELD") {
                    dataDef = fromComponent.component.__data[property];
                	if(dataDef && (dataType = dataDef.type)) {
                		updateAttr = !dataDef.hideAttr;
                		if(dataType !== _LC.getDataType(value) && (value !== undefined || dataType === "boolean")) {
                			value = _LC.typeCast(value, dataType);
                		}
                	}
                	if(value === oldValue) {
                        _LC.clearError(object, property);
                        return;
                	}
                    if(!options || (typeof options == "object" && options.skipValidation != true)){
                        let error = _LC.handleValidation(object, property, value, fromComponent.component);
                        if(error) {
                            return;
                        }
                    }
            }
            	//object[property] = value;
                if(!object.hasOwnProperty(property) && !(Array.isArray(object))) {
                    _LC.oF(object, "add", property, value, true )
                } else {
                    object[property] = value;
                }
            }
            let toBeExecuted = fromComponent ? true : false;
            let dasherizedAttr = _LC.String.dasherize(property);
            let callDeepObs = false;
            if(object._scp){
                if(!Lyte.cmpData(oldValue, value)){
                    callDeepObs = true;
                }
                if(oldValue && (Array.isArray(oldValue) || typeof oldValue == "object")){
                    var keys = Array.from(object._scp.keys());
                    keys.forEach(function(id){
                        var nestObj = Lyte.nestScp[id];
                        var isCyclic = nestObj.cyclic;
                        Lyte.removeNestScp(oldValue, id);
                        if(isCyclic){
                            Lyte.bindObj(nestObj._data, undefined, id, [], new Map(), undefined, undefined, true);
                        }
                    });
                }
            }
            if((Lyte.isRecord(object) && object.$.__scpObj) || (object.hasOwnProperty("__component__") && object.__component__.__scpObj)){
                var _scpObj, kmpKey;
                if(Lyte.isRecord(object)){
                    _scpObj = object.$.__scpObj;
                    kmpKey = object;
                }else{
                    _scpObj = object.__component__.__scpObj;
                    kmpKey = object.__component__;
                }
                if(_scpObj.hasOwnProperty(property)){
                    var _sId = _scpObj[property].split("_");
                    Lyte.removeNestScp(oldValue, _sId[0], _sId[1], undefined, kmpKey, undefined, Lyte.isRecord(value) || Array.isArray(value) && value.model && value.add ? value : undefined);
                    delete _scpObj[property];
                }
            }
            var customDtype;
            if(dataDef &&  Lyte.Transform[dataDef.type]){
                var customDataType = Lyte.Transform[dataDef.type]
                if(/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))){
                    customDtype=true;
                }
            }
            if (fromStore && Lyte.isRecord(object) || object && object.hasOwnProperty("_scp") && object._scp.size || dataDef && /^(object|array)$/.test(dataDef.type) && dataDef.watch == true || customDtype) {
                Lyte.establishObjectBinding(object, property, fromStore, true, storeRecord, (dataDef && dataDef.watch)?dataDef.watch:undefined);
           }
            if(fromComponent && actualProperty && ( (typeof value === "string" && fromComponent.getAttribute(dasherizedAttr) !==  value) || fromComponent.hasAttribute(dasherizedAttr) )) {
                 if((!_LC.customPropRegex.exec(property) || fromComponent.hasAttribute(dasherizedAttr) ) && updateAttr) {
                     if(value && typeof value === "object") {
                    	 let jsonString;
                         try{
                            jsonString = JSON.stringify(value);
                            fromComponent.attributes.getNamedItem(dasherizedAttr).__lyteIgnore = true;
                            fromComponent.setAttribute(dasherizedAttr, jsonString);
                         } catch(e) {

                         }
                     } else {
                    	 let attributeString = _LC.typeCast(value, "string");
                    	 if(fromComponent.getAttribute(dasherizedAttr) !== attributeString) {
                             let detAttr = fromComponent.attributes.getNamedItem(dasherizedAttr);
                             if(detAttr) {
                                 detAttr.__lyteIgnore = true;
                             }
                             attributeString = attributeString || "";
                             fromComponent.setAttribute(dasherizedAttr, attributeString);
                         }
                     }
                 }
            }
            if(value && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number" ) {
                //newValue is of type object 
                
                if(oldValue && typeof oldValue === "object" && oldValue._bindings) {
                    //Both oldValue and newValue are objects. 
                    if(!value._bindings) {
                        defProp(value, "_bindings", {
                            enumerable: false, 
                            writable: true, 
                            value : new Set(),
                            configurable: true
                        });
                    }
                    //for changing only child component
                    if(fromComponent && fromComponent.component.data === object && property.indexOf('.')=== -1) {
                        let bindings = fromComponent.getProperty(property);
                        this.removeSelectedBindingDeep(bindings, oldValue);
                        addBindings(value._bindings,bindings);
                        this.establishBindings(bindings, value);
                        //For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                        if(bindings._forHelpers) {
                            let bindfor = bindings._forHelpers.toArrayLyte();
                            for(var i=0;i<bindfor.length;i++){
                                let item = bindfor[i];
                                if(item._propBindingObject) {
                                    this.removeSelectedBindingDeep(item._propBindingObject, oldValue);
//                                  value._bindings.add(item._propBindingObject);
//                                  this.establishBindings(item._propBindingObject, value);
                                }
                            }
                        }
                        this.affectChanges(bindings,undefined,oldValue,setterScope,object[property]);
                    } else {
                    	//To change only the bindings present in the object and not all the bindings present in the oldValue.
                    	if(object._bindings) {
                    		let oldbind = object._bindings.toArrayLyte();
                            for(let i=0; i<oldbind.length;i++){
                                let item = oldbind[i][property];
                                if(item) {
                                	this.removeSelectedBindingDeep(item, oldValue);
                                    addBindings(value._bindings,item);
                                	this.establishBindings(item, value);
                                	//For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
                                	if(item._forHelpers) {
                                		let forbind = item._forHelpers.toArrayLyte();
                                		for(let j=0;j<forbind.length;j++){
                                			let itemBinding = forbind[j];
                                			if(itemBinding._propBindingObject) {
                                				this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                			}
                                		}
                                	}
                                	this.affectChanges(item,undefined,oldValue,setterScope,object[property]);
                                }
                            }
                    	}
                    
                    
                    }
                } else {
                    //newValue is object and oldValue is string. Hence establish bindings from oldValue's object and place it in the newValue. 
                    if(object._bindings) {
                    	makeSet(value, "_bindings");
                        let objbind = object._bindings.toArrayLyte();
                        for(let i=0;i<objbind.length;i++){
                            let item = objbind[i];
                            if(item[property]) {
                                addBindings(value._bindings,item[property]);
                                this.establishBindings(item[property], value);
                                this.affectChanges(item[property],undefined,oldValue,setterScope,object[property]);
                            }
                        }
                    }
                }
                dataDef = dataDef || (fromComponent && fromComponent.tagName !== "LYTE-YIELD" ? fromComponent.component.__data[property] : undefined); 
                if((fromStore && Lyte.isRecord(object)) || (object && object.hasOwnProperty("_scp") && object._scp.size) || (dataDef && (/^(object|array)$/.test(dataDef.type))&& (dataDef.watch || (dataDef.hasOwnProperty("items") || dataDef.hasOwnProperty("properties"))) )){
                    estObjBind = true;
                }
            } else {
                //newValue is string
                
                if(oldValue && typeof oldValue === "object" && oldValue._bindings && object._bindings) {
                    //newValue is string and oldValue is object 
                    let objbind = object._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item[property]) {
                            //oldValue._bindings.delete(item[property]);
                            //if(oldValue._bindings.size === 0) {
                            //  delete oldValue._bindings;
                            //  break;
                            //}
                        this.removeSelectedBindingDeep(item[property], oldValue);
                            if(item[property]._forHelpers) {
                                let forbind = item[property]._forHelpers.toArrayLyte();
                                for(let j=0;j<forbind.length;j++){
                                    let itemBinding =forbind[j];
                                    if(itemBinding._propBindingObject) {
                                        this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
                                    }
                                }
                            }
                        }
                    }
                }
                
                //when newValue and oldValue , both are string, no need to change bindings. 
                if(object._bindings) {
                    let objbind = object._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item[property]) {
                            this.affectChanges(item[property],undefined,oldValue,setterScope,object[property]);
                        }
                    }
                }
            }
            if(callDeepObs && object._scp){
                this.callDeepObservers(object, { type:"deepChange", oldValue:oldValue, newValue : value }, property);
            }
            if(toBeExecuted && !fromParent && fromComponent._attributeDetails && fromComponent._callee) {
            	//let syntaxValue = fromComponent.getAttributeNode(property).syntaxValue;
            	let attrDetail = fromComponent._attributeDetails[_LC.String.dasherize(property)];
            	let syntaxValue;
            	if(attrDetail && attrDetail.isLbind) {
            		syntaxValue = attrDetail.dynamicValue;
            	}
            	if(syntaxValue) {
            		let contextSwitchArray;
            		if(fromComponent._cx) {
            			contextSwitchArray = [];
            			_LC.changeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
            		}
                    let obj = _LC.getNew(fromComponent._callee.component.data, syntaxValue);
                    if(!obj.context){
                        return;
                    }
            		let exec = false;
            		if(obj.context === fromComponent._callee.component.data) {
            			if(fromComponent._callee._properties[obj.lastKey] && fromComponent._callee._properties[obj.lastKey].__fromComponent) {
            				exec = true;
            			}
            		} else {
            			exec = true;
            		}
            		//self.setData(this._lbind,this.value);
            		if(exec) {
                        let lastKeyIndex = +obj.lastKey;
                        if(Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
                            let callReplaceAt = lastKeyIndex < obj.context.length;
                            if(obj.context[lastKeyIndex] !== value || !callReplaceAt){
                                _LC.aF(obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, value);
                            }
                        } else {
                            _LC.set(obj.context, obj.lastKey, value, options);
                        }
            		}
            		if(contextSwitchArray) {
            			_LC.removeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx )
            		}
            	}
            }
        },
        "getContentForIE" : function getContentForIE(content, constr, newlyCreated, info) {
            if(typeof content === "string") {
                newlyCreated = true;
                var div = createElement("div");
                div.innerHTML = content;
                content = div.childNodes[0];
                constr.splitTextNodes(content);
            }
            if(content.getAttribute && content.getAttribute("depth")) {
                if(Lyte._ms && info) {
                    info._content = div;
                }
                var itr = parseInt(content.getAttribute("depth"));
                content = _Lyte._ie ? content : (newlyCreated ? content.content : content.content.cloneNode(true));
                for(var i=0;i<itr;i++) {
                    content = content.childNodes[0];
                }
            }
            return content;
        },
        "replaceWithPf" : function(node1, node2) {
            if(_Lyte._rwpf) {
            	insertBefore(node1.parentNode,node2, node1);
                node1.remove();
            } else {
                node1.replaceWith(node2);
            }
        },
        "getCallee" : function(callee, self){
            while(callee &&  !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
                if(callee.tagName === "BODY") {
                    callee = null;
                    break;
                }
                callee = callee.parentNode;
            }
            if(callee && callee.tagName === "LYTE-YIELD") {
            return callee._registerYield? callee._registerYield._callee : undefined;
            }
            return ((self ===  callee) ? undefined : callee);
        },
        "set" : function(object, property, value, options, fromStore, fromParent) {
            let lastIndex = -1;
            var s_rec,check={},recDottedProp;
            if(Lyte.isRecord(object) && fromStore){
                s_rec=object;
            }
            if(!(typeof property === "object") || !property){
                property = property+"";
                lastIndex = property.lastIndexOf('.');
            }
            let actualProperty = property;
            if(lastIndex !== -1) {
                let outerPropertyPath = property.substring(0, lastIndex);
                property = property.substring(lastIndex + 1);
                object = _LC.get(object, outerPropertyPath);
                recDottedProp=true;
            }
            if(typeof property === "string" && object[property] === value) {
                if(object.__component__) {
                    _LC.clearError(object, property);
                } else if(_Lyte.isRecord(object) && !object.$.isCloned) {
                    store.$.clrRecErr(object.$, property);
                    object.$.emit ? object.$.emit("set", [object, property]) : undefined;
                    object.$.model && object.$.model.emit ? object.$.model.emit("set", [object.$.model._name, object, property]) : undefined;
                    store.emit ? store.emit("set", [object.$.model._name, object, property]) : undefined;
                }
                return;
            }
            let oldValues = [];
            if(object._setterScope){
                var setterScope = object._setterScope;
            }
            var checkSim = false, watch = [];
            if(object._scp && object._scp.size){
                var keys = Array.from(object._scp.keys());
                keys.forEach(function(id){
                    var _obj = object._scp.get(id);
                    obj = _obj.paths;
                    var recObj = Lyte.nestScp[id], model, field, rec, attr, wobj = {};
                    var pathArr = Object.keys(obj), aPath;
                    if(pathArr.length > 1){
                        aPath = "*";
                    }
                    else if(pathArr.length == 1){
                        aPath = pathArr[0];
                    }
                    wobj.path = aPath;
                    wobj.id = id;
                    if(pathArr.length > 1){
                        wobj.paths = pathArr;
                    }
                    wobj.attr = attr;
                    wobj.data = recObj.data;
                    wobj.PropsInfo = recObj.PropsInfo||undefined;
                    if(recObj.model){
                        var mMap = recObj.model;
                        wobj.Error = recObj.Error;
                        var mKeys = Array.from(recObj.model.keys());
                        for(var i=0; i<mKeys.length; i++){
                            var mName = mKeys[i];
                            var pkMap = mMap.get(mName);
                            if(pkMap){
                                var pkArr = Array.from(pkMap.keys());
                                var pkLen = pkArr.length;
                                for(var j=0; j<pkLen; j++){
                                    var mPk = pkArr[j];
                                    var attrMap = pkMap.get(mPk);
                                    var attrArr = Array.from(attrMap.keys());
                                    var attrLen = attrArr.length;
                                    for(k=0; k<attrLen; k++){
                                        var mAttr = attrArr[k];
                                        var mObj = Object.assign({}, wobj);
                                        var mRec = store.peekRecord(mName, mPk);
                                        if(mRec){
                                            model = mRec.$.model;
                                            field = model.fieldList[mAttr];
                                            if(field && (field.properties || field.items || field.watch == true || Lyte.Transform[field.type])){
                                                mObj.data = Lyte.deepCopyObject(mRec[mAttr]);
                                                mObj.rec = mRec;
                                                mObj.isRec = true;
                                                mObj.attr = mAttr;
                                                mObj.dtype = model.fieldList[mAttr];
                                                mObj._cmpErr=mRec.$.error;
                                                mObj.key=mAttr;
                                            }
                                            watch.push(mObj);
                                        }
                                    }
                                }
                            }
                        }
                    } 
                    else{
                        watch.push(wobj);
                    }
                    // var isAttr = rec.$._attributes.hasOwnProperty(attr);
                    // if(!isAttr){
                    //     rec.$._attributes[attr] = Lyte.deepCopyObject(rec[attr]);
                    // }
                    // else{
                    //     checkSim = true;
                    // }
                    // rec.$.isModified = true;          
                });
                watch.forEach(function(val){
                    if((!options || (typeof options == "object" && options.skipValidation != true)) ){
                        var id = val.id,path=val.path.split("."),dtype=val.dtype,errs;
                        if(val.isRec){
                            if(fromStore){
                                path = actualProperty.split(".")
                                path.splice(-1);
                                path.shift();
                            }
                            path = path.length == 1 && path[0] == property ? []:path;
                            check.Prop = dtype;
                            Lyte.checkNestedProp(id,path,dtype,val,object,property,value,check,fromStore); 
                        }
                        if(val.PropsInfo){
                            val.PropsInfo.forEach(function(props){
                                props.path = val.path;
                                props.attr = val.attr;
                                dtype = props.dtype;
                                check.Prop = dtype;
                                Lyte.checkNestedProp(id,path,dtype,props,object,property,value,check,fromStore);
                            })
                        }
                    }
                })
                if(check.value && check.value.code){
                    _Lyte.error("ERR35",check.Prop.type)
                    return;
                }
            }
            actualProperty = actualProperty === property ? actualProperty : undefined;
            var shareObj = {};
            if(typeof property === "object"){
            	if(_Lyte.isRecord(object) && !fromStore && !object.$.isCloned) {
                        // for(let key in property){
                        //     if(Array.isArray(object[key])){
                        //         oldValues.push({key:key,oldValue:object[key].slice(0)});    
                        //     }
                        //     else{
                        //         oldValues.push({key:key,oldValue:object[key]});
                        //     }
                        // }
                        for(let key in property) {
                            let locValue = property[key];
                            let dataType = object.$.model.fieldList[key];
                            dataType = dataType ? dataType.type : undefined;
                            if(dataType && (locValue !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(locValue)) {
                                property[key] = _LC.typeCast(locValue, dataType);
                            }
                        }
                        let record = store.$.setData(object.$, property, undefined, options, undefined, undefined, shareObj);
                        if(record.$.isError){
                            return record;
                        }
                        // for(let i=0; i<oldValues.length; i++){
                        //     _LC.update(object,oldValues[i].key,object[oldValues[i].key],fromStore,(oldValues[i].oldValue === undefined)?null:oldValues[i].oldValue ,setterScope, actualProperty, fromParent);
                        // }
                } else {
                    //object[property] =  value;
                    for(let key in property){
                        //_LC.update(object,key,property[key],fromStore,undefined,setterScope, actualProperty, fromParent);
                        //value is option here
                        _LC.set(object,key,property[key],value,fromStore, fromParent);
                    }
                }
            }
            else{
                if(_Lyte.isRecord(object) && (!fromStore || (fromStore && recDottedProp)) && !object.$.isCloned) {
                    let old = object[property];
					let dataType = object.$.model.fieldList[property];
                    dataType = dataType ? dataType.type : undefined;
                    if(dataType && (value !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(value)) {
                        value = _LC.typeCast(value, dataType);
                    }
                    let record = store.$.setData(object.$, property,value, options, undefined, undefined, shareObj);
                    if(record.$.isError){
                        return record;
                    }
                    //Commented because update will happend when "set" is called from setData of store. 
                    //_LC.update(object,property,value,fromStore,(old === undefined) ? null : old,setterScope , actualProperty);    
                } else {
                    _LC.update(object,property,value,options,fromStore,undefined,setterScope,actualProperty, fromParent, s_rec);
                }
            }
            if(watch && watch.length){
                watch.forEach(function(obj){
                    if(obj.isRec){
                        store.$.deepValueChange(obj.rec, obj.attr, obj.rec[obj.attr], obj);
                    }
                });
            }
        },
        "adCx" : function(node, contextSwitchArray) {
        	let isYield = node.tagName === "LYTE-YIELD";
        	if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
        		_LC.changeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        	} else if(isYield && node._callee._cx) {
        		_LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        	}
        }, 
        "rmCx" : function(node, contextSwitchArray) {
        	let isYield = node.tagName === "LYTE-YIELD";
        	if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
        		_LC.removeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
        	} else if(isYield && node._callee._cx) {
        		_LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
        	}
        },
        "changeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
            if(!contextSwitchInfo) {
                return;
            }
            let isYield = node.tagName === "LYTE-YIELD";
            if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
                _LC.changeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
            } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            	_LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);
            }
            if(isYield) {
                let insertYield = node._registerYield;
                let callee = insertYield._callee;
                if(callee && callee._cx) {
                    _LC.changeContext(callee._cx.node, contextSwitchArray, callee._cx);
                }
            }
            let indexValue, itemValue;
            if(contextSwitchInfo.type) {
                if(contextSwitchInfo.type === "for") {
                    indexValue = node.getAttribute("index");
                    itemValue = node.getAttribute("item");
                    if(node._items.length === 0) {
                        return;
                    }
                } else {
                    indexValue = node.getAttribute("key");
                    itemValue = node.getAttribute("value");
                    if(Object.keys(node._items).length === 0) {
                        return;
                    }
                }
                let callee = node._callee;
                let initialItemValue = callee.component.data[itemValue];
                let initialIndexValue = callee.component.data[indexValue];
                let initialItemProp = callee._properties[itemValue];
                let initialIndexProp = callee._properties[indexValue];
                 let items = contextSwitchInfo.type === "for" ? node._currentItems : node._currentObject;
                // let items = contextSwitchInfo.type === "for" ? node._attributes.items : node._attributes.object;
                callee.component.data[itemValue] = items[contextSwitchInfo.itemIndex];
                callee.component.data[indexValue] = contextSwitchInfo.itemIndex;
                callee._properties[itemValue] = node._items[contextSwitchInfo.itemIndex].itemProperty;
                callee._properties[indexValue] = node._items[contextSwitchInfo.itemIndex].indexProperty;
                let dummyObject = {"initialItemValue" : initialItemValue , "initialIndexValue" : initialIndexValue, "initialItemProp" : initialItemProp, "initialIndexProp" : initialIndexProp};
                contextSwitchArray.push(dummyObject);
            } else {
                //handling for yield
                let dummyObject = {};
                let callee = node._registerYield._callee;
                Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                    dummyObject[key] = {};
                    dummyObject[key].value = callee.component.data[key];
                    dummyObject[key].property = callee._properties[key];
                    callee._properties[key] = contextSwitchInfo.node._properties[key];
                    callee.component.data[key] = contextSwitchInfo.node.component.data[key];
                }); 
                contextSwitchArray.push(dummyObject);
            }
        },
        "removeContext" : function(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
            if(!contextSwitchInfo) {
                return;
            }
            let isYield = node.tagName === "LYTE-YIELD";
            if(node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
                _LC.removeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
            } else if((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
            	_LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx)
            }
            if(isYield) {
                let insertYield = node._registerYield;
                let callee = insertYield._callee;
                if(callee && callee._cx) {
                    _LC.removeContext(callee._cx.node, contextSwitchArray, callee._cx);
                }
            }
            let indexValue, itemValue;
            if(contextSwitchInfo.type) {
                if(contextSwitchInfo.type === "for") {
                    indexValue = node.getAttribute("index");
                    itemValue = node.getAttribute("item");
                    if(node._items.length === 0) {
                        return;
                    }
                } else {
                    indexValue = node.getAttribute("key");
                    itemValue = node.getAttribute("value");
                    if(Object.keys(node._items).length === 0) {
                        return;
                    }
                }
                let callee = node._callee;
                let items = node._attributes.items;
                let removedObject = contextSwitchArray.shift();
                callee.component.data[itemValue] = removedObject.initialItemValue;
                callee.component.data[indexValue] = removedObject.initialIndexValue;
                callee._properties[itemValue] = removedObject.initialItemProp;
                callee._properties[indexValue] = removedObject.initialIndexProp;
            } else {
                let callee = node._registerYield._callee;
                let removedObject = contextSwitchArray.shift();
                Object.keys(contextSwitchInfo.node._properties).forEach(function(key) {
                    callee.component.data[key] = removedObject[key].value;
                    callee._properties[key] = removedObject[key].property;
                });
            }
        },
        "sortCommands" : function(array1, arrayB) {
            var retVal = {};
            var arrayA = array1.slice();
            retVal.origianlArray = array1;
            var commands = [];
            
            for (let i = 0; i < arrayB.length; i++) {
                // var targetIndex = arrayA.findIndex((element) => element === arrayB[i]);
                var targetIndex = arrayA.indexOf(arrayB[i]);
            
                if (targetIndex === -1) {
                commands.push({
                    type: 'Add',
                    element: arrayB[i], 
                    toIndex : i
                });
                arrayA.splice(i, 0, arrayB[i]);
                } else {
                if (targetIndex !== i) {
                    commands.push({
                    type: 'Move',
                    element: arrayB[i],
                    fromIndex: targetIndex,
                    toIndex: i
                    });
                    arrayA.splice(targetIndex, 1);
                    arrayA.splice(i, 0, arrayB[i]);
                }
                }
            }
            
            for (let i = arrayA.length - 1; i >= arrayB.length; i--) {
                commands.push({
                type: 'Remove',
                element: arrayA[i]
                });
                arrayA.splice(i, 1);
            }
            retVal.commands = commands;
            retVal.changedArray = arrayB;
            return retVal;
        },
        "oF" : function() {
            let object = arguments[0];
            let functionName = arguments[1];
            let property = arguments[2];
            let newValue = arguments[3];
            let fromComponent = arguments[4];
            let fromStore = arguments[5];
            if(functionName === "add" && !fromComponent) {
            	_LC.set(object, property, newValue, undefined,fromStore);
            	return;
            }
            let options = {};
            options.type = functionName;
            options.property = property;
            if(!/^(add|delete)$/.test(functionName)) {
                _Lyte.error("LC005", functionName);
                return;
            }
            let bindings = object._bindings;
            if(functionName === "delete") {
            	_LC.set(object, property, undefined, undefined,fromStore);
            } else {
                object[property] = newValue;
            }
            if(bindings) {
                let bind = bindings.toArrayLyte();
                for(let i=0;i<bind.length;i++) {
                    let binding = bind[i];
                    let forHelpers = binding._forHelpers;
                    if(forHelpers) {
                    	let helperBind = forHelpers.toArrayLyte();
                        for(let j=0;j<helperBind.length;j++) {
                            let forHelper = helperBind[j];
                            if(forHelper.getAttribute("is") != "forIn"){
                                continue;
                            }
                            let itemValue = forHelper.getAttribute("key");
                            //Need to check
//                            _LC.removeSelectedBindingDeep({[itemValue] :                        forHelper._items[property].itemProperty}, {[itemValue] : object[property]});
                        	let contextSwitchArray = [];
                            if(functionName === "add") {
                            	_LC.adCx(forHelper, contextSwitchArray);
                            }
                            forHelper._callee.updateForInHelper(forHelper, options);
                            if(functionName === "add") {
                                _LC.rmCx(forHelper, contextSwitchArray);
                            }
                        }
                    }
                }
            }
            if(functionName === "delete") {
                delete object[property];
            }
        },
        "aF" : function() {
            let array = arguments[0];
            let initialArrLength = array.length;
            let callLengthObserver = true;
            let functionName = arguments[1];
            let value = arguments[3],check={};
            if(/^(replaceAt|removeAt|shift)$/.test(functionName) && !array.length) {
                _Lyte.warn(functionName + " operation cannot be performed on empty array");
                return;
            }
            let commands;
            if(functionName == "sort") {
                var originalArray = arguments[0];
                var sortFunction = arguments[2];
                var addedArguments = arguments[3] || [];
                var dummyArray = originalArray.slice();
                addedArguments.forEach(function(item) {
                    dummyArray.push(item);
                });
                if(typeof arguments[2] == "function") {
                    dummyArray.sort(sortFunction);
                } else {
                    var obj = arguments[2];
                    var key = obj.sortBy;
                    var order = obj.sortOrder;
                    function sorting(item1, item2) {
                        var item1 = key ? item1[key] : item1;
                        var item2 = key ? item2[key] : item2;
                        if(item1 > item2) {
                            return order ? 1 : -1;
                        } else if(item1 < item2) {
                            return order ? -1 : 1;
                        } else {
                            return 0;
                        }
                    }
                    dummyArray.sort(sorting)
                }
                commands = this.sortCommands(originalArray, dummyArray).commands;
            }
            let commArgs = arguments[2], oldVal, obsObj, watch = [];
            if(array._scp && /^(replaceAt|splice|removeAt|remove|insertAt)$/.test(functionName)){
                array._scp.forEach(function(_obj, id){
                    var rec, attr, wobj = {};
                    var recObj = Lyte.nestScp[id];
                    var obj = _obj.paths;
                    var pathArr = Object.keys(obj), aPath;
                    if(pathArr.length > 1){
                        aPath = "*";
                    }
                    else if(pathArr.length == 1){
                        aPath = pathArr[0];
                    }
                    wobj.path = aPath;
                    wobj.id = id;
                    if(pathArr.length > 1){
                        wobj.paths = pathArr;
                    }
                    wobj.attr = attr;
                    wobj.data = recObj.data;
                    wobj.reInit = Lyte.isRecord(recObj.data) || (Array.isArray(recObj.data) && recObj.data.model && recObj.data.add);
                    wobj.PropsInfo = recObj.PropsInfo || undefined;
                    wobj.index=commArgs;
                    if(recObj.model){
                        var mMap = recObj.model;
                        wobj.Error = recObj.Error;
                        var mKeys = Array.from(recObj.model.keys());
                        for(var i=0; i<mKeys.length; i++){
                            var mName = mKeys[i];
                            var pkMap = mMap.get(mName);
                            if(pkMap){
                                var pkArr = Array.from(pkMap.keys());
                                var pkLen = pkArr.length;
                                for(var j=0; j<pkLen; j++){
                                    var mPk = pkArr[j];
                                    var attrMap = pkMap.get(mPk);
                                    var attrArr = Array.from(attrMap.keys());
                                    var attrLen = attrArr.length;
                                    for(k=0; k<attrLen; k++){
                                        var mAttr = attrArr[k];
                                        var mObj = Object.assign({}, wobj);
                                        var mRec = store.peekRecord(mName, mPk);
                                        if(mRec){
                                            model = mRec.$.model;
                                            field = model.fieldList[mAttr];
                                            if(field && (field.properties || field.items || field.watch == true || Lyte.Transform[field.type] )){
                                                mObj.data = Lyte.deepCopyObject(mRec[mAttr]);
                                                mObj.rec = mRec;
                                                mObj.isRec = true;
                                                mObj.attr = mAttr;
                                                mObj.dtype = model.fieldList[mAttr];
                                                mObj._cmpErr=mRec.$.error;
                                                mObj.key=mAttr;
                                            }
                                            // mObj.reInit = true;
                                            watch.push(mObj);
                                        }
                                    }
                                }
                            }
                        }
                    } 
                    else{
                        wobj.reInit = Lyte.isRecord(recObj.data) || (Array.isArray(recObj.data) && recObj.data.model && recObj.data.add);
                        watch.push(wobj);
                    }
                });
                watch.forEach(function(val){
                    var id = val.id,
                    path=val.path == "" ? [] : val.path.split("."),
                    dtype=val.dtype || undefined;
                    if(val.isRec){
                        // path.shift();
                        // path = path.length == 1 && path[0] == property ? []:path;
                        check.Prop = dtype;
                        Lyte.checkNestedProp(id, path, dtype, val, array, val.index, value, check);
                    }
                    if(val.PropsInfo){
                        val.PropsInfo.forEach(function(props){
                            props.path = val.path ;
                            dtype = props.dtype;
                            props.index = val.index;
                            check.Prop = dtype;
                            Lyte.checkNestedProp(id, path, dtype, props, array, val.index, value, check);
                        })
                    }
                })
                if(check.value && check.value.code){
                    _Lyte.error("ERR35",check.Prop.type);
                    return;
                }
            }  
            switch(functionName) {
            case "replaceAt" : 
                {
                let index = parseInt(arguments[2]);
                if(index > array.length) {
                    _Lyte.warn("index provided for replaceAt is greater than array length");
                    return [];
                }
                //let args = Array.prototype.slice.call(arguments, 3);
                let args = arguments[3];
                if(!(Array.isArray(args))) {
                    args = [args];
                }
                let deletedItems = array.splice.apply(array, [index, 1].concat(args));
                let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "replace"};
                //All references updated by now
                if(options.secondIndex == 1){
                    callLengthObserver = false;
                }
                //remove binding from previous object
                if(array._bindings) {
                    let objbind = array._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item._forHelpers) {
                            let helperbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<helperbind.length;j++){
                                let helper = helperbind[j];
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                /*if(helper.hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                let finalIndex = index + deletedItems.length;
                                let itemValue = helper.getAttribute("item");
                                for(let i=index, j=0;i<finalIndex;i++,j++) {
                                    _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                            }
                        }
                        for(let key in item) {
                            let parsedKey = parseInt(key);
                            let cond = (options.secondIndex == 1) ? (parsedKey == options.firstIndex) : (parsedKey >= options.firstIndex);
                            if(!isNaN(parsedKey) && cond) {
                                let diff = parsedKey - options.firstIndex;
                                let oldObject;
                                if(diff < 1) {
                                    oldObject = deletedItems[diff];
                                } else {
                                    oldObject = array[options.firstIndex - 1  + options.secondIndex + diff];
                                }
                                this.removeSelectedBindingDeep(item[key], oldObject);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                                }
                                this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                                if(options.secondIndex == 1){
                                    break; 
                                }
                            }
                        }
                    }
                }
                obsObj = {type:"array",insertedItems:args, removedItems:deletedItems, index:index};
                _LC.bindWatchObj(watch, array, args, deletedItems, index);
                _LC.callArrayObservers(array,obsObj,callLengthObserver,initialArrLength);
                return deletedItems[0];
                }
                break;
            case "splice" : {
                let index = parseInt(arguments[2]);
                if(index > array.length) {
                    _Lyte.warn("index provided is greater than array length");
                    return [];
                }
                let toBeDeleted = arguments.length > 3 ? arguments[3] : array.length - index;
                let args = arguments.length > 4 ? arguments[4] : [];
                if(!(Array.isArray(args))) {
                    args = [args];
                }
                let deletedItems = array.splice.apply(array, [index, toBeDeleted].concat(args));
                let options = {"firstIndex" : index, "secondIndex" : args.length, "thirdIndex" : toBeDeleted, "type" : "splice"};
                //All references updated by now
                if(options.secondIndex == options.thirdIndex){
                    callLengthObserver = false
                }
                //remove binding from previous object
                if(array._bindings) {
                    let objbind = array._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item._forHelpers) {
                            let helperbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<helperbind.length;j++){
                                let helper = helperbind[j];
                                /*if(helper.hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let finalIndex = index + deletedItems.length;
                                let itemValue = helper.getAttribute("item");
                                for(let i=index, j=0;i<finalIndex;i++,j++) {
                                    _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                            }
                        }
                        for(let key in item) {
                            let parsedKey = parseInt(key);
                            var cond = options.secondIndex == options.thirdIndex ? key >= options.firstIndex && key < (options.firstIndex+options.secondIndex) : parsedKey >= options.firstIndex;
                            if(!isNaN(parsedKey) && cond) {
                                let diff = parsedKey - options.firstIndex;
                                let oldObject;
                                if(diff < options.thirdIndex) {
                                    oldObject = deletedItems[diff];
                                } else {
                                    oldObject = array[options.firstIndex - options.thirdIndex  + options.secondIndex + diff];
                                }
                                this.removeSelectedBindingDeep(item[key], oldObject);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                                }
                                this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                            }
                        }
                    }
                }
                obsObj = {type:'array',index:index,insertedItems:args, removedItems:deletedItems};
                _LC.bindWatchObj(watch, array, args, deletedItems, index);
                _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);
                return deletedItems;
            }
            break;
            case "push" : 
                {
                let toPush = arguments[2];
                if(!(Array.isArray(toPush))) {
                    toPush = [toPush];
                }
                _LC.aF(array, 'insertAt', array.length, toPush);
                }
                break;
            case "pop" : 
                   return _LC.aF(array, 'remove', array.length -1)[0];
                break;
            case "shift" : 
            case "shiftObject" :
                  return _LC.aF(array, 'remove', 0)[0];
                  break;
            case "removeAt" : 
            case "remove" : 
                {
                let index = parseInt(arguments[2]);
                if(index > array.length) {
                    _Lyte.warn("index provided for removeAt is greater than array length");
                    return [];
                }
                let length = arguments[3] ? parseInt(arguments[3]) : 1;
                let options = {"firstIndex" : index, "secondIndex" : length, "type" : "remove"};
                let deletedItems = array.splice(index,length);
                if(array._bindings) {
                    let objbind = array._bindings.toArrayLyte();
                    for(let i=0;i<objbind.length;i++){
                        let item = objbind[i];
                        if(item._forHelpers) {
                            let helperbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<helperbind.length;j++){
                                let helper = helperbind[j];
                                /*if(helper.hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let finalIndex = index + deletedItems.length;
                                let itemValue = helper.getAttribute("item");
                                for(let i=index, j=0;i<finalIndex;i++,j++) {
                                    _LC.removeSelectedBindingDeep({[itemValue] : helper._items[i].itemProperty}, {[itemValue] : deletedItems[j]});
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                            }
                           }
                            for(let key in item) {
                            let parsedKey = parseInt(key);
                            if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                                let diff = parsedKey - options.firstIndex;
                                let oldObject;
                                if(diff < options.secondIndex) {
                                    oldObject = deletedItems[diff];
                                } else {
                                    oldObject = array[options.firstIndex - options.secondIndex + diff];
                                }
                                this.removeSelectedBindingDeep(item[key], oldObject);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});
                                }
                                this.affectChanges(item[key],undefined,oldObject,undefined,array[parsedKey]);
                            }
                        }
                    }
                }
                obsObj = {type:"array",removedItems:deletedItems,index:index};
                _LC.bindWatchObj(watch, array, undefined, deletedItems, index);
                _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength); 
                return deletedItems;
                }
                break;
            case "removeObject" : 
                    commArgs = [commArgs];
            case "removeObjects" :
                if(!(Array.isArray(commArgs))) {
                    commArgs = [commArgs];
                }
                if(commArgs == array){
                    commArgs = Array.from(commArgs);// both array are same instance so cloning
                }
                for(var i=0;i<commArgs.length;i++) {
                    let inde = array.indexOf(commArgs[i]);
                    if(inde !== -1) {
                       _LC.aF(array, 'removeAt', inde);                         
                    }
                }
                //_Lyte.arrayUtils(array, 'removeObject', actObj);
                //_Lyte.arrayUtils(array, 'removeObjects', []);
            break;
            case "unshift" : 
            case "unshiftObject" : 
            case "unshiftObjects" : 
                //_LC.aF.apply(_LC, [array, 'insertAt', 0].concat(Array.prototype.slice.call(arguments, 2)));
                {
                let toPush = arguments[2];
                if(!(Array.isArray(toPush))) {
                    toPush = [toPush];
                }
                _LC.aF(array, 'insertAt', 0, toPush);
                }
                break;
            case "insertAt" : 
                {
                let index = parseInt(arguments[2]);
                //let args = Array.prototype.slice.call(arguments, 3);
                let args = arguments[3];
                let len = args.length;
                if(!(Array.isArray(args))) {
                    args = [args];
                }
                for(let i=index;i>array.length;i--) {
                    args.unshift(undefined);
                    index--;
                }
                let options = {"firstIndex" : index, "secondIndex" : args.length, "type" : "insert"};
                array.splice.apply(array, [index, 0].concat(args));
                if(array._bindings) {
                    let arrbind = array._bindings.toArrayLyte();
                    for(let i=0;i<arrbind.length;i++){
                        let item = arrbind[i];
                        if(item._forHelpers) {
                            let forbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<forbind.length;j++){
                            	/*if(forbind[j].hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                let helper = forbind[j];
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                helper._callee.updateForHelper(helper, options);
                                _LC.rmCx(helper, contextSwitchArray);
                            }
                        }
                        for(let key in item) {
                            let parsedKey = parseInt(key);
                            if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
                                this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
                                if(item[key]._forHelpers) {
                                    let bindfor = item[key]._forHelpers.toArrayLyte();
                                    for(var j=0;j<bindfor.length;j++){
                                        let item1 = bindfor[j];
                                        if(item1._propBindingObject) {
                                            this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
//                                          value._bindings.add(item._propBindingObject);
//                                          this.establishBindings(item._propBindingObject, value);
                                        }
                                    }
                                }
                                if(array[parsedKey] && typeof array[parsedKey] === "object") {
                                	makeSet(array[parsedKey], "_bindings");
                                this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
                                }
                                this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
                            }
                        }
                    }
                }
                let position = parseInt(arguments[2]);
                obsObj = {type:"array",insertedItems:(!(Array.isArray(arguments[3]))) ? [arguments[3]]: arguments[0].slice(position,position+len),index:position};
                _LC.bindWatchObj(watch, array, args, undefined, position);
                _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);                
                }
                break;
            case "concat" : 
                //_LC.aF.apply(_LC, [array, 'insertAt',array.length].concat(arguments[2]));
                _LC.aF(array, 'insertAt', array.length, arguments[2]);
                break;
            case "sort" :  {
                let optionsArray = [];
                commands.forEach(function(command) {
                    switch(command.type) {
                        case "Remove" : {
                            let removedItems = array.splice(command.toIndex, 1);
                            optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                        }
                        break;
                        case "Move" : {
                            let removedItems = array.splice(command.fromIndex, 1);
                            array.splice(command.toIndex, 0, command.element);
                            optionsArray.push({"firstIndex" : command.fromIndex, "secondIndex" : 1, "type" : "remove", "removedItem" : removedItems[0]});
                            // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                            optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                        }
                        break;
                        case "Add" : {
                            array.splice(command.toIndex, 0, command.element);
                            // optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
                            optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "type" : "insert"});
                        }
                        break;
                    }
                });
                if(array._bindings) {
                    let arrbind = array._bindings.toArrayLyte();
                    for(let i=0;i<arrbind.length;i++){
                        let item = arrbind[i];
                        if(item._forHelpers) {
                            let forbind = item._forHelpers.toArrayLyte();
                            for(let j=0;j<forbind.length;j++){
                            	/*if(forbind[j].hasAttribute("unbound")) {
                            		continue;
                            	}*/
                                let helper = forbind[j];
                                if(helper.getAttribute("is") != "for"){
                                    continue;
                                }
                                let contextSwitchArray = [];
                                _LC.adCx(helper, contextSwitchArray);
                                for(let j=0;j<optionsArray.length;j++) {
                                    let optionItem = optionsArray[j];
                                    // Removal of bindings
                                    let itemValue = helper.getAttribute("item");
                                    if(optionItem.type == "remove") {
                                        this.removeSelectedBindingDeep({[itemValue] : helper._items[optionItem.firstIndex].itemProperty}, {[itemValue] : optionItem.removedItem});
                                    }
                                    helper._callee.updateForHelper(helper, optionItem);
                                }
                                _LC.rmCx(helper, contextSwitchArray);
                            }
                        }
//                         for(let key in item) {
//                             let parsedKey = parseInt(key);
//                             if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
//                                 this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
//                                 if(item[key]._forHelpers) {
//                                     let bindfor = item[key]._forHelpers.toArrayLyte();
//                                     for(var j=0;j<bindfor.length;j++){
//                                         let item1 = bindfor[j];
//                                         if(item1._propBindingObject) {
//                                             this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
// //                                          value._bindings.add(item._propBindingObject);
// //                                          this.establishBindings(item._propBindingObject, value);
//                                         }
//                                     }
//                                 }
//                                 if(array[parsedKey] && typeof array[parsedKey] === "object") {
//                                 	makeSet(array[parsedKey], "_bindings");
//                                 this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
//                                 }
//                                 this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
//                             }
//                         }
                    }
                }
                if(Array.isArray(arguments[3]) && arguments[3].length) {
                    obsObj = {type:"array",insertedItems:arguments[3]};
                    var indices = [];
                    arguments[3].forEach(function(item) {
                        indices.push(array.indexOf(item));
                    });
                    obsObj.indices = indices;
                    _LC.callArrayObservers(array,obsObj,callLengthObserver ,initialArrLength);
                }
            }
                break;
            default: 
                _Lyte.error("LC006" , functionName);
                return;
            }
        },
        "callDeepObservers" : function (data, args, property ,callLengthObserver){
            var self = this;
            var keys = Array.from(data._scp.keys());
            keys.forEach(function(id){
                var _scp = data._scp.get(id), 
                scp = _scp.paths,
                pathArr = Object.keys(scp), 
                aPath;
                if(pathArr.length == 1){
                    aPath = pathArr[0];
                }
                else if(pathArr.length > 1){
                    aPath = pathArr;
                }
                var recObj = Lyte.nestScp[id], 
                attr, 
                rec, 
                isRec = false;
                if(recObj.model){
                    var mMap = recObj.model;
                    var mKeys = Array.from(recObj.model.keys());
                    for(var i=0; i<mKeys.length; i++){
                        var mName = mKeys[i];
                        var pkMap = mMap.get(mName);
                        if(pkMap){
                            var pkArr = Array.from(pkMap.keys());
                            var pkLen = pkArr.length;
                            for(var j=0; j<pkLen; j++){
                                var mPk = pkArr[j];
                                var attrMap = pkMap.get(mPk);
                                var attrArr = Array.from(attrMap.keys());
                                var attrLen = attrArr.length;
                                for(k=0; k<attrLen; k++){
                                    var mAttr = attrArr[k];
                                    var mRec = store.peekRecord(mName, mPk);
                                    self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver)                                    
                                }
                            }
                        }
                    }
                } 
                else{
                    rec = recObj.data;
                    self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver)
                }
            });
        },
        "deepObsBind":function(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver){
            var type = args.type
            var watchPath , propPath;
            if(rec._bindings){
                var newArgs = Object.assign({},args);
                var objbind = rec._bindings.toArrayLyte();
                for (var _i65 = 0; _i65 < objbind.length; _i65++) {
                    propPath = aPath;
                    var binding = objbind[_i65], obj = undefined;
                    watchPath = objbind[_i65]._path
                    if(isRec){
                        if(binding.hasOwnProperty(attr) && binding[attr].hasOwnProperty("*")){
                            obj = binding[attr]["*"];
                            watchPath = binding[attr]._path;
                        } 
                    }
                    else if(binding.hasOwnProperty("*")){
                        obj = binding["*"];
                    }
                    if(obj){
                        var obsbind = obj._observers ? obj._observers.toArrayLyte() : [], path;
                        if(property){
                            if(pathArr.length > 1){
                                var len = pathArr.length, nPathArr = [];
                                for(var i=0;i<len;i++){
                                    nPathArr.push(pathArr[i] ? pathArr[i]+"."+property : property);
                                }
                                propPath = nPathArr;
                            }
                            else if(pathArr.length == 1){
                                propPath = aPath ? aPath.concat("." + property) : property;
                            }
                        }
                        for (var j = 0; j < obsbind.length; j++) {
                            var observer = obsbind[j];
                            newArgs.path = propPath;
                            newArgs.type = "deepChange";
                            newArgs.data = rec;
                            var argPath = obj._path.split('.');
                            argPath.pop();
                            newArgs.item = argPath.join('.'); 
                            var exactPath = newArgs.index!=undefined?(propPath!=""?propPath+".":propPath)+newArgs.index:propPath
                            if(observer.callee && observer.callee.component){
                                //  observer.observer.value.call(observer.callee.component, newArgs);
                                var calldeep = true;
                                var _data = observer.callee.component.__data[newArgs.item];
                                var _watch = _data ? _data.watch : undefined;
                                if(_data && typeof _watch != "boolean"){
                                    var watchArr = obsbind[j].observer.Jpath[watchPath];
                                    calldeep = Lyte.checkWatchPath(exactPath , watchArr);
                                }
                                if(calldeep){
                                    observer.observer.value.call(observer.callee.component, newArgs);
                                }
                            }
                            else{
                                var scope = data._setterScope ? data._setterScope : window;
                                if(Array.isArray(scope)){
                                    var sLen = scope.length;
                                    for(var k=0;k<sLen;k++){
                                        var itm = scope[k];
                                        var calldeep = true;
                                        if(newArgs.data && newArgs.hasOwnProperty("item")){
                                            var watchArr = newArgs.data.$.model._fldGrps.watch[newArgs.item].watch
                                            if(Array.isArray(watchArr)){
                                                watchArr = obsbind[j].observer.Jpath[watchPath];
                                                calldeep = Lyte.checkWatchPath(exactPath , watchArr);
                                            }
                                        }
                                        if(calldeep){
                                            observer.observer.value.call(itm, newArgs);
                                        }
                                    }
                                }
                                else{
                                    var calldeep = true;
                                    if(newArgs.data && newArgs.hasOwnProperty("item")){
                                        var watchArr = newArgs.data.$.model._fldGrps.watch[newArgs.item].watch
                                        if(Array.isArray(watchArr)){
                                            watchArr = obsbind[j].observer.Jpath[watchPath];
                                            calldeep = Lyte.checkWatchPath(exactPath , watchArr);
                                        }
                                    }
                                    if(calldeep){
                                        observer.observer.value.call(scope, newArgs);
                                    }
                                }
                            }
                        }
                    }
                    if (!callLengthObserver && type == "array" && binding.length) {
                        this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);
                    }
                }
            }
        },
        "callArrayObservers" : function(array, args ,callLengthObserver ,initialArrLength) {
            if(array._scp && array._scp.size){
                this.callDeepObservers(array, Object.assign({},args) ,undefined, true);          
            }
            if(array._bindings) {
                let objbind = array._bindings.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let binding = objbind[i];
                    let path = objbind[i]._path;
                    if(binding._observers) {
                        let obsbind = binding._observers.toArrayLyte();
                        for(let j=0;j<obsbind.length;j++){
                            let observer = obsbind[j];
                            if(observer.isArrayObserver) {
                                if(args){
                                    args.item = path;
                                }
                                if(observer.callee && observer.callee.component){
                                    observer.observer.value.call( observer.callee.component, args);
                                }
                                else{
                                    var scope = array._setterScope ? array._setterScope : window;
                                    if(Array.isArray(scope)){
                                        var sLen = scope.length;
                                        for(var k=0;k<sLen;k++){
                                            var itm = scope[k];
                                            observer.observer.value.call( itm, args);                                                        
                                        }
                                    }
                                    else{
                                        observer.observer.value.call(scope, args);
                                    }
                                }
                            }
                        }
                    }
                    if(binding.length) {
                        this.affectChanges(binding.length,undefined,initialArrLength,undefined,array.length,callLengthObserver);
                    }
                }
            }
        },
        "bindWatchObj" : function(watch, data, insItems, remItems, pos){
            if(watch && watch.length){
                watch.forEach(function(wObj){
                    if(wObj.isRec){
                        store.$.deepValueChange(wObj.rec, wObj.attr, data, wObj);
                    }
                    if(remItems){
                        remItems.forEach(function(itm){
                            Lyte.removeNestScp(itm, wObj.id, undefined, undefined, undefined, undefined, wObj.reInit ? wObj.data : undefined);
                        });
                    }
                    if(insItems){
                        insItems.forEach(function(itm,idx){
                            if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                                var pth = wObj.path.split(',');
                                pth.push(pos+idx);
                                Lyte.bindObj(itm, undefined, wObj.id,  pth && pth.length ? pth : [],undefined,undefined,undefined,true);
                            }
                        });
                    }
                    if(pos !== undefined){
                        var nestObj = Lyte.nestScp[wObj.id];
                        if(nestObj && nestObj.cyclic){
                            Lyte.removeNestScp(nestObj._data, wObj.id);
                            Lyte.bindObj(nestObj._data, undefined, wObj.id, [],undefined,undefined,undefined,true);
                        }
                        else{
                            var insLen = insItems ? insItems.length : 0, newInd = pos+insLen;
                            var arr = data.slice(newInd);
                            arr.forEach(function(itm){
                                Lyte.removeNestScp(itm, wObj.id);
                            });
                            arr.forEach(function(itm,idx){
                                if(itm && ( Array.isArray(itm) || typeof itm == "object" )){
                                    var pth = wObj.path.split(',');
                                    pth.push(newInd+idx);
                                    Lyte.bindObj(itm, undefined, wObj.id,  pth && pth.length ? pth : [],undefined,undefined,undefined,true);
                                }
                            });
                        }
                    }
                });
            }
        },
        "establishUpdateBindings" : function(bindings, property, actualData) {
            let objbind = bindings.toArrayLyte();
            for(let i=0;i<objbind.length;i++){
                let item = objbind[i];
                if(item[property]) {
                    makeSet(actualData, "_bindings");
                    addBindings(actualData._bindings,item[property]);
                    this.establishBindings(item[property], actualData);
                }

            }
        },
        "establishSelectedBinding" : function(property, actualData,node) {
            if(!property) {
                return;
            }
            let propName = property._path;
            let props = propName.split('.');
            let currentProp = node.getProperty(props[0]);
            let currentValue = actualData[props[0]];
            for(let i=0;i<props.length;i++) {
                if(!currentValue || typeof currentValue !== "object") {
                    break;
                } 
                makeSet(currentValue, "_bindings");
                    addBindings(currentValue._bindings,currentProp);
                    currentProp = currentProp[props[i+1]];
                    currentValue = currentValue[props[i+1]];
            }
        },
        "establishBindings": function(properties, actualData) {
            if(properties._helperNodes) {
                let path = properties._path;
                let arr = properties._helperNodes.toArrayLyte();
                for(let s=0;s<arr.length;s++) {
                    let nodes = arr[s]._dynamicProperty ? arr[s]._dynamicProperty[path]: undefined;
                    if(nodes) {
                        for(let j=0;j<nodes.length;j++) {
                            let node = nodes[j];
                            let helper = node.ownerElement;
                            if(helper && helper.tagName === "TEMPLATE" && helper.getAttribute("is") === "for") {
                                if(helper._items) {
                                    let item = helper.getAttribute("item");
                                    for(let i=0;i<helper._items.length;i++) {
                                        let data = actualData[i];
                                        let item = helper.getAttribute("item");
                                        if(data) {
                                            if(typeof helper._items[i] === "object") {
                                                this.establishBindings(helper._items[i].itemProperty, {[item] : data});
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            for(let i in properties) {
                let actData = actualData[i];
                if(!actData || typeof actData === "string" || typeof actData === "number" || typeof actData === "boolean") {
                    if(!actualData._bindings) {
                    	makeSet(actualData, "_bindings");
                    }
                    addBindings(actualData._bindings,properties);
                } else {
                    if(!actData._bindings) {
                    	makeSet(actData, "_bindings");
                    }
                    addBindings(actData._bindings,properties[i]);
                    if(typeof properties[i] === "object") {
                        this.establishBindings(properties[i], actData);
                    }
                }
            }
        },
        "removeSelectedBindingDeep" : function(binding, actualData, fromDisConnect) {
            var del = "delete";
            if(!actualData && !fromDisConnect) {
                return;
            }
            if(actualData && actualData._bindings) {
            	deleteBindingCheckSize(actualData, "_bindings", binding);
            }
            for(let i in binding) {
                let actData;
                if(actualData){
                    actData = actualData[i];
                }   
                if(actData && actData._bindings) {
                    deleteBindingCheckSize(actData, "_bindings", binding[i]);
                }
                if(typeof binding[i] === "object") {
                    this.removeSelectedBindingDeep(binding[i], actData ,fromDisConnect);
                }
            }
            if(fromDisConnect){
                let dynNodes = binding._dynamicNodes;
                let helperNodes = binding._helperNodes;
                if(dynNodes && dynNodes.length){
                    binding._dynamicNodes.splice(0,dynNodes.length);   
                }
                if(helperNodes && helperNodes.size){
                    helperNodes.clear();
                }
            }
            if(binding && binding._forHelpers) {
                let objbind = binding._forHelpers.toArrayLyte();
                for(let i=0;i<objbind.length;i++){
                    let fH = objbind[i];
                    if(fH.getAttribute("is") === "for") {
                        let item = fH.getAttribute("item");
                        let items = fH._attributes.items;
                        let itemCases = fH._items;
                        for(let i=0;i<itemCases.length;i++) {
                            this.removeSelectedBindingDeep(itemCases[i].itemProperty, items[i], fromDisConnect);
                        }
                    } else {
                        if(fH._propBindingObject) {
                            if(actualData && actualData._bindings) {
                            	deleteBindingCheckSize(actualData, "_bindings", fH._propBindingObject);
                                this.removeSelectedBindingDeep(fH._propBindingObject, actualData, fromDisConnect);
                            }
                        }
                    }
                }
            }
        },
        "removeAllBindings" : function(properties, data) {
            var del = "delete";
            for(let key in properties) {
                if(data[key] && data[key]._bindings) {
//                    data[key]._bindings[del](properties[key]);
//                    if(!data[key]._bindings.size) {
//                        delete data[key]._bindings;
//                    }
                	deleteBindingCheckSize(data[key], "_bindings", properties[key]);
                }
                if(data[key] && typeof data[key] !== "string") {
                    _LC.removeAllBindings(properties[key], data[key]);
                }
            }
        },
        "affectChanges" : function(item, contextAlreadySwitched,oldValue,setterScope,newValue,callLengthObserver) {
            if(item._dynamicNodes) {
                for(let i=0;i<item._dynamicNodes.length;i++) {
                    item._dynamicNodes[i]._callee.updateNode(item._dynamicNodes[i], item._path);
                }
            }
            let propPath = item._path;
            if(item._helperNodes) {
                let nodes = [],itemHelperNodes = item._helperNodes.toArrayLyte();
                for(let s=0;s<itemHelperNodes.length;s++){
                    if(!item._helperNodes.has(itemHelperNodes[s])) {
                        continue;
                    }
                    if(itemHelperNodes[s].getAttribute("is") === "for" && itemHelperNodes[s]._items) {
                        let innerContextSwitchArray = [];
                        _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                        let  indexValue = itemHelperNodes[s].getAttribute("index");
                        let itemValue = itemHelperNodes[s].getAttribute("item");
                        let callee = itemHelperNodes[s]._callee;
                        let initialItemValue = callee.component.data[itemValue];
                        let initialIndexValue = callee.component.data[indexValue];
                        let initialItemProp = callee._properties[itemValue];
                        let initialIndexProp = callee._properties[indexValue];
                        let items = itemHelperNodes[s]._attributes.items;
                        for(let i=0;i<itemHelperNodes[s]._items.length;i++) {
                            callee.component.data[itemValue] = items[i];
                            callee.component.data[indexValue] = i;
                            callee._properties[itemValue] = itemHelperNodes[s]._items[i].itemProperty;
                            if(itemHelperNodes[s]._items[i]._dynamicProperty[propPath]) {
                                nodes = itemHelperNodes[s]._items[i]._dynamicProperty[propPath];
                                for(let i=0;i<nodes.length;i++) {
                                    nodes[i]._callee.updateNode(nodes[i], propPath);
                                }
                            }
                        }
                        callee.component.data[itemValue] = initialItemValue;
                        callee.component.data[indexValue] = initialIndexValue;
                        callee._properties[itemValue] = initialItemProp;
                        callee._properties[indexValue] = initialIndexProp;
                        _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);                                    
                    } else if(itemHelperNodes[s].getAttribute("is") === "forIn" && itemHelperNodes[s]._items) {
                        let innerContextSwitchArray = [];
                        _LC.adCx(itemHelperNodes[s], innerContextSwitchArray);
                        let  indexValue = itemHelperNodes[s].getAttribute("key");
                        let itemValue = itemHelperNodes[s].getAttribute("value");
                        let callee = itemHelperNodes[s]._callee;
                        let initialItemValue = callee.component.data[itemValue];
                        let initialIndexValue = callee.component.data[indexValue];
                        let initialItemProp = callee._properties[itemValue];
                        let initialIndexProp = callee._properties[indexValue];
                        let object = itemHelperNodes[s]._attributes.object;
                        for(let key in itemHelperNodes[s]._items) {
                            callee.component.data[itemValue] = object[key];
                            callee.component.data[indexValue] = key;
                            callee._properties[itemValue] = itemHelperNodes[s]._items[key].itemProperty;
                            if(itemHelperNodes[s]._items[key]._dynamicProperty[propPath]) {
                                nodes = itemHelperNodes[s]._items[key]._dynamicProperty[propPath];
                                for(let i=0;i<nodes.length;i++) {
                                    nodes[i]._callee.updateNode(nodes[i], propPath);
                                }
                            }
                        }
                        callee.component.data[itemValue] = initialItemValue;
                        callee.component.data[indexValue] = initialIndexValue;
                        callee._properties[itemValue] = initialItemProp;
                        callee._properties[indexValue] = initialIndexProp;
                        _LC.rmCx(itemHelperNodes[s], innerContextSwitchArray);    
                    } else {
                        nodes = itemHelperNodes[s]._dynamicProperty[item._path] || [];
                        let contextSwitchArray = [];
                        if(nodes.length) {
                            _LC.adCx(itemHelperNodes[s], contextSwitchArray);
                            for(let i=0;i<nodes.length;i++) {
                                nodes[i]._callee.updateNode(nodes[i], item._path);
                            }
                            _LC.rmCx(itemHelperNodes[s], contextSwitchArray);    
                        }
                        
                    }
                }
            }
            if(item._observers) {
                let objbind = item._observers.toArrayLyte();
                let cond = callLengthObserver == false ? false : oldValue != undefined || newValue != undefined;
                if(cond){
                    for(let i=0;i<objbind.length;i++){
                        let observer = objbind[i];
                        let obsObj = {type:"change",oldValue:oldValue,newValue:newValue, item: item._path};
                        if(observer.callee && observer.callee.component){
                            observer.observer.value.call(  observer.callee.component, obsObj);                      
                        }
                        else{
                            var scope = setterScope ? setterScope : window;
                            if(Array.isArray(scope)){
                                var sLen = scope.length;
                                for(var k=0;k<sLen;k++){
                                    var itm = scope[k];
                                    observer.observer.value.call( itm, obsObj);
                                }
                            }
                            else{
                                observer.observer.value.call( scope, obsObj);                      
                            }
                        }
                    }
                }
            }
            if(Array.isArray(item)){
                for(var i=0;i<item.length;i++){
                    for(let key in item[i]) {
                        this.affectChanges(item[i][key], true,oldValue?(oldValue[i]?oldValue[i][key]:oldValue[i]):oldValue,setterScope,newValue?(newValue[i]?newValue[i][key]:newValue[i]):newValue);
                    }
                }
            }
            else{
                for(let key in item) {
                    var oldV = oldValue ? oldValue[key] : oldValue, newV = newValue ? newValue[key] : newValue;
                    if(key == "*" && item[key].hasOwnProperty("_observers")){
                        oldV = oldValue;
                        newV = newValue
                    }
                    this.affectChanges(item[key], true, oldV, setterScope, newV);
                }
            }
        },
        "skipArgProcessing" : function(cloneActObj,ev,target) {
            if(cloneActObj.skipArgProcessing) {
                let args = cloneActObj.args = cloneActObj.actArgs;
                args.shift();
                var eventIndex = args.indexOf("__lyteEvent__");
                var nodeIndex = args.indexOf("__lyteNode__");
                if(eventIndex !== -1) {
                    args[eventIndex] = ev;
                } 
                if(nodeIndex !== -1) {
                    args[nodeIndex] = target;
                }
            } else {
                cloneActObj.args.shift();
            }
        },
        // getDV added
        "getDV" : function(value){    
            var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
            for(var i=0;i<value.length;i++){
                if(value[i] === "."){
                    if(data.length){
                        ref.push(data);
                    }
                    data = "";
                    continue;
                }
                else if(value[i] === "["){
                    arrayStack.push(i)
                    if(data.length){
                        ref.push(data);
                    }
                    while(value[i+1] === "\s"){
                        i++;
                    }
                    if(value[i+1] === "\"" || value[i+1] === "'"){
                        strStack.push(value[i+1]);
                        strLast = value[i+1];
                        i++;
                    }
                    else if(arr.length){
                        ref.push([]);
                        refStack.push(ref);
                        ref = ref[ref.length-1];
                    }else{
                        arr.push([]);
                        refStack.push(ref);
                        ref = arr[arr.length-1];
                    }
                    data = "";
                    continue;
                }
                else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
                    while(value[i] === "\s" && value[i] != "]"){
                        i++;
                    }
                    strStack.pop();
                    str = true;
                }
                if(value[i] === "]"){
                    arrayStack.pop();
                    if(data.length){
                        if(str === true){
                            ref.push(data);    
                        }
                        else if(!isNaN(parseInt(data))){
                            if(refStack.length){
                                ref = refStack.pop();
                                if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                                    ref.pop();
                                }
                                ref.push(data);
                                if(!arrayStack.length && arr.length){
                                    arr.shift();
                                }
                            }
                        }
                        else{
                            ref.push(data);
                        }
                    }
                    if(!arrayStack.length && arr.length){
                        result.push(arr.shift());
                        ref = result;
                    }
                    else if(refStack.length && !arr.length){ 
                        ref = refStack.pop();
                    }
                    data = "";
                    str = "";
                    continue;
                }
                data = data.concat(value[i]);
            }
            if(data.length){
                result.push(data);
            }
            if(strStack.length || arrayStack.length){
                console.log("check the syntax",strStack,arrayStack);
            }
            return result;
        },
        "ccDelay" : [],
        "callCC" : function() {
            this.ccDelay.forEach(function(item) {
                if(item.component) {
                    item.actualConnectedCallback();
                }
            });
            this.ccDelay = [];
        },
        "getDD":function(context,dataArr){
            var self = context;
            dataArr.forEach(function(item,index){
                if(Array.isArray(item)){
                    if(context == undefined){
                        return undefined;
                    }
                    var inner = _LC.getDD(self,item);
                    if(inner == undefined){
                        return undefined;
                    }
                    context = context[inner];
                }else{
                    if(context == undefined){
                        return undefined;
                    }
                    context = context[item];
                }
            });
            return context;
        },

        "processStatic" : function(temp) {
            let arr = temp.innerHTML.split("__**");
            let newArr = [];
            for(var i=0;i<arr.length;i++) {
                if(arr[i].startsWith("--Lyte")) {
                    newArr.push(parseInt(arr[i].substring(6)));
                } else {
                    newArr.push(undefined);
                }
            }
            arr.cc = newArr;
            return arr;
        },
        "findLastNodeL" : function(lastNode1,count,node){
            var totalNodeIndex = 0;
            if(count != undefined){
                totalNodeIndex = count; 
            }
            var helperNode;
            switch(node.getAttribute("is")) {
                case "for" : 
                    if(node._helpers[totalNodeIndex]){
                        helperNode = node._helpers[totalNodeIndex][0];   
                    }
                    if(!lastNode1) {
                        if(node._forContent[0]){
                            lastNode1 = node._forContent[0][0];
                        }
                    }
                    break;
                case "forIn" : 
                    if(node._helpers[node._keysArray[0]]){
                        helperNode = node._helpers[node._keysArray[0]][0];
                    }
                    if(!lastNode1) {
                        if(node._forContent[node._keysArray[0]]){
                            lastNode1 = node._forContent[node._keysArray[0]][0];
                        }
                    }                   
                    break;
                case "if" : 
                case "switch" : 
                    helperNode = node._helpers[totalNodeIndex];
                    if(!lastNode1) {
                        lastNode1 = node._caseContent[0];
                    }
                break;
                case "component" : 
                    lastNode1 = lastNode1._renderedComponent[lastNode1._currentComponent] || lastNode1;
                    return lastNode1;
            }
            if(!lastNode1){
                lastNode1 = node._placeHolder;
            }
            if(helperNode && (lastNode1 == helperNode._placeHolder)) {
                lastNode1 =  this.findLastNodeL(undefined, undefined, helperNode);
            }
            return lastNode1;
        },
        "processAction" : function(node) {
            Array.from(node.querySelectorAll('[lyteaction]')).forEach(function(item) { 
                let locIndex = item.attributes.lyteaction.value;
                item._boundEvents = _LC.fRP[locIndex];
                delete _LC.fRP[locIndex];
                // _LC.pushFrc(locIndex);
                // item._boundEvents = JSON.parse(item.attributes.lyteaction.value);
                var _cx = item._boundEvents._cx;
                let boundEvents = item._boundEvents;
                delete boundEvents._cx;
                let componentName = boundEvents.componentName;
                delete boundEvents.componentName;
                for(var key in item._boundEvents) {
                    if(key.indexOf("-") !== -1) {
                        item._actions = item._actions || {};
                        item._actions[key] = new CustomEvent(key);
                        item._actions[key].processAction = item._boundEvents[key];
                        item._boundEvents[key].actArgs.shift();
                        let nodeIndex = item._boundEvents[key].actArgs.indexOf("__lyteNode__");
                        if(nodeIndex !== -1) {
                        	item._boundEvents[key].actArgs[nodeIndex] = item;
                        }
                        item._boundEvents[key].args = item._boundEvents[key].actArgs;
                        delete item._boundEvents[key];
                    } else {
                        let actArgs = _Lyte.deepCopyObject(item._boundEvents[key].args);
                        let actName = actArgs.splice(0,1)[0];
                        actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                        let actString = getArgString(actName, actArgs);
                        item.setAttribute(key.startsWith("on") ? key.substr(2) : key ,componentName+" => "+ actString);
                        if(!item._boundEvents[key].globalEvent) {
                            item.addEventListener(key,globalEventHandler);
                        }
                    }
                }
                item._boundEvents._cx = _cx;
                item.removeAttribute("lyteaction");
                //item._boundEvents = item.
            });
        },
        "getCtxVal" : function(context,val){
            if(context != undefined){
                return context[val];
            }else{
                return undefined;
            }
        },
        "get" : function(context, path, ac,cache) {
            if(!ac) {
                ac = [];
            }
            if(cache && cache.hasOwnProperty(path)){// cache.cacheData[path]
                nodeValue = cache[path]._data;
                if(cache[path]._dyn){
                    cache[path]._dyn.forEach(function(item){
                        ac.push(item);
                    });
                }
                return nodeValue;
            }
            else{
            try{
                let arr = path.match(/([^[\]]+|\[\])/g);
                let initialContext = context;
                ac.push(arr[0]);
                let locArr = arr[0].split('.'); 
                for(let k=0;k<locArr.length;k++) {
                    context = _LC.getCtxVal(context,locArr[k])
                }
                for(let i=1;i<arr.length;i++) {
                    let locVal = arr[i];
                    //this is context switching
                    if(locVal.startsWith(".")) {
                        //direct context switching
                        let locArr = locVal.substring(1).split('.');
                        for(let k=0;k<locArr.length;k++) {
                            context = _LC.getCtxVal(context,locArr[k])
                        }
                        // ac[ac.length -1] = ac[ac.length - 1] + locVal;
                        ac[0] = ac[0] + locVal;
                    } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                        if(!isNaN(locVal)) {
                            // ac[ac.length-1] = ac[0] + "." + locVal;
                            ac[0] = ac[0] + "." + locVal;
                            context = _LC.getCtxVal(context,locVal)
                        } else {
                            // ac[ac.length-1] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                            ac[0] = ac[0] + "." + locVal.substring(1, locVal.length -1);
                            context = _LC.getCtxVal(context,locVal.substring(1, locVal.length -1))
                        } 
                    } else {
                        let length = ac.length;
                        let val = _LC.get(initialContext, locVal, ac);
                        ac[0] = ac[0] + "." + val;
                        context = _LC.getCtxVal(context,val)
                    }
                    }
                    if(cache){
                        cache[path] = {};
                        cache[path]._data = context;  
                        cache[path]._dyn = ac;
                    }
                return context;
            } catch(e) {
                return undefined;
            }
            }
        },
        "getNew" : function(context, path) {
            try{
                let arr = path.match(/([^[\]]+|\[\])/g);
                let initialContext = context;
                let locArr = arr[0].split('.'); 
                if(arr.length < 2) {
                    if(locArr.length <2) {
                        return {"context": initialContext, "lastKey" : locArr[0]};
                    } else {
                        for(var k=0;k<locArr.length-1;k++) {
                            context = context[locArr[k]];
                        }
                        return {"context" : context, "lastKey" : locArr[k]}
                    }
                }
                for(let k=0;k<locArr.length;k++) {
                    context = context[locArr[k]];
                }
                for(var i=1;i<arr.length - 1;i++) {
                    let locVal = arr[i];
                    //this is context switching
                    if(locVal.startsWith(".")) {
                        //direct context switching
                        let locArr = locVal.substring(1).split('.');
                        for(let k=0;k<locArr.length;k++) {
                            context = context[locArr[k]];
                        }
                    } else if(locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
                        context = context[locVal.substring(1, locVal.length -1)];
                    } else {
                        let val = this.get(initialContext, locVal);
                        context = context[val];
                    }
                    }
                let lastKey = arr[i];
                if(lastKey.startsWith(".")) {
                    //direct context switching
                    let locArr = lastKey.substring(1).split('.');
                    let k=0
                    for(;k<locArr.length - 1;k++) {
                        context = context[locArr[k]];
                    }
                    lastKey = locArr[k];
                } else if(lastKey.startsWith("'") || lastKey.startsWith('"') || !isNaN(lastKey)) {
                    lastKey = lastKey.substring(1, lastKey.length -1);
                } else {
                    lastKey = this.get(initialContext, lastKey);
                }
                return {"context" : context, "lastKey" : lastKey };
            } catch(e) {
                return undefined;
            }
        },
        "componentGetData" : function(key){
            if(key) {
                return this.get(key);
            } else {
                return this.data;
            }
        },
        "componentSetData" : function(arg0, arg1 ,options) {
            if(typeof arg0 === "string") {
                this.set(arg0, arg1 ,options);
            } else if(typeof arg0 === "object") {
                for(let key in arg0) {
                    this.set(key, arg0[key],arg1);
                }
            }
        },
        "componentGetMethods" : function(key) {
            let node = this.$node;
            if(node){
                if(key && node._methods) {
                    return node._methods[key];
                } else {
                    return node._methods;
                }
            }
        }, 
        "componentHasAction" : function(key) {
            let node = this.$node;
            if(node){
                if(key && node._actions[key]) {
                    return true;
                } else {
                    return false;
                }
            }
        }, 
        "componentsetActions" : function(arg0,arg1) {
            let actions = this.$node._actions;
            if(typeof arg0 === "string") {
                actions[arg0] = arg1;
            } else if(typeof arg0 === "object") {
                for(let key in arg0) {
                    actions[key] = arg0[key];
                }
            }
        },
        "componentSetMethods" : function(arg0, arg1) {
            let node = this.$node;
            if(node){
                if(typeof arg0 === "string") {
                    node._methods[arg0] = arg1;
                } else if(typeof arg0 === "object") {
                    for(let key in arg0) {
                        node._methods[key] = arg0[key];
                    }
                }
            }
        },
        "render" : function(componentName, data, outlet, options) {
            var component
            if(componentName) {
                if(typeof componentName == "string") {
                    component = createElement(componentName);
                } else if(componentName.compName) {
                    component = createElement(componentName.compName);
                } else {
                    _Lyte.error("LC007");    
                    return;
                }
            } else {
                _Lyte.error("LC007");
                return;
            }
            
            if(data){
                component.setData(data);
            }
            if(options && options.methods){
                component.setMethods(options.methods);
            }
            if(outlet) {
                let actOutlet;
                if(typeof outlet == "string"){
                    actOutlet = document.querySelector(outlet);
                }else{
                    actOutlet = outlet;
                }
                if(actOutlet) {
                    if(options && options.dataType){
                        component.component.__data = options.dataType;
                    }
                    actOutlet.appendChild(component);
                    component._callee = component.getCallee ? component.getCallee(actOutlet) : undefined;
                } else {
                    _Lyte.error("LC008", outlet);
                }
            }
            return component;
        },
        "String" : {
            "cache_c":{},
            "cache_d":{},
            "upperCaseFirstLetter" : function(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            },
            "lowerCaseFirstLetter" : function(string) {
                return string.charAt(0).toLowerCase() + string.slice(1);
            }, 
            "toCamelCase" : function(string) {
                if(!this.cache_c[string]){
                    this.cache_c[string] = string.replace(/(-\w)/g, function(m){return m[1].toUpperCase();});
                }
                return this.cache_c[string];
            }, 
            "dasherize" : function(string) {
                if(!this.cache_d[string]){
                    this.cache_d[string] = string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
                }
                return this.cache_d[string];
            }
        },
        "appendChild" : function(outlet, component) {
            _LC.ignoreDisconnect = true;
            outlet.appendChild(component);
            _LC.ignoreDisconnect = false;
        },
        "replaceWith" : function() {
            var argumentsArr = Array.from(arguments);
            var oldNode = argumentsArr.shift();
            _LC.ignoreDisconnect = true;
            var parentNode = oldNode.parentNode;
            for(var i=0,node;node=argumentsArr[i];i++) {
                parentNode.insertBefore(node,oldNode);
            }
            oldNode.remove();
            _LC.ignoreDisconnect = false;
        },	
        "insertBefore" : function(referenceNode, newNode, parentNode) {
            _LC.ignoreDisconnect = true;
            if(!parentNode) {
                if(!referenceNode) {
                    _Lyte.error("LC010");
                    _LC.ignoreDisconnect = false;
                    return;
                } else {
                    parentNode = referenceNode.parentNode;
                }
            }
            insertBefore(parentNode , newNode, referenceNode ? referenceNode : null);
            _LC.ignoreDisconnect = false;
        },
        "insertAfter" : function() {
            var argumentsArr = Array.from(arguments);
            var referenceNode = argumentsArr.shift();
            _LC.ignoreDisconnect = true;
            referenceNode.after.apply(referenceNode, argumentsArr);
            _LC.ignoreDisconnect = false;
        },
        "executeMethod" : function() {
            let node = this.$node;
            if(node){
                let args = Array.prototype.slice.call(arguments, 1);
                var methodName = _LC.String.toCamelCase(arguments[0]);
                if(!node._methods[methodName]) {
                    _Lyte.error("LC009", methodName, this.$node.tagName);
                    return;
                }
                return node._methods[methodName].apply(this, args);
            }
        },
        "getProperData" : function(obj) {
            var dataType = obj.dataType;
            var attr = obj.attr;
            var newValue = obj.newValue;
            var tagName = obj.tagName;
            switch(dataType) {
            case "boolean" : 
                {
                    if(!newValue || newValue === "false") {
                        newValue= false;
                    } else {
                        newValue = true;
                    }
                }
                break;
            case "object" : 
                try{
                    newValue = JSON.parse(newValue);
                    if(!(newValue instanceof Object)) {
                        _Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
                    }
                } catch(e) {
                    _Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
                    return;
                }
                break;
            case "array":
                try{
                    newValue = JSON.parse(newValue);
                    if(!(newValue instanceof Array)) {
                        _Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
                    }
                } catch(e) {
                    _Lyte.warn("attribute "+attr+ " is not a valid JSON string.");
                    return;
                }
                break;
            case "number":
                {
            let numValue = +newValue;
                if(newValue === numValue+"") {
                    newValue = numValue;
                } else {
                    _Lyte.warn("data type of the value provided for attribute "+ attr + " of " + tagName + " is not valid");
                    return;
                }
            }
                break;
            }
            obj.newValue = newValue;
            return true;
        }, 
        "cssEscape" : function(string) {
            if(string) {
                return string.replace(/['"]/g, "\\$&");    
            } else {
                return string;
            }
            
        }

}
_Lyte.typeCast = LyteComponent.typeCast;
_Lyte.getDataType = LyteComponent.getDataType;
_Lyte.Component._get = LyteComponent.get;
_LyteComponent.chromeBugFix = function() {
    var version = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);;
    version = version ? parseInt(version[2], 10) : 0;
    if(version > 62) {
        this.chI = [];
        document.addEventListener("focus", function(event) {
            var target = event.target;
            if(target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "DIV") {
                if(Lyte.Component.chI.indexOf(target) == -1) {
                    Lyte.Component.chI.push(target);
                }
            }
        } , true);
        this.chromeBugFix = function() {
            var tags = Lyte.Component.chI;
            var tagsL = tags.length;
            var toRemove = ["_callee", "_attributeDetails", "_attributes", "_removedAttributes", "_yields" , "_rA", "_cx"];//no i18n
            var toBeRemoved = [];
            var keepAliveInputs = [];
            document.querySelectorAll("[lyte-keep-alive]").forEach(function(item,index){
                for(var key in item._renderedComponent) {
                    keepAliveInputs.push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll("input")));
                }
            });
            for(var i= tagsL-1, item;item=tags[i];i--) {
                if((document.compareDocumentPosition(item) % 2) && (keepAliveInputs.indexOf(item) == -1)) {
                    tags.splice(i,1);
                    item.remove();
                    toBeRemoved.push(item);
                    item._rA = item._rA || [];
                    item._rA.forEach(function(remAttr) { //eslint-disable-line no-loop-func
                        remAttr.ownerElement = undefined;
                    });
                    toRemove.forEach(function(key) {//eslint-disable-line no-loop-func
                        item[key] = undefined;
                    });
                    Array.from(item.attributes).forEach(function(itemVal) {//eslint-disable-line no-loop-func
                        item.removeAttribute(itemVal.nodeName);
                    });
                }
            }
        }
        Lyte.addEventListener("afterRouteTransition", function() {
            Lyte.Component.chromeBugFix();
        });
        if(!Lyte.Router) {
            setInterval(function() {
                // Lyte.Component.chromeBugFix();
                LyteComponent.String.cache_c = {};
                LyteComponent.String.cache_d = {};
            },300000)
        }
    }
}

let _LC = LyteComponent;

customElements.define("lyte-safari-test-component", Test);
var divTest = document.createElement("div");
divTest.innerHTML = "<lyte-safari-test-component t></lyte-safari-test-component>";

_LyteComponent.render = _LC.render;
//Change it in v3.0 - Remove from LyteComponent scope. 
_LyteComponent.insertBefore = _LC.insertBefore;
_LyteComponent.insertAfter = _LC.insertAfter;
_LyteComponent.replaceWith = _LC.replaceWith;
_LyteComponent.appendChild = _LC.appendChild;
_LC.tDiv=createElement("template");
// _LC.tDiv = createElement("div");
_LC.tDiv.setAttribute("id", "dummy-templates-div");
// _LC.tDiv.setAttribute("style", "display:none");
_LC.hDiv=createElement("template");

// _LC.hDiv = createElement("div");
_LC.hDiv.setAttribute("id", "keep-alive-div");
// _LC.hDiv.setAttribute("style", "display:none");
_LC.h1Div=createElement("template");

// _LC.h1Div = createElement("div");
_LC.h1Div.setAttribute("id", "lyte-helper-div");
// _LC.h1Div.setAttribute("style", "display:none");
Lyte.Compile.componentsDiv = _LC.lyteComponentsDiv = createElement("div");
_LC.lyteComponentsDiv.setAttribute("id", "lyte-components-div");

Set.prototype.toArrayLyte = function() {
    if(this.constructor.name === "Set"){
        return Array.from(this);
    }
    else{
        return Array.from(this._values);
    }
}
//_LC.registerListener(function() {
//  
//});

if(document.readyState === "complete" || document.readyState === "interactive") {
    onDomContentForLyte();
} else {
    document.addEventListener("DOMContentLoaded", function(e){
        onDomContentForLyte();
    },true);
}
function createSvgDepth(actualTemplate,type){
    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    for(var s=0; s<actualTemplate.childNodes.length; s++){
        svg.appendChild(actualTemplate.childNodes[s].cloneNode(true));
    }
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    for(var s=0; s<svg.childNodes.length; s++){
        depthTemp.content.appendChild(svg.childNodes[s]);
        s--;
    }
    return depthTemp;
}
function createDepth(actualTemplate,type){
    var depthTemp = document.createElement("template");
    depthTemp.setAttribute("is", type);
    depthTemp.innerHTML = actualTemplate.innerHTML;
    return depthTemp;
}
function appendDepth(depthTemp,constr){
    constr.splitTextNodes(depthTemp);
    constr._depthTemp.content.appendChild(depthTemp);
}
function setHT(dynN,info,dynNewCompile,constr){
    var flag  = true;
    if(dynN.tagName == "TEMPLATE") {
        info._ht = dynN.innerHTML;
        flag = false;
    }
    if(info._ht) {
        if(flag){
            dynN.innerHTML = info._ht;
            constr.splitTextNodes(dynN);
        }
        if(dynNewCompile && dynNewCompile.innerHTML !== info._ht) {
            dynNewCompile.innerHTML = info._ht;
            constr.splitTextNodes(dynNewCompile);
        }
    }
}
function doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile) {
    let lastUsedAttrPosition ;
    for(let j=0;j<dynamicNodes.length;j++) {
        let info = dynamicNodes[j], type = info.type, pos = info.position, helperInfo;
        let dynN = getDynamicNode(dynamicN,pos);
        let dynNewCompile;
        if(newCompile) {
            dynNewCompile = getDynamicNode(newCompile,pos);
        }
        switch(type) {
        case "text" : {
            let mustache = Lyte.Compile.getMustache(dynN.nodeValue),dynamicValue,helperFunc;
            if(mustache){
                    helperFunc = Lyte.Compile.getHelper(mustache);
            }   
            let dynamic = mustache;
            if(helperFunc){
                 info.helperInfo = helperFunc;
                 if(dynNewCompile) {
                    info.newHelperInfo = Lyte.Compile.getHelper(mustache,true);
                    _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                 }                 
            }
            else if(dynamic){
                //deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: dynamic});
                info.dynamicValue = dynamic;
                info.newDynamicValue = _LC.getDV(dynamic);
                if(dynNewCompile) {
                    _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                }
//              LN to do
//              deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: getDV(dynamic)});                    
            }
        }
        break;
        case "insertYield" : {
             if(dynNewCompile) {
                 dynNewCompile.appendChild(document.createTextNode("__**--Lyte"+j+"__**"));
                 let yieldAttr = dynNewCompile.attributes["yield-name"];
                 info.yieldName = yieldAttr ? yieldAttr.nodeValue : undefined;
             }
        }
        break;
        case "componentDynamic" : {
        	if(dynNewCompile) {
        		dynNewCompile.appendChild(document.createTextNode("__**--Lyte"+j+"__**"));
        		info.componentName = dynNewCompile.localName;
        		var attrs = Array.from(dynNewCompile.attributes);
        		info.staticAttrs = {};
        		for(var i=0;i<attrs.length;i++) {
        			info.staticAttrs[_LC.String.toCamelCase(attrs[i].nodeName)] = attrs[i].nodeValue;
        		}
        		delete info.staticAttrs._lyteprop;
        	}
        }
        break;
        case "attr" : {
            let add = false, toBeRemoved = [],toBeAdded = [];
            let node = dynN;
            let attr = info.attr = info.attr || {};
            for(let i=0;i<node.attributes.length;i++) {
                if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                    let val = node.attributes[i].nodeValue;
                    let actValue = Lyte.Compile.getMustache(val), actObj ;
                    if(actValue){
                        actObj = Lyte.Compile.getHelper(actValue);  
                    }
                    else if(/{{.*}}/.test(val) && !(/\\{{.*}}/.test(val))){
                        actObj = Lyte.Compile.splitMixedText(val);
                    }
                    if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/.test(node.attributes[i].name)){
                            attr[node.attributes[i].name.substr(2)] = {name:node.attributes[i].name.substr(2),camelCase : _LC.String.toCamelCase(node.attributes[i].name.substr(2)), helperInfo: actObj, newHelperInfo : Lyte.Compile.getHelper(actValue, true), globalEvent: true};

                            let actArgs = _Lyte.deepCopyObject(actObj.args);
                            let actName = actArgs.splice(0,1)[0];
                            actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                            let actString = getArgString(actName, actArgs);
                            node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            if(dynNewCompile) {
                                dynNewCompile.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                            }
                            toBeRemoved.push(node.attributes[i].name);                            
                    }
                    else{
                        if(actObj || actValue) {
                            let attrToPush = {};
                            
                            if(node.attributes[i].name.startsWith("lbind:")) {
                                toBeRemoved.push(node.attributes[i].name);
                                toBeAdded.push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                                attrToPush.isLbind = true;
                                attrToPush.name = node.attributes[i].name.substring(6);
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            else {
                                attrToPush.name = node.attributes[i].name;
                                attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
                            }
                            if(actObj) {
                                if(actObj.name === "lbind") {
                                    attrToPush.dynamicValue = actObj.args[0];
                                    attrToPush.newDynamicValue = _LC.getDV(actObj.args[0]);
                                    attrToPush.isLbind = true;
                                }
                                else {
                                    attrToPush.helperInfo = actObj;
                                    attrToPush.newHelperInfo = Lyte.Compile.getHelper(actValue, true);
                                }
                            } 
                            else {
                                attrToPush.dynamicValue = actValue;
//                              LN to do
                                attrToPush.newDynamicValue = _LC.getDV(actValue);
                            }
                            add = true;
                            attr[attrToPush.name] = attrToPush;
                        }                  
                    }
                }
            }
            if(toBeRemoved.length){
                for(let i=0; i<toBeRemoved.length;i++){
                    node.removeAttribute(toBeRemoved[i]);
                    if(dynNewCompile) {
                        dynNewCompile.removeAttribute(toBeRemoved[i]);
                    }
                }
            }
            if(dynNewCompile) {
                for(var key in attr) {
                    dynNewCompile.removeAttribute(key);
                }
                dynNewCompile.setAttribute("_lyteAttr" , "__**--Lyte" + j + "__**", "");
            }
            if(toBeAdded.length) {
                for(let i=0;i<toBeAdded.length;i++) {
                    node.setAttribute(toBeAdded[i].name, toBeAdded[i].value);
                }
            }
        } 
        break;
        case "for" : 
        case "forIn" : 
        case "registerYield" : 
            setHT(dynN,info,dynNewCompile,constr);
        case "component" : {
            var actualTemplate = _Lyte._ie ? dynN : dynN.content;
            if(!dynNewCompile && (type == "registerYield" || dynN.hasAttribute("unbound"))) {
                if(_Lyte._ms) {
                    dynNewCompile = document.createElement("div");
                    dynNewCompile.innerHTML = info.actualTemplate ? info.actualTemplate : dynN.outerHTML;
                    dynNewCompile = dynNewCompile.childNodes[0];
                    constr.splitTextNodes(dynNewCompile);
                } else {
                    dynNewCompile = dynN.cloneNode(true);
                }
            }
            let depthTemp;
            let dnNode;
            var actualTemplateNewCompile = dynNewCompile ? (_Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
            let args = {};
                if(info.actualTemplate) {
                    actualTemplate = _LC.getContentForIE(info.actualTemplate, constr, undefined, _Lyte._ms? info : undefined);
                if(dynNewCompile) {
                    actualTemplateNewCompile = _LC.getContentForIE(info.actualTemplate, constr);
                }
                }
                  doCompile(actualTemplate, info.dynamicNodes, componentName, constr, actualTemplateNewCompile, info);
                    if(actualTemplateNewCompile) {
                      let staticTemp = info.actualTemplate ? actualTemplateNewCompile : dynNewCompile;
                      info._sta = _LC.processStatic(staticTemp);                      
                    }
                  if(_Lyte._ms) {
                      if(info.actualTemplate) {
                          info.templateContent = actualTemplate.outerHTML;
                          if(info._content) {
                              info.actualTemplate = info._content.innerHTML;
                              delete info._content;
                          }
                      } else {
                          info.templateContent = dynN.outerHTML;
                      }
                    dynN.innerHTML = "";  
                }
                if(info.actualTemplate) {
                    depthTemp = type;
                    if(!_Lyte._ie ) {
                        if(info.svg){
                            depthTemp = createSvgDepth(actualTemplate,type)
                        }else{
                            depthTemp = createDepth(actualTemplate,type)
                        }
                        appendDepth(depthTemp,constr);
                    }
                    if(dynamicNodes[j-1] && (dynamicNodes[j-1].position.toString() === dynamicNodes[j].position.toString())) {
                        dnNode = dynamicNodes[j-1];
                    } else {
                        dnNode = dynamicNodes[j];
                    }
                    dnNode._depthTemp = depthTemp;
                }
            
                if(dynNewCompile) {
                    info._args = {};
                    if(type === "registerYield") {
                        //dynNewCompile.parentNode.parentNode.insertBefore(document.createTextNode("__**--Lyte"+j+"__**"), dynNewCompile.parentNode);
                        //dynNewCompile.parentNode.setAttribute("_lyteyield", "");
                        //_LC.replaceWithPf(dynNewCompile, document.createTextNode(""));
                        _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                    } else if(type === "component") {
                        _LC.replaceWithPf(dynNewCompile, document.createTextNode((dynNewCompile.hasAttribute("_lyteattr") ? dynNewCompile.getAttribute("_lyteattr"): "" )+ "__**--Lyte"+j+"__**"));
                    } else {
                        //dynNewCompile.replaceWith(document.createTextNode("__**--Lyte"+j+"__**"))
                        _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
                    }
                    Array.from(dynNewCompile.attributes).forEach(function(item) { //eslint-disable-line no-loop-func
                        info._args[item.nodeName] = item.nodeValue;
                    });
                }
                if(info._ht) {
                    info._ht = dynN.cloneNode(true);
                    constr._helperTemplate.content.append(info._ht)
                    dynN.innerHTML = "";
                }
                //  When a registerYield is present inside another registerYield, in fastRender, we will not be able to get the template using the positions and parentComponent alone, since the insertYield is present inside the insertYield of the parent component. 
                // info.actYield = dynN;
              }
        break;
        case "if" : 
        case "switch" : {
            setHT(dynN,info,dynNewCompile,constr);
            var oldDyn = dynN;
            let depthTemp;
            var actualTemplateNewCompile = dynNewCompile ? (_Lyte._ie ? dynNewCompile : dynNewCompile.content) : undefined;
            if(info.actualTemplate) {
                dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);
                if(dynNewCompile) {
                    let dummy = _LC.getContentForIE(info.actualTemplate, constr);
                    actualTemplateNewCompile = _Lyte._ie ? dummy : dummy.content;
                }
            }
            var def = "default";
            if(_Lyte._ms) {
            	var cases = {};
                var defCase;
                var dynNchildNodes = _Lyte._ed ? dynN.content.childNodes : dynN.childNodes;
                for(var i=0;i<dynNchildNodes.length;i++) {
                  if(dynNchildNodes[i].tagName === "TEMPLATE"){
                	  if(dynNchildNodes[i].getAttribute("case")) {
                		  cases[dynNchildNodes[i].getAttribute("case")] = dynNchildNodes[i];
                	  } else if(dynNchildNodes[i].hasAttribute("default")) {
                		  defCase = dynNchildNodes[i];
                	  }
                  }
                }
                for (var key in info.cases) {
                    let contentNewCompile;
                    content = _LC.getContentForIE(cases[key], undefined, true);
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[case='"+LyteComponent.cssEscape(key)+ "']"));
                    }
                    setHT(content,info.cases[key],contentNewCompile,constr);
                    doCompile(content, info.cases[key].dynamicNodes, componentName, constr, contentNewCompile ? _LC.getContentForIE(contentNewCompile) : undefined);

                    cases[key].remove();
                    if(actualTemplateNewCompile) {
                        info.cases[key]._sta = _LC.processStatic(contentNewCompile);
                    }
                    info.cases[key].templateContent = cases[key].outerHTML;
                }
                if (info[def].dynamicNodes) {
                    let contentNewCompile;
                    content = _LC.getContentForIE(defCase, undefined, true);
                    if(actualTemplateNewCompile) {
                        contentNewCompile = actualTemplateNewCompile.querySelector("[default]");
                    }
                    setHT(content,info[def],contentNewCompile,constr);
                    doCompile(content, info[def].dynamicNodes, componentName, constr, contentNewCompile? _LC.getContentForIE(contentNewCompile) : undefined);

                    defCase.remove();
                    info[def].templateContent = defCase.outerHTML;
                    if(actualTemplateNewCompile) {
                        info[def]._sta = _LC.processStatic(contentNewCompile);
                    }
                }
            } else {
                var dynNContent = dynN.content || dynN;
            	for(let key in info.cases) {
                    let contentNewCompile;
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[case='"+LyteComponent.cssEscape(key)+ "']"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector("[case='"+_LC.cssEscape(key)+ "']"), undefined, true);
                    setHT(content,info.cases[key],contentNewCompile,constr);
            		doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.cases[key].dynamicNodes,componentName, constr, contentNewCompile);
                    if(actualTemplateNewCompile) {
                      info.cases[key]._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info.cases[key]._ht) {
                        info.cases[key]._ht = content.cloneNode(true);
                        constr._helperTemplate.content.append(info.cases[key]._ht)
                        content.innerHTML = "";
                    }
            	}
            	if(info[def].dynamicNodes) {
                    let contentNewCompile
                    if(actualTemplateNewCompile) {
                        contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[default]"));
                    }
                    var content = _LC.getContentForIE(dynNContent.querySelector("[default]"), undefined, true);
                    setHT(content,info[def],contentNewCompile,constr);
            		doCompile(content.tagName === "TEMPLATE" ? content.content : content, info[def].dynamicNodes,componentName, constr, contentNewCompile);
                    if(actualTemplateNewCompile) {
                      info[def]._sta = _LC.processStatic(contentNewCompile);
                    }
                    if(info[def]._ht) {
                        info[def]._ht = content.cloneNode(true);
                        constr._helperTemplate.content.append(info[def]._ht)
                        content.innerHTML = "";
                    }
            	}
            	
            }

            if(info.actualTemplate) {
                depthTemp = type;
                if(!_Lyte._ie ) {
                    if(info.svg){
                        depthTemp = createSvgDepth(dynN.content,type)
                    }else{
                        depthTemp = createDepth(dynN,type)
                    }
                    appendDepth(depthTemp,constr);
                }
                if(dynamicNodes[j-1] && (dynamicNodes[j-1].position.toString() === dynamicNodes[j].position.toString())) {
            		dynamicNodes[j-1]._depthTemp = depthTemp;
            	} else {
            		dynamicNodes[j]._depthTemp = depthTemp;
            	}
            }

            if(dynNewCompile) {
                _LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte"+j+"__**"));
            }
            if(info._ht) {
                info._ht = dynN.cloneNode(true);
                constr._helperTemplate.content.append(info._ht)
                dynN.innerHTML = "";
            }
        }
        break;    
        }
    }
}

//This is the function where the actual rendering takes place. 
    //It takes the template, finds the actual dynamic nodes uwing dynamicNodes argument and then binds each node with the associated
    //property by calling bindNode. 

function getDynamicNode(content, positions){
    let dynamicN = content;
    for(var i=0; i<positions.length; i++){
        dynamicN = (dynamicN.tagName != "TEMPLATE" || _Lyte._ie) ? dynamicN.childNodes[positions[i]] : dynamicN.content.childNodes[positions[i]];
    }
    return dynamicN;
}

function getArgString(name, array) {
    let retString;
    for(let i=0;i<array.length;i++) {
        if(array[i] && typeof array[i] === "object") {
            array[i] = getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}

_LC[registerHelperStr]("unbound",function(value){
     return value;
});

_LC[registerHelperStr]("action",function(parentNode,attrName,isCustom,actObj){
    if(isCustom){
        parentNode._actions = parentNode._actions? parentNode._actions : {};
        if(!parentNode._actions[attrName]){
            this.createCustomEvent(attrName, parentNode, actObj); 
            parentNode.removeAttribute(attrName);
        }
    }
    else{
        
        this.createEventListeners(parentNode,attrName,actObj);    
    }
});

_LC[registerHelperStr]("lbind",function(name){
	return this.getData(name);
});

_LC[registerHelperStr]("method", function(parentComponent, attributeNode, functionName) {
    var parentComponent = arguments[0];
    var attributeNode = arguments[1];
    var functionName = arguments[2];
    var self = arguments[0].component;
    var childComponent = attributeNode? attributeNode.ownerElement : null;
    var attributeName = arguments[1].nodeName;
    attributeNode = null;
    var args = Array.prototype.slice.call(arguments, 2);
    var newFunc = function() {
        let node = this.$node;
        let contextSwitchArray = [];
        _LC.adCx(node, contextSwitchArray);
        let processedArgs = this.$node.processArgs(this.$node._callee,{"helperInfo" : {"args" : args}}, [], undefined, this.$node);
        let functionName1 = processedArgs.splice(0,1)[0];
        _LC.rmCx(node, contextSwitchArray);
        let customArgs = Array.from(arguments);
        let mainArgs = processedArgs.concat(customArgs);
        if(self.$node._methods[functionName1]) {
            return self.$node._methods[functionName1].apply(self, mainArgs);
        }
        _Lyte.error("LC009", functionName, self.$node.tagName);
    }
    if(childComponent) {
        if(!childComponent.set) {
            childComponent.setMethods(_LC.String.toCamelCase(attributeName), newFunc);
        } else {
            childComponent._methods[_LC.String.toCamelCase(attributeName)] = newFunc;
        }
    } else {
        return newFunc;
    }
});

_LC[registerHelperStr]("unescapeAttr",function(){
    debugger
    return Lyte.Component.registeredHelpers.unescape.apply(this,arguments).innerHTML;
});
_LC[registerHelperStr]("unescape",function(value,additionalObject,userInstance){
    if(_LC.ffr) {
        return value;
    }
    if(Lyte.Security.ignoreSanitizer){
        let divEle = document.createElement("div");
        divEle.innerHTML = value;
        return divEle;
    }
    else{
        if(additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length >0){
            if(Object(additionalObject.GLOBAL_TAGS).length>0){
                var index = additionalObject.GLOBAL_TAGS.indexOf("link-to");
                if(index != -1){
                    additionalObject.GLOBAL_TAGS.splice(index,1);
                }
            }
            if(additionalObject && additionalObject.GLOBAL_ATTRIBUTES && Object.keys(additionalObject.GLOBAL_ATTRIBUTES).length>0){
                var arr = ["is","yield-name","lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target","lt-prop-td","lt-prop-custom","lt-prop-target","lt-prop-id","lt-prop-class","lt-prop-style","lt-prop-rel","lt-prop-title"];
                for(var i=0;i<arr.length;i++){
                    var index =additionalObject.GLOBAL_ATTRIBUTES.indexOf(arr[i]);
                    if(index != -1){
                        additionalObject.GLOBAL_ATTRIBUTES.splice(index,1);
                    }
                }
            }
        }
        if(additionalObject && additionalObject.GLOBAL_TAGS){//this if check is inorder to getobserved attributes given in globaltags
            if(additionalObject.GLOBAL_ATTRIBUTES == undefined){
                additionalObject.GLOBAL_ATTRIBUTES = [];
            }
            var globalTagArr = Array.from(additionalObject.GLOBAL_TAGS);
            var attr = [];
            for(var a=0; a<globalTagArr.length; a++){
                if(LyteComponent._registeredComponents[globalTagArr[a]]){
                    attr = LyteComponent._registeredComponents[globalTagArr[a]].observedAttributes;
                }else if(Lyte.registeredCustomComponent[globalTagArr[a]]){
                    if(Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes){
                        attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
                    }else{
                        attr = [];
                    }
                }
                for(var i=0; i<attr.length; i++){
                    if(additionalObject.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1){
                        additionalObject.GLOBAL_ATTRIBUTES.push(attr[i]);
                    }
                }
            }
        }
        var divEle = document.createElement("div");
        if(userInstance && Object.keys(userInstance).length){
            if(additionalObject && Object.keys(additionalObject).length){
                Lyte.Security.addGlobalObject(userInstance,additionalObject);
                var clean = userInstance.sanitize(value);
                Lyte.Security.removeGlobalObject(userInstance,additionalObject);
            }
            else{
                var clean = userInstance.sanitize(value);
            }
        }
        else{
            if(additionalObject && Object.keys(additionalObject).length){
                Lyte.Security.addGlobalObject(Lyte.Security._ourSanitizerInstance_,additionalObject);
                var clean = Lyte.Security._ourSanitizerInstance_.sanitize(value);
                Lyte.Security.removeGlobalObject(Lyte.Security._ourSanitizerInstance_,additionalObject);
            }else{
                var clean = Lyte.Security._ourSanitizerInstance_.sanitize(value);
            }
        }
        divEle.innerHTML = clean;
        return divEle;
    }
});

_LC[registerHelperStr]("escape",function(value,type){
    if(type == 'url'){
        return ZWAF['7_0_0'].Encoder.encodeForHTMLAttribute(value);	
    }
    else if(type == 'js'){
        return ZWAF['7_0_0'].Encoder.encodeForJavaScript(value);
    }
    else if(type == 'css'){
        return ZWAF['7_0_0'].Encoder.encodeForCSS(value);	
    }
    else{
        return value;
    }
});

_LC[registerHelperStr]("debugger", function() {
    debugger;
});

_LC[registerHelperStr]("log", function() {
    console.log.apply(window, Array.from(arguments));
});

_LC[registerHelperStr]("ifEquals", function(arg1, arg2) {
    if(arg1 === arg2) {
        return true;
    } else {
        return false;
    }
});

_LC[registerHelperStr]("if", function(value, trueValue, falseValue) {
    if(value) {
        return trueValue;
    } else {
        return falseValue;
    }
});

_LC[registerHelperStr]("negate", function(arg1) {
    return !arg1;
});


_LC[registerHelperStr]("ifNotEquals", function(arg1, arg2) {
    if(arg1 === arg2) {
        return false;
    } else {
        return true;
    }
});

_LC[registerHelperStr]('concat',function(){
	var resp = '';
	var argLength = arguments.length;
	for(var i=0;i<argLength;i++){
		if(arguments[i] != undefined){
			resp += arguments[i];
		}
	}
	return resp;
});


defProp(HTMLElement.prototype, 'setData', {
    enumerable: false, 
    value : function(arg0, arg1) {
        this._initProperties = this._initProperties || {};
        if(typeof arg0 === "string") {
            this._initProperties[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initProperties[key] = arg0[key];
            }
        }
    }
});

defProp(HTMLElement.prototype, 'setMethods', {
    enumerable: false, 
    value : function(arg0, arg1) {
        this._initMethods = this._initMethods || {};
        if(typeof arg0 === "string") {
            this._initMethods[arg0] = arg1
        } else if(typeof arg0 === "object") {
            for(let key in arg0) {
                this._initMethods[key] = arg0[key];
            }
        }
    }
});

_LC[registerHelperStr]('encAttr', function(val) {
    return ZWAF['7_0_0'].Encoder.encodeForHTMLAttribute(encodeURIComponent(val));
})

_LC[registerHelperStr]('expHandlers',function(leftOperand,operator,rightOperand,nextOperand){
    var argLen = arguments.length;
    if(operator == '++' ){
    	if(rightOperand == "postfix"){
    	   return (leftOperand++);
    	} else if(rightOperand == "prefix"){
    		return (++leftOperand);
    	}
    } else if(operator == "--"){
    	if(rightOperand == "postfix"){
    	   return (leftOperand--);
    	} else if(rightOperand == "prefix") {
    		return (--leftOperand);
    	}
    } else if((operator == "==")){
    	return leftOperand == rightOperand;
    }
     else if((operator == "===")){
    	return leftOperand === rightOperand;
    }
    
    else if((operator == "!=")) {
        return leftOperand != rightOperand;
    }
    else if((operator =="!==")) {
        return leftOperand !== rightOperand;
    }
    else if( operator == "&&") {
    	return leftOperand && rightOperand;
    } else if(operator == "||") {
    	return leftOperand || rightOperand;
    } else if(operator == "+"){
        if(argLen > 2){
        	return leftOperand+rightOperand;
        }
        return leftOperand;
    } else if(operator == '-'){
         if(argLen > 2){
        	return leftOperand-rightOperand;
        }
        return (-leftOperand);
    } else if(operator == '*'){
    	return leftOperand * rightOperand;
    } else if(operator == "/"){
    	return leftOperand / rightOperand;
    } else if(operator == "%"){
    	return leftOperand % rightOperand;
    } else if(operator == "<"){
    	return leftOperand < rightOperand;
    } else if(operator == ">") {
    	return leftOperand > rightOperand;
    } else if(operator == "<=") {
    	return leftOperand <= rightOperand;
    } else if(operator == ">=") {
    	return leftOperand >= rightOperand;
    } else if(operator == '|') {
        return leftOperand | rightOperand;
    } else if(operator == '&') {
        return leftOperand & rightOperand;
    }
    else if(operator == "!" ){
        return (!leftOperand);
    } else if(operator == '=') {
        leftOperand = rightOperand;
        return leftOperand;
    } else if(operator == "+=") {
        return leftOperand += rightOperand;
    } else if(operator == '-=') {
        return leftOperand -= rightOperand;
    } else if(operator == "*=") {
        return leftOperand *= rightOperand;
    } else if(operator == '/=') {
        return leftOperand /= rightOperand;
    } else if(operator == '?:') {
        return (leftOperand ? rightOperand : nextOperand);
    }
 });


_LyteComponent.register("lyte-event-listener",{
            _template : "<template tag-name=\"lyte-event-listener\"></template>",
            _dynamicNodes : [],
            _observedAttributes : ['eventName'],
            init: function() {
                let self = this;
                let regId = _Lyte.addEventListener(this.get('eventName'), function() {
                    let args = Array.prototype.slice.call(arguments);
                    args.splice(0,0,'on-fire')
                    self.throwEvent.apply(self, args );
                });
                //this.set('regId', regId);
                this.regId = regId;
            },
            data: function(){
                return {
                    "eventName" : _Lyte.attr("string")
                }
            }, 
            didDestroy : function() {
                _Lyte.removeEventListener(this.regId);
            }
        });

_LyteComponent.registerCustomPropHandler("ltProp");

_LyteComponent.shouldIgnoreDisconnect = function() {
    return _LC.ignoreDisconnect;
}

_LyteComponent.addLyteEventListener = function(element, eventName, func, context) {
  element._lyteEvents = element._lyteEvents || {};
  element._lyteEvents[eventName] = element._lyteEvents[eventName] || []; 
  var ind = element._lyteEvents[eventName].push({"func" : func, "fromEventListener" : true, "context" : context});
  return eventName + "-" + ind; 
}

_LyteComponent.removeLyteEventListener = function(element, listenerId) {
    if(!listenerId) {
        _Lyte.error("No listenerId provided");
        return;
    }
    var split = listenerId.split('-');
    var eventName = split[0];
    var index = parseInt(split[1]);
    if(!element._lyteEvents || !element._lyteEvents[split[0]] || isNaN(index)) {
        _Lyte.error("Invalid listenerId / listener is not available");
        return;
    }
    element._lyteEvents[split[0]][split[1] - 1] = {};
}

_LyteComponent.throwEvent = _LC.throwEvent;

_LC.hasLyteEvents = function(element, eventName) {
    if(element._lyteEvents && element._lyteEvents[eventName]) {
        return true;
    } else {
        return false;
    }
}

_LC.handleLyteEvents = function(element, event) {
    var funcs = element._lyteEvents[event.type];
    var ret;
    var eventStopped;
    for(var i=0;i<funcs.length;i++) {
        if(funcs[i].func) {
            ret = funcs[i].func.call(funcs[i].context ? funcs[i].context : window, event);
            if(ret === false || event.cancelBubble) {
                eventStopped = true;
                break;
            } 
        }
    }
    if(eventStopped) {
        event.stopPropagation();
    }
    return eventStopped;
}

Object.defineProperty(window, "LyteComponent", {
	get : function() {
		_Lyte.warn("Usage of LyteComponent is deprecated. Use Lyte.Component instead");
		return LyteComponent;
	}
})
_LyteComponent.chromeBugFix();
_LC.booleanAttrList = ["async","autocomplete","autofocus","autoplay","border","challenge","checked1","compact","contenteditable","controls","default","defer","disabled","formNoValidate","frameborder","hidden","indeterminate","ismap","loop","multiple","muted","nohref","noresize","noshade","novalidate","nowrap","open","readonly","required","reversed","scoped","scrolling","seamless","selected","sortable","spellcheck","translate"]
Lyte.$.requiredMixins.component = function (mix, compDetails){
    var mixinsToBeUsed=[];
    var actionsFromMixin = {}; 
    var methodsFromMixin = {};
    var newDefinition = {};
    mixinsToBeUsed.push(mix);
    compDetails.forEach(ele => {
        var componentName = ele;
        var customCrmComponent = LyteComponent._registeredComponents[componentName];
        if(mixinsToBeUsed.length){
            LyteComponent.dataFromMixin(mixinsToBeUsed,actionsFromMixin,methodsFromMixin,newDefinition);
        }
        customCrmComponent._actions = Object.assign(customCrmComponent._actions, actionsFromMixin);
        var methods = Object.assign(customCrmComponent._methods, methodsFromMixin);
        delete newDefinition.methods;
        LyteComponent.updateCustomCrmComponent(newDefinition,customCrmComponent);
        customCrmComponent._methods = methods;
        LyteComponent._registeredComponents[componentName] = customCrmComponent; 
    });
}

Lyte.$.injectServices.component = function(key, name, type, ins, compClass, data){
    if(compClass){
        var obj = {};
        obj[compClass.compName] = compClass;
    }
    var registeredComponents = compClass ? obj : _LC._registeredComponents;
    if(registeredComponents){
        var arr = Object.keys(registeredComponents);
        arr.forEach(function(comp){
            var component = registeredComponents[comp];
            // obj = {};
            // obj[key] = name;
            // component._serviceToBeUsed = Object.assign(obj, component._serviceToBeUsed);
            if(ins && Lyte.__gS[key]){
                component.component.prototype[key] = ins;
            }
            else{
                Lyte.$.requiredServices(key,name,function(serviceData,serviceKey){
                    component.component.prototype[serviceKey] = serviceData;
                },undefined,undefined, true, data);
            }
        });
    }
}
    //security
    Lyte.Security.addGlobalObject = function(instanceObj,additionalObj){
        for (var property in additionalObj) {
                if(Array.isArray(additionalObj[property])){
                    additionalObj[property].forEach(function(item){
                        if(instanceObj["_"+property].indexOf(item) == -1){
                            instanceObj["_"+property].push(item);
                        }
                    });
            }
        }
    }
    Lyte.Security.removeGlobalObject = function(instanceObj,additionalObj){
        for (var property in additionalObj) {
            if(Array.isArray(additionalObj[property])){
                additionalObj[property].forEach(function(item){
                    var index = instanceObj["_"+property].indexOf(item);
                    if(index != -1){
                        instanceObj["_"+property].splice(index,1);
                    }
                });
        }
        };
    }
    Lyte.Compile.getTrimmedContent = function(content, position, node) {
        let dummyContent = content;
        if(node) {
            position = [];
            let parentNode = node.parentNode;
            while(true) {
                position.unshift(this.getArrayIndex(parentNode.childNodes,node));
                parentNode = parentNode.parentNode;
                node = node.parentNode;
                if(!parentNode) {
                    break;
                }
            }
        }
        for(let i=0;i<position.length;i++) {
            for(let j=content.childNodes.length-1;j>position[i];j--) {
                content.childNodes[j].remove();
            }
            content = content.childNodes[position[i]];
        }
        return dummyContent;
    }
    Lyte.Compile.getArrayIndex = function(array,value) {
        for(let i=0;i<array.length;i++) {
            if(array[i] === value) {
                return i
            };
        }
    }

    Lyte.Compile.splitMixedText = function(str){
        var stack=[], start=0, helper = { name:"concat", args: []}, strStack = [],lastAdded,helperStarted;
        for(var i=0;i<str.length;i++){
          var j = i;
            if(helperStarted && str[i] === "'"){
                if(lastAdded === "'" && str[i-1] !== "\\"){
                    strStack.pop();
                    lastAdded = undefined;
                }
                else if(!strStack.length){
                    lastAdded = str[i];
                    strStack.push(lastAdded);
                }
            }
            else if(helperStarted && str[i] === "\""){
                if(lastAdded === "\"" && str[i-1] !== "\\"){
                    strStack.pop();
                    lastAdded = undefined;
                }
                else if(!strStack.length){
                    lastAdded = str[i];
                    strStack.push(lastAdded);
                }
            }
          else if( ((helperStarted && !strStack.length) || !helperStarted) && str[i-1] !== "\\" && str[i] === "{" && str[++i] === "{"){
            stack.push('{{');
            helper.args.push("'"+str.substr(start,j-start)+"'");
            start = i + 1;
            helperStarted = true;
          }
          else if( ((helperStarted && !strStack.length) || !helperStarted) && str[i] === "}" && str[++i] === "}" && stack.length){
            stack.pop(start);
            helperStarted = false;
            var toPush = str.substr(start,j-start);
            var actObj = this.getHelper(toPush);  
            if(actObj){
                toPush = actObj;
            helper.args.push({type:"helper",value:toPush});
            }
            else{
                helper.args.push(toPush);
            }
            start = i + 1;
         }
    
        }
        // if(stack.length){
            // return false;
        // }
        if(start<str.length){
            helper.args.push("'"+str.substr(start,str.length-start)+"'");
        }
        return helper;
    }
    
    Lyte.Compile.getHelper = function(dynamicValue, newCompile){
        let helperValue = /\((?:[^)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/.exec(dynamicValue);
        if(helperValue){
            return this.getHelperInfo(dynamicValue,helperValue, newCompile);
        }
        return undefined;
    }
    
    
    Lyte.Compile.getHelperInfo = function(dynamicValue, helperValue, newCompile){
        let helperFunc = {};
        helperFunc.name = dynamicValue.substr(0,helperValue.index).replace(/\s/g,'');
        helperValue = (helperValue) ? helperValue[0].trim() : helperValue;
        if(helperFunc.name == "lyteViewPort" && helperValue == "()"){
            helperFunc.args = [];
            return helperFunc;
        }
        let args = this.getHelperArgs(helperValue.substr(1,helperValue.length-2), newCompile);
        if(args === false){
            return false;
        }
        helperFunc.args = args;
        return helperFunc;
    }
    
    Lyte.Compile.getHelperArgs = function(str, newCompile){
        let stack = [], args = [] , from=0;
        let lastPushed; 
        for(let i=0; i<str.length; i++){
            if(!stack.length && str.charAt(i) === ","){
                let toPush = str.substr(from,i-from);
                toPush = toPush.trim();
                if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
                    toPush = toPush.slice(1,-1);
                    toPush = "'" + toPush + "'";
                }
                toPush = this.getHelperArgValue(toPush, newCompile);
                args.push(toPush);
                from = i + 1;
            }
            else if(str.charAt(i) === "("){
                if(stack[stack.length - 1] != "'" && stack[stack.length - 1] != "\""){
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                }
            }
            else if(str.charAt(i) === ")"){
                if(stack[stack.length-1] === "("){
                    stack.pop();
                }
            } else if (str.charAt(i) === "'" && str.charAt(i - 1) !== "\\") {
                if (stack[stack.length - 1] === "'") {
                    stack.pop();
                } else if (stack[stack.length - 1] !== "\"") {
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                }
            } else if (str.charAt(i) === "\"" && str.charAt(i - 1) !== "\\") {
                if (stack[stack.length - 1] === "\"") {
                    stack.pop();
                    //                  str.replaceAt(i, "'");
                } else if (stack[stack.length - 1] !== "'") {
                    stack.push(str.charAt(i));
                    lastPushed = str.charAt(i);
                    //                  str.replaceAt(i, "'");
                }
            }
        }
        if (stack.length) {
            return false;
        }
        var toPush = str.substr(from, str.length - from);
        toPush = toPush.trim();
        if (toPush && toPush.startsWith("\"") && toPush.endsWith("\"")) {
            toPush = toPush.slice(1, -1);
            toPush = "'" + toPush + "'";
        }
        try {
            toPush = this.getHelperArgValue(toPush, newCompile);
        } catch (err) {
            //console.log("errr",err);
            return false;
        }
    
        args.push(toPush);
        if(newCompile) {
            var newArgs = [];
            args.forEach(function(item) {
                if(typeof item === "string" && item[0] !== "'" && item !== "event" && item !== "this") {
                    newArgs.push(_LC.getDV(item));
                } else {
                    newArgs.push(item);
                }
            });
            args = newArgs;
        }
        return args;
    };
        
    Lyte.Compile.getHelperArgValue = function(argValue, newCompile) {
        switch(argValue) {
            case "undefined" : 
                return undefined
            case "true" : 
                return true;
            case "false" : 
                return false;
            case "null" : 
                return null;
            case "" : 
                return undefined;
            default :
                if(argValue && argValue.startsWith("'") && argValue.endsWith("'")){
                    //escaping
                    argValue = argValue.replace(/\\\'/g, "'")
                    argValue = argValue.replace(/\\\"/g, '"');
                    return argValue;
                }
                else if(/\([\w\s,')(]*/.test(argValue)) {
                    return {"type" : "helper" , "value" : this.getHelper(argValue, newCompile)}
                } else if(!isNaN(argValue)) {
                    return parseInt(argValue);
                } else {
                    return argValue;
                }
        }
    }
    Lyte.Compile.getMustache = function(value){
        value=(value && typeof value === "string") ? value.trim() : value;
        if(/^{{(?=[\s]*[\w-_\(\$)]+)/.test(value)){
            let arr = value.match(/{{[a-zA-Z0-9_.[\]()]*(?![\\])}}/g);
            if(arr && arr.length > 1){
                //console.log("length>1",value)
                return undefined;
            }
            if(!this.syntaxCheck(value) || !(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/.test(value))){ //'
                return undefined;
            }
            let dynamic = value.match(/[\w!@#$%^&*)(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g); //'
            if(dynamic && dynamic.length > 1){
                return undefined;
            }
            else{
                dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                
            }
    //        let dynamic = /[\w!@#\$%\^\&*\)\(+=.,_-]+(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?(?=}}$)/.exec(value);
            return dynamic;
        }
        return undefined;
    }
    Lyte.Compile.syntaxCheck = function(value){
        var stack = [],lastAdded;
        for(var i=0;i<value.length;i++){
            if(value[i] === "'"){
                if(lastAdded === "'" && value[i-1] !== "\\"){
                    stack.pop();
                    lastAdded = undefined;
                }
                else if(!stack.length){
                    lastAdded = value[i];
                    stack.push(lastAdded);
                }
            }
            else if(value[i] === "\""){
                if(lastAdded === "\"" && value[i-1] !== "\\"){
                    stack.pop();
                    lastAdded = undefined;
                }
                else if(!stack.length){
                    lastAdded = value[i];
                    stack.push(lastAdded);
                }
            }
        }
        if(stack.length){
            return false;
        }
        return true;
    }
    LyteComponent.replaceWithOrigTemplate = function(node){
        node._origTemplate._fakeTemp = node;
        return node._origTemplate;
    }
    LyteComponent.pendingViewPortElements = [];
    LyteComponent.isInViewPort = function(el) {
        var rect = el.getBoundingClientRect();
        if(rect.width == 0 && rect.height == 0 && rect.top == 0 && rect.bottom == 0 && el.localName != "dummy-port-element"){
            // hidden Element
            return false;
        }
        return ((rect.top >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight)) || (rect.bottom >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) ));
    }
    _LC._doneRaf = {};
    Lyte.Component.registerHelper("lyteViewPort",function(node,config){    
        let compName = this.localName;
        let self = this;
        let actNode = _LC.getActViewPortTemplate(node);
        if(actNode._viewPortRendered){
            return false;
        }
        let disableViewPort = config;
        let pve = _LC.pendingViewPortElements;
        let promise;
        actNode._disable = {};
        if(config && typeof config == "object"){
            actNode._custom = true;
            disableViewPort = config.disableViewPort;
            if(config.viewIn || config.viewOut){
                promise = true;
                actNode._viewIn = config.viewIn ? Object.assign(config.viewIn) : undefined;
                actNode._viewOut = config.viewOut ? Object.assign(config.viewOut) : undefined;

                // actNode._inView = config.inView;
                // actNode._didRender = config.didRender;
                // actNode._isLoading = config.isLoading;
                let _res,_rej;
                actNode._renderPromise = new Promise(function(res,rej){
                    _res = res;
                    _rej = rej;
                });
                actNode._promiseObject = {
                    resolvedByLyte : false,
                    spouse : actNode._viewIn,
                    resolve : function(){
                        if(!actNode._viewOut._afterAppendCalled && actNode._viewOut.beforeRemove && actNode._renderPromise && !actNode._viewOut._beforeRemoveCalled){
                            actNode._viewOut.beforeRemove.apply(actNode._viewOut,[node._promiseObject]);
                        }
                        if(actNode._renderPromise){
                            // let config = actNode._promiseObject.options;
                            // if(config && config.disable){
                            //     if(config.disable.inView === true){
                            //         actNode._disable.inView = true; 
                            //     }
                            //     if(config.disable.didRender === true){
                            //         actNode._disable.didRender = true;
                            //     }
                            // }
                            _res();
                        }
                    },
                    reject : function(){
                        actNode._renderPromise._reject = true;
                        // actNode._disable.inView = true;
                        // actNode._disable.didRender = true;
                        _rej();
                    },
                    // options : {
                    //     disable : {
                    //         inView : false,
                    //         didRender : false
                    //     }
                    // }
                }
                // actNode._renderPromise.resolve = _res;
                // actNode._renderPromise.reject = _rej;

                actNode._renderPromise.then(function(){ //fix observers issue ember
                    if(!actNode._callee.component){
                        return;
                    }
                    actNode._renderPromise._resolved = true;
                    let ind = pve.indexOf(actNode);
                    if(ind != -1){
                        pve.splice(ind,1)
                    }
                    let viewInIns = actNode._viewIn;
                    if(viewInIns && viewInIns.beforeAppend){
                        viewInIns.beforeAppend.apply(viewInIns);
                    }
                    _LC._executeIfTemplates(actNode);
                    if(viewInIns && viewInIns.afterAppend){
                        viewInIns.afterAppend.apply(viewInIns);
                    }
                    actNode._renderPromise = null;
                },function(){
                    Lyte.error("Promise rejected - Viewport cannot be toggled.");
                })
            }
        }
        if(!disableViewPort){
            // if(!LyteComponent._pendingAnimationFrame){
            if(!_LC._doneRaf[compName]){
                requestAnimationFrame(function () {
                    requestAnimationFrame(function () {
                        let inViewTemplates = [];
                        var arr = Array.from(pve);
                        let beforeRemoveHook = [];
                        for(var i=arr.length-1;(i >= 0);i--) {
                            let temp = arr[i];
                            var actTemp = _LC.getActViewPortTemplate(temp);
                            let viewOutIns = actTemp._viewOut;
                            //var loaderAfterAppend = actTemp._viewOut.afterAppend;
                            if(viewOutIns && viewOutIns.afterAppend){
                                viewOutIns.afterAppend.apply(viewOutIns,[actTemp._promiseObject]);
                                viewOutIns._afterAppendCalled = true;
                            }
                        }
                        for(var i=arr.length-1;(i >= 0);i--) {
                            let temp = arr[i];
                            var actTemp = _LC.getActViewPortTemplate(temp);
                            // let viewOutIns = actTemp._viewOut;
                            //var loaderAfterAppend = actTemp._viewOut.afterAppend;
                            // if(viewOutIns && viewOutIns.afterAppend){
                            //     viewOutIns.afterAppend.apply(viewOutIns,[actTemp._promiseObject]);
                            //     viewOutIns._afterAppendCalled = true;
                            // }
                            if(_LC.isViewPortTemplate(temp) && !temp._callee._destroyed){
                                if(_LC._isInViewPort(actTemp,actTemp._callee,beforeRemoveHook)){
                                    inViewTemplates.push(pve.splice(i,1)[0]);
                                    temp._inPve = false;
                                    temp._viewPortRendered = true;
                                }
                                actTemp._inPve = temp._inPve;
                                actTemp._viewPortRendered = temp._viewPortRendered;
                            }
                        }
                        for(let i=0; i<beforeRemoveHook.length; i++){
                            beforeRemoveHook[i].viewOutIns.beforeRemove.apply(beforeRemoveHook[i].viewOutIns,beforeRemoveHook[i].arg);
                        }
                        for(let i=0; i<inViewTemplates.length; i++){
                            _LC._executeIfTemplates(inViewTemplates[i]);
                        }
                        // LyteComponent._pendingAnimationFrame = false;
                        _LC._doneRaf[compName] = false;
                        if(inViewTemplates.length) {
                            requestAnimationFrame(function() {
                                requestAnimationFrame(function() {
                                    _LC.executePendingViewPort();
                                });
                            });    
                        }
                    });
                });
                // LyteComponent._pendingAnimationFrame = true;
                _LC._doneRaf[compName] = true;
            }
            if(pve.indexOf(_LC.getFakeTemplate(node)) == -1){
                node._inPve = true;
                pve.push(node);
            }
            return true;
        }else if(pve.length){
            let fakeTemp = _LC.getFakeTemplate(node);
            let ind = pve.indexOf(fakeTemp);
            if(ind != -1){
                pve[ind]._inpve = node._inPve = false;
                pve[ind]._viewPortRendered = node._viewPortRendered = true;
                pve.splice(ind,1);
            }
        }
    });
    LyteComponent._isInViewPort = function(node,comp,beforeRemoveHook){
        var fchild = node._caseContent[0];
        if(fchild && _LC.isInViewPort(fchild)) {
            node._isInView = true;
            if(node._custom){
                let viewOutIns = node._viewOut;
                if(viewOutIns && !node._renderPromise._resolved && viewOutIns.beforeRemove){
                    node._promiseObject.resolvedByLyte = true;
                    viewOutIns._beforeRemoveCalled = true;
                    beforeRemoveHook.push({
                        viewOutIns : viewOutIns,
                        arg : [node._promiseObject]
                    });
                    // viewOutIns.beforeRemove.apply(viewOutIns,[node._promiseObject]);
                }else if(!node._renderPromise._reject){
                    return true;
                }    
            }
            // if(node._inView && !node._renderPromise._resolved && !node._disable.inView){
            //     node._inView.apply(this,[node._promiseObject]);
            // }
            else{
                return true;
            }
        }
    }
    LyteComponent._executeIfTemplates = function(node){
        let actNode = _LC.getActViewPortTemplate(node);
        // actNode._renderPromise = null;
		actNode._attributes.value = false;
        var isYieldContext,contextSwitchInfo;
        if (actNode._cx || actNode.nodeType === 2 && actNode.ownerElement._cx) {
            contextSwitchInfo = actNode._cx || actNode.ownerElement._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
        } else if (actNode.tagName === "LYTE-YIELD" && actNode._callee._cx) {
            isYieldContext = true;
            contextSwitchInfo = actNode._callee._cx;
            var contextSwitchArray = [];
            _LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
        }
        if(!actNode._callee.component){
            debugger
        }
        actNode._callee.updateSwitchHelper("if", actNode, actNode._cx, true, true);
        if (contextSwitchInfo) {
            _LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
        }
        // node._isViewPortPending = false;
	}
    LyteComponent.isViewPortTemplate = function(node){
        if((node.tagName == "TEMPLATE" || node._origTemplate) && node.getAttribute("is") == "if"){
            return true;
        }
    }
    LyteComponent.getActViewPortTemplate = function(node){
        return node._origTemplate ? node._origTemplate : node;
    }
    LyteComponent.getFakeTemplate = function(node){
        return node._fakeTemp ? node._fakeTemp : node;
    }
    LyteComponent.executePendingViewPort = function(options) {
        var pve = _LC.pendingViewPortElements;
        if(!pve.length) {
            return;
        }
        var arr = Array.from(pve);
        var inViewPortElements = [];
        let beforeRemoveHook = [];
        if(!options || !options.force){
        for(var i=arr.length-1;(i >= 0);i--) {
            let ele = arr[i];
            if(_LC.isViewPortTemplate(ele)){
                let actTemp = _LC.getActViewPortTemplate(ele);
                if(_LC._isInViewPort(actTemp,actTemp._callee,beforeRemoveHook)){
                    inViewPortElements.push(pve.splice(i,1)[0]);
                    ele._inPve = false;
                    ele._viewPortRendered = true;
                }
                actTemp._inPve = ele._inPve;
                actTemp._viewPortRendered = ele._viewPortRendered;
            }
            else if(_LC.isInViewPort(ele._dummyViewPortF) || _LC.isInViewPort(ele._dummyViewPortL)) {
                ele._dummyViewPortF = ele._dummyViewPortL = undefined;
                inViewPortElements.push(pve.splice(i,1)[0]);
            }
        }
        for(let i=0; i<beforeRemoveHook.length; i++){
            beforeRemoveHook[i].viewOutIns.beforeRemove.apply(beforeRemoveHook[i].viewOutIns,beforeRemoveHook[i].arg);
        }
        }else{
            inViewPortElements = arr;
        }

        _LC.isViewPortPending = false;

        for(var j=0;j<inViewPortElements.length;j++) {
            let ele = inViewPortElements[j];
            if(_LC.isViewPortTemplate(ele)){
                _LC._executeIfTemplates(ele);
            }else{
                ele.setData("lyteViewPort", false);
            }
        }
        if(inViewPortElements.length) {
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.executePendingViewPort();
                });
            });    
        }
    }

    window.addEventListener("resize", function() {
        requestAnimationFrame(function() {
            requestAnimationFrame(function() {
                _LC.executePendingViewPort();     
            })    
        });
    });
    
    document.addEventListener("scroll", function() {
        var debounceTime = _LyteComponent.viewPortSettings.debounce
        if(debounceTime) {
            if(_LC.viewPortScrollDebounce) {
                clearTimeout(_LC.viewPortScrollDebounce);
            }
            _LC.viewPortScrollDebounce = setTimeout(function() {
                    requestAnimationFrame(function() {
                        requestAnimationFrame(function() {
                            _LC.executePendingViewPort();        
                        }) 
                    });
                    _LC.viewPortScrollDebound = undefined;
            },debounceTime);
        } else {
            requestAnimationFrame(function() {
                requestAnimationFrame(function() {
                    _LC.executePendingViewPort();        
                }) 
            });
            
        }
    }, true);
    
    LyteComponent.core = {};
    LyteComponent.core._constructor = customElementPrototype;
    LyteComponent.core._registerComponent = customElementPrototype._registerComponent;
    LyteComponent.core.registerComponent = _LC.registerComponent;
    LyteComponent.core.executeBlockHelpers = customElementPrototype.prototype.executeBlockHelpers;
    LyteComponent.core.updateForHelper = customElementPrototype.prototype.updateForHelper;
    LyteComponent.core.updateForInHelper = customElementPrototype.prototype.updateForInHelper;
    LyteComponent.core.updateSwitchHelper = customElementPrototype.prototype.updateSwitchHelper;

    _LyteComponent.viewPortSettings = {
        debounce : 0,
        executePendingViewPortElements : function(options) {
            LyteComponent.executePendingViewPort(options);
        }
    }
}(window));
 
 Lyte.developmentVariables =  { production :undefined}