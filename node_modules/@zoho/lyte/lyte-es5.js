window.DOMPurifyCopy = window.DOMPurify ? window.DOMPurify : undefined;!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.ZWAF=t()}(this,function(){"use strict";function e(e,t,n,r,o,i,a){if(r||!(t in e))return Object.defineProperty&&function(){try{return Object.defineProperty({},"x",{}),1}catch(e){return}}()?(o=!0===o,i=!0===i,a=!0===a,Object.defineProperty(e,t,{value:n,writable:o,configurable:i,enumerable:a})):(e[t]=n,e)}function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var t=(function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e}(n,[{key:"debug",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&this.level===this.LEVELS.DEBUG){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).debug.apply(e,n.concat([performance.now()]))}}},{key:"info",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.INFO)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).log.apply(e,n.concat([performance.now()]))}}},{key:"warn",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.WARN)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).warn.apply(e,n.concat([performance.now()]))}}},{key:"error",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.ERROR)){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];(e=window.console).error.apply(e,n.concat([performance.now()]))}}}]),n);function n(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),this.LEVELS={NONE:-1,DEBUG:0,INFO:1,WARN:2,ERROR:3},e===this.LEVELS.NONE||e===this.LEVELS.DEBUG||e===this.LEVELS.INFO||e===this.LEVELS.WARN||e===this.LEVELS.ERROR?this.level=e:this.level=this.LEVELS.ERROR}var o=window&&window.ZWAF?window.ZWAF:{version:"7.0.0"},i=new t;o.defineProperty||(o.defineProperty=e),o.logger||(o.logger=i),o["7_0_0"]||(o["7_0_0"]={version:"7.0.0",defineProperty:e,logger:i});var a=!1,t={log:function(){if(window&&window.console&&window.console.log&&window.navigator&&window.navigator.userAgent&&!a){var e=window.navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(a=!0,e&&e[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;");window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}}};function B(e,t){if(e instanceof Object)for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function H(e,t){var n;(n=Array.prototype.splice).call.apply(n,[e,e.length,0].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t)))}function V(e,t){if(!e||e.constructor===Object)return e;for(var n={},r=0;r<e.length;r++){var o=e[r];n[o[t]]=o}return n}function W(e){if(e&&e.constructor===String)return e.toLowerCase();if(e.constructor===Array)for(var t=0;t<e.length;t++)e[t]=W(e[t]);return e}function z(e,t,n,r){if(Array.isArray(e))for(var o=0,i=e.length;o<i;o++)l(e,t,o,n);else for(var a in e)r&&-1!==r.indexOf(a)||l(e,t,a,n);return t}function l(e,t,n,r){var o;r?(o=e[n],Array.isArray(o)?(t[n]||(t[n]=[]),z(o,t[n],r)):o instanceof Object?(t[n]||(t[n]={}),z(o,t[n],r)):t[n]=o):t[n]=e[n]}function c(e,t,n){var r=2<arguments.length&&void 0!==n?n:{},r=Object.assign({path:"/",SameSite:"lax","max-age":864e7},r);if(encodeURIComponent){var o,i=encodeURIComponent(e)+"="+encodeURIComponent(t);for(o in r){i+="; "+o;var a=r[o];!0!==a&&(i+="="+a)}document.cookie=i}}function s(e,t){c(e,"",{path:1<arguments.length&&void 0!==t?t:"/","max-age":-1})}function u(e){return!!function(e){e+="=";var t=document.cookie,r=void 0;return t.split("; ").forEach(function(t){if(void 0===r){var n=void 0;try{decodeURIComponent&&(n=decodeURIComponent(t))}catch(e){n=t,ZWAF&&ZWAF.logger&&ZWAF.logger.warn&&ZWAF.logger.warn("Error while trying to decode Cookie value!")}0===n.indexOf(e)&&(r=n.substring(e.length))}}),r}(e)}"7.0.0"!==o.version||o.Console||o.defineProperty(o,"Console",t,!0,!1,!1,!0),o["7_0_0"].Console||o.defineProperty(o["7_0_0"],"Console",t,!0,!1,!1,!0);["_zcsr_tmp","com_chat_owner","com_avcliq_owner","wms.agent"].some(u)&&o&&o["7_0_0"]&&o["7_0_0"].Console&&o["7_0_0"].Console.log();var d="_zwaf_ua",i={init:function(){s(d);var e=!!window.ulaa,t=navigator&&navigator.brave&&"function"==typeof navigator.brave.isBrave;e?c(d,"Ulaa"):t?c(d,"Brave"):window&&window.addEventListener("load",function(){window.setTimeout(function(){window.getComputedStyle(window.document.documentElement).getPropertyValue("--arc-palette-background")&&c(d,"Arc")},1e3)})},disable:function(){s(d)}};"7.0.0"!==o.version||o.UAIdentification||o.defineProperty(o,"UAIdentification",i,!0,!1,!1,!0),o["7_0_0"].UAIdentification||o.defineProperty(o["7_0_0"],"UAIdentification",i,!0,!1,!1,!0),o&&o["7_0_0"]&&o["7_0_0"].UAIdentification&&o["7_0_0"].UAIdentification.init();var f,p=Object.hasOwnProperty,m=Object.setPrototypeOf,A=Object.isFrozen,T=Object.getPrototypeOf,_=Object.getOwnPropertyDescriptor,je=Object.freeze,t=Object.seal,E=Object.create,i="undefined"!=typeof Reflect&&Reflect,h=(h=i.apply)||function(e,t,n){return e.apply(t,n)},je=je||function(e){return e},t=t||function(e){return e},N=(N=i.construct)||function(e,t){return new(Function.prototype.bind.apply(e,[null].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t))))},Xe=g(Array.prototype.forEach),Ye=g(Array.prototype.pop),Ke=g(Array.prototype.push),Qe=g(String.prototype.toLowerCase),qe=g(String.prototype.toString),Ze=g(String.prototype.match),$e=g(String.prototype.replace),Je=g(String.prototype.indexOf),et=g(String.prototype.trim),tt=g(RegExp.prototype.test),nt=(f=TypeError,function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return N(f,t)});function rt(e){return"number"==typeof e&&isNaN(e)}function g(o){return function(e){for(var t=arguments.length,n=Array(1<t?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return h(o,e,n)}}function ot(e,t,n){n=n||Qe,m&&m(e,null);for(var r=t.length;r--;){var o,i=t[r];"string"!=typeof i||(o=n(i))!==i&&(A(t)||(t[r]=o),i=o),e[i]=!0}return e}function it(e){var t=E(null),n=void 0;for(n in e)!0===h(p,e,[n])&&(t[n]=e[n]);return t}function at(e,t){for(;null!==e;){var n=_(e,t);if(n){if(n.get)return g(n.get);if("function"==typeof n.value)return g(n.value)}e=T(e)}return function(e){return null}}var lt=je(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),ct=je(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),st=je(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),ut=je(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),dt=je(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),ft=je(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),pt=je(["#text"]),mt=je(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),At=je(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),Tt=je(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),_t=je(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),Et=t(/\{\{[\w\W]*|[\w\W]*\}\}/gm),ht=t(/<%[\w\W]*|[\w\W]*%>/gm),Nt=t(/\${[\w\W]*}/gm),gt=t(/^data-[\-\w.\u00B7-\uFFFF]/),Lt=t(/^aria-[\-\w]+$/),Rt=t(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),St=t(/^(?:\w+script|data):/i),Ot=t(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),yt=t(/^html$/i),vt=t(/^[a-z][.\w]*(-[.\w]+)+$/i),It="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function wt(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var bt=function(){return"undefined"==typeof window?null:window},Dt=function(e,t){if("object"!==(void 0===e?"undefined":It(e))||"function"!=typeof e.createPolicy)return null;var n=null,r="data-tt-policy-suffix",n="dompurify"+((n=t.currentScript&&t.currentScript.hasAttribute(r)?t.currentScript.getAttribute(r):n)?"#"+n:"");try{return e.createPolicy(n,{createHTML:function(e){return e},createScriptURL:function(e){return e}})}catch(e){return null}};var i=function t(e){function u(e){return t(e)}var c=0<arguments.length&&void 0!==e?e:bt();if(u.version="2.5.4",u.removed=[],!c||!c.document||9!==c.document.nodeType)return u.isSupported=!1,u;var s=c.document,o=c.document,d=c.DocumentFragment,n=c.HTMLTemplateElement,f=c.Node,l=c.Element,r=c.NodeFilter,e=c.NamedNodeMap,i=void 0===e?c.NamedNodeMap||c.MozNamedAttrMap:e,a=c.HTMLFormElement,p=c.DOMParser,m=c.trustedTypes,e=l.prototype,A=at(e,"cloneNode"),T=at(e,"nextSibling"),_=at(e,"childNodes"),E=at(e,"parentNode");"function"!=typeof n||(g=o.createElement("template")).content&&g.content.ownerDocument&&(o=g.content.ownerDocument);var h=Dt(m,s),N=h?h.createHTML(""):"",g=o,L=g.implementation,R=g.createNodeIterator,S=g.createDocumentFragment,O=g.getElementsByTagName,y=s.importNode,g={};try{g=it(o).documentMode?o.documentMode:{}}catch(e){}var v={};u.isSupported="function"==typeof E&&L&&void 0!==L.createHTMLDocument&&9!==g;function I(e){return e instanceof RegExp||e instanceof Function}function w(e){ye&&ye===e||(e=it(e=e&&"object"===(void 0===e?"undefined":It(e))?e:{}),Re=-1===Se.indexOf(e.PARSER_MEDIA_TYPE)?"text/html":e.PARSER_MEDIA_TYPE,Oe="application/xhtml+xml"===Re?qe:Qe,B="ALLOWED_TAGS"in e?ot({},e.ALLOWED_TAGS,Oe):H,W="ALLOWED_ATTR"in e?ot({},e.ALLOWED_ATTR,Oe):z,ge="ALLOWED_NAMESPACES"in e?ot({},e.ALLOWED_NAMESPACES,qe):Le,me="ADD_URI_SAFE_ATTR"in e?ot(it(Ae),e.ADD_URI_SAFE_ATTR,Oe):Ae,fe="ADD_DATA_URI_TAGS"in e?ot(it(pe),e.ADD_DATA_URI_TAGS,Oe):pe,ue="FORBID_CONTENTS"in e?ot({},e.FORBID_CONTENTS,Oe):de,X="FORBID_TAGS"in e?ot({},e.FORBID_TAGS,Oe):{},Y="FORBID_ATTR"in e?ot({},e.FORBID_ATTR,Oe):{},b="USE_PROFILES"in e&&e.USE_PROFILES,K=!1!==e.ALLOW_ARIA_ATTR,Q=!1!==e.ALLOW_DATA_ATTR,q=e.ALLOW_UNKNOWN_PROTOCOLS||!1,Z=!1!==e.ALLOW_SELF_CLOSE_IN_ATTR,$=e.SAFE_FOR_TEMPLATES||!1,J=!1!==e.SAFE_FOR_XML,ee=e.WHOLE_DOCUMENT||!1,re=e.RETURN_DOM||!1,oe=e.RETURN_DOM_FRAGMENT||!1,ie=e.RETURN_TRUSTED_TYPE||!1,V=!1!==e.DONT_TRIM,ne=e.FORCE_BODY||!1,ae=!1!==e.SANITIZE_DOM,le=e.SANITIZE_NAMED_PROPS||!1,ce=!1!==e.KEEP_CONTENT,se=e.IN_PLACE||!1,G=e.ALLOWED_URI_REGEXP||G,he=e.NAMESPACE||Ee,j=e.CUSTOM_ELEMENT_HANDLING||{},e.CUSTOM_ELEMENT_HANDLING&&I(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(j.tagNameCheck=e.CUSTOM_ELEMENT_HANDLING.tagNameCheck),e.CUSTOM_ELEMENT_HANDLING&&I(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(j.attributeNameCheck=e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),e.CUSTOM_ELEMENT_HANDLING&&"boolean"==typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(j.allowCustomizedBuiltInElements=e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),$&&(Q=!1),oe&&(re=!0),b&&(B=ot({},[].concat(wt(pt))),W=[],!0===b.html&&(ot(B,lt),ot(W,mt)),!0===b.svg&&(ot(B,ct),ot(W,At),ot(W,_t)),!0===b.svgFilters&&(ot(B,st),ot(W,At),ot(W,_t)),!0===b.mathMl&&(ot(B,dt),ot(W,Tt),ot(W,_t))),e.ADD_TAGS&&ot(B=B===H?it(B):B,e.ADD_TAGS,Oe),e.ADD_ATTR&&ot(W=W===z?it(W):W,e.ADD_ATTR,Oe),e.ADD_URI_SAFE_ATTR&&ot(me,e.ADD_URI_SAFE_ATTR,Oe),e.FORBID_CONTENTS&&ot(ue=ue===de?it(ue):ue,e.FORBID_CONTENTS,Oe),ce&&(B["#text"]=!0),ee&&ot(B,["html","head","body"]),B.table&&(ot(B,["tbody"]),delete X.tbody),je&&je(e),ye=e)}var b,D=Et,C=ht,U=Nt,P=gt,x=Lt,k=St,M=Ot,F=vt,G=Rt,B=null,H=ot({},[].concat(wt(lt),wt(ct),wt(st),wt(dt),wt(pt))),V=!0,W=null,z=ot({},[].concat(wt(mt),wt(At),wt(Tt),wt(_t))),j=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),X=null,Y=null,K=!0,Q=!0,q=!1,Z=!0,$=!1,J=!0,ee=!1,te=!1,ne=!1,re=!1,oe=!1,ie=!1,ae=!0,le=!1,ce=!0,se=!1,ue=null,de=ot({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),fe=null,pe=ot({},["audio","video","img","source","image","track"]),me=null,Ae=ot({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),Te="http://www.w3.org/1998/Math/MathML",_e="http://www.w3.org/2000/svg",Ee="http://www.w3.org/1999/xhtml",he=Ee,Ne=!1,ge=null,Le=ot({},[Te,_e,Ee],qe),Re=void 0,Se=["application/xhtml+xml","text/html"],Oe=void 0,ye=null,ve=o.createElement("form"),Ie=ot({},["mi","mo","mn","ms","mtext"]),we=ot({},["foreignobject","annotation-xml"]),be=ot({},["title","style","font","a","script"]),De=ot({},ct);ot(De,st),ot(De,ut);var Ce=ot({},dt);ot(Ce,ft);function Ue(t){Ke(u.removed,{element:t});try{t.parentNode.removeChild(t)}catch(e){try{t.outerHTML=N}catch(e){t.remove()}}}function Pe(e,t){try{Ke(u.removed,{attribute:t.getAttributeNode(e),from:t})}catch(e){Ke(u.removed,{attribute:null,from:t})}if(t.removeAttribute(e),"is"===e&&!W[e])if(re||oe)try{Ue(t)}catch(e){}else try{t.setAttribute(e,"")}catch(e){}}function xe(e){var t=void 0,n=void 0;ne?e="<remove></remove>"+e:n=(r=Ze(e,/^[\r\n\t ]+/))&&r[0],"application/xhtml+xml"===Re&&he===Ee&&(e='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+e+"</body></html>");var r=h?h.createHTML(e):e;if(he===Ee)try{t=(new p).parseFromString(r,Re)}catch(e){}if(!t||!t.documentElement){t=L.createDocument(he,"template",null);try{t.documentElement.innerHTML=Ne?N:r}catch(e){}}return r=t.body||t.documentElement,e&&n&&r.insertBefore(o.createTextNode(n),r.childNodes[0]||null),he===Ee?O.call(t,ee?"html":"body")[0]:ee?t.documentElement:r}function ke(e){return R.call(e.ownerDocument||e,e,r.SHOW_ELEMENT|r.SHOW_COMMENT|r.SHOW_TEXT|r.SHOW_PROCESSING_INSTRUCTION|r.SHOW_CDATA_SECTION,null,!1)}function Me(e){return e instanceof a&&(void 0!==e.__depth&&"number"!=typeof e.__depth||void 0!==e.__removalCount&&"number"!=typeof e.__removalCount||"string"!=typeof e.nodeName||"string"!=typeof e.textContent||"function"!=typeof e.removeChild||!(e.attributes instanceof i)||"function"!=typeof e.removeAttribute||"function"!=typeof e.setAttribute||"string"!=typeof e.namespaceURI||"function"!=typeof e.insertBefore||"function"!=typeof e.hasChildNodes)}function Fe(e){return"object"===(void 0===f?"undefined":It(f))?e instanceof f:e&&"object"===(void 0===e?"undefined":It(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName}function Ge(e,t,n){v[e]&&Xe(v[e],function(e){e.call(u,t,n,ye)})}function Be(e){var t;if(Ge("beforeSanitizeElements",e,null),Me(e))return Ue(e),1;if(tt(/[\u0080-\uFFFF]/,e.nodeName))return Ue(e),1;var n=Oe(e.nodeName);if(Ge("uponSanitizeElement",e,{tagName:n,allowedTags:B}),e.hasChildNodes()&&!Fe(e.firstElementChild)&&(!Fe(e.content)||!Fe(e.content.firstElementChild))&&tt(/<[/\w]/g,e.innerHTML)&&tt(/<[/\w]/g,e.textContent))return Ue(e),1;if("select"===n&&tt(/<template/i,e.innerHTML))return Ue(e),1;if(7===e.nodeType)return Ue(e),1;if(J&&8===e.nodeType&&tt(/<[/\w]/g,e.data))return Ue(e),1;if(B[n]&&!X[n])return e instanceof l&&!function(e){var t=E(e);t&&t.tagName||(t={namespaceURI:he,tagName:"template"});var n=Qe(e.tagName),r=Qe(t.tagName);return ge[e.namespaceURI]&&(e.namespaceURI===_e?t.namespaceURI===Ee?"svg"===n:t.namespaceURI===Te?"svg"===n&&("annotation-xml"===r||Ie[r]):Boolean(De[n]):e.namespaceURI===Te?t.namespaceURI===Ee?"math"===n:t.namespaceURI===_e?"math"===n&&we[r]:Boolean(Ce[n]):e.namespaceURI===Ee?(t.namespaceURI!==_e||we[r])&&(t.namespaceURI!==Te||Ie[r])&&!Ce[n]&&(be[n]||!De[n]):"application/xhtml+xml"===Re&&ge[e.namespaceURI])}(e)||("noscript"===n||"noembed"===n||"noframes"===n)&&tt(/<\/no(script|embed|frames)/i,e.innerHTML)?(Ue(e),1):($&&3===e.nodeType&&(t=e.textContent,t=$e(t,D," "),t=$e(t,C," "),t=$e(t,U," "),e.textContent!==t&&(Ke(u.removed,{element:e.cloneNode()}),e.textContent=t)),Ge("afterSanitizeElements",e,null),0);if(!X[n]&&ze(n)){if(j.tagNameCheck instanceof RegExp&&tt(j.tagNameCheck,n))return;if(j.tagNameCheck instanceof Function&&j.tagNameCheck(n))return}if(ce&&!ue[n]){var r=E(e)||e.parentNode,o=_(e)||e.childNodes;if(o&&r)for(var i=o.length-1;0<=i;--i){var a=A(o[i],!0);a.__removalCount=(e.__removalCount||0)+1,r.insertBefore(a,T(e))}}return Ue(e),1}function He(e,t,n){if(ae&&("id"===t||"name"===t)&&(n in o||n in ve||"__depth"===n||"__removalCount"===n))return!1;if((!Q||Y[t]||!tt(P,t))&&(!K||!tt(x,t)))if(!W[t]||Y[t]){if(!(ze(e)&&(j.tagNameCheck instanceof RegExp&&tt(j.tagNameCheck,e)||j.tagNameCheck instanceof Function&&j.tagNameCheck(e))&&(j.attributeNameCheck instanceof RegExp&&tt(j.attributeNameCheck,t)||j.attributeNameCheck instanceof Function&&j.attributeNameCheck(t))||"is"===t&&j.allowCustomizedBuiltInElements&&(j.tagNameCheck instanceof RegExp&&tt(j.tagNameCheck,n)||j.tagNameCheck instanceof Function&&j.tagNameCheck(n))))return!1}else if(!me[t]&&!tt(G,$e(n,M,""))&&("src"!==t&&"xlink:href"!==t&&"href"!==t||"script"===e||0!==Je(n,"data:")||!fe[e])&&(!q||tt(k,$e(n,M,"")))&&n)return!1;return!0}function Ve(e){var t,n=void 0,r=void 0,o=void 0;Ge("beforeSanitizeAttributes",e,null);var i=e.attributes;if(i){for(var a={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:W,nodeName:e.nodeName.toLowerCase()},o=i.length;o--;){var l=(n=i[o]).name,c=n.namespaceURI,r="value"===l?n.value:et(n.value);if(V&&(r=n.value),t=Oe(l),a.attrName=t,a.attrValue=r,a.keepAttr=!0,a.keepElement=!0,a.forceKeepAttr=void 0,Ge("uponSanitizeAttribute",e,a),!a.keepElement)return 1;if(r=a.attrValue,!a.forceKeepAttr&&(Pe(l,e),a.keepAttr))if(Z||!tt(/\/>/i,r))if(J&&tt(/((--!?|])>)|<\/(style|title)/i,r))Pe(l,e);else{$&&(r=$e(r,D," "),r=$e(r,C," "),r=$e(r,U," "));var s=e.nodeName.toLowerCase();if(He(s,t,r)){if(!le||"id"!==t&&"name"!==t||(Pe(l,e),r="user-content-"+r),h&&"object"===(void 0===m?"undefined":It(m))&&"function"==typeof m.getAttributeType&&!c)switch(m.getAttributeType(s,t)){case"TrustedHTML":r=h.createHTML(r);break;case"TrustedScriptURL":r=h.createScriptURL(r)}try{c?e.setAttributeNS(c,l,r):e.setAttribute(l,r),Me(e)?Ue(e):Ye(u.removed)}catch(e){}}}else Pe(l,e)}return Ge("afterSanitizeAttributes",e,null),0}}function We(e){var t,n=void 0,r=ke(e);for(Ge("beforeSanitizeShadowDOM",e,null);n=r.nextNode();)Ge("uponSanitizeShadowNode",n,null),Be(n)||(t=E(n),1===n.nodeType&&(t&&t.__depth?n.__depth=(n.__removalCount||0)+t.__depth+1:n.__depth=1),(255<=n.__depth||rt(n.__depth))&&Ue(n),n.content instanceof d&&(n.content.__depth=n.__depth,We(n.content)),Ve(n)&&Ue(n));Ge("afterSanitizeShadowDOM",e,null)}var ze=function(e){return"annotation-xml"!==e&&Ze(e,F)};return u.sanitize=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=void 0,r=void 0,o=void 0,i=void 0;if("string"!=typeof(e=(Ne=!e)?"\x3c!--\x3e":e)&&!Fe(e)){if("function"!=typeof e.toString)throw nt("toString is not a function");if("string"!=typeof(e=e.toString()))throw nt("dirty is not a string, aborting")}if(!u.isSupported){if("object"===It(c.toStaticHTML)||"function"==typeof c.toStaticHTML){if("string"==typeof e)return c.toStaticHTML(e);if(Fe(e))return c.toStaticHTML(e.outerHTML)}return e}if(te||w(t),u.removed=[],se="string"!=typeof e&&se){if(e.nodeName&&(t=Oe(e.nodeName),!B[t]||X[t]))throw nt("root node is forbidden and cannot be sanitized in-place")}else if(e instanceof f)1===(t=(n=xe("\x3c!----\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===t.nodeName||"HTML"===t.nodeName?n=t:n.appendChild(t);else{if(!re&&!$&&!ee&&-1===e.indexOf("<"))return h&&ie?h.createHTML(e):e;if(!(n=xe(e)))return re?null:ie?N:""}n&&ne&&Ue(n.firstChild);for(var a,l=ke(se?e:n);r=l.nextNode();)3===r.nodeType&&r===o||Be(r)||(a=E(r),1===r.nodeType&&(a&&a.__depth?r.__depth=(r.__removalCount||0)+a.__depth+1:r.__depth=1),(255<=r.__depth||rt(r.__depth))&&Ue(r),r.content instanceof d&&(r.content.__depth=r.__depth,We(r.content)),Ve(r)?Ue(r):o=r);if(o=null,se)return e;if(re){if(oe)for(i=S.call(n.ownerDocument);n.firstChild;)i.appendChild(n.firstChild);else i=n;return i=W.shadowroot||W.shadowrootmod?y.call(s,i,!0):i}return e=ee?n.outerHTML:n.innerHTML,ee&&B["!doctype"]&&n.ownerDocument&&n.ownerDocument.doctype&&n.ownerDocument.doctype.name&&tt(yt,n.ownerDocument.doctype.name)&&(e="<!DOCTYPE "+n.ownerDocument.doctype.name+">\n"+e),$&&(e=$e(e,D," "),e=$e(e,C," "),e=$e(e,U," ")),h&&ie?h.createHTML(e):e},u.setConfig=function(e){w(e),te=!0},u.clearConfig=function(){ye=null,te=!1},u.isValidAttribute=function(e,t,n){return ye||w({}),e=Qe(e),t=Qe(t),He(e,t,n)},u.addHook=function(e,t){"function"==typeof t&&(v[e]=v[e]||[],Ke(v[e],t))},u.removeHook=function(e){if(v[e])return Ye(v[e])},u.removeHooks=function(e){v[e]&&(v[e]=[])},u.removeAllHooks=function(){v={}},u}(),j=(Object.seal||function(e){return e})(/\$\{[A-Z._]+?\}/i);function X(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var Y=Object.freeze;t={FORCE_BODY:!0,ALLOWED_URI_REGEXP:!1,REUSE_CONFIG:!1,REMOVE_ONEVENTS:!0,EXTENDS:["GLOBAL_TAGS","GLOBAL_ATTR","FORBID_TAGS","FORBID_ATTR","TAG_RULES","GLOBAL_ATTR_RULES","GLOBAL_APPEND_ATTR","ADD_DATA_URI_TAGS","ADD_URI_SAFE_ATTR"],ALLOWED_STYLE:"NONE",STYLE_RULES:{FORBID_PROPS:[],FORBID_CSSRULES:[],UNSAFE_PROP_RULES:{}}};t.GLOBAL_TAGS="a|abbr|acronym|address|area|article|aside|audio|b|bdi|bdo|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|decorator|del|details|dfn|dir|div|dl|dt|element|em|fieldset|figcaption|figure|font|footer|form|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|img|input|ins|kbd|label|legend|li|main|map|mark|marquee|menu|menuitem|meter|nav|nobr|ol|optgroup|option|output|p|pre|progress|q|rp|rt|ruby|s|samp|section|select|shadow|small|source|spacer|span|strike|strong|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|#text".split("|"),t.GLOBAL_ATTR="accept|action|align|alt|autocomplete|background|bgcolor|border|cellpadding|cellspacing|checked|cite|class|clear|color|cols|colspan|coords|datetime|default|dir|disabled|download|enctype|face|for|headers|height|hidden|high|href|hreflang|id|ismap|label|lang|list|loop|low|max|maxlength|media|method|min|multiple|name|noshade|novalidate|nowrap|open|optimum|pattern|placeholder|poster|preload|pubdate|radiogroup|readonly|rel|required|rev|reversed|role|rows|rowspan|spellcheck|scope|selected|shape|size|span|srclang|start|src|step|summary|tabindex|title|target|type|usemap|valign|value|width|xmlns|sandbox".split("|"),t.FORBID_TAGS=[],t.FORBID_ATTR=[],t.GLOBAL_ATTR_RULES={},t.GLOBAL_APPEND_ATTR={},t.ADD_DATA_URI_TAGS=[],t.ADD_URI_SAFE_ATTR=[],t.TAG_RULES={a:{APPEND_ATTR:{rel:{ATTR_NAME:"rel",APPEND_ATTR_VALUE:"noopener noreferrer",SIBLING_CONDITIONS:[{ATTR_NAME:"target",CONDITIONS:[{IS_MANDATORY:"true",CONTAINS:"_blank"}]}]}}}},t.TAG_SPECIFIC_ATTRS={};i=function t(_,n){var E="GLOBAL_TAGS",h="GLOBAL_ATTR",N="GLOBAL_ATTRIBUTES",g="FORBID_TAGS",L="FORBID_ATTR",R="TAG_RULES",S="STYLE_RULES",O="GLOBAL_ATTR_RULES",y="GLOBAL_APPEND_ATTR",v="ADD_DATA_URI_TAGS",I="ADD_URI_SAFE_ATTR",e="REMOVE_ONEVENTS",o=["ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","RETURN_DOM","RETURN_DOM_FRAGMENT","IN_PLACE","DONT_TRIM","FORCE_BODY","SANITIZE_DOM","KEEP_CONTENT","ALLOWED_URI_REGEXP"],w=[];H(w,o),H(w,["EXTENDS",e,"ALLOWED_STYLE"]);var r={iframe:{ATTR_RULES:{sandbox:{FALLBACK_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin",CONDITIONS:[{NOT_CONTAINS:["allow-top-navigation","allow-popups-to-escape-sandbox"]}]}},APPEND_ATTR:{sandbox:{APPEND_ATTR_VALUE:"allow-popups allow-forms allow-scripts allow-same-origin"}}},embed:{ATTR_RULES:{type:{CONDITIONS:[{EQUAL:"application/pdf",FALLBACK_VALUE:"application/pdf"}]}},APPEND_ATTR:{type:{APPEND_ATTR_VALUE:"application/pdf"},typemustmatch:{APPEND_ATTR_VALUE:"true"}}},object:{ATTR_RULES:{type:{CONDITIONS:[{EQUAL:"application/pdf",FALLBACK_VALUE:"application/pdf"}]}},APPEND_ATTR:{type:{APPEND_ATTR_VALUE:"application/pdf"},typemustmatch:{APPEND_ATTR_VALUE:"true"}}}},i=void 0,a=void 0,l=void 0,c=_.GLOBAL_TAGS,b=_.GLOBAL_ATTR,s=_.FORBID_TAGS,u=_.FORBID_ATTR,D=_.TAG_RULES,d=_.STYLE_RULES,f=_.GLOBAL_ATTR_RULES,p=_.GLOBAL_APPEND_ATTR,C=_.TAG_SPECIFIC_ATTRS,U=d.FORBID_PROPS,P=d.FORBID_CSSRULES,x=d.UNSAFE_PROP_RULES,m=U&&0!==U.length||P&&0!==P.length;function A(i){if(!i||i.constructor!==Object)return z(_,i={},!0),i;i[R]||(i[R]={}),i[O]||(i[O]={}),i[y]||(i[y]={}),i[v]||(i[v]=[]),i[I]||(i[I]=[]),i[E]||(i[E]=[]),i[h]||(i[h]=[]),i[N]||(i[N]=[]),i[g]||(i[g]=[]),i[L]||(i[L]=[]),i[S]||(i[S]={}),i[S].FORBID_CSSRULES||(i[S].FORBID_CSSRULES=[]),i[S].FORBID_PROPS||(i[S].FORBID_PROPS=[]),i[S].UNSAFE_PROP_RULES||(i[S].UNSAFE_PROP_RULES={}),i.TAG_SPECIFIC_ATTRS={};for(var e=0;e<w.length;e++){var t=w[e];void 0===i[t]&&(i[t]=_[t])}i[R]=V(i[R],"NAME"),i[O]=V(i[O],"ATTR_NAME"),i[y]=V(i[y],"APPEND_ATTR_NAME");var n=i,a=n.TAG_RULES,r=n.TAG_SPECIFIC_ATTRS,o=n.STYLE_RULES,l=n.GLOBAL_ATTR,c=n.GLOBAL_ATTRIBUTES,s=n.GLOBAL_ATTR_RULES,u=n.GLOBAL_APPEND_ATTR,d=n.EXTENDS,f=o.FORBID_CSSRULES,p=o.FORBID_PROPS,m=o.UNSAFE_PROP_RULES;B(u,function(e,t){F(t)}),B(s,function(e,t){F(t)});for(var A=function(e){var n,t,r=d[e];switch(r){case h:var o=[];H(o,b),B(C,function(e){-1<(e=o.indexOf(e))&&o.splice(e,1)}),H(l,c),H(l,o);break;case E:case g:case L:case v:case I:H(i[r],_[r]);break;case R:n=a,(t=D)&&t.constructor===Object&&B(t,function(e,t){e in n?(void 0===n[e].APPEND_ATTR&&(n[e].APPEND_ATTR=t.APPEND_ATTR),void 0===n[e].ATTR_RULES&&(n[e].ATTR_RULES=t.ATTR_RULES)):n[e]=t});break;case y:case O:B(_[r],function(e){i[r][e]||(i[r][e]={},z(_[r][e],i[r][e],!0))});break;case S:p.push.apply(p,X(U)),f.push.apply(f,X(P)),B(x,function(e){m[e]||(m[e]={},z(x[e],m[e],!0))})}},T=0;T<d.length;T++)A(T);return B(s,function(e){-1===l.indexOf(e)&&(l.push(e),r[e]&&r[e].constructor===Array||(r[e]=[]),-1===r[e].indexOf("*")&&r[e].push("*"))}),B(a,function(n,e){n=W(n),e.APPEND_ATTR||(e.APPEND_ATTR={}),e.APPEND_ATTR=V(e.APPEND_ATTR,"APPEND_ATTR_NAME"),B(e.APPEND_ATTR,function(e,t){F(t)}),e.ATTR_RULES||(e.ATTR_RULES={}),e.ATTR_RULES=V(e.ATTR_RULES,"ATTR_NAME"),B(e.ATTR_RULES,function(e,t){F(t),e=W(e),(-1===l.indexOf(e)||r[e]&&0<r[e].length)&&(-1===l.indexOf(e)&&l.push(e),r[e]&&r[e].constructor===Array||(r[e]=[]),-1===r[e].indexOf(n)&&r[e].push(n))})}),delete i.USE_PROFILES,i}function T(e,t,n){if(e.constructor===String){if(t.CASE_SENSITIVE||(e=e.toLowerCase()),t.DONT_TRIM||(e=e.trim()),t.MAX_LENGTH&&e.length>t.MAX_LENGTH)return!1;if(t.MIN_LENGTH&&e.length<t.MIN_LENGTH)return!1;if(t.REGEX&&t.REGEX.constructor===RegExp&&-1===e.search(t.REGEX))return!1;if(t.REGEX&&t.REGEX.constructor===String&&(new RegExp(t.REGEX),-1===e.search(t.REGEX)))return!1;if(t.REGEX&&t.REGEX.constructor===Array)for(var r=0;r<t.REGEX.length;r++)if(-1===e.search(t.REGEX[r]))return!1;if(t.VALIDATOR&&t.VALIDATOR.HANDLER&&!t.VALIDATOR.HANDLER(e,t.VALIDATOR.CONFIG,n))return!1;if(void 0!==t.STARTS_WITH&&0!==e.indexOf(t.STARTS_WITH))return!1;if(void 0!==t.ENDS_WITH&&e.lastIndexOf(t.ENDS_WITH)!==e.length-t.ENDS_WITH.length)return!1;if(t.CONTAINS&&t.CONTAINS.constructor===String&&-1===e.indexOf(t.CONTAINS))return!1;if(t.CONTAINS&&t.CONTAINS.constructor===Array)for(var o=0;o<t.CONTAINS.length;o++)if(-1===e.indexOf(t.CONTAINS[o]))return!1;if(t.NOT_CONTAINS&&t.NOT_CONTAINS.constructor===String&&-1<e.indexOf(t.NOT_CONTAINS))return!1;if(t.NOT_CONTAINS&&t.NOT_CONTAINS.constructor===Array)for(var i=0;i<t.NOT_CONTAINS.length;i++)if(-1<e.indexOf(t.NOT_CONTAINS[i]))return!1;if(void 0!==t.EQUAL&&e!=t.EQUAL)return!1;if(void 0!==t.NOT_EQUAL&&e==t.NOT_EQUAL)return!1}if(t.LIST&&-1===t.LIST.indexOf(e))return!1;if("INTEGER"===t.TYPE||"FLOAT"===t.TYPE){n=void 0;try{n="INTEGER"===t.TYPE?window.parseInt(e,10):window.parseFloat(e)}catch(e){return!1}if(window.isNaN(n))return!1;if(void 0!==t.GREATER_THAN&&n<=t.GREATER_THAN)return!1;if(void 0!==t.GREATER_THAN_OR_EQUAL&&n<t.GREATER_THAN_OR_EQUAL)return!1;if(void 0!==t.LESSER_THAN&&n>=t.LESSER_THAN)return!1;if(void 0!==t.LESSER_THAN_OR_EQUAL&&n>t.LESSER_THAN_OR_EQUAL)return!1;if(void 0!==t.EQUAL&&n!==t.EQUAL)return!1;if(void 0!==t.NOT_EQUAL&&n===t.NOT_EQUAL)return!1}return!0}function k(e,t,n){var r=!0;if(!t||!t.CONDITIONS||0===t.CONDITIONS.length)return{isValid:r,rule:t};n=t.ATTR_NAME||n;for(var o,i,a,l,c=0;c<t.CONDITIONS.length;c++){var s=t.CONDITIONS[c];if(o=e,i=n,l=void 0,l=!1!==(a=s).IS_MANDATORY,r=i&&!o.hasAttribute(i.toLowerCase())?a.IS_FORBIDDEN||!l:!a.IS_FORBIDDEN&&T(o=null==(o=o.getAttribute(i.toLowerCase()))?"":o,a,i),r=s.NEGATION?!r:r){if(s.NEXT)return k(e,s.NEXT,n);break}}return{isValid:r,rule:t}}function M(o){B(o,function(e,t){if(t&&t.constructor===String&&(0<U.length&&-1<U.indexOf(e)&&(o[e]="",i=!0),x[e]))for(var n=x[e],r=0;r<n.CONDITIONS.length;r++)if(T(t,n.CONDITIONS[r],e))return o[e]=void 0===n.FALLBACK_VALUE?"":n.FALLBACK_VALUE,i=!0,0})}function F(e){if(e&&(e.CONDITIONS&&0<e.CONDITIONS.length&&(e.CONDITIONS=function(e){if(!e)return e;for(var t=0;t<e.length;t++)e[t]=function(e){if(!e||e&&e.CASE_SENSITIVE)return e;for(var t=["STARTS_WITH","ENDS_WITH","CONTAINS","EQUAL","NOT_EQUAL","LIST"],n=0;n<t.length;n++){var r=t[n];e[r]&&(e[r]=W(e[r]))}return e.NEXT&&F(e.NEXT),e}(e[t]);return e}(e.CONDITIONS)),e.SIBLING_CONDITIONS&&0<e.SIBLING_CONDITIONS.length))for(var t=0;t<e.SIBLING_CONDITIONS.length;t++)F(e.SIBLING_CONDITIONS[t])}m||B(x,function(){m=!0});function G(e){return t(e=A(e),n(window))}return G.sanitize=function(e,t){t=function(n){if(!n||n.constructor!==Object)return _;var r={};return B(_,function(e,t){e in n&&-1!==o.indexOf(e)&&(!0===n[e]||!1===n[e]||n[e]&&n[e].constructor===RegExp)?r[e]=n[e]:r[e]=t}),r.SAFE_FOR_TEMPLATES&&(r.ALLOW_DATA_ATTR=!1),r.RETURN_DOM_FRAGMENT&&(r.RETURN_DOM=!0),r.KEEP_CONTENT&&r.GLOBAL_TAGS.push("#text"),r.ADD_TAGS&&delete r.ADD_TAGS,r.ADD_ATTR&&delete r.ADD_ATTR,r}(t),e=n.sanitize(e,t);return(t=G.removed).splice.apply(t,[0,G.removed.length].concat(X(n.removed))),e},H(s,["script"]),H(u,[]),d=_.ALLOWED_STYLE,n.removeAllHooks(),i=!1,-1===s.indexOf("style")&&s.push("style"),-1===u.indexOf("style")&&u.push("style"),"INLINE"!==d&&"ALL"!==d||(u.splice(u.indexOf("style"),1),-1===b.indexOf("style")&&b.push("style"),m&&n.addHook("uponSanitizeAttribute",function(e,t){var n,r;"style"===t.attrName&&(e.ownerDocument.baseURI||((r=(n=window.document).createElement("base")).href=n.baseURI,e.ownerDocument.head.appendChild(r)),i=!1,M(e.style),0!==(r=e.style.cssText).length?t.attrValue=i?r:e.getAttribute("style"):t.keepAttr=!1)})),"INTERNAL"!==d&&"ALL"!==d||(s.splice(s.indexOf("style"),1),-1===c.indexOf("style")&&c.push("style"),m&&n.addHook("uponSanitizeElement",function(e,t){var n;"style"===t.tagName&&null!==e.sheet&&(n=e.sheet.cssRules,i=!1,function e(t,n){for(var r=t.length-1;0<=r;r--){var o=t[r];0<P.length&&-1<P.indexOf(o.type)?(n.deleteRule(r),i=!0):1===o.type&&o.selectorText||8===o.type&&o.keyText?o.style&&M(o.style):4!==o.type&&7!==o.type&&12!==o.type||!o.cssRules||e(o.cssRules,o)}}(n,e.sheet),i&&(function(e,t){for(var n=t.length-1;0<=n;n--)1!==t[n].type&&3!==t[n].type&&4!==t[n].type&&7!==t[n].type&&12!==t[n].type||e.push(t[n].cssText)}(t=[],n),e.textContent=t.join("\n")))})),(f||D)&&(a={},B(r,function(n,e){a[n]={},B(e.ATTR_RULES,function(e,t){return a[n][e]=t})}),B(a,function(n,e){B(f,function(e,t){return a[n][e]=t})}),B(D,function(n,e){a[n]||(a[n]={}),B(e.ATTR_RULES,function(e,t){return a[n][e]=t})}),n.addHook("uponSanitizeAttribute",function(e,t){var n,r,o=a[t.nodeName]&&a[t.nodeName][t.attrName]||f&&f[t.attrName];o&&(r=(n=k(e,o,t.attrName)).isValid,(o=n.rule)&&o.FORCE_KEEP_ATTR&&(t.forceKeepAttr=!0),r||(n=e,r=t,"REMOVE_ELEMENT"!==(e=o).ACTION?void 0!==e.FALLBACK_VALUE?(t=e.FALLBACK_VALUE,(o=j.exec(e.FALLBACK_VALUE))&&(n=n.getAttribute(e.ATTR_NAME),"${ZWAF.URL_COMPONENT}"===o[0]&&(n=window.encodeURIComponent(n)),t=e.FALLBACK_VALUE.replace(o[0],n)),St.test(t.replace(Ot,""))?r.keepAttr=!1:r.attrValue=t):r.keepAttr=!1:r.keepElement=!1))})),(p||D)&&(l={},B(r,function(n,e){l[n]={},B(e.APPEND_ATTR,function(e,t){return l[n][e]=t})}),B(l,function(n,e){B(f,function(e,t){return l[n][e]=t})}),B(D,function(n,e){l[n]||(l[n]={}),B(e.APPEND_ATTR,function(e,t){return l[n][e]=t})}),n.addHook("afterSanitizeAttributes",function(e){var i,t=e.nodeName.toLowerCase(),n={};B(p,function(e,t){return n[e]=t}),B(l[t],function(e,t){return n[e]=t}),i=e,B(n,function(e,t){if(!i.hasAttribute(e.toLowerCase()))if(t.SIBLING_CONDITIONS&&0!=t.SIBLING_CONDITIONS.length)for(var n=0;n<t.SIBLING_CONDITIONS.length;n++){var r=(o=k(i,t.SIBLING_CONDITIONS[n])).isValid,o=o.rule;if(r)return o=(void 0!==o.APPEND_ATTR_VALUE?o:t).APPEND_ATTR_VALUE,i.setAttribute(e,o),0}else i.setAttribute(e,t.APPEND_ATTR_VALUE)})})),_[e]&&n.addHook("uponSanitizeAttribute",function(e,t){0===t.attrName.indexOf("on")&&(t.keepAttr=!1)}),C&&n.addHook("uponSanitizeAttribute",function(e,t){C[t.attrName]&&-1===C[t.attrName].indexOf(t.nodeName)&&-1===C[t.attrName].indexOf("*")&&(t.keepAttr=!1)}),_.ALLOWED_TAGS=c,_.ALLOWED_ATTR=b,_.GLOBAL_ATTRIBUTES=b,_&&!_.REUSE_CONFIG&&Y&&Y(_),G.isSupported=n.isSupported,G.version=n.version,G.removed=[],G}(t,i);return Y&&Y(i),delete window.DOMPurify,"7.0.0"!==o.version||o.HTMLPurifier||o.defineProperty(o,"HTMLPurifier",i,!0,!1,!1,!0),o["7_0_0"].HTMLPurifier||o.defineProperty(o["7_0_0"],"HTMLPurifier",i,!0,!1,!1,!0),o});
;if(window.DOMPurifyCopy) { window.DOMPurify = window.DOMPurifyCopy; window.DOMPurifyCopy = undefined; };!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):e.ZWAF=r()}(this,function(){"use strict";function e(e,r,o,n,t,i,a){if(n||!(r in e))return Object.defineProperty&&function(){try{return Object.defineProperty({},"x",{}),1}catch(e){return}}()?(t=!0===t,i=!0===i,a=!0===a,Object.defineProperty(e,r,{value:o,writable:t,configurable:i,enumerable:a})):(e[r]=o,e)}var c,u,l=(l=String.prototype.codePointAt)||function(e){if(null===this)throw new TypeError(" ");var r=String(this),o=r.length,n=e?Number(e):0;if(!((n=window.isNan(n)?0:n)<0||o<=n)){var t=r.charCodeAt(n),e=void 0;return 55296<=t&&t<=56319&&n+1<o&&56320<=(e=r.charCodeAt(n+1))&&e<=57343?1024*(t-55296)+e-56320+65536:t}},o=String.fromCodePoint;function n(e,r){for(var o=0;o<r.length;o++){var n=r[o];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}o||(c=String.fromCharCode,u=Math.floor,o=function(){for(var e=[],r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];var t=o.length,i=-1;if(!t)return"";for(var a="";++i<t;){var l=Number(o[i]);if(!isFinite(l)||l<0||1114111<l||u(l)!==l)throw new RangeError("Invalid code point: "+l);l<=65535?e.push(l):(l-=65536,e.push(55296+(l>>10),l%1024+56320)),(i+1===t||16384<e.length)&&(a+=c.apply(void 0,e),e.length=0)}return a});var r=(function(e,r,o){return r&&n(e.prototype,r),o&&n(e,o),e}(t,[{key:"debug",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&this.level===this.LEVELS.DEBUG){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).debug.apply(e,o.concat([performance.now()]))}}},{key:"info",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.INFO)){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).log.apply(e,o.concat([performance.now()]))}}},{key:"warn",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.WARN)){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).warn.apply(e,o.concat([performance.now()]))}}},{key:"error",value:function(){var e;if(window&&window.console&&this.level!==this.LEVELS.NONE&&!(this.level>this.LEVELS.ERROR)){for(var r=arguments.length,o=Array(r),n=0;n<r;n++)o[n]=arguments[n];(e=window.console).error.apply(e,o.concat([performance.now()]))}}}]),t);function t(e){!function(e,r){if(!(e instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t),this.LEVELS={NONE:-1,DEBUG:0,INFO:1,WARN:2,ERROR:3},e===this.LEVELS.NONE||e===this.LEVELS.DEBUG||e===this.LEVELS.INFO||e===this.LEVELS.WARN||e===this.LEVELS.ERROR?this.level=e:this.level=this.LEVELS.ERROR}var i=window&&window.ZWAF?window.ZWAF:{version:"7.0.0"},a=new r;i.defineProperty||(i.defineProperty=e),i.logger||(i.logger=a),i["7_0_0"]||(i["7_0_0"]={version:"7.0.0",defineProperty:e,logger:a});var s=!1,r={log:function(){if(window&&window.console&&window.console.log&&window.navigator&&window.navigator.userAgent&&!s){var e=window.navigator.userAgent.match(/opera|chrome|safari|firefox|msie|trident(?=\/)/i);if(s=!0,e&&e[0].search(/trident|msie/i)<0)return window.console.log("%cSTOP!","color:red;font-size:xx-large;font-weight:bold;"),void window.console.log("%cThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details","font-size:large;");window.console.log("STOP!\nThis is a browser feature intended for developers. Do not enter or paste code which you don't understand. It may allow attackers to steal your information or impersonate you.\nSee https://en.wikipedia.org/wiki/Self-XSS for more details")}}};a=Array.prototype.indexOf||function(e){if(null==this)throw new TypeError(" ");var r={},o=r.length>>>0;if(0==o)return-1;var n=0;if(0<(arguments.length<=1?0:arguments.length-1)&&(n=Number(arguments.length<=2?void 0:arguments[2]),isNaN(n)?n=0:0!==n&&n!==1/0&&n!==-1/0&&(n=(0<n||-1)*Math.floor(Math.abs(n)))),o<=n)return-1;for(var t=0<=n?n:Math.max(o-Math.abs(n),0);t<o;t++)if(t in r&&r.charAt(t)===e)return t;return-1};function d(e,r,o){var n=2<arguments.length&&void 0!==o?o:{},n=Object.assign({path:"/",SameSite:"lax","max-age":864e7},n);if(encodeURIComponent){var t,i=encodeURIComponent(e)+"="+encodeURIComponent(r);for(t in n){i+="; "+t;var a=n[t];!0!==a&&(i+="="+a)}document.cookie=i}}function f(e,r){d(e,"",{path:1<arguments.length&&void 0!==r?r:"/","max-age":-1})}function p(e){return!!function(e){e+="=";var r=document.cookie,n=void 0;return r.split("; ").forEach(function(r){if(void 0===n){var o=void 0;try{decodeURIComponent&&(o=decodeURIComponent(r))}catch(e){o=r,ZWAF&&ZWAF.logger&&ZWAF.logger.warn&&ZWAF.logger.warn("Error while trying to decode Cookie value!")}0===o.indexOf(e)&&(n=o.substring(e.length))}}),n}(e)}"7.0.0"!==i.version||i.Console||i.defineProperty(i,"Console",r,!0,!1,!1,!0),i["7_0_0"].Console||i.defineProperty(i["7_0_0"],"Console",r,!0,!1,!1,!0);["_zcsr_tmp","com_chat_owner","com_avcliq_owner","wms.agent"].some(p)&&i&&i["7_0_0"]&&i["7_0_0"].Console&&i["7_0_0"].Console.log();r={arrayIndexOf:a};Object.freeze&&Object.freeze(r),"7.0.0"!==i.version||i.util||i.defineProperty(i,"util",r,!0,!1,!1,!0),i["7_0_0"].util||i.defineProperty(i["7_0_0"],"util",r,!0,!1,!1,!0);var h="_zwaf_ua",a={init:function(){f(h);var e=!!window.ulaa,r=navigator&&navigator.brave&&"function"==typeof navigator.brave.isBrave;e?d(h,"Ulaa"):r?d(h,"Brave"):window&&window.addEventListener("load",function(){window.setTimeout(function(){window.getComputedStyle(window.document.documentElement).getPropertyValue("--arc-palette-background")&&d(h,"Arc")},1e3)})},disable:function(){f(h)}};"7.0.0"!==i.version||i.UAIdentification||i.defineProperty(i,"UAIdentification",a,!0,!1,!1,!0),i["7_0_0"].UAIdentification||i.defineProperty(i["7_0_0"],"UAIdentification",a,!0,!1,!1,!0),i&&i["7_0_0"]&&i["7_0_0"].UAIdentification&&i["7_0_0"].UAIdentification.init();a={};function g(e){for(var r=[],o=0;o<e.length;o++)r.push(e[o].charCodeAt(0));return r}for(var m=r.arrayIndexOf,w={HTML:g([",",".","-","_"," "]),HTMLATTR:g([",",".","-","_"]),CSS:g([]),JAVASCRIPT:g([",",".","_"])},v={},y=(y="34=&quot|38=&amp|60=&lt|62=&gt|160=&nbsp|161=&iexcl|162=&cent|163=&pound|164=&curren|165=&yen|166=&brvbar|167=&sect|168=&uml|169=&copy|170=&ordf|171=&laquo|172=&not|173=&shy|174=&reg|175=&macr|176=&deg|177=&plusmn|178=&sup2|179=&sup3|180=&acute|181=&micro|182=&para|183=&middot|184=&cedil|185=&sup1|186=&ordm|187=&raquo|188=&frac14|189=&frac12|190=&frac34|191=&iquest|192=&Agrave|193=&Aacute|194=&Acirc|195=&Atilde|196=&Auml|197=&Aring|198=&AElig|199=&Ccedil|200=&Egrave|201=&Eacute|202=&Ecirc|203=&Euml|204=&Igrave|205=&Iacute|206=&Icirc|207=&Iuml|208=&ETH|209=&Ntilde|210=&Ograve|211=&Oacute|212=&Ocirc|213=&Otilde|214=&Ouml|215=&times|216=&Oslash|217=&Ugrave|218=&Uacute|219=&Ucirc|220=&Uuml|221=&Yacute|222=&THORN|223=&szlig|224=&agrave|225=&aacute|226=&acirc|227=&atilde|228=&auml|229=&aring|230=&aelig|231=&ccedil|232=&egrave|233=&eacute|234=&ecirc|235=&euml|236=&igrave|237=&iacute|238=&icirc|239=&iuml|240=&eth|241=&ntilde|242=&ograve|243=&oacute|244=&ocirc|245=&otilde|246=&ouml|247=&divide|248=&oslash|249=&ugrave|250=&uacute|251=&ucirc|252=&uuml|253=&yacute|254=&thorn|255=&yuml|338=&OElig|339=&oelig|352=&Scaron|353=&scaron|376=&Yuml|402=&fnof|710=&circ|732=&tilde|913=&Alpha|914=&Beta|915=&Gamma|916=&Delta|917=&Epsilon|918=&Zeta|919=&Eta|920=&Theta|921=&Iota|922=&Kappa|923=&Lambda|924=&Mu|925=&Nu|926=&Xi|927=&Omicron|928=&Pi|929=&Rho|931=&Sigma|932=&Tau|933=&Upsilon|934=&Phi|935=&Chi|936=&Psi|937=&Omega|945=&alpha|946=&beta|947=&gamma|948=&delta|949=&epsilon|950=&zeta|951=&eta|952=&theta|953=&iota|954=&kappa|955=&lambda|956=&mu|957=&nu|958=&xi|959=&omicron|960=&pi|961=&rho|962=&sigmaf|963=&sigma|964=&tau|965=&upsilon|966=&phi|967=&chi|968=&psi|969=&omega|977=&thetasym|978=&upsih|982=&piv|8194=&ensp|8195=&emsp|8201=&thinsp|8204=&zwnj|8205=&zwj|8206=&lrm|8207=&rlm|8211=&ndash|8212=&mdash|8216=&lsquo|8217=&rsquo|8218=&sbquo|8220=&ldquo|8221=&rdquo|8222=&bdquo|8224=&dagger|8225=&Dagger|8226=&bull|8230=&hellip|8240=&permil|8242=&prime|8243=&Prime|8249=&lsaquo|8250=&rsaquo|8254=&oline|8260=&frasl|8364=&euro|8465=&image|8472=&weierp|8476=&real|8482=&trade|8501=&alefsym|8592=&larr|8593=&uarr|8594=&rarr|8595=&darr|8596=&harr|8629=&crarr|8656=&lArr|8657=&uArr|8658=&rArr|8659=&dArr|8660=&hArr|8704=&forall|8706=&part|8707=&exist|8709=&empty|8711=&nabla|8712=&isin|8713=&notin|8715=&ni|8719=&prod|8721=&sum|8722=&minus|8727=&lowast|8730=&radic|8733=&prop|8734=&infin|8736=&ang|8743=&and|8744=&or|8745=&cap|8746=&cup|8747=&int|8756=&there4|8764=&sim|8773=&cong|8776=&asymp|8800=&ne|8801=&equiv|8804=&le|8805=&ge|8834=&sub|8835=&sup|8836=&nsub|8838=&sube|8839=&supe|8853=&oplus|8855=&otimes|8869=&perp|8901=&sdot|8968=&lceil|8969=&rceil|8970=&lfloor|8971=&rfloor|10216=&lang|10217=&rang|9674=&loz|9824=&spades|9827=&clubs|9829=&hearts|9830=&diams").split("|"),E=0;E<y.length;E++){var A=y[E].split("=");v[A[0]]=A[1]}for(var b=[],S=0;S<255;S++)b[S]=48<=S&&S<=57||65<=S&&S<=90||97<=S&&S<=122?null:S.toString(16);function _(e){return e<256?b[e]:e.toString(16)}function L(e,r){if(-1!==m.call(e,r))return o(r);e=_(r);if(null===e)return o(r);if(r<=31&&9!=r&&10!=r&&13!=r||127<=r&&r<=159||32===r)return"&#x20;";r=v[r];return void 0!==r?r+";":"&#x"+e+";"}function O(e,r){if(-1!==m.call(e,r))return String.fromCharCode(r);if(null===_(r))return String.fromCharCode(r);e=r.toString(16);return r<256?"\\x"+"00".substr(e.length)+e.toUpperCase():"\\u"+"0000".substr(e.length)+e.toUpperCase()}function C(e,r){if(-1!==m.call(e,r))return o(r);e=_(r);return null===e?o(r):"\\"+e+" "}function N(e,r,o,n){if(null==r||"string"!=typeof r)return r;for(var t,i="",a=0;a<r.length;a++)n?(i+=o(e,t=l.call(r,a),n),65535<t&&a++):i+=o(e,r.charCodeAt(a));return i}return a.encodeForHTML=function(e){return N(w.HTML,e,L,!0)},a.encodeForHTMLAttribute=function(e){return N(w.HTMLATTR,e,L,!0)},a.encodeForJavaScript=function(e){return N(w.JAVASCRIPT,e,O,!1)},a.encodeForCSS=function(e){return N(w.CSS,e,C,!0)},Object.freeze&&Object.freeze(a),"7.0.0"!==i.version||i.Encoder||i.defineProperty(i,"Encoder",a,!0,!1,!1,!0),i["7_0_0"].Encoder||i.defineProperty(i["7_0_0"],"Encoder",a,!0,!1,!1,!0),i});
window.ZSEC = window.ZWAF;var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*Polyfills for functions not available in other browsers. */

/*Polyfill for Node.after
//Not supported out of the box in IE and Edge. 
//from: https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/after()/after().md */
(function (arr) {
	arr.forEach(function (item) {
		if (item.hasOwnProperty('after')) {
			return;
		}
		Object.defineProperty(item, 'after', {
			configurable: true,
			enumerable: true,
			writable: true,
			value: function after() {
				var argArr = Array.prototype.slice.call(arguments),
				    docFrag = document.createDocumentFragment();

				argArr.forEach(function (argItem) {
					var isNode = argItem instanceof Node;
					docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
				});

				this.parentNode.insertBefore(docFrag, this.nextSibling);
			}
		});
	});
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

/*Polyfill for replaceWith. 
//Not supported out of the box for IE and Edge. */
function ReplaceWith(Ele) {
	var parent = this.parentNode,
	    i = arguments.length,
	    firstIsNode = +(parent && (typeof Ele === 'undefined' ? 'undefined' : _typeof(Ele)) === 'object');
	if (!parent) {
		return;
	}

	while (i-- > firstIsNode) {
		if (parent && _typeof(arguments[i]) !== 'object') {
			arguments[i] = document.createTextNode(arguments[i]);
		}if (!parent && arguments[i].parentNode) {
			arguments[i].parentNode.removeChild(arguments[i]);
			continue;
		}
		parent.insertBefore(this.previousSibling, arguments[i]);
	}
	if (firstIsNode) {
		parent.replaceChild(this, Ele);
	}
}
if (!Element.prototype.replaceWith) {
	Element.prototype.replaceWith = ReplaceWith;
}
if (!CharacterData.prototype.replaceWith) {
	CharacterData.prototype.replaceWith = ReplaceWith;
}
if (!DocumentType.prototype.replaceWith) {
	DocumentType.prototype.replaceWith = ReplaceWith;
}

/*Polyfill for startsWith
//Not supported out of the box for  IE */
if (!String.prototype.startsWith) {
	String.prototype.startsWith = function (searchString, position) {
		position = position || 0;
		return this.indexOf(searchString, position) === position;
	};
}

/*Polyfill for endsWith
//Not supported out of the box for  IE */
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function (search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	};
}

window.Lyte = {
	version: "3.4.1",
	$: {
		consoleTime: []
	},
	registeredMixins: {},
	registeredServices: {},
	requiredServices: {},
	toBeInjectedServices: {},
	_registeredComponents: {},
	_keywords: {
		"component": ["init", "didConnect", "didDestroy", "constructor", "onError", "actions", "methods", "data"],
		"adapter": ["namespace", "actionNamespace", "host", "withCredentials", "buildURL", "methodForRequest", "headersForRequest", "reloadRecord", "reloadRecord", "reloadAll", "processRequest", "parseResponse", "parseRequest", "super"],
		"serializer": ["normalize", "normalizeResponse", "serialize", "serializeKey", "deserializeKey", "extractMeta", "payloadKey", "serializeRecord", "normalizeRecord", "super"],
		"route": ["getDependencies", "getResources", "beforeModel", "model", "afterModel", "redirect", "renderTemplate", "afterRender", "beforeExit", "didDestroy", "queryParams", "title", "routeName", "component", "parent", "currentModel", "forceFetch", "setTitle", "setQueryParams", "getQueryParams", "setDynamicParam", "getDynamicParam", "removeFromCache", "refresh", "transitionTo", "replaceWith", "actions"],
		"is": function is(key, scope) {
			var arr = ["component", "adapter", "serializer", "route"];
			if (scope) {
				arr = [scope];
			}
			var len = arr.length;
			for (var i = 0; i < len; i++) {
				var keyArr = this[arr[i]];
				if (keyArr) {
					var res = keyArr.indexOf(key);
					if (res != -1) {
						return true;
					}
				}
			}
			return false;
		}
	},
	Mixin: {},
	Service: {},
	debug: false,
	performance: false,
	toBeRegistered: [],
	browser: {},
	registeredCustomComponent: {},
	Globals: {}
};
(function () {
	var userAgent = Lyte.$.userAgent = window.userAgent = navigator.userAgent;
	//temporary fix for IE 11
	if (userAgent.match(/rv:11/)) {
		Lyte.browser.ie = true;
		window.action = function () {
			return;
		};
	}
	if (userAgent.match('Edge')) {
		var s = createElement("div");
		s.innerHTML = "<template><div>c</div></template>";
		if (s.querySelector("template").childNodes.length) {
			Lyte.browser.ie = true;
		} else {
			Lyte.browser.edge = true;
		}
		s.remove();
	}
	Object.defineProperty(Lyte, "__gl", {
		value: {}
	});

	Lyte.Globals.set = function (scope, value) {
		Lyte.Component.set(Lyte.__gl, scope, value);
	};

	Lyte.Globals.get = function (scope) {
		return Lyte.Component._get(Lyte.__gl, scope);
	};

	Lyte.$.assetsDiv = document.createElement("div");
	Lyte.$.assetsDiv.setAttribute("id", "lyteAssetsDiv");
	Lyte.assetsDivContainer = document.head;

	Lyte.domContentLoaded = function (callback) {
		if (document.readyState === "complete" || document.readyState === "interactive") {
			callback();
		} else {
			window.addEventListener('DOMContentLoaded', function () {
				callback();
			});
		}
	};

	Lyte.createApplication = function (name, obj) {
		if (obj.init) {
			obj.init.apply(Lyte);
		}
	};

	Lyte.registerErrorCodes = function (obj) {
		Object.assign(Lyte.errorCodes, obj);
	};

	Lyte.establishObserverBindings = function (observers, fromStore, properties, model) {
		var scope = this;
		var watchProps = model && fromStore ? model._fldGrps.JsonPathWatch : scope.constructor._deepWatchProperties;
		if (fromStore) {
			scope = fromStore;
		}
		for (var i = 0; i < observers.length; i++) {
			var props = observers[i].properties;
			var obsAttr = {},
			    obsDuplicate = false;
			var Jpath = {};
			for (var j = 0; j < props.length; j++) {
				var actProp;
				var isArrayObserver = false;
				if (typeof props[j] == "string") {
					if (props[j].search(/^\$\./g) != -1) {

						var JsonPath = props[j];

						var CmpPropertyPath = JsonPath.match(/[^\$.][^\.]*/g)[0];
						if (CmpPropertyPath.search(/\[[0-9*]\]/g) != -1) {
							CmpPropertyPath = CmpPropertyPath.split(/\[[0-9*]\]/g)[0];
						}
						if (watchProps[CmpPropertyPath] == undefined) {
							watchProps[CmpPropertyPath] = [];
						}

						if (Jpath[CmpPropertyPath] == undefined) {
							Jpath[CmpPropertyPath] = [];
						}

						var JSONPATH;
						var reg = "^\\$\\." + CmpPropertyPath + "\\.?";
						reg = new RegExp(reg);
						JSONPATH = props[j].replace(reg, "$.");
						if (!watchProps[CmpPropertyPath].includes(JSONPATH)) {
							watchProps[CmpPropertyPath].push(JSONPATH);
						}

						if (!Jpath[CmpPropertyPath].includes(JSONPATH)) {
							Jpath[CmpPropertyPath].push(JSONPATH);
						}

						CmpPropertyPath = CmpPropertyPath + ".*";
						if (!obsAttr.hasOwnProperty(CmpPropertyPath)) {
							actProp = Lyte.getProperty.call(this, CmpPropertyPath, fromStore, properties);
							obsAttr[CmpPropertyPath] = true;
							obsDuplicate = false;
						} else {
							obsDuplicate = true;
						}
					} else if (props[j].indexOf('.[]') !== -1) {
						isArrayObserver = true;
						actProp = Lyte.getProperty.call(this, props[j].substring(0, props[j].indexOf('.[]')), fromStore, properties);
					} else {
						if (props[j].indexOf('.*') !== -1) {
							var prop = props[j].split(".")[0];
							var isDeepObs = !fromStore && this.component.__data[prop] && this.component.__data[prop].watch || fromStore && model && model.fieldList && model.fieldList[prop] && model.fieldList[prop].watch ? true : false;
							if (!isDeepObs) {
								continue;
							}
						}
						actProp = Lyte.getProperty.call(this, props[j], fromStore, properties);
					}
					if (!obsDuplicate) {
						if (!actProp._observers) {
							Object.defineProperty(actProp, '_observers', {
								value: new Set(),
								enumerable: false,
								writable: true,
								configurable: true
							});
						}
						actProp._observers.add({ callee: scope, observer: observers[i], isArrayObserver: isArrayObserver });
					}
				} else {
					Lyte.warn("ERR27", JSON.stringify(props[j]), observers[i].fnName, this.tagName);
				}
			}
			observers[i].Jpath = Jpath;
			obsAttr = {};
		}
	};

	Lyte.getProperty = function (key, fromStore, properties) {
		var arr = key.match(/([^[\].]+|\[\])/g);
		var property = this;
		if (fromStore) {
			property = properties;
			if (!properties[arr[0]]) {
				properties[arr[0]] = {};
			}
			property = properties[arr[0]];
		} else {
			if (!property._properties[arr[0]]) {
				property._properties[arr[0]] = {};
			}
			property = property._properties[arr[0]];
		}

		Object.defineProperty(property, '_path', { enumerable: false, value: arr[0] });
		for (var _i = 1; _i < arr.length; _i++) {
			if (arr[_i].startsWith("'") || arr[_i].startsWith('"')) {
				arr[_i] = arr[_i].substring(1, arr[_i].length - 1);
			}
			if (!property[arr[_i]]) {
				property[arr[_i]] = {};
				Object.defineProperty(property[arr[_i]], '_path', { enumerable: false, value: property._path + "." + arr[_i] });
			}
			property = property[arr[_i]];
		}
		return property;
	};

	Lyte.getErrorMessage = function (code) {
		var args = Array.from(arguments).slice(1);
		if (Lyte.errorCodes[code]) {
			return Lyte.errorCodes[code].replace(/{(\d+)}/g, function (t, i) {
				return args[i];
			});
		} else {
			return code;
		}
	};

	Lyte.error = function () {
		var errorObj = arguments[0],
		    parse = errorObj.stack;
		errorObj = parse ? errorObj : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
		if (Lyte.onerror) {
			Lyte.onerror.call(this, errorObj, arguments[1]);
		}
		Lyte.triggerEvent("error", errorObj, arguments[1]);
		var safari = errorObj.stack && errorObj.stack.indexOf(errorObj.message) == -1;
		if (parse && !safari) {
			errorObj = JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj)));
		}
		if (arguments[1]) {
			console.error(errorObj.stack ? safari ? errorObj : errorObj.stack : errorObj.message, arguments[1]);
		} else {
			console.error(errorObj.stack ? safari ? errorObj : errorObj.stack : errorObj.message);
		}
	};

	Lyte.warn = function () {
		var errorObj = arguments[0];
		errorObj = errorObj.stack ? JSON.parse(JSON.stringify(errorObj, Object.getOwnPropertyNames(errorObj))) : Error(Lyte.getErrorMessage.apply(Lyte, arguments));
		console.warn(errorObj.stack ? errorObj.stack.indexOf(errorObj.message) != -1 ? errorObj.stack.replace("Error: ", "") : errorObj : errorObj.message);
	};

	var requiredMixins = {};
	var fnProto = Function.prototype;
	if (!fnProto.on) {
		fnProto.on = function () {
			Lyte.warn("'.on()' method with the argument '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
		};
	}
	if (!fnProto.observes) {
		fnProto.observes = function () {
			Lyte.warn("'.observes()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
		};
	}
	if (!fnProto.computed) {
		fnProto.computed = function () {
			Lyte.warn("'.computed()' method with the arguments '" + arguments[0] + "' cannot be executed outside component scope.");
			return { "type": "computed", "value": this, "properties": arguments };
		};
	}
	Lyte._onObj = function () {
		return { "type": "callBack", "value": this.type === "observer" ? this.value : this, "properties": arguments, "observes": this.type === "observer" ? this : undefined };
	};
	Lyte._observesObj = function () {
		return { "type": "observer", "value": this, "properties": arguments, "on": Lyte._onObj, "lyteOn": Lyte._onObj };
	};
	Lyte._computedObj = function () {
		return { "type": "computed", "value": this, "properties": arguments };
	};
	Lyte._preRegister = function () {
		Lyte._actualFnProtoOn = Function.prototype.on;
		Lyte._actualFnProtoObserves = Function.prototype.observes;
		Lyte._actualFnProtoComputed = Function.prototype.computed;
		var fnProto = Function.prototype;
		fnProto.on = fnProto.lyteOn = Lyte._onObj;
		fnProto.observes = fnProto.lyteObserves = Lyte._observesObj;
		fnProto.computed = fnProto.lyteComputed = Lyte._computedObj;
	};
	Lyte._postRegister = function () {
		var fnProto = Function.prototype;
		fnProto.on = Lyte._actualFnProtoOn;
		fnProto.observes = Lyte._actualFnProtoObserves;
		fnProto.computed = Lyte._actualFnProtoComputed;
	};
	Object.defineProperty(Lyte.Mixin, "register", {
		get: function get() {
			Lyte._preRegister();
			return Lyte.registerMixinWrapper;
		}
	});
	Lyte.registerMixinWrapper = function () {
		try {
			Lyte.registerMixin.apply(Lyte, arguments);
			Lyte._postRegister();
		} catch (e) {
			Lyte._postRegister();
		}
	};
	Lyte.registerMixin = function (name, mixin) {
		Lyte.registeredMixins[name] = mixin;
		var req;
		if (req = requiredMixins[name]) {
			for (var key in req) {
				Lyte.$.requiredMixins[key](mixin, req[key], key);
			}
		}
	};

	Lyte.Mixin.get = function (name) {
		return Lyte.registeredMixins[name];
	};

	Lyte.Service.register = function (name, service) {
		if (Lyte.registeredServices.hasOwnProperty(name)) {
			Lyte.warn('Service -' + name + ' is already registered');
			return;
		}
		if (!Lyte._keywords.is(name)) {
			var data = service,
			    req;
			Lyte.registeredServices[name] = data;
			var serv = Lyte.requiredServices[name];
			if (serv && serv.size) {
				serv.forEach(function (obj) {
					var toSend = data;
					if (obj.isGlobal) {
						toSend = Lyte.__gS[obj.key] = Lyte.__gS[obj.key] || new service(obj.data);
					}
					obj.cB(toSend, obj.key, obj.name, name);
				});
			}
			return data;
		} else {
			Lyte.warn('Service name-' + name + ' should not be a keyword used in Lyte');
		}
	};

	Lyte.Service.getInjected = function (key) {
		if (Lyte.__gS.hasOwnProperty(key)) {
			return Lyte.__gS[key];
		}
	};

	// Lyte.Service.get = function(name) {
	//   return Lyte.registeredServices[name];
	// }

	Lyte.$.requiredServices = function (key, serviceName, cB, type, name, isGlobal, data) {
		var reqServ = Lyte.requiredServices[serviceName];
		var req = reqServ ? reqServ : Lyte.requiredServices[serviceName] = new Map();
		var id = Lyte.$.genMapId(req);
		req.set(id, { key: key, cB: cB, type: type, name: name, serviceName: serviceName, isGlobal: isGlobal, data: data });
		return serviceName + "-" + id;
	};

	Lyte.$.lazyRegisterService = function (service, obj) {
		var scope = obj.scope,
		    name = obj.name,
		    callback = scope[obj.type][name];
		if (callback) {
			callback[obj.key] = service;
		}
	};

	Lyte.$.injectServices = {};
	Object.defineProperty(Lyte, "__gS", {
		value: {}
	});
	Lyte.injectServices = function (data) {
		var serv = {};
		if (!Array.isArray(data)) {
			data = [data];
		}
		data.forEach(function (itm) {
			if (itm && (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == 'object') {
				var key = itm.as,
				    service = itm.service,
				    args = itm.data;
				if (!Lyte._keywords.is(key)) {
					if (!Lyte.toBeInjectedServices.hasOwnProperty(key)) {
						Lyte.toBeInjectedServices[key] = service;
						serv[key] = { service: service, data: args };
						if (Lyte.registeredServices[service]) {
							Lyte.__gS[key] = new Lyte.registeredServices[service](args);
						}
					} else {
						Lyte.warn("A service has already been injected in the key named, ", key);
					}
				} else {
					Lyte.warn("Service cannot be used in any keywords of Lyte.");
				}
			} else if (typeof itm == "string") {
				if (!Lyte.toBeInjectedServices.hasOwnProperty(itm)) {
					Lyte.toBeInjectedServices[itm] = itm;
					serv[itm] = { service: itm };
					if (Lyte.registeredServices[itm]) {
						Lyte.__gS[itm] = new Lyte.registeredServices[itm]();
					}
				} else {
					Lyte.warn("A service has already been injected in the key named, ", itm);
				}
			} else {
				Lyte.warn("Invalid data passed to injectServices", itm);
			}
		});
		var mdlObj = Lyte.$.injectServices;
		for (var mKey in mdlObj) {
			for (var key in serv) {
				mdlObj[mKey](key, serv[key].service, mKey, Lyte.__gS[key], undefined, serv[key].data);
			}
		}
	};

	Lyte.$.genMapId = function (map) {
		var id = Math.floor(Math.random() * 10000000000 + 1);
		while (map.get(id)) {
			id = Math.floor(Math.random() * 10000000000 + 1);
		}
		return id.toString();
	};

	Lyte.$.toRemoveFromRequiredServices = function (str) {
		var arr = str.split("-"),
		    id = arr[arr.length - 1],
		    idLen = id.length,
		    servName = str.substr(0, str.length - (idLen + 1));
		var reqArr = Lyte.requiredServices[servName];
		if (reqArr) {
			reqArr.delete(id);
		}
	};

	Lyte.toBeUsedServices = function (obj) {
		// var serviceToBeUsed = obj.callback ? Object.assign({}, Lyte.toBeInjectedServices) : {};
		var serviceToBeUsed = {};
		var arr = obj.services;
		if (arr) {
			arr.forEach(function (service) {
				if (typeof service == "string") {
					serviceToBeUsed[service] = service;
				} else if (service && (typeof service === 'undefined' ? 'undefined' : _typeof(service)) == "object") {
					var key = service.as,
					    serv = service.service;
					if (!Lyte._keywords.is(key, obj.type)) {
						serviceToBeUsed[key] = serv;
					} else {
						Lyte.warn("Service cannot be used in any keywords of Lyte.");
					}
				}
			});
		}
		return serviceToBeUsed;
	};

	Lyte.extendService = function (arg) {
		var servObj = Lyte.toBeUsedServices(arg),
		    name;
		for (var serv in servObj) {
			name = servObj[serv];
			// var scp = arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) : Lyte.registeredServices; 
			if (arg.isGlobal && Lyte.__gS.hasOwnProperty(serv) || !arg.isGlobal && Lyte.registeredServices.hasOwnProperty(name)) {
				var ins = arg.ins,
				    service = arg.isGlobal ? Lyte.__gS[serv] : new Lyte.registeredServices[name]();
				if (!Array.isArray(ins)) {
					ins = [arg.ins];
				}
				ins.forEach(function (insObj) {
					insObj[serv] = arg.isGlobal ? Lyte.__gS[serv] : new Lyte.registeredServices[name]();
				});
			} else {
				Lyte.$.requiredServices(serv, name, arg.callback, arg.type, arg.name, arg.isGlobal, arg.data);
			}
		}
	};

	Lyte.$.requiredMixins = function (mixin, dir, type) {
		var req = requiredMixins[mixin] ? requiredMixins[mixin] : requiredMixins[mixin] = {};
		if (!req[type]) {
			req[type] = [dir];
		} else {
			req[type].push(dir);
		}
	};

	Lyte.Mixin.exists = function (name) {
		if (!Lyte.registeredMixins[name]) {
			// Lyte.error('Mixin used before being registered.');
			return false;
		}
		return true;
	};

	Lyte.log = function (text, src, color) {
		if (Lyte.debug) {
			if (color) {
				console.log("%c" + text, 'color:' + color);
			} else {
				console.log(text);
			}
		}
	};

	Lyte.time = function (fn) {
		if (Lyte.performance) {
			var index;
			if ((index = Lyte.$.consoleTime.indexOf(fn)) != -1) {
				Lyte.$.consoleTime.splice(index, 1);
				console.timeEnd(fn);
			} else {
				Lyte.$.consoleTime.push(fn);
				console.time(fn);
			}
		}
	};

	Lyte.isRecord = function (object) {
		if (object && object.$ && object.$.hasOwnProperty("isModified")) {
			return true;
		}
		return false;
	};

	Lyte.isComponent = function (object) {
		if (object && object.$node && object.__data) {
			return true;
		}
		return false;
	};

	/* --------- lyte router v2 changes starts---- */
	Lyte.$.reqFiles = {};

	Lyte.injectResources = function (files, every, completed, options) {
		var successFiles = [],
		    errorFiles = [];
		every = every || function () {};
		completed = completed || function () {};
		return new Promise(function (resolve, reject) {
			processRequirements(files, function () {
				if (options && options.defer) {
					options.defer({
						injectJS: injectJS,
						files: files,
						errorFiles: errorFiles
					});
					resolve();
				} else {
					injectJS(files, function () {
						completed(successFiles, errorFiles);
						if (errorFiles.length) {
							reject(successFiles, errorFiles);
						} else {
							resolve(successFiles, errorFiles);
						}
					});
				}
			}.bind(this));
		});

		function injectJS(files, resolve, execFiles) {
			execFiles = execFiles || [];
			if (!files) {
				resolve(successFiles, errorFiles);
			} else {
				if (!Array.isArray(files)) {
					files = [files];
				}
				if (!files.length) {
					resolve(successFiles, errorFiles);
				}
				var len = -files.length;
				files.forEach(function (file) {
					if (typeof file == "string") {
						var type = getFileExtn(file);
						if (type && (type == ".js" || type == ".css") && execFiles.indexOf(file) == -1) {
							execFiles.push(file);
							createScript(file, function () {
								loaded();
							});
						} else {
							loaded();
						}
					} else if (Array.isArray(file)) {
						injectJS(file, function () {
							loaded();
						});
					} else {
						len--;
						injectJS(file.parent, function () {
							injectJS(file.child, function () {
								loaded();
							});
							loaded();
						});
					}
				});
			}

			function loaded() {
				len++;
				if (len == 0) {
					resolve(successFiles, errorFiles);
				}
			}
		}

		function createScript(file, resolve) {
			var ev = Lyte.injectResources.respObj[file];
			if (!Lyte.injectResources.availableTags[file] || Lyte.injectResources.availableTags[file].tag.getAttribute("rel") == "preload") {
				var type = getFileExtn(file),
				    tag;
				if (type == ".js") {
					tag = document.createElement('script');
					tag.setAttribute('type', "text/javascript");
					tag.setAttribute('src', file);
				} else if (type == ".css") {
					tag = document.createElement('link');
					tag.setAttribute('type', "text/css");
					tag.setAttribute('rel', "stylesheet");
					tag.setAttribute('href', file);
				}
				ev.getAttributeNames().forEach(function (attr) {
					if (["href", "as", "rel"].indexOf(attr) == -1) {
						tag.setAttribute(attr, ev.getAttribute(attr));
					}
				});
				delete Lyte.injectResources.respObj[file];
				tag.onerror = tag.onload = function (event) {
					if (event.type == "error") {
						errorFiles.push(event);
					} else {
						successFiles.push(event);
					}
					Lyte.injectResources.availableTags[file].tag.remove();
					Lyte.injectResources.availableTags[file] = { tag: tag, event: event, type: event.type == "error" ? "error" : "load" };
					resolve();
					tag.onerror = tag.onload = undefined;
				};
				Lyte.$.assetsDiv.appendChild(tag);
			} else {
				var t = Lyte.injectResources.availableTags[file];
				if (t.type == "error") {
					errorFiles.push(t.event);
				} else {
					successFiles.push(t.event);
				}
				resolve();
			}
		}

		function processRequirements(files, resolve) {
			if (!files) {
				resolve();
			} else {
				if (!Array.isArray(files)) {
					files = [files];
				}
				if (!files.length) {
					resolve();
				}
				var len = -files.length;
				files.forEach(function (file) {
					if (typeof file == "string") {
						requestFile(file, Lyte.injectResources.availableTags[file], function () {
							loaded();
						});
					} else if (Array.isArray(file)) {
						new Promise(function (r) {
							processRequirements(file, r);
						}).then(function () {
							loaded();
						});
					} else {
						len--;
						new Promise(function (r) {
							processRequirements(file.parent, r);
						}).then(function () {
							loaded();
						});
						new Promise(function (r) {
							processRequirements(file.child, r);
						}).then(function () {
							loaded();
						});
					}
				});
			}

			function loaded() {
				len++;
				if (len == 0) {
					resolve();
				}
			}

			function requestFile(file, cached, resolve) {
				if (Lyte.$.reqFiles[file]) {
					Lyte.$.reqFiles[file].push(resolve);
				} else {
					Lyte.$.reqFiles[file] = [resolve];
					if (cached && cached.event.type != "error") {
						if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
							Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
						}
						fileLoaded.call(cached.tag, file, cached.event, true);
						resolve();
					} else {
						makeRequest(file, function (event) {
							Lyte.injectResources.respObj[file] = this;
							Lyte.$.reqFiles[file].forEach(function (resolve) {
								resolve();
							});
							// filesObj[file] = this;
							fileLoaded.call(this, file, event);
							every.call(this, event);
						});
					}
				}
			}

			function fileLoaded(file, event, cached) {
				delete Lyte.$.reqFiles[file];
				if (!cached) {
					if (Lyte.injectResources.availableTags[file]) {
						Lyte.injectResources.availableTags[file].tag.remove();
						delete Lyte.injectResources.respObj[file];
					}
					Lyte.injectResources.availableTags[file] = { tag: this, event: event, type: event.type };
				}
			}
		}

		function makeRequest(file, callBack) {
			var tag,
			    ev = every.internal || {},
			    type = getFileExtn(file);
			ev.file = file;
			if (type == null) {
				Lyte.error('Type of file is not specified in injectResources.');
				return;
			}
			tag = document.createElement('link');
			tag.setAttribute('href', file);
			ev.tag = tag;
			if (type == '.css') {
				tag.setAttribute('as', "style");
			} else {
				tag.setAttribute('as', "script");
			}
			tag.setAttribute('rel', "preload");
			tag.onerror = tag.onload = function (event) {
				callBack.call(this, event);
				this.onerror = this.onload = undefined;
			};
			Lyte.triggerEvent("onBeforeInject", ev);
			Lyte.$.assetsDiv.appendChild(tag);
		};
	};

	function getFileExtn(file) {
		return file.match(/\.[a-zA-Z]+(?=\?|$)/);
	}

	Lyte.injectResources.availableTags = [];
	Lyte.injectResources.respObj = [];

	function getFileExtn(file) {
		return file.match(/\.[a-zA-Z]+(?=\?|$)/);
	}

	Lyte.$.replaceOldInjectResource = function () {
		Lyte.injectResources = function (files, every, completed) {
			var successFiles = [],
			    errorFiles = [];
			every = every || function () {};
			completed = completed || function () {};
			return new Promise(function (resolve) {
				processRequirements(files, resolve);
			}).then(function () {
				completed(successFiles, errorFiles);
			});

			function processRequirements(files, resolve) {
				if (!files) {
					resolve();
				} else {
					if (!Array.isArray(files)) {
						files = [files];
					}
					if (!files.length) {
						resolve();
					}
					var len = -files.length;
					files.forEach(function (file) {
						if (typeof file == "string") {
							requestFile(file, Lyte.injectResources.availableTags[file], function () {
								loaded();
							});
						} else if (Array.isArray(file)) {
							new Promise(function (r) {
								processRequirements(file, r);
							}).then(function () {
								loaded();
							});
						} else {
							new Promise(function (r) {
								processRequirements(file.parent, r);
							}).then(function () {
								new Promise(function (r1) {
									processRequirements(file.child, r1);
								}).then(function () {
									loaded();
								});
							});
						}
					});
				}

				function loaded() {
					len++;
					if (len == 0) {
						resolve();
					}
				}

				function requestFile(file, cached, resolve) {
					if (Lyte.$.reqFiles[file]) {
						Lyte.$.reqFiles[file].push(resolve);
					} else {
						Lyte.$.reqFiles[file] = [resolve];
						if (cached && cached.event.type != "error") {
							if (Lyte.removeFromCache.arr.indexOf(file) != -1) {
								Lyte.removeFromCache.arr.splice(Lyte.removeFromCache.arr.indexOf(file), 1);
							}
							fileLoaded.call(cached.tag, cached.event, true);
							resolve();
						} else {
							makeRequest(file, function (event) {
								Lyte.$.reqFiles[file].forEach(function (resolve) {
									resolve();
								});
								fileLoaded.call(this, event);
								every.call(this, event);
							});
						}
					}
				}

				function fileLoaded(event, cached) {
					var file = this.getAttribute('src') || this.getAttribute('href');
					delete Lyte.$.reqFiles[file];
					if (!cached) {
						if (Lyte.injectResources.availableTags[file]) {
							Lyte.injectResources.availableTags[file].tag.remove();
						}
						this.onerror = this.onload = undefined;
						Lyte.injectResources.availableTags[file] = { tag: this, event: { type: event.type } };
					}
				}
			}

			function makeRequest(file, callBack) {
				var tags = { ".js": 'script', ".css": 'link' },
				    type = getFileExtn(file);
				tag = document.createElement(tags[type]);
				if (!type) {
					Lyte.error('Type of file is not specified in injectResources.');
					return;
				} else if (type == '.css') {
					tag.setAttribute('href', file);
					tag.setAttribute('type', "text/css");
					tag.setAttribute('rel', "stylesheet");
				} else {
					tag.setAttribute('src', file);
				}
				tag.onerror = tag.onload = function (event) {
					if (event.type == "error") {
						errorFiles.push(event);
					} else {
						successFiles.push(event);
					}
					if (callBack) {
						callBack.call(this, event);
					}
				};
				var ev = every.internal || {};
				ev.file = file;
				ev.tag = tag;
				Lyte.triggerEvent("onBeforeInject", ev);
				Lyte.$.assetsDiv.appendChild(tag);
			};
		};

		Lyte.injectResources.availableTags = [];
		Lyte.injectResources.respObj = [];
	};

	Lyte.removeFromCache = function (arr) {
		Lyte.removeFromCache.assign(arr);
		if (Lyte.removeFromCache.arr.length) {
			Lyte.removeFromCache.arr.forEach(function (file) {
				if (Lyte.injectResources.availableTags[file]) {
					Lyte.injectResources.availableTags[file].tag.remove();
					delete Lyte.injectResources.availableTags[file];
					delete Lyte.injectResources.respObj[file];
				}
			});
			Lyte.removeFromCache.arr = [];
		}
	};

	Lyte.removeFromCache.arr = [];

	Lyte.removeFromCache.assign = function (arr) {
		arr = arr == "*" ? Object.keys(Lyte.injectResources.availableTags) : Array.isArray(arr) ? arr : [arr];
		Lyte.removeFromCache.arr = Lyte.removeFromCache.arr.concat(arr);
		return;
	};

	Lyte.$.prefetchSupport = false;
	try {
		if (!Lyte.browser.ie) {
			var link = document.createElement('link');
			Lyte.$.prefetchSupport = link.relList.supports('prefetch') && link.relList.supports('preload');
		}
	} catch (e) {}
	if (!Lyte.$.prefetchSupport) {
		console.log("Prefetch is not supported. Falling back to old implementation");
		Lyte.$.replaceOldInjectResource();
	}

	/* --------- lyte router v2 changes ends ---- */

	Lyte.checkProperty = function (property, dataVal, key, fieldVal, field, record, type, name, init) {
		var exts = "extends";
		switch (property) {
			case "type":
				if (Lyte.Transform.hasOwnProperty(fieldVal) && dataVal !== undefined && dataVal !== null) {
					var _fld = Lyte.Transform[fieldVal],
					    _ret = true;
					if (Array.isArray(dataVal)) {
						if (Lyte.Transform[fieldVal][exts] != "array") {
							return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
						}
						if (_fld.hasOwnProperty("items")) {
							_ret = Lyte.checkProperty("items", dataVal, key, _fld.items);
						}
					} else if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) === "object" && Lyte.Transform[fieldVal][exts] == "object" && _fld.hasOwnProperty("properties")) {
						_ret = Lyte.checkProperty("properties", dataVal, key, _fld.properties);
					} else if (Lyte.Transform[fieldVal][exts] != (typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal))) {
						return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
					}
					if (_ret !== true) {
						return _ret;
					}
				} else if (dataVal !== undefined && dataVal !== null) {
					if (Array.isArray(dataVal)) {
						if (fieldVal != "array") {
							return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
						}
					} else if (fieldVal != (typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal))) {
						return { code: "ERR03", message: Lyte.errorCodes.ERR03, expected: fieldVal };
					}
				}
				break;
			case "mandatory":
				var validateFlag = fieldVal;
				if ((typeof fieldVal === 'undefined' ? 'undefined' : _typeof(fieldVal)) == "object") {
					if (init && fieldVal.skipValidationOnInit == true) {
						validateFlag = false;
					}
				}
				if (validateFlag && (dataVal == undefined || dataVal == null || dataVal === "")) {
					return { code: "ERR02", message: Lyte.errorCodes.ERR02 };
				}
				break;
			case "maximum":
				if (typeof dataVal == "number" && dataVal > fieldVal) {
					return { code: "ERR04", message: Lyte.errorCodes.ERR04, expected: fieldVal };
				}
				break;
			case "minimum":
				if (typeof dataVal == "number" && dataVal < fieldVal) {
					return { code: "ERR05", message: Lyte.errorCodes.ERR05, expected: fieldVal };
				}
				break;
			case "maxLength":
			case "maxItems":
				if (dataVal && dataVal.length > fieldVal) {
					return { code: "ERR06", message: Lyte.errorCodes.ERR06, expected: fieldVal };
				}
				break;
			case "minLength":
			case "minItems":
				if (dataVal && dataVal.length < fieldVal) {
					return { code: "ERR07", message: Lyte.errorCodes.ERR07, expected: fieldVal };
				}
				break;
			case "pattern":
				if (typeof dataVal == "string" && !new RegExp(fieldVal).test(dataVal)) {
					return { code: "ERR08", message: Lyte.errorCodes.ERR08, expected: fieldVal };
				}
				break;
			case "uniqueItems":
				{
					if (Array.isArray(dataVal) && fieldVal) {
						var newArr = [];
						for (var i = 0; i < dataVal.length; i++) {
							var val = dataVal[i];
							if (newArr.indexOf(val) != -1) {
								return { code: "ERR09", message: Lyte.errorCodes.ERR09 };
							}
							newArr.push(val);
						}
					}
					break;
				}
			case "constant":
				if (Array.isArray(dataVal)) {
					var resp = dataVal.length == fieldVal.length && dataVal.every(function (v, i) {
						return v === fieldVal[i];
					});
					if (!resp) {
						return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
					}
				} else if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) == "object") {
					var resp = store.adapter.$.compareObjects(dataVal, fieldVal);
					if (!resp) {
						return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
					}
				} else if (dataVal && dataVal != fieldVal) {
					return { code: "ERR10", message: Lyte.errorCodes.ERR10, expected: fieldVal };
				}
				break;
			case "items":
				{
					if (Array.isArray(dataVal)) {
						for (var i = 0; i < dataVal.length; i++) {
							if (!(fieldVal.any && Array.isArray(fieldVal))) {
								fieldVal = [fieldVal];
							}
							var fldLen = fieldVal.length,
							    _ret = true;
							for (var j = 0; j < fldLen; j++) {
								var _fld = fieldVal[j];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, dataVal[i], i, _fld[property], _fld);
									if (resp !== true) {
										if (_ret === true) {
											resp.path = resp.path ? i + "." + resp.path : resp.path;
											_ret = resp;
										}
										break;
									}
								}
							}
							if (_ret !== true) {
								return _ret;
							}
						}
					}
					break;
				}
			case "properties":
				if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) == "object" && !Array.isArray(dataVal)) {
					for (var key in dataVal) {
						if (fieldVal.hasOwnProperty(key)) {
							var fld = fieldVal[key];
							if (!(fld.any && Array.isArray(fld))) {
								fld = [fld];
							}
							var fldLen = fld.length,
							    _ret = true;
							for (var i = 0; i < fldLen; i++) {
								var _fld = fld[i];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, dataVal[key], key, _fld[property], _fld);
									if (resp != true) {
										if (_ret === true) {
											resp.path = resp.path ? key + "." + resp.path : key.toString();
											_ret = resp;
										}
										break;
									}
								}
							}
							if (_ret !== true) {
								return _ret;
							}
						}
						// else if(field.exact){
						// 	return { code : "ERR29", message: Lyte.errorCodes.ERR29, property: key };
						// }
					}
				}
				break;
			case "validation":
				{
					var resp = Lyte.customValidator[fieldVal].apply(record, [key, dataVal, name]);
					if (resp != true) {
						return resp;
					}
					break;
				}
			case "instanceof":
				{
					if ((typeof dataVal === 'undefined' ? 'undefined' : _typeof(dataVal)) === "object" && !Array.isArray(dataVal) && !(dataVal instanceof fieldVal)) {
						return { code: "ERR30", message: Lyte.errorCodes.ERR30, property: key, instanceof: fieldVal };
					}
				}
		}
		return true;
	};

	Lyte.checkNestedProp = function (id, path, dtype, wobj, object, property, value, check, fromStore) {
		if (Lyte.Transform[dtype.type]) {
			dtype = Lyte.Transform[dtype.type];
			dtype.type = dtype.extends;
		}
		if (path.length != 0) {
			if (dtype.type == 'array') {
				if (dtype.items && !isNaN(path[0]) && _typeof(dtype.items) == 'object') {
					path = path.slice(1);
					Lyte.checkNestedProp(id, path, dtype.items, wobj, object, property, value, check, fromStore);
				}
			} else if (dtype.type == "object") {
				if (dtype.properties && dtype.properties.hasOwnProperty(path[0])) {
					var k = path[0];
					path = path.slice(1);
					Lyte.checkNestedProp(id, path, dtype.properties[k], wobj, object, property, value, check, fromStore);
				}
			}
		} else {
			var err;
			if (dtype && (dtype.properties || dtype.items) && !check.hasOwnProperty("warn")) {
				var component = {};component.__data = {};
				if (dtype.properties) {
					component.__data[property] = dtype.properties[property];
				} else if (dtype.items && wobj.index) {
					component.__data[wobj.index] = dtype;
				} else {
					component.__data[property] = dtype.items;
				}
				var cp = Lyte.validate(object, property, value, component);
				var errKey = wobj.attr ? wobj.attr : wobj.key,
				    _path = wobj.path.split(".");
				var PathWay = wobj.index == undefined && property ? wobj.path + (wobj.path != "" ? "." : "") + property : wobj.index != undefined ? wobj.path + (wobj.path != "" ? "." : "") + wobj.index : wobj.path;
				if (cp && (typeof cp === 'undefined' ? 'undefined' : typeof cp === 'undefined' ? 'undefined' : _typeof(cp)) == "object" && cp.code) {
					cp.value = value;
					cp.path = wobj.path != "" ? wobj.path : property;
					if (wobj.isRec && fromStore && wobj.key == undefined && wobj.path != "") {
						errKey = wobj.path.split(".")[0];
						_path.shift();
						_path = _path.length == 1 && _path[0] == property ? [] : _path;
					}
					// wobj.Error ? true : wobj.Error = {}
					wobj.Error && wobj.Error[errKey] ? wobj.Error[errKey].code && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : wobj.Error[errKey].nested = {} : wobj.Error[errKey] = { nested: {} };
					wobj.Error[errKey].code = "ERR34";
					wobj.Error[errKey].message = Lyte.errorCodes.ERR34;
					err = wobj.Error[errKey].nested;
					wobj._cmpErr[errKey] ? true : wobj._cmpErr[errKey] = {};
					wobj._cmpErr[errKey].code = "ERR34";
					wobj._cmpErr[errKey].message = Lyte.errorCodes.ERR34;
					var cmpErrPath = wobj._cmpErr[errKey].path ? wobj._cmpErr[errKey].path : [];
					if (wobj.path != "") {
						_path.forEach(function (k) {
							if (err && !err[k]) {
								err = err[k] = {};
							} else {
								err = err[k];
							}
						});
					}
					wobj.index != undefined ? err[wobj.index] = cp : err[property] = cp;
					if (!cmpErrPath.includes(PathWay)) {
						cmpErrPath.push(PathWay);
					}
					wobj._cmpErr[errKey].path = cmpErrPath;
				} else {
					if (wobj.isRec && fromStore && wobj.key == undefined) {
						errKey = wobj.path.split(".")[0];
						_path.shift();
						_path = _path.length == 1 && _path[0] == property ? [property] : _path;
					}
					err = wobj.Error[errKey] && wobj.Error[errKey].nested ? wobj.Error[errKey].nested : undefined;
					var cmpErr = wobj._cmpErr[errKey] || undefined;
					if (cmpErr && cmpErr.path && cmpErr.path.includes(PathWay)) {
						var ind = cmpErr.path.indexOf(PathWay);
						cmpErr.path.splice(ind, 1);
					}
					//var p = object.$.error[property];
					if (err) {
						var key = wobj.index || property;
						var flag = true,
						    p = PathWay.split(".");
						p.forEach(function (r) {
							if (err[r] && err[r].code) {
								delete err[r];
								if (err && Object.keys(err).length == 0) {
									flag = true;
								} else {
									flag = false;
								}
							} else {
								err = err[r];
							}
						});
						if (flag == true && wobj.Error[errKey] && wobj._cmpErr[errKey]) {
							delete wobj.Error[errKey];
							delete wobj._cmpErr[errKey];
						}
					}
				}
				if (check.value && check.value.hasOwnProperty("code") && cp.code || !check.value) {
					check.value = cp;
				}
			}
		}
		wobj.index && delete wobj.index;
	};

	Lyte.types = ["string", "object", "number", "boolean", "array"];

	Lyte.attr = function (type, opts) {
		var obj = {};
		obj.type = type;
		if (opts == undefined) {
			opts = {};
		}
		if (this.types.indexOf(type) == -1 && !Lyte.Transform.hasOwnProperty(type)) {
			throw new Error("Not a valid field type - " + type);
		}
		Object.assign(obj, opts);
		return obj;
	};

	Lyte.defineRelation = function (name, type, opts) {
		var relation = { type: "relation", relType: type, relatedTo: name };
		if (opts) {
			relation.opts = opts;
		}
		return relation;
	};

	Lyte.belongsTo = function (name, opts) {
		return this.defineRelation(name, "belongsTo", opts);
	};

	Lyte.hasMany = function (name, opts) {
		return this.defineRelation(name, "hasMany", opts);
	};

	Lyte.Transform = {};

	Lyte.customValidator = {};

	Lyte.registerDataType = function (fieldTypeName, properties) {
		var exts = "extends";
		if (this.Transform.hasOwnProperty(fieldTypeName)) {
			Lyte.warn("Custom Field Type - " + fieldTypeName + " -  already exists.");
			return;
		}
		if (properties[exts] == undefined || Lyte.types.indexOf(properties[exts]) == -1) {
			Lyte.error("Not a valid field type - " + properties[exts]);
			return;
		}
		this.Transform[fieldTypeName] = properties;
	};

	Lyte.registerValidator = function (customValidatorName, func) {
		if (this.customValidator.hasOwnProperty(customValidatorName)) {
			Lyte.warn("Custom Validator with name - " + customValidatorName + " - already exists");
			return;
		}
		this.customValidator[customValidatorName] = func;
	};

	Lyte.patterns = {
		email: /^([A-Za-z0-9._%\-'+/]+@[A-Za-z0-9.-]+\.[a-zA-Z]{2,22})$/,
		url: /(^(ht|f)tp(s?):\/\/[0-9a-zA-Z][-.\w]*(:[0-9])*(\/?)([a-zA-Z0-9\-.?,:'/\\+=&amp;%$#_[\]@!()*;~]*)?$)/,
		ampm: /^(AM|PM|am|pm)$/,
		hour: /^(0?[0-9]|1[0-9]|2[0-4])$/,
		minute: /^(0?[0-9]|[1-5][0-9]|60)$/,
		boolean: /^(true|false|TRUE|FALSE)$/,
		alphaNumeric: /([a-zA-Z0-9])+/,
		alphabetsOnly: /([a-zA-Z])+/,
		numeric: /([0-9])+/,
		phoneNo: /^[0-9a-zA-Z+.()\-;\s]+$/
	};

	Lyte.validate = function (object, key, value, component, init) {
		var definition = component.__data[key];
		var isError = false;
		var type = definition ? definition.type : undefined;
		var _def = definition;
		if (_def) {
			if (!(_def.any && Array.isArray(_def))) {
				_def = [_def];
			}
			var defLen = _def.length,
			    _ret = true;
			for (var i = 0; i < defLen; i++) {
				var _d = _def[i];
				for (var defKey in _d) {
					isError = Lyte.checkProperty(defKey, value, key, _d[defKey], _d, object, type, undefined, init);
					if (isError !== true) {
						if (_ret === true) {
							_ret = isError;
						}
					}
				}
			}
			if (_ret !== true) {
				return _ret;
			}
		}
		return false;
	};

	Lyte.registerPattern = function (patternName, pattern) {
		this.patterns[patternName] = pattern;
	};

	Lyte.errorCodes = {
		ERR01: "Primary key cannot be modified", ERR02: "Mandatory field cannot be empty", ERR03: "Type of value does not match the specified data type", ERR04: "Value is greater than the maximum value allowed",
		ERR05: "Value is less than the minimum value allowed", ERR06: "Length of string/array is greater than the maximum limit allowed", ERR07: "Length of string/array is less than the minimum limit allowed",
		ERR08: "String does not match the specified pattern", ERR09: "Values in array are not unique", ERR10: "Value is not equal to the specified constant", ERR11: "Model of related field is not defined",
		ERR12: "Model of backward relation is not defined", ERR13: "Record not found", ERR14: "Model does not match the related field model", ERR15: "Error in creating a record as a relation",
		ERR16: "Record with primary key already exists", ERR17: "Value cannot be changed because record has been deleted", ERR18: "Action not defined", ERR19: "Model not defined",
		ERR20: "Key not specified", ERR21: "'belongsTo' relationship expects a single object/id", ERR22: "Type not specified for polymorphic relation", ERR23: "Primary Key value not present", ERR24: "Error while relating record", ERR25: "Backward relation not present", ERR26: "Primary key value cannot be undefined or null",
		ERR27: "Observer can observe only string data type value, '{0}' value cannot be observed in the function named '{1}' in the component '{2}'",
		ERR28: "Unloaded record cannot be saved",
		ERR29: "Property not defined in the object",
		ERR30: "Error in variables declaration for Query", ERR31: "Query not registered for the Model",
		ERR32: "Property not defined in the object",
		ERR33: "Property's value is not an instanceof the mentioned class",
		ERR34: "Type definition for nested properties / items does not match with the value",
		ERR35: "A datatype mismatch has occurred for custom DataType '{0}'"
	};

	Lyte.registeredGlobalEvents = Lyte.__lyteRegisteredEvents = {};
	Lyte.triggerEvent = function () {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventName = arguments[0];
		var stopEvent = false;
		var s = this.__lyteRegisteredEvents[eventName];
		if (!s) {
			s = this.__lyteRegisteredEvents[eventName] = { "listeners": [] };
		} else {
			for (var i = 0; i < s.listeners.length; i++) {
				var func = s.listeners[i];
				if (func) {
					var ret = func.apply(this, args);
					if (ret === false) {
						stopEvent = true;
						break;
					}
				}
			}
		}
		var customEvent = new CustomEvent(eventName, { "detail": args });
		if (!stopEvent) {
			document.dispatchEvent(customEvent);
		}
	};

	Lyte.addEventListener = function (eventName, func) {
		if (typeof func !== "function") {
			Lyte.error("Second parameter to Lyte.Component.addGlobalEventListener() must be a function");
			return;
		}
		var s = this.__lyteRegisteredEvents[eventName];
		if (!s) {
			s = this.__lyteRegisteredEvents[eventName] = { "listeners": [] };
		}
		var d = s.listeners.push(func);
		return eventName + "-" + (d - 1);
	};

	Lyte.removeEventListener = function (id) {
		var lastIndex = void 0;
		if (!id || (lastIndex = id.lastIndexOf("-")) == -1) {
			Lyte.error("listener unique id not specified / invalid");
			return;
		}
		var eventName = id.substring(0, lastIndex);
		var eventId = id.substring(lastIndex + 1);
		var s = this.__lyteRegisteredEvents[eventName];
		if (!s || !s.listeners[eventId]) {
			Lyte.error("No such listener registered");
			return;
		}
		s.listeners[eventId] = null;
	};

	Lyte.extendEventListeners = function (scp) {
		if (scp && (typeof scp === 'undefined' ? 'undefined' : _typeof(scp)) == "object" && !scp.hasOwnProperty("__lyteRegisteredEvents")) {
			Object.defineProperties(scp, {
				__lyteRegisteredEvents: {
					value: {}
				},
				addEventListener: {
					value: Lyte.addEventListener
				},
				removeEventListener: {
					value: Lyte.removeEventListener
				},
				triggerEvent: {
					value: Lyte.triggerEvent
				}
			});
		}
	};

	Lyte.deepCopyObject = function (obj) {
		var targetVal = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
		var current,
		    copies = [{ source: obj, target: targetVal }],
		    keys,
		    propertyIndex,
		    descriptor,
		    nextSource,
		    indexOf,
		    sourceReferences = [obj];
		var cloneObject = copies[0].target,
		    targetReferences = [cloneObject];
		while (current = copies.shift()) {
			keys = Object.keys(current.source);
			for (propertyIndex = 0; propertyIndex < keys.length; propertyIndex++) {
				descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
				if (!descriptor) {
					continue;
				}
				if (!descriptor.value || _typeof(descriptor.value) != "object") {
					Object.defineProperty(current.target, keys[propertyIndex], descriptor);
					continue;
				}
				nextSource = descriptor.value;
				descriptor.value = Array.isArray(nextSource) ? [] : nextSource instanceof Set ? new Set() : Object.create(Object.getPrototypeOf(nextSource));
				indexOf = sourceReferences.indexOf(nextSource);
				if (indexOf != -1) {
					descriptor.value = targetReferences[indexOf];
					Object.defineProperty(current.target, keys[propertyIndex], descriptor);
					continue;
				}
				sourceReferences.push(nextSource);
				targetReferences.push(descriptor.value);
				Object.defineProperty(current.target, keys[propertyIndex], descriptor);
				copies.push({ source: nextSource, target: descriptor.value });
			}
			if (Lyte.isRecord(current.source)) {
				Object.defineProperty(current.target, "$", {
					value: {}
				});
				current.target.$.isNew = current.source.$.isNew;
				current.target.$.isModified = current.source.$.isModified;
				current.target.$.isDeleted = current.source.$.isDeleted;
				current.target.$.pK = current.source.$.pK;
				current.target.$._attributes = current.source.$._attributes;
				current.target.$.isCloned = true;
				current.target.$.model = { _name: current.source.$.model._name };
				if (current.source.$.hasOwnProperty("deepNest")) {
					current.target.$.deepNest = current.source.$.deepNest;
				}
				if (current.source.$.hasOwnProperty("partialType")) {
					current.target.$.partialType = current.source.$.partialType;
				}
			}
			if (Array.isArray(current.source)) {
				if (current.source.partial) {
					Object.defineProperty(current.target, "partial", {
						value: current.source.partial
					});
				}
			}
		}
		return cloneObject;
	};

	Lyte.nestScpId = 1;
	Lyte.nestScp = {};
	Lyte.__nestRef__ = {};
	// Lyte.__nestScp__ = {};
	Lyte.__nestScp__ = new Map();
	// Lyte.__nestScp1__ = new Map();
	Lyte.establishObjectBinding = function (data, attr, fromStore, update, storeRecord, watch) {
		var model, fld, nestObj;
		var checkAttrs = data.__component__ && data.__component__.component.__data ? data.__component__.component.__data[attr] : undefined;
		if (fromStore) {
			if (data && !data.$ && data._scp) {
				var keys = Array.from(data._scp.keys());
				keys.forEach(function (id) {
					var recObj = Lyte.nestScp[id];
					model = store.modelFor(recObj.model);
				});
			} else {
				model = data.$.model;
			}
			fld = model && model.fieldList && model.fieldList.hasOwnProperty(attr) ? model.fieldList[attr] : {};
			var _checkDtype = false;
			if (fld) {
				var _dtype = Lyte.Transform[fld.type];
				if (_dtype && (_dtype.hasOwnProperty("properties") || _dtype.hasOwnProperty("items"))) {
					_checkDtype = true;
				}
			}
			if (fld && fld.type !== "relation" && fld.watch || _checkDtype) {
				checkAttrs = fld;
			} else {
				if (data._scp) {
					var keys = Array.from(data._scp.keys());
					keys.forEach(function (id) {
						var _mpObj = data._scp.get(id),
						    mpObj = _mpObj.paths;
						var _dtype = Lyte.nestScp[id] || undefined;
						watch = _dtype && _dtype["watch"] ? _dtype["watch"] : watch;
						for (var key in mpObj) {
							var path = key ? key.split(".") : [];
							path.push(attr);
							Lyte.bindObj(data, attr, id, path, new Map(), undefined, checkAttrs, watch, true);
						}
					});
				}
				return;
			}
		}
		if (update && data._scp && data._scp.size) {
			var keys = Array.from(data._scp.keys());
			keys.forEach(function (id) {
				var _mpObj = data._scp.get(id),
				    mpObj = _mpObj.paths;
				var _dtype = Lyte.nestScp[id] || undefined;
				watch = _dtype && _dtype["watch"] ? _dtype["watch"] : watch;
				for (var key in mpObj) {
					var path = key ? key.split(".") : [];
					path.push(attr);
					Lyte.bindObj(data, attr, id, path, new Map(), undefined, checkAttrs, watch, true);
				}
			});
		}
		var customDtype = false;
		if (checkAttrs && Lyte.Transform[checkAttrs.type]) {
			var dtype = Lyte.Transform[checkAttrs.type];
			if (dtype.hasOwnProperty("properties") || dtype.hasOwnProperty("items")) {
				checkAttrs = Lyte.Transform[checkAttrs.type];
				customDtype = true;
			}
		}
		if ((!fromStore || fld.watch || fld.properties || fld.items || watch || customDtype) && data[attr]) {
			var _scpObj, kmpKey;
			if (data && data.__component__) {
				data.__component__.__scpObj || Object.defineProperty(data.__component__, "__scpObj", {
					value: {}
				});
				kmpKey = data.__component__;
				_scpObj = data.__component__.__scpObj;
			} else if (Lyte.isRecord(data)) {
				data.$.__scpObj || Object.defineProperty(data.$, "__scpObj", {
					value: {}
				});
				kmpKey = data;
				_scpObj = data.$.__scpObj;
			}
			var obj = _scpObj,
			    id;
			if (_scpObj) {
				var __nestScp1Set__ = false,
				    __nestScp2Set__ = false;
				if (fromStore) {
					if (data[attr] && !Lyte.__nestScp__.has(data[attr])) {
						nestObj = { model: model._name, attr: attr, pK: data.$.pK, Error: {} };
						__nestScp1Set__ = true;
					} else {
						// var kmp = Lyte.__nestScp__[kid] = Lyte.__nestScp__[kid] || new Map();
						// data ? kmp.set(data, true) : undefined;
						var __nId = Lyte.__nestScp__.get(data[attr]);
						var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
						var refMpId = Lyte.$.genMapId(refMp);
						refMp.set(refMpId, true);
						Lyte.setRecBindMap(Lyte.nestScp[__nId], { model: model._name, attr: attr, pK: data.$.pK, Error: {} });
						obj[attr] = __nId + "_" + refMpId;
					}
				} else {
					if (data[attr] && !Lyte.__nestScp__.has(data[attr])) {
						var ErrMap = [],
						    cmpDataKeys = {};
						cmpDataKeys.key = attr;
						cmpDataKeys.dtype = data.__component__.component.__data[attr];
						cmpDataKeys._cmpErr = data.errors;
						cmpDataKeys.Error = {};
						ErrMap.push(cmpDataKeys);
						nestObj = { data: data[attr], PropsInfo: ErrMap };
						if (cmpDataKeys.dtype.watch) {
							nestObj.watch = true;
						}
						__nestScp2Set__ = true;
					} else {
						var __nId = Lyte.__nestScp__.get(data[attr]);
						var scope = Lyte.nestScp[__nId];
						if (scope) {
							var errMp = scope.PropsInfo;
							var cmpDataKeys = {};
							cmpDataKeys.key = attr;
							cmpDataKeys.Error = {};
							cmpDataKeys._cmpErr = data.errors;
							cmpDataKeys.dtype = data.__component__.component.__data[attr];
							if (cmpDataKeys.dtype.watch) {
								scope.watch = true;
							}
							errMp.push(cmpDataKeys);
						}
						var refMp = Lyte.__nestRef__[__nId] = Lyte.__nestRef__[__nId] || new Map();
						var refMpId = Lyte.$.genMapId(refMp);
						refMp.set(refMpId, true);
						obj[attr] = __nId + "_" + refMpId;
					}
				}
				if (nestObj) {
					var nestScpId = Lyte.nestScpId++;
					var refMp = Lyte.__nestRef__[nestScpId] = Lyte.__nestRef__[nestScpId] || new Map();
					var refMpId = Lyte.$.genMapId(refMp);
					refMp.set(refMpId, true);
					// var kmp = Lyte.__nestScp__[nestScpId] = Lyte.__nestScp__[nestScpId] || new Map();
					// kmp.set(kmpKey, true);
					Lyte.__nestScp__.set(data[attr], nestScpId);
					if (__nestScp1Set__) {
						Lyte.nestScp[nestScpId] = {};
						Lyte.setRecBindMap(Lyte.nestScp[nestScpId], nestObj);
						Lyte.nestScp[nestScpId].Error = nestObj.Error;
						//     Lyte.setRecBindMap(model._name, attr, data.$.pK, nestScpId); 
					}
					if (__nestScp2Set__) {
						Lyte.nestScp[nestScpId] = nestObj;
						//     Lyte.__nestScp2__.set(data[attr], nestScpId);
					}
					Lyte.nestScp[nestScpId]._data = data[attr];
					obj[attr] = obj[attr] || nestScpId + "_" + refMpId;
					var path = [];
					// fromStore ? path.push(attr) : undefined;
					Lyte.bindObj(data, attr, nestScpId, path, new Map(), undefined, checkAttrs, watch);
				}
			}
		}
	};

	Lyte.removeNestScp2Bind = function (mp, mdlObj) {
		var mp = mp.model;
		if (mp.has(mdlObj.model)) {
			var mp1 = mp.get(mdlObj.model);
			if (mp1.has(mdlObj.pK)) {
				var mp2 = mp1.get(mdlObj.pK);
				if (mp2.has(mdlObj.attr)) {
					mp2.delete(mdlObj.attr);
				}
				!mp2.size ? mp1.delete(mdlObj.pK) : undefined;
			}
			!mp1.size ? mp.delete(mdlObj.model) : undefined;
		}
	};

	Lyte.setRecBindMap = function (obj, nestObj) {
		var mp = obj.model = obj.model || new Map(),
		    modelName = nestObj.model,
		    pK = nestObj.pK,
		    attr = nestObj.attr;
		if (modelName && !mp.has(modelName)) {
			mp.set(modelName, new Map());
		}
		mp = mp.get(modelName);
		if (pK && !mp.has(pK)) {
			mp.set(pK, new Map());
		}
		mp = mp.get(pK);
		if (attr && !mp.has(attr)) {
			mp.set(attr, true);
		}
	};

	Lyte.bindObj = function (data, key, id, path, mp, check, checkAttrs, watch, ignoreCyclicDelete) {
		mp = mp || new Map();
		var value = key != undefined ? data[key] : data;
		var cyclic = false;
		if (!ignoreCyclicDelete && !path.length && Lyte.__nestScp__.get(data) === id) {
			delete Lyte.nestScp[id].cyclic;
		}
		if (path.length > 1 && value && Lyte.nestScp[id] && Lyte.nestScp[id].hasOwnProperty("data") && Lyte.nestScp[id].data === value) {
			if (mp.get(value)) {
				cyclic = true;
			} else {
				try {
					JSON.stringify(value);
				} catch (exp) {
					cyclic = true;
				}
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				Lyte.estObjScp(value, id, path, cyclic);
			}
			return;
		}
		var attrs, nestedSCP;
		if (checkAttrs) {
			if (checkAttrs.hasOwnProperty("items") || checkAttrs.hasOwnProperty("properties")) {
				attrs = checkAttrs.items || checkAttrs.properties;
				nestedSCP = true;
			} else if (watch == undefined && checkAttrs.watch == true) {
				watch = checkAttrs.watch;
			}
		}
		attrs = watch ? undefined : attrs;
		if (Array.isArray(value)) {
			if (!mp.get(value)) {
				mp.set(value, true);
				value.forEach(function (val, idx) {
					path.push(idx);
					if (watch || checkAttrs && checkAttrs.hasOwnProperty("items") && _typeof(checkAttrs.items) == "object") {
						Lyte.bindObj(value, idx, id, path, mp, undefined, attrs, watch);
					}
					path.pop();
				});
			} else {
				cyclic = true;
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				var _establish;
				if (Array.isArray(watch)) {
					_establish = Lyte.checkEstablishingSCP(value, path, watch);
				}
				if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
					Lyte.estObjScp(value, id, path, cyclic);
				}
			}
		} else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
			var cyclic = false;
			if (!mp.get(value)) {
				mp.set(value, true);
				for (var str in value) {
					path.push(str);
					if (watch || attrs && attrs.hasOwnProperty(str)) {
						Lyte.bindObj(value, str, id, path, mp, undefined, attrs ? attrs[str] : undefined, watch);
					}
					path.pop();
				}
			} else {
				cyclic = true;
			}
			if (Lyte.checkAndAddBind(value, id, path, cyclic)) {
				var _establish;
				if (Array.isArray(watch)) {
					_establish = Lyte.checkEstablishingSCP(value, path, watch);
				}
				if (_establish || typeof watch == "boolean" && watch || nestedSCP) {
					Lyte.estObjScp(value, id, path, cyclic);
				}
			}
		}
	};

	Lyte.checkAndAddBind = function (value, id, path, cyclic) {
		if (!value._scp || !value._scp.size) {
			return true;
		}
		if (value._scp.size) {
			if (value._scp.has(id)) {
				var _obj = value._scp.get(id);
				var obj = _obj.paths;
				if (obj.hasOwnProperty(path.join("."))) {
					if (cyclic) {
						Lyte.nestScp[id].cyclic = true;
					}
					return false;
				}
			}
		}
		return true;
	};

	Lyte.estObjScp = function (value, id, path, cyclic) {
		if (!value._scp) {
			Object.defineProperty(value, "_scp", {
				value: new Map(),
				enumerable: false,
				configurable: true
			});
		}
		var mp = value._scp;
		if (!mp.has(id)) {
			mp.set(id, {});
		}
		var obj = mp.get(id),
		    path = path ? path.join(".") : path;
		var pathObj = obj.paths = obj.paths || {};
		pathObj[path] = true;
		var nestObj = Lyte.nestScp[id];
		if (!nestObj.cyclic && cyclic == true) {
			nestObj.cyclic = true;
		}
	};

	Lyte.cmpObjs = function (obj1, obj2) {
		if (Object.keys(obj1).length !== Object.keys(obj2).length) {
			return false;
		}
		for (var key in obj1) {
			if (!obj2.hasOwnProperty(key)) {
				return false;
			}
			var ret = Lyte.cmpData(obj1[key], obj2[key]);
			if (ret == false) {
				return false;
			}
		}
		return true;
	};

	Lyte.cmpData = function (data1, data2) {
		if (Array.isArray(data1)) {
			if (!Array.isArray(data2) || data1.length !== data2.length) {
				return false;
			}
			if (data1 === data2) {
				return true;
			}
			var len = data1.length,
			    ret;
			for (var i = 0; i < len; i++) {
				ret = Lyte.cmpData(data1[i], data2[i]);
				if (ret == false) {
					return false;
				}
			}
		} else if (data1 && data2 && (typeof data1 === 'undefined' ? 'undefined' : _typeof(data1)) == "object" && (typeof data2 === 'undefined' ? 'undefined' : _typeof(data2)) == "object") {
			if (data1 === data2) {
				return true;
			}
			return Lyte.cmpObjs(data1, data2);
		}
		// else if(Lyte && Lyte.isRecord(data1) && Lyte.isRecord(data2)){
		//   if( (data1.$.model._name !== data1.$.model._name) || (Lyte.getpKVal(data1) !== Lyte.getpKVal(data2)) ){
		//     return false;
		//   }
		// }
		else if (data1 !== data2) {
				return false;
			}
		return true;
	};

	Lyte.nestScpRmPath = function (obj, path) {
		if (obj && obj.paths) {
			obj = obj.paths;
			for (var key in obj) {
				if (key.startsWith(path + ".")) {
					delete obj[key];
				}
			}
		}
	};

	Lyte.nestScpRemove = function (data, id, path) {
		var mp = data._scp;
		if (mp && mp.size) {
			if (path) {
				Lyte.nestScpRmPath(mp.get(id), path);
				var _obj = mp.get(id);
				var obj = _obj ? _obj.paths : undefined;
				if (obj && !Object.keys(obj).length) {
					mp.delete(id);
				}
			} else {
				mp.delete(id);
			}
			if (!mp.size) {
				delete data._scp;
			}
		}
	};

	Lyte.rmNestScp = function (value, id, mp, data, path) {
		if (Array.isArray(value)) {
			if (!mp.get(value)) {
				mp.set(value, true);
				value.forEach(function (val, idx) {
					Lyte.rmNestScp(val, id, mp, undefined, path);
				});
			}
			Lyte.nestScpRemove(value, id, path);
		} else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object") {
			if (!mp.get(value)) {
				mp.set(value, true);
				for (var str in value) {
					Lyte.rmNestScp(value[str], id, mp, undefined, path);
				}
			}
			Lyte.nestScpRemove(value, id, path);
		}
	};

	Lyte.removeNestScp = function (value, id, mpId, path, context, mp, data, recObj) {
		mp = mp || new Map();
		id = Number.parseInt(id);
		var obj = Lyte.nestScp[id],
		    kmp = Lyte.__nestRef__[id];
		if (recObj && obj.model) {
			Lyte.removeNestScp2Bind(obj, recObj);
		}
		if (context) {
			if (kmp && kmp.has(mpId)) {
				kmp.delete(mpId);
			}
			if (!kmp || kmp && !kmp.size) {
				delete Lyte.__nestRef__[id];
				if (Lyte.__nestScp__.has(value)) {
					Lyte.__nestScp__.delete(value);
				}
				Lyte.rmNestScp(value, id, mp, true, path);
				if (!data) {
					delete Lyte.nestScp[id];
				}
			}
		} else {
			Lyte.rmNestScp(value, id, mp, true, path);
		}
	};

	Lyte.resolvePromises = function (promises) {
		if (typeof promises == "string" || promises instanceof Promise) {
			return promises;
		} else {
			if (Array.isArray(promises)) {
				return promiseArray(promises);
			} else if ((typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) == "object") {
				return promiseHash(promises);
			}
		}

		function promiseHash(promiseObj) {
			var actPromKeys = [],
			    promises = [],
			    promiseKeys = Object.keys(promiseObj);
			promiseKeys.forEach(function (key) {
				var value = promiseObj[key];
				if (value instanceof Promise || value && !Array.isArray(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object" && typeof value.then == "function") {
					actPromKeys.push(key);
					promises.push(value);
				}
			});
			if (!promises.length) {
				return Promise.resolve(promiseObj);
			} else {
				var obj = {},
				    promise = new Promise(function (resolve, reject) {
					Promise.all(promises).then(function (data) {
						promiseKeys.forEach(function (promiseKey) {
							if (actPromKeys.indexOf(promiseKey) != -1) {
								obj[promiseKey] = data[actPromKeys.indexOf(promiseKey)];
							} else {
								obj[promiseKey] = promiseObj[promiseKey];
							}
						});
						resolve(obj);
					}, function (err) {
						reject(err);
						Lyte.error('Error on resolve promises', err);
					});
				});
				return promise;
			}
		}

		function promiseArray(promiseArray) {
			var array = [],
			    hasPromise = false;
			promiseArray.every(function (item, i) {
				if (item instanceof Promise || item && !Array.isArray(item) && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == "object" && typeof item.then == "function") {
					hasPromise = true;
					return false;
				}
				return true;
			});
			if (!hasPromise) {
				return Promise.resolve(promiseArray);
			}
			var promise = new Promise(function (resolve, reject) {
				Promise.all(promiseArray).then(function (data) {
					promiseArray.forEach(function (key, index) {
						array[index] = data[index];
					});
					resolve(array);
				}, function (err) {
					reject(err);
					Lyte.error('Error on resolve promises', err);
				});
			});
			return promise;
		}
	};
	function domContentLoaded1() {
		Lyte.assetsDivContainer.appendChild(Lyte.$.assetsDiv);
	}

	if (document.readyState === "complete" || document.readyState === "interactive") {
		domContentLoaded1();
	} else {
		document.addEventListener("DOMContentLoaded", function (e) {
			domContentLoaded1();
		}, true);
	};

	var XHRSend = XMLHttpRequest.prototype.send;
	XMLHttpRequest.prototype.send = function () {
		var event = window.event;
		var type,
		    target = event ? event.target : undefined;
		if (Lyte.getConfig("stateHandling")) {
			if (event) {
				type = event.type;
				/^(click|dblclick)$/.test(type) && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false" ? addStateToMap(type, target, this) : undefined;
			} else {
				var router = Lyte && Lyte.Router ? Lyte.Router.getRouteInstance() : undefined;
				if (router) {
					var currentAction = router.transition ? router.transition.ev : undefined;
					if (currentAction && currentAction.target && currentAction.target.getAttribute && currentAction.target.getAttribute("lyte-state-handling") != "false") {
						var mp = Lyte.__transXHRMap = Lyte.__transXHRMap || new Map();
						mp.set(router.transition, { currentAction: currentAction, XHR: this });
						addStateToMap(currentAction.type, currentAction.target, this);
					}
				}
			}
		}
		XHRSend.apply(this, arguments);
	};

	Lyte.addEventListener("transitionStart", function (obj) {
		var trans = obj.nextTrans;
		if (trans && obj.prevTrans) {
			if (window.event && /^(click|dblclick)$/.test(window.event.type)) {
				trans.ev = window.event;
				if (obj.prevTrans.ev) {
					delete obj.prevTrans.ev;
				}
			} else if ((obj.prevTrans.state == 409 || obj.prevTrans.state == 308) && obj.prevTrans.ev) {
				trans.ev = obj.prevTrans.ev;
				delete obj.prevTrans.ev;
			}
		}
	});

	Lyte.addEventListener("afterRouteTransition", function (obj) {
		if (obj && obj.trans) {
			var mp = Lyte.__transXHRMap,
			    removeEv = false;
			if (obj.trans.state == 409 || obj.trans.state == 308) {
				var ev1 = window.event,
				    ev2 = obj.trans.ev;
				if (!ev1 || ev1 && ev2 && ev1 != ev2 && ev1.target == ev2.target && ev1.type == ev2.type) {
					obj.trans.nested = true;
				} else {
					removeEv = true;
				}
				if (mp) {
					var mpObj = mp.get(obj.trans);
					if (mpObj) {
						removeStateFromMap(mpObj.XHR, mpObj.currentAction.type, mpObj.currentAction.target);
						mp.delete(obj.trans);
					}
				}
			} else if (obj.trans.state == 200) {
				mp ? mp.delete(obj.trans) : undefined;
				removeEv = true;
			}
			if (removeEv) {
				obj.trans.ev ? delete obj.trans.ev : undefined;
			}
		}
	});

	Lyte.addEventListener("beforeRouteTransition", function (obj) {
		if (obj && obj.prevTrans && obj.prevTrans.nested) {
			obj.trans.ev = obj.prevTrans.ev;
			delete obj.prevTrans.ev;
			obj.trans.fromPrevTrans = true; // temp check
		}
	});

	function addStateToMap(event, target, XHR, stateName) {
		var mp = Lyte.__nodeXHRMap = Lyte.__nodeXHRMap || new Map();
		var nodeMap = mp.get(target);
		if (!nodeMap) {
			mp.set(target, new Map());
		}
		nodeMap = mp.get(target);
		var sr = target.lyteState = target.lyteState || [],
		    type = stateName || XHR;
		if (sr.indexOf(type) == -1) {
			sr.push(type);
		}
		target.setAttribute("lyte-state", "");
		var evMap = nodeMap.get(event);
		if (!evMap) {
			nodeMap.set(event, []);
			evMap = nodeMap.get(event);
		}
		if (stateName) {
			evMap.push({ state: stateName });
			return { target: target, event: event };
		} else {
			evMap.push({ isXHR: true, xhr: XHR });
			var callback = function callback(arg) {
				if (XHR.readyState == 4) {
					removeStateFromMap(XHR, event, target);
					XHR.removeEventListener("readystatechange", callback);
				}
			};
			XHR.addEventListener("readystatechange", callback);
		}
	}
	function removeStateFromMap(type, event, target) {
		var mp = Lyte.__nodeXHRMap;
		var nodeMap = mp.get(target);
		if (!nodeMap) {
			return;
		}
		var evMap = nodeMap.get(event);
		if (!evMap) {
			return;
		}
		if (evMap) {
			var arr = evMap;
			var ind = -1;
			arr.every(function (itm, idx) {
				if (itm && itm.isXHR && itm.xhr == type || typeof type == "string" && itm.state == type) {
					ind = idx;
					return false;
				}
				return true;
			});
			if (ind != -1) {
				arr.splice(ind, 1);
				var sind = target.lyteState.indexOf(type);
				target.lyteState.splice(sind, 1);
				if (!arr.length) {
					nodeMap.delete(event);
					var tyInd = target && Array.isArray(target.lyteState) ? target.lyteState.indexOf(type) : -1;
					tyInd != -1 ? target.lyteState.splice(tyInd, 1) : undefined;
					if (target && target.lyteState && target.lyteState.length == 0) {
						target.lyteState = null;
						target.removeAttribute("lyte-state");
					}
				}
				if (!nodeMap.size) {
					mp.delete(target);
				}
			}
		}
	}

	Lyte.setState = function (str) {
		if (!str) {
			console.error("Please provide a state name");
		}
		var evnt = window.event;
		if (/^(click|dblclick)$/.test(evnt.type)) {
			var target = evnt.target;
			if (Lyte.getConfig("stateHandling") == true && target && target.getAttribute && target.getAttribute("lyte-state-handling") != "false") {
				var state = target.getAttribute("lyte-state");
				if (!state) {
					var mp = Lyte.__stateMap = Lyte.__stateMap || new Map();
					var mpobj = mp.get(str);
					if (!mpobj) {
						var obj = addStateToMap(evnt.type, target, undefined, str);
						mp.set(str, obj);
					} else {
						console.error("There is already a open state by the name", str);
					}
				}
			}
		}
	};

	Lyte.removeState = function (str) {
		if (!str) {
			console.error("Please provide a state name");
		}
		var mp = Lyte.__stateMap;
		if (mp) {
			var obj = mp.get(str);
			if (obj) {
				mp.delete(str);
				removeStateFromMap(str, obj.event, obj.target);
			}
		}
	};
	Lyte.setConfig = function (key, value) {
		var configObj = Lyte.__config = Lyte.__config || {};
		configObj[key] = value;
	};
	Lyte.getConfig = function (key) {
		var configObj = Lyte.__config;
		if (configObj) {
			return configObj[key];
		}
	};
	Lyte.establishWatchScope = function (watchProps, model) {
		var scope = this,
		    object;
		for (var v in watchProps) {
			var property = v;
			var watch = watchProps[v];
			if (scope.component && scope.component.__data && scope.component.__data[property]) {
				object = scope.getData(property);
				watch = scope.component.__data[property].watch ? true : watch;
				if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) == "object") {
					Lyte.establishObjectBinding(scope.component.data, v, false, undefined, undefined, watch);
				}
				var dataDef = scope.component.__data;
				if (Lyte.nestScp[Lyte.__nestScp__.get(object)]) {
					// nestScp[__nestScp__.get(object)].dtype.watch = watch;
					dataDef[v].watch = watch;
				}
			} else {
				if (model) {
					var fieldList = model.fieldList;
					if (fieldList[v] && fieldList[v].watch == undefined) {
						fieldList[v].watch = watch;
						model._fldGrps.watch[v] = fieldList[v];
					}
				}
			}
		}
	};

	Lyte.checkEstablishingSCP = function (value, path, watch) {
		if (Array.isArray(watch)) {
			var _path = '';
			_path = path.join(".");
			if (Lyte.checkWatchPath(_path, watch, true) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) != "object") {
				return true;
			}
			var _key = Object.keys(value);
			for (var i_scp = 0; i_scp < _key.length; i_scp++) {
				var spiePath = _key[i_scp];
				var finalaUth = _path == "" ? spiePath : _path + "." + spiePath;
				if (Lyte.checkWatchPath(finalaUth, watch, true)) {
					return true;
				}
			}
		}
	};
	Lyte.checkWatchPath = function (actualPath, watchArr, establishBind) {
		if (typeof watchArr == "boolean" && watchArr === true) {
			return true;
		} else if (Array.isArray(watchArr)) {
			for (var i_watch = 0; i_watch < watchArr.length; i_watch++) {
				var path = watchArr[i_watch];
				path = path.replace(/ /g, "");
				path = path.replace(/\$\.\./g, "..");
				path = path.replace(/\$\./g, "");
				var weirdPath = path.search(/\.\./g) != -1 || path.search(/\[|\\]|\{|\}/g) != -1 ? true : false || path.includes("*");
				if (actualPath == path) {
					return true;
				} else if (weirdPath) {
					if (establishBind) {
						if (path.search(/\.\./) != -1) {
							path = path.replace(/\.\.\S+/g, "..*");
							if (path == "..*") {
								return true;
							}
						}
					}
					path = path.search(/\[/) == 0 ? path.replace("[", "") : path;
					path = path.search(/\.\.\[/) == 0 ? path.replace("..[", "..") : path;
					path = path.replace(/\.*\[/g, ".");
					path = path.replace(/\]/g, "");
					var _watchPath = Lyte.checkWeirdPath(path, actualPath);
					if (_watchPath) {
						return true;
					}
				}
			}
		}
	};
	Lyte.checkWeirdPath = function (watchPath, actualPath) {
		if (actualPath == watchPath) {
			return true;
		} else if (watchPath.includes("..") || watchPath.includes("*")) {
			var cmpPath = watchPath;
			cmpPath = cmpPath.replace(/\*/g, "$$");
			cmpPath = cmpPath.replace(/\.\./g, "::");
			// cmpPath = cmpPath.replace("[","\\[")
			cmpPath = cmpPath.replace(/\./g, "\\.");
			cmpPath = cmpPath.replace(/\:\:/g, "\\.?.*\\.?");
			cmpPath = cmpPath.replace(/\$/g, ".*");
			var _wildCard = watchPath.split(".");
			var _wClenght = _wildCard.length;
			if (_wildCard[_wClenght - 2] == "" && _wildCard[_wClenght - 1] != "*") {
				cmpPath = cmpPath + "$";
			}
			var regularExp = new RegExp(cmpPath);
			if (regularExp.test(actualPath)) {
				return true;
			}
			return false;
		}
	};
})();
;(function (window) {
	//latest
	function Router(routes) {
		/*-----------string declaration starts------------*/
		var functionStr = "function",
		    routeStr = "route",
		    TransitionStr = "Transition",
		    pendingStr = "pending",
		    completedStr = "completed",
		    abortedStr = "aborted",
		    TransitionAbortedStr = TransitionStr + " " + abortedStr + ".",
		    TransitionResumedStr = TransitionStr + " resumed.",
		    TransitionPausedStr = TransitionStr + " paused.",
		    TransitionComletedStr = TransitionStr + " " + completedStr + ".",
		    parseRouteMappingStr = "parseRouteMapping",
		    constructRunLoopStr = "constructRunLoop",
		    RouteTransitionStr = "Route" + TransitionStr,
		    getDependenciesStr = "getDependencies",
		    getResourcesStr = "getResources",
		    beforeStr = "before",
		    afterStr = "after",
		    beforeModelStr = beforeStr + "Model",
		    modelStr = "model",
		    afterModelStr = afterStr + "Model",
		    redirectStr = "redirect",
		    renderTemplateStr = "renderTemplate",
		    afterRenderStr = afterStr + "Render",
		    beforeExitStr = beforeStr + "Exit",
		    didDestroyStr = "didDestroy",
		    willTransitionStr = "will" + TransitionStr,
		    didTransitionStr = "did" + TransitionStr,
		    onErrorStr = "onError",
		    beforeLoadStr = "beforeLoad",
		    onBeforeLoadStr = "onBeforeLoad",
		    beforeRouteTransitionStr = beforeStr + "Route" + TransitionStr,
		    afterRouteTransitionStr = afterStr + "Route" + TransitionStr,
		    beforeTemplateDestroyStr = beforeStr + "TemplateDestroy",
		    resourcesStr = "resources",
		    dependenciesStr = "dependencies",
		    ltPropStr = "lt-prop",
		    pReplace = ltPropStr + "-replace",
		    startHFromStr = "start-from",
		    pStartFrom = ltPropStr + "-" + startHFromStr,
		    pRoute = ltPropStr + "-" + routeStr,
		    pFragment = ltPropStr + "-fragment",
		    pDp = ltPropStr + "-dp",
		    pQp = ltPropStr + "-qp",
		    pTd = ltPropStr + "-td",
		    pTrans = ltPropStr + "-trans",
		    refreshHRouteStr = "refresh-" + routeStr,
		    pRefreshRoute = ltPropStr + "-" + refreshHRouteStr,
		    linktoStr = "link-to",
		    LINKTOStr = "LINK-TO",
		    stateChangeStr = "stateChange",
		    dependencyRequestLog = 'Requesting files in ' + getDependenciesStr + ' will stall execution of route till download completes. Please validate files ' + beforeStr + ' requesting.',
		    renderTemplateWarning = renderTemplateStr + " hook should return either component or HTML. Rendering of HTML directly into the DOM within the " + renderTemplateStr + " hook is deprecated.",
		    addRoutesWarning = "addRoutes function will be deprecated from next version",
		    ltPropWarning = "Error while parsing ltProp in " + linktoStr,

		/*-----------string declaration ends------------*/
		fontColor = 'MediumOrchid',
		    newTransInfo,
		    newTransInfoClone,
		    newTransInfoTimer,
		    t = Lyte.time,
		    log = Lyte.log,
		    parse = JSON.parse,
		    LR = this,
		    d = document,
		    dloc = d.location,
		    config = {
			routeHash: {},
			urlCache: {},
			stickyRoutes: {},
			allLinks: {},
			activeLinkTags: []
		},
		    trans,
		    prevTrans,
		    newTrans,
		    visibleTrans,
		    historyObj,
		    initialLoad = true,
		    allowHistoryChange = false,
		    historyLength = getMeta() ? getMeta().index : 0,
		    fromHistoryGo = false,
		    routeParser,
		    processedDispatch,
		    Processed,
		    emptyFn = function emptyFn() {},
		    run = {},
		    reqestedType = {
			getResources: resourcesStr,
			getDependencies: dependenciesStr
		};

		run[getDependenciesStr] = run[getResourcesStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
			    callback = this.R[index][hook];
			routeInstance.__lp[reqestedType[hook] + 'Loaded'] = true;
			if (callback && validateTransition(this)) {
				var require = callHookWithoutPromise.call(this, callback, this.routes[index], hook, index, params(index));
				if (require && require instanceof Promise) {
					return require;
				}
				routeInstance.__lp[reqestedType[hook]] = require;
				routeInstance.__lp[reqestedType[hook] + 'Loaded'] = !require || !(require.length || (typeof require === 'undefined' ? 'undefined' : _typeof(require)) == "object");
				if (require) {
					if (hook == getDependenciesStr) {
						console.warn(dependencyRequestLog);
					}
					routeInstance.__lp[fnType] = function () {
						routeInstance.__lp[fnType] = pendingStr;
					};
					getRequirements.call(this, { reqType: reqestedType[hook], r: routeInstance, index: index });
				}
			}
			return callHookWithPromise();
		};

		run[beforeModelStr] = run[modelStr] = run[afterModelStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    callback = this.R[index][hook],
			    args = [this.R[index][hook], routeInstance, params(index)];
			if (hook == afterModelStr) {
				args.splice(2, 0, routeInstance.currentModel);
			}
			if (callback) {
				var setDataIns = function setDataIns(data) {
					routeInstance.$[hook] = data;
					if (hook == modelStr) {
						routeInstance.currentModel = data;
					}
					delete callback.then;
				};

				callback.then = { success: setDataIns, failure: setDataIns };
			}
			return callHookWithPromise.apply(this, args);
		};

		run[redirectStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    args = [this.R[index][hook], routeInstance, params(index)];
			args.splice(2, 0, routeInstance.currentModel);
			return callHookWithPromise.apply(this, args);
		};

		run[onErrorStr] = function (hook, index, err, state, options) {
			setPendingResume.call(trans, trans.prom);
			trans._trans.triggerEvent(onErrorStr, { error: err, hook: hook });
			var errIns = this.routes[index];
			for (; index >= 0 && !this.aborted && this.paused; index--) {
				var instance = this.routes[index];
				log(onErrorStr + " of " + instance.routeName, routeStr, fontColor);
				if (callAction.call(this, onErrorStr, index, [err, this._trans, params(index), hook]) == false) {
					break;
				}
			}
			consoleErrorFromCallback(err, hook, errIns.routeName, state, options);
		};

		run[willTransitionStr] = function (hook, index) {
			if (callAction.call(prevTrans, hook, index, [trans._trans]) == false) {
				removeHook(trans.runLoop.previous, hook);
			}
			return callHookWithPromise();
		};

		run[beforeRouteTransitionStr] = function () {
			if (validateTransition(this)) {
				var pt;
				if (pt = prevTrans && prevTrans._trans) {
					delete pt.abort;
					delete pt.pause;
				}
				var obj = {
					prevTrans: pt,
					trans: trans._trans,
					history: LR.history
				};
				LR[beforeRouteTransitionStr](obj.prevTrans, obj.trans, obj.history);
				trans._trans.triggerEvent(beforeRouteTransitionStr, obj);
				Lyte.triggerEvent(beforeRouteTransitionStr, obj);
			}
			return callHookWithPromise();
		};

		run[afterRouteTransitionStr] = function (_trans) {
			LR[afterRouteTransitionStr](_trans);
			trans._trans.triggerEvent(afterRouteTransitionStr, { trans: _trans });
			Lyte.triggerEvent(afterRouteTransitionStr, { trans: _trans });
		};

		run[beforeLoadStr] = function (hook, index) {
			var route = this.routes[index],
			    loadingTemplate = callHookWithoutPromise.call(this, this.R[index][hook], this.routes[index], hook, index, params(index)),
			    outlet;
			if (loadingTemplate && loadingTemplate.outlet && (outlet = getOutlet(loadingTemplate.outlet, route.parent))) {
				if (outlet.childNodes[0]) {
					triggerTemplateDestroy({ outlet: outlet, route: route }, false);
				}
				if (loadingTemplate.component) {
					var component = d.createElement(loadingTemplate.component);
					setDataInComponent.call(this, component, loadingTemplate.data, routeInstance, hook, index);
					outlet.innerHTML = '';
					outlet.appendChild(routeInstance.component = component);
				} else if (renderTemplate.html) {
					routeInstance.component = undefined;
					outlet.innerHTML = renderTemplate.html;
					var scripts = outlet.getElementsByTagName('script');
					if (scripts.length) {
						scriptExecution(Array.from(scripts), outlet);
					}
				}
			}
			return callHookWithPromise();
		};

		run[onBeforeLoadStr] = function () {
			return new Promise(function (resolve, reject) {
				for (var len = trans.matched.route.length, i = 1; i <= len && validateTransition(trans); i++) {
					var l = len - i;
					if (trans.R[l].actions && trans.R[l].actions.onBeforeLoad) {
						console.log(onBeforeLoadStr + ' action is depricated. Use beforeLoad callback');
					}
					if (callAction.call(trans, onBeforeLoadStr, l, [params(l)]) == false || i == len) {
						resolve();
						break;
					}
				}
			});
		};

		run[afterRenderStr] = run[didTransitionStr] = function (hook, index) {
			return new Promise(function (resolve, reject) {
				var st = setTimeout(function () {
					if (hook == afterRenderStr) {
						var routeInstance = this.routes[index];
						routeInstance.__ltp.rendered = true;
						callHookWithPromise.call(this, this.R[index][hook], routeInstance, routeInstance.currentModel, params(index), routeInstance.component).then(function (data) {
							if (!trans.routes[index + 1]) {
								trans._trans.triggerEvent(afterRenderStr);
							}
							resolve(data);
						}, function (data) {
							reject(data);
						});
					} else {
						run.removeTemplate.call(this);
						if (callAction.call(this, hook, index, [params(index), trans._trans]) == false) {
							removeHook(trans.runLoop.current, hook);
							index = 0;
						}
						resolve();
						if (index == 0) {
							transitionCompleted({ state: 200 });
						}
					}
				}.bind(this, hook, index), 0);
				this.fns.push(st);
			}.bind(this));
		};

		run[beforeExitStr] = function (hook, index) {
			var prevTransRouteInstance = prevTrans.routes[index],
			    callback = prevTrans.R[index][hook];
			return callHookWithPromise.call(this, callback, prevTransRouteInstance, prevTransRouteInstance.currentModel, params(index, prevTrans));
		};

		run[renderTemplateStr] = function (hook, index) {
			var routeInstance = this.routes[index],
			    r = this.R[index];
			if (r[hook]) {
				run.removeTemplate.call(this);
				var renderTemplate = callHookWithoutPromise.call(this, r[hook], routeInstance, hook, index, routeInstance.currentModel, params(index));
				if (validateTransition(this)) {
					if (renderTemplate && (routeInstance.outletName = renderTemplate.outlet)) {
						var data = routeInstance.currentModel,
						    outlet;
						if (routeInstance.outlet = outlet = getOutlet(renderTemplate.outlet, routeInstance.parent)) {
							var obj = {
								outlet: renderTemplate.outlet,
								route: routeInstance
							};
							if (renderTemplate.component) {
								if (routeInstance.component && !renderTemplate.reRender && routeInstance.component.tagName.toLocaleLowerCase() == renderTemplate.component && routeInstance.outlet == outlet && outlet.contains(routeInstance.component)) {
									setDataInComponent.call(this, routeInstance.component, data, routeInstance, hook, index);
								} else {
									triggerTemplateDestroy(obj, false);
									var component = d.createElement(renderTemplate.component);
									component._route = routeInstance.__lp.objPath;
									setDataInComponent.call(this, component, data, routeInstance, hook, index);
									outlet.innerHTML = '';
									outlet.appendChild(routeInstance.component = component);
								}
							} else if (renderTemplate.html) {
								routeInstance.component = undefined;
								triggerTemplateDestroy(obj, false);
								outlet.innerHTML = renderTemplate.html;
								var scripts = outlet.getElementsByTagName('script');
								if (scripts.length) {
									scriptExecution(Array.from(scripts), outlet);
								}
							}
						}
					} else {
						Lyte.warn(renderTemplateWarning);
					}
				}
			} else if (validateTransition(this) && this.runLoop.templateToRemove && this.R.length == index + 1) {
				run.removeTemplate.call(this);
			}
			return callHookWithPromise();
		};

		function setDataInComponent(component, data, routeInstance, hook, index) {
			if (data) {
				if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" && !Array.isArray(data)) {
					component.setData(data);
				} else {
					processError.call(this, { stopTrans: true, err: Error(getError(203)).stack, instance: routeInstance, hook: hook, index: index });
				}
			}
		}

		function getOutlet(outlet, parent) {
			var _outlet;
			if (parent) {
				_outlet = parent.outlet ? parent.outlet.querySelector(outlet) : undefined;
				if (!_outlet) {
					return getOutlet(outlet, parent.parent);
				}
			} else if (!(_outlet = d.querySelector(outlet))) {
				consoleError(428, outlet);
			}
			return _outlet;
		}

		function scriptExecution(scriptNode) {
			for (var i = 0, currentScript; currentScript = scriptNode[i]; i++) {
				var parent = currentScript.parentNode,
				    s = d.createElement("script");
				for (var j = 0, attributes; attributes = currentScript.attributes[j]; j++) {
					s.setAttribute(attributes.name, attributes.value);
				}
				s.innerHTML = currentScript.innerHTML;
				parent.appendChild(s);
				parent.removeChild(currentScript);
			}
		}

		run.removeTemplate = function () {
			var arr = this.runLoop.templateToRemove;
			if (!this.cleared) {
				if (prevTrans && arr) {
					templateDelete(arr);
				}
				this.cleared = true;
				if (visibleTrans != this) {
					visibleTrans = this;
				}
				delete this.runLoop.templateToRemove;
				Lyte.removeFromCache();
			}
		};

		function params(index, t) {
			t = t || trans;
			var routeInstance = t.routes[index];
			return {
				queryParams: routeInstance.__ltp.queryParams,
				dynamicParam: routeInstance.__ltp.dynamicParam
			};
		}

		function validateTransition(trans) {
			return !trans.aborted && !trans.paused;
		}

		function addToHistory(obj) {
			var type = obj.replace ? "replaceState" : "pushState",
			    url = config.history ? _delimit(shiftBaseURL(obj.url, true)) : '#' + (config.slashAfterHash ? _delimit(obj.url) : obj.url[0] == "/" && obj.url.length > 1 ? obj.url.substring(1, obj.url.length) : obj.url);
			obj.title = obj.title || d.title;
			/* support for windows, undefined is appended to url */
			var args = [obj.state, obj.title];
			if (url) {
				args.push(url);
			}
			window.history[type].apply(history, args);
		}

		function getMeta() {
			return history.state && history.state.meta;
		}

		function getData() {
			return history.state && history.state.data;
		}

		function getHistoryState(obj) {
			/* 
   	state data which needs to be pushed to history. 
   	- Matched object is added to process url directly with history back and forward.
   	- Index is used to detect browser back or forward.
   */

			return {
				meta: {
					matched: obj.matched,
					url: obj.url,
					index: obj.fromHistory ? getMeta() ? getMeta().index : historyLength : obj.replace && getMeta() ? getMeta().index : historyLength = historyLength + 1
				},
				data: obj.data
			};
		}

		function getHistoryObj(obj) {
			/* parses history state to history object. */
			if (!LR.history) {
				historyRegistration();
			}
			LR.history.index = obj.state.meta.index;
			LR.history.fromHistory = obj.fromHistory ? prevTrans ? prevTrans.stateObj.meta.index < trans.stateObj.meta.index ? 'forward' : 'back' : 'reload' : false;
			allowHistoryChange = true;
			LR.history.state = getData() || {};
			LR.history.initial = initialLoad;
			return LR.history;
		}

		this.configureDefaults = function (options) {
			options = options || {};
			config.history = options.history == "html5";
			config.baseURL = options.baseURL;
			config.slashAfterHash = options.slashAfterHash == undefined ? true : options.slashAfterHash;
			config.deferInit = options.deferInit || false;
			config.preserveUrlOnBrowserNavigation = options.preserveUrlOnBrowserNavigation;
			config.linkActiveClass = options.hasOwnProperty("linkActiveClass") ? options.linkActiveClass : "";
			config.cipher = options.cipher;
			config.queryParamOptions = {
				sticky: options.queryParamOptions && options.queryParamOptions.hasOwnProperty('sticky') ? options.queryParamOptions.sticky : true
			};
			if (!Lyte.$.prefetchSupport || options.execRouteRequirementsOnDemand == false) {
				Lyte.$.replaceOldInjectResource && Lyte.$.replaceOldInjectResource();
				config.execRouteRequirementsOnDemand = false;
			} else {
				config.execRouteRequirementsOnDemand = true;
			}

			this.__lp.config = config;
		};

		this.__lp = {
			version: "3.2.7",
			pendingReg: [],
			getDefinition: function getDefinition(arr, def) {
				if (arr == "*") {
					return config.routes;
				} else {
					def = def || config.routes;
					def = _getObj(arr, def);
					return def && def.__lp && def.__lp.def || undefined;
				}
			}
		};

		this.configureRoutes = function (map) {
			if (!this.__lp.config) {
				this.configureDefaults();
			}
			parseRouteMapping.call(this, map);
			for (var i = 0, l = this.__lp.pendingReg.length; i < l; i++) {
				registerRoute.apply({}, this.__lp.pendingReg[i]);
			}
			this.__lp.pendingReg = [];
			Lyte.domContentLoaded(init);
			this.__lp.routesConfigured = true;
		};

		function init() {
			if (!config.deferInit && LR.init) {
				LR.init();
			}
		}

		this.init = function (r) {
			delete this.init;
			this.popstate = function (onChangeEvent) {
				var goValue, url;
				if (config.preserveUrlOnBrowserNavigation) {
					if (fromHistoryGo) {
						fromHistoryGo = false;
						return;
					}
					if (getMeta() && prevTrans && prevTrans.stateObj.meta.index != getMeta().index) {
						fromHistoryGo = true;
						url = getUrlFromMeta(onChangeEvent);
						goValue = prevTrans.stateObj.meta.index - getMeta().index;
						history.go(goValue);
					}
				}
				url = url || getUrlFromMeta(onChangeEvent);
				historyObj = {
					fromHistory: true,
					url: url,
					goValue: goValue
				};
				if (onChangeEvent && history.state) {
					historyObj.data = history.state;
				}
				if (trans && !trans.aborted) {
					console.log("aborting from dispatch");
					trans.abort({ state: 308, iAbort: true });
				}
				dispatch(url);
			};
			window.addEventListener('popstate', this.popstate);
			if (config.history) {
				this.popstate();
			} else {
				historyObj = {
					fromHistory: true,
					url: getLocation()
				};
				dispatch(historyObj.url);
			}
			linkToRegistration();
			return this;
		};

		function getUrlFromMeta(onChangeEvent) {
			var url;
			if (!(getMeta() && (url = getMeta().url))) {
				if (config.history) {
					url = getLocation();
				} else {
					var newURL = onChangeEvent && onChangeEvent.newURL || dloc.hash;
					url = checkForEmptyPath(newURL.replace(/.*#/, ''));
				}
			}
			return url;
		}

		this.beforeScroll = this[beforeRouteTransitionStr] = this[afterRouteTransitionStr] = emptyFn;

		function setRouteDef(dir, value) {
			var cache = config.routes,
			    len = dir.length,
			    dirLen = len - 1;
			for (var i = 0, key; i < len; i++) {
				key = dir[i];
				if (dirLen === i) {
					var obj = cache[key];
					if (obj && obj.__lp) {
						obj.__lp.def = value;
					} else if (obj) {
						obj.__lp = { def: value };
					} else {
						cache[key] = { __lp: { def: value } };
					}
				} else if (!cache[key]) {
					cache[key] = {};
				}
				cache = cache[key];
			}
		}

		function linkToRegistration() {
			var LinkTo = function (_HTMLElement) {
				_inherits(LinkTo, _HTMLElement);

				function LinkTo() {
					_classCallCheck(this, LinkTo);

					return _possibleConstructorReturn(this, (LinkTo.__proto__ || Object.getPrototypeOf(LinkTo)).apply(this, arguments));
				}

				_createClass(LinkTo, [{
					key: 'attributeChangedCallback',
					value: function attributeChangedCallback(attr, oldValue, newValue) {
						if (this.matched && this.hasAttribute("lyte-rendered")) {
							var aTag = this.getElementsByTagName('A')[0];
							//If attr is ltProp
							if (aTag) {
								if (attr === ltPropStr) {
									this.handleLtProp();
									if (!this.hasAttribute("lt-prop-custom")) {
										this.setCustomAttributes(aTag, true);
									}
									this.constructHref(aTag);
								} else if (/^(lt-prop-route|lt-prop-fragment|lt-prop-dp|lt-prop-qp)$/.test(attr)) {
									//if it is a route transition attribute
									this.getMatchedObject();
									this.constructHref(aTag, attr, oldValue, newValue);
								} else if (!this.hasAttribute('lt-prop-custom')) {
									//for rest of the attributes
									aTag.setAttribute(attr.substring(8), newValue);
								}
							}
						}
					}
				}, {
					key: 'connectedCallback',
					value: function connectedCallback() {
						this.ltProp = this.ltProp || {};
						this.handleLtProp();
						if (this.hasAttribute("lyte-rendered")) {
							if (this.getElementsByTagName('A')[0] && !this.matched) {
								this.getMatchedObject();
							}
							return;
						}
						var isCustom = this.hasAttribute("lt-prop-custom") || this.ltProp.custom,
						    aTag;
						if (isCustom) {
							if (aTag = this.getElementsByTagName('A')[0]) {
								this.getMatchedObject();
								this.constructHref(aTag);
							}
						} else {
							aTag = d.createElement("a");
							while (this.childNodes[0]) {
								aTag.appendChild(this.childNodes[0]);
							}
							this.setCustomAttributes(aTag);
							this.getMatchedObject();
							this.constructHref(aTag);
							this.appendChild(aTag);
						}
						if (Lyte.Component) {
							this._linkToEventId = Lyte.Component.addLyteEventListener(this, "click", function (event) {
								linkToEventListener(event, this);
							}, this);
						} else {
							this.addEventListener("click", linkToEventListener);
						}
						this.setAttribute("lyte-rendered", "");
					}
				}, {
					key: 'modifyLinkToTagsInRoute',
					value: function modifyLinkToTagsInRoute(remove) {
						var strRoute = Array.isArray(this.matched.route) ? this.matched.route.join('.') : this.matched.route,
						    allLinks = config.allLinks[strRoute];
						if (remove) {
							if (allLinks) {
								var pos = allLinks.indexOf(this);
								if (pos != -1) {
									allLinks.splice(pos, 1);
								}
							}
						} else {
							if (allLinks) {
								allLinks.push(this);
							} else {
								config.allLinks[strRoute] = [this];
							}
						}
						if (config.stickyRoutes[strRoute]) {
							var routesObj = config.routes,
							    _routes = void 0;
							if (remove) {
								if (this.matched) {
									_routes = remove;
								} else {
									return;
								}
							} else {
								_routes = this.matched.route;
							}
							if (!_routes) {
								return;
							}
							_routes = Array.isArray(_routes) ? _routes : dotSerperator(_routes);
							for (var i = 0, l = _routes.length, r; i < l; i++) {
								r = _routes[i];
								routesObj = _getObj(r, routesObj);
								if (!routesObj || !routesObj.__lp) {
									consoleError(422, _routes, i);
									return false;
								}
								var def = routesObj.__lp.def.__lp;
								if (remove) {
									var _pos = def.stickyLinks.indexOf(this);
									if (_pos !== -1) {
										def.stickyLinks.splice(_pos, 1);
									}
								} else if (def.qpdef) {
									def.stickyLinks.push(this);
								}
							}
						}
					}
				}, {
					key: 'disconnectedCallback',
					value: function disconnectedCallback() {
						var m = this.modifyLinkToTagsInRoute.bind(this);
						if (!Lyte.Component.shouldIgnoreDisconnect()) {
							if (this.matched && this.matched.route) {
								m(this.matched.route);
							}
							if (this._linkToEventId) {
								Lyte.Component.removeLyteEventListener(this, this._linkToEventId);
							}
						}
					}
				}, {
					key: 'handleLtProp',
					value: function handleLtProp() {
						var ltProp = this.getAttribute(ltPropStr);
						if (ltProp) {
							try {
								this.ltProp = parse(ltProp);
							} catch (e) {
								Lyte.warn(ltPropWarning);
							}
						}
					}
				}, {
					key: 'setCustomAttributes',
					value: function setCustomAttributes(linkTag, onlyLtProp) {
						for (var _key2 in this.ltProp) {
							if (/^(id|class|style|target)$/.test(_key2)) {
								linkTag.setAttribute(_key2, this.ltProp[_key2]);
							}
						}
						if (!onlyLtProp) {
							for (var _i2 = 0, attr, attrName; attr = this.attributes[_i2]; _i2++) {
								if ((attrName = attr.nodeName) !== ltPropStr && /^(lt-prop-id|lt-prop-rel|lt-prop-class|lt-prop-style|lt-prop-target|lt-prop-tabindex|lt-prop-aria-label|lt-prop-aria-attributes)$/.test(attrName)) {
									linkTag.setAttribute(attrName.substring(8), attr.nodeValue);
								}
							}
						}
					}
				}, {
					key: 'constructHref',
					value: function constructHref(linkTag, attr, oldValue) {
						var href,
						    m = this.modifyLinkToTagsInRoute.bind(this);
						if (href = LR.getURL.call(this, this.matched)) {
							linkTag.setAttribute("href", href);
							if (attr === pRoute) {
								m(oldValue);
								m();
							} else {
								m();
							}
						}
					}
				}], [{
					key: 'observedAttributes',
					get: function get() {
						return [pRoute, pDp, pFragment, pQp, ltPropStr, 'lt-prop-class', 'lt-prop-data-tabindex', 'lt-prop-data-tabindex', 'lt-prop-tabindex', 'lt-prop-aria-label', 'lt-prop-aria-attributes', 'lt-prop-id', 'lt-prop-rel', 'lt-prop-title', 'lt-prop-style', 'lt-prop-target'];
					}
				}]);

				return LinkTo;
			}(HTMLElement);

			LinkTo.prototype.getMatchedObject = function () {
				var matched = this.matched || {},
				    ga = this.getAttribute.bind(this),
				    dynamicParams = ga(pDp) || this.ltProp.dp || [],
				    queryParams = ga(pQp) || this.ltProp.qp || {};
				if (!(dynamicParams instanceof Array)) {
					try {
						dynamicParams = parse(dynamicParams);
					} catch (e) {
						consoleError(498, "dynamicParams", this.outerHTML);
						return;
					}
				}
				if (!(queryParams instanceof Object)) {
					try {
						queryParams = parse(queryParams);
						if (Array.isArray(queryParams)) {
							consoleError(498, "queryParams", this.outerHTML);
							return;
						}
					} catch (e) {
						consoleError(498, "queryParams", this.outerHTML);
						return;
					}
				}
				matched.route = ga(pRoute) || this.ltProp.route;
				matched.fragment = ga(pFragment) || this.ltProp.fragment;
				matched.dynamicParams = dynamicParams || [];
				matched.queryParams = queryParams || {};
				matched.refreshRoute = ga(pRefreshRoute) != undefined ? ga(pRefreshRoute) : this.ltProp[refreshHRouteStr];
				matched.refreshRoute = matched.refreshRoute == "" || matched.refreshRoute == 'true' ? matched.route : matched.refreshRoute;
				matched.startFrom = ga(pStartFrom) || this.ltProp[startHFromStr];
				return this.matched = matched;
			};
			customElements.define(linktoStr, LinkTo);
		}

		function linkToEventListener(event, linkTo) {
			if (event.button == 2 || event.defaultPrevented) {
				return;
			}
			var targetElem = linkTo || event.currentTarget;
			if (targetElem.children[0].tagName === "A" && (event.ctrlKey == true || event.metaKey == true || event.which == 2 || targetElem.children[0].hasAttribute("target") && targetElem.children[0].getAttribute("target") !== "_self")) {
				return;
			}
			event.preventDefault();
			if (!targetElem.matched) {
				targetElem.getMatchedObject();
			}
			var matched = Object.assign({}, targetElem.matched);
			matched.route = Array.isArray(matched.route) ? matched.route.join('.') : matched.route;
			var replace = targetElem.ltProp.replace || targetElem.hasAttribute(pReplace),
			    transitionInstance = LR[replace && replace != "false" ? "replaceWith" : "transitionTo"](targetElem.matched);
			var transObj = {},
			    transProp;
			if (transProp = targetElem.getAttribute(pTrans)) {
				try {
					transObj = parse(transProp);
				} catch (e) {
					consoleError(498, pTrans, linkTo.outerHTML);
				}
			}
			var transitionData = targetElem.getAttribute(pTd);
			if (transitionData = transitionData || transObj.data) {
				if (typeof transitionData === "string") {
					try {
						transitionData = parse(transitionData);
					} catch (e) {
						consoleError(498, pTd, linkTo.outerHTML);
					}
				}
				transObj.data = transitionData;
			}
			for (var key in transObj) {
				transitionInstance[key] = transObj[key];
			}
		}

		this.checkIfSameRoute = function (transInfo1, transInfo2) {
			if (transInfo1.route == transInfo2.route && transInfo1.fragment == transInfo2.fragment && transInfo1.dynamicParams.length === transInfo2.dynamicParams.length && _compareObj(transInfo1.queryParams, transInfo2.queryParams)) {
				return checkIfSameDp(transInfo1.dynamicParams, transInfo2.dynamicParams);
			}
			return false;
		};

		function checkIfSameDp(dp1, dp2) {
			if (dp1.length) {
				for (var i = 0, dp; dp = dp1[i]; i++) {
					if (dp != dp2[i]) {
						return false;
					}
				}
			}
			return true;
		}

		function convertMatchedObjToRouteInfo(matched) {
			var info = {
				route: matched.route.join("."),
				fragment: matched.fragment,
				dynamicParams: matched.dynamicParams.filter(_arrayClean),
				queryParams: matched.queryParams

			};
			return info;
		}

		this.addRoutes = function (map, route) {
			var clr = setInterval(function () {
				if (Lyte.Router.__lp.routesConfigured) {
					clearInterval(clr);
					Lyte.warn(addRoutesWarning);
					var routeArr = route ? route.split(".") : [],
					    routes = _getObj(routeArr, config.routes);
					if (!routes) {
						console.error(route + " is not specified in router map.");
						return;
					}
					Object.assign(routes, parseRouteMapping.call(routeParser, map));
				}
			}, 0);
		};

		function dotSerperator(str) {
			return str.split('.').filter(function (s) {
				return s != "";
			});
		}

		function _arrayClean(e) {
			return e != undefined;
		}

		function parseRouteMapping(map) {
			t(parseRouteMappingStr);
			var routesObj = config.routes ? config.routes : config.routes = {},
			    mapObj = {},
			    pathStringArr = [],
			    routeStringArr = [];
			routeParser = {
				route: function route(routeName, obj, nestedFn) {
					if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object") {
						if (!obj.path) {
							obj.path = _delimit(routeName);
						} else {
							if (_presence(obj.path, "?")) {
								var split = obj.path.split('?');
								obj.defQP = frameQueryParams(split[1]);
								obj.path = split[0] || "/";
							}
						}
						if (obj.queryParams) {
							obj.defQP = obj.queryParams;
						}
					} else {
						if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == functionStr) {
							nestedFn = obj;
						}
						obj = { path: _delimit(routeName) };
					}
					mapObj = _getObj(pathStringArr, config.routeHash)[obj.path] = { __lp: {} };
					if (obj.path == '/') {
						pathStringArr.push('/');
					} else {
						var trimedPath = obj.path;
						if (dynamicRouteCheck(trimedPath) || wildcardRouteCheck(trimedPath)) {
							_splitPath(trimedPath).every(function (seg, index, arr) {
								if (dynamicRouteCheck(seg) || wildcardRouteCheck(seg)) {
									var dkey;
									if (dynamicRouteCheck(seg)) {
										dkey = seg.replace(":", "");
									} else {
										dkey = seg.replace("*", "");
										obj.wildcard = mapObj.__lp.wildcard = true;
										obj.sufix = mapObj.__lp.sufix = [];
										for (var i = index + 1, j; j = arr[i]; i++) {
											mapObj.__lp.sufix.push(j);
										}
									}
									obj.dkey = mapObj.__lp.dkey = dkey;
									obj.dIndex = mapObj.__lp.dIndex = index;
									return false;
								}
								return true;
							});
						}
						pathStringArr.push(trimedPath);
					}
					var routes = _getObj(routeStringArr, routesObj) || routesObj;
					routeStringArr.push(routeName);
					mapObj.__lp.route = Array.from(routeStringArr);
					routes[routeName] ? Object.assign(routes[routeName].__lp, obj) : routes[routeName] = { __lp: obj };
					if (nestedFn) {
						nestedFn.call(this, {});
					}
					routeStringArr.pop();
					pathStringArr.pop();
				}
			};
			map.call(routeParser, {});
			t(parseRouteMappingStr);
			return routesObj;
		}

		this.replaceWith = function () {
			var args = normalizeMatchedObj.call(this, normalizeTransitionParams.apply(this, arguments));
			if (args) {
				args.matched.replace = true;
				return routeTransition(args);
			}
		};

		this.transitionTo = function () {
			var processed;
			if (processed = normalizeMatchedObj.call(this, normalizeTransitionParams.apply(this, arguments))) {
				return routeTransition(processed);
			}
		};

		this.getURL = function (matched) {
			if (matched) {
				if (!matched.route) {
					matched = normalizeTransitionParams.apply(this, arguments);
				} else if (!matched.queryParams) {
					matched.queryParams = {};
				}
				var url,
				    l,
				    linkTo = this.tagName == LINKTOStr,
				    cache = config.urlCache,
				    matchedCache,
				    sticky = config.queryParamOptions.sticky;
				if (!sticky && (matchedCache = cache[Array.isArray(matched.route) ? matched.route.join('.') : matched.route])) {
					url = matchedCache.url;
					if (l = matched.dynamicParams && matched.dynamicParams.length) {
						for (var i = 0; i < l; i++) {
							url = url.replace('<<dp>>', matched.dynamicParams[i]);
						}
					} else if (url.indexOf('<<dp>>') != -1) {
						consoleError(499, matched.route, linkTo ? this : undefined);
					}
					for (var key in matchedCache.defQP) {
						if (!matched.queryParams[key] && matchedCache.defQP[key]) {
							matched.queryParams[key] = matchedCache.defQP[key];
						}
					}
					url = appendQueryParamsAndFrag(url, matched);
				} else {
					if (linkTo) {
						url = constructURLFromRoute.apply(this, arguments);
					} else {
						url = constructURLFromRoute.call(this, matched);
					}
				}
				if (url) {
					url = config.history ? shiftBaseURL(url, true) : '#' + url;
					return url;
				}
			}
		};

		this.getRoute = function (url) {
			var matched = traverse(shiftBaseURL(url), true);
			if (matched) {
				matched.dynamicParams = matched.dynamicParams.filter(_arrayClean);
				matched.route = matched.route.join('.');
			}
			return matched;
		};

		function routeTransition(processed) {
			if (LR.init) {
				consoleError(405);
				return;
			}
			var matched = processed.matched,
			    currRoute;
			processed.currRoute = currRoute = matched.route.join('.');
			matched.refreshRoute && currRoute == prevTrans.info.route;
			newTransInfo = {
				replace: matched.replace || (matched.refreshRoute && LR.checkIfSameRoute(convertMatchedObjToRouteInfo(processed.matched), convertMatchedObjToRouteInfo(prevTrans.matched)) ? true : matched.replace),
				title: trans ? trans.title : d.title,
				fromHistory: false
			};
			var url = dispatchTransition(processed);
			if (url && newTrans) {
				log('Transitioning to ' + currRoute + ' ' + url, routeStr);
				return newTrans._trans;
			} else {
				log('Transition failed');
				return {};
			}
		}

		function getLocation() {
			if (config.history) {
				var path = checkForEmptyPath(dloc.pathname + dloc.search + (dloc.hash || ""));
				path = shiftBaseURL(path);
				return _delimit(path);
			} else {
				return _delimit(checkForEmptyPath(dloc.hash.replace('#', '')));
			}
		}

		function checkForEmptyPath(path) {
			if (!path) {
				path = '/';
			}
			return path;
		}

		function shiftBaseURL(path, append) {
			var baseURL;
			if ((baseURL = config.baseURL) && path) {
				baseURL = _delimit(baseURL);
				if (path.indexOf(baseURL) == 0 && !append) {
					return path.replace(baseURL, '');
				} else if (append && path.indexOf(baseURL) != 0) {
					return baseURL + path;
				}
			}
			return path;
		}

		function constructURLFromRoute(matched) {
			if (matched && matched.route) {
				var strRoute;
				if (!Array.isArray(matched.route)) {
					matched.route = dotSerperator(strRoute = matched.route);
				} else {
					strRoute = matched.route.join('.');
				}
				matched.queryParams = matched.queryParams || {};
				matched.dynamicParams = matched.dynamicParams || [];
				matched.refreshModel = false;
				var url,
				    sameRoute = !!trans,
				    dynamicPos = matched.dynamicParams.length != matched.route.length,
				    dynamicParamPos = 0,
				    linkTo = this.tagName == LINKTOStr,
				    routeObj = config.routes,
				    templateUrl = url = '',
				    defQPTemp = {},
				    route;
				for (var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					if (sameRoute && trans.matched.route[i] != route) {
						sameRoute = false;
					}
					routeObj = _getObj(route, routeObj);
					if (!routeObj && !routeObj.__lp && routeObj.__lp.path) {
						consoleError(422, matched.route, i);
						return false;
					}
					var def = routeObj.__lp.def;
					if (!def && !linkTo) {
						consoleError(422, matched.route, i);
					}
					var path = routeObj.__lp.path,
					    defaultQP;
					if (!def || !def.__lp) {
						if (defaultQP = routeObj.__lp.defQP) {
							for (var key in defaultQP) {
								if (matched.queryParams && !matched.queryParams.hasOwnProperty(key)) {
									matched.queryParams[key] = defaultQP[key];
								}
							}
						}
					} else if (def.queryParams) {
						defaultQP = routeObj.__lp.defQP;
						var qpdef = def.__lp.qpdef;
						for (var key in qpdef) {
							if (!matched.queryParams.hasOwnProperty(key)) {
								if (sameRoute && qpdef[key].sticky) {
									matched.queryParams[key] = trans.routes[i].__ltp.queryParams[key];
								} else if (defaultQP && defaultQP.hasOwnProperty(key)) {
									defQPTemp[key] = matched.queryParams[key] = defaultQP[key];
								}
							}
							if (constructURLFromRoute.caller.name != "pathProcessor" && qpdef[key].cipher && config.cipher.encryptor) {
								matched.queryParams[key] = config.cipher.encryptor(matched.queryParams[key]);
							}
							if (!linkTo && !matched.refreshModel && qpdef[key].refreshModel) {
								matched.refreshModel = true;
							}
						}
					}
					if (routeObj.__lp.dkey) {
						var dynamicPathSplit = _splitPath(path),
						    dynamicPathSplitTemp = _splitPath(path),
						    pos = dynamicPos ? dynamicParamPos : i;
						if (!matched.dynamicParams || !matched.dynamicParams[pos]) {
							consoleError(499, route, linkTo ? this : undefined);
							return false;
						} else {
							dynamicPathSplit[routeObj.__lp.dIndex] = encodeURI(matched.dynamicParams[pos]);
							dynamicPathSplitTemp[routeObj.__lp.dIndex] = _delimit('<<dp>>');
							templateUrl += _delimit(dynamicPathSplitTemp.join('/'));
							url += _delimit(dynamicPathSplit.join('/'));
							dynamicParamPos++;
						}
					} else {
						templateUrl += _delimit(path);
						url += _delimit(path);
					}
				}
				if (!config.stickyRoutes[strRoute]) {
					config.urlCache[strRoute] = { url: validateURL(templateUrl), defQP: defQPTemp };
				}
				return appendQueryParamsAndFrag(url, matched);
			}
		}

		function appendQueryParamsAndFrag(url, matched) {
			url = url[url.length - 1] == '/' && url.length != 1 ? url.slice(0, -1) : url;
			if (matched.queryParams) {
				var ques = true;
				for (var key in matched.queryParams) {
					if (matched.queryParams[key] != undefined) {
						if (ques) {
							url += '?';
							ques = false;
						} else {
							url += '&';
						}
						url += key + '=' + encodeURIComponent(matched.queryParams[key]);
					}
				}
			}
			if (config.history && matched.fragment) {
				url = url + "#" + matched.fragment;
			}
			return validateURL(url);
		}

		function historyRegistration() {
			LR.history = new History();
			function History() {
				return this;
			}

			Object.defineProperty(History.prototype, 'state', {
				get: function get() {
					return getData();
				},
				set: function set(data) {
					if (allowHistoryChange) {
						allowHistoryChange = false;
					} else {
						Lyte.warn('setting on data will not be pushed to history. If needed, use `LR.history.replaceState`.');
					}
					return data;
				}
			});

			History.prototype.replaceState = function () {
				stateChange.apply(Array.from(arguments).push(true));
			};

			History.prototype.pushState = function () {
				stateChange.apply(Array.from(arguments));
			};

			function stateChange(data, title, url, replace) {
				if (!replace) {
					getMeta().index++;
				}
				addToHistory({
					state: {
						meta: getMeta(),
						data: data
					},
					title: title,
					url: url
				});
			}
		}

		var invokeRunLoop;
		function dispatch(path, processed, data) {
			t(RouteTransitionStr);
			if (path && config.baseURL && d.location.pathname.indexOf(config.baseURL) == -1) {
				consoleError(400);
				return;
			}
			processed = processed || (!initialLoad && getMeta() && getMeta().matched && getMeta().url == getLocation() ? normalizeMatchedObj(getMeta().matched) : traverse(path));
			if (processed && processed.matched.route.length) {
				clearTimeout(invokeRunLoop);
				processed.prevTrans = processed.prevTrans || Lyte.Router.__lp.prevTrans;
				processed.path = processed.path || path;
				processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched, processed.R);
				invoke(Processed = processed);
				Lyte.triggerEvent("transitionStart", { prevTrans: prevTrans && prevTrans._trans, nextTrans: newTrans._trans });
				invokeRunLoop = setTimeout(function () {
					Processed = undefined;
					if (trans && trans.state == 102 && newTrans && LR.checkIfSameRoute(newTrans.info, trans.info) && !trans.aborted && JSON.stringify(trans._data) == JSON.stringify(newTrans._trans.data)) {
						if (trans.iPause == true) {
							trans.resume();
						}
						return;
					} else if (trans && trans.state == 102) {
						trans.abort({ state: 409 });
					}
					trans = newTrans;
					trans._data = trans._trans.data ? Lyte.deepCopyObject(trans._trans.data) : undefined;
					processed.previous = true;
					trans.transComp = processed.transComp;
					// trans.transComp = processed.transComp = processed.transComp || getTransitionDiffernce(processed.prevTrans, processed.matched,processed.R);
					trans.runLoop = constructRunLoop(processedDispatch = processed);
					if (trans._trans.data) {
						newTransInfo.data = trans._trans.data;
					}
					newTransInfo.state = trans.stateObj = getHistoryState({
						replace: newTransInfo.replace,
						data: newTransInfo.data,
						url: trans.url,
						matched: trans.matched,
						fromHistory: newTransInfo.fromHistory
					});
					getHistoryObj(newTransInfo);
					trans.run();
				}, 0);
			}
		}

		function getTransitionDiffernce(prevTrans, matched, R) {
			var like = true,
			    similar = true,
			    rendered = [],
			    common = [],
			    unRendered = [],
			    templateToRemove,
			    currRoute = matched.route.join('.'),
			    r,
			    tar = "";

			if (prevTrans) {
				var prevMatched = prevTrans.matched,
				    route,
				    startFrom = matched.refreshRoute && currRoute == prevTrans.info.route ? matched.refreshRoute : matched.startFrom;
				for (var i = 0, l = matched.route.length; i < l; i++) {
					route = matched.route[i];
					tar = tar + (tar ? "." : "") + route;
					if (similar && route == prevMatched.route[i] && (!startFrom || tar != startFrom)) {
						r = R ? R[i] : LR.__lp.getDefinition(route.slice(0, i));
						if (like && compareRoute(r, i, prevMatched, matched)) {
							common.push(route);
							if (prevTrans.routes[i].__ltp.rendered) {
								rendered.push(route);
							} else {
								// like = false; dont change this code. It is commented for decideTransition function
								unRendered.push(route);
							}
						} else {
							like = false;
							unRendered.push(route);
						}
					} else {
						similar = false;
						if (templateToRemove == undefined && prevTrans.routes[i] && prevTrans.routes[i].__ltp.rendered && prevTrans.routes[i].outlet) {
							templateToRemove = i;
						}
						unRendered.push(route);
					}
				}
				if (prevMatched.route.length > matched.route.length) {
					var index = matched.route.length;
					if (templateToRemove == undefined && prevTrans.routes[index].__ltp.rendered /* && prevTrans.routes[i].outlet */) {
							templateToRemove = index;
						}
				}
			} else {
				unRendered = unRendered.concat(matched.route);
			}
			return {
				rendered: rendered,
				unRendered: unRendered,
				common: common,
				templateToRemove: templateToRemove
			};
		}

		function compareRoute(r, index, prevMatched, matched) {
			var same = true,
			    routeObj = _getObj(r.__lp.objPath, config.routes);
			if (!r.queryParams && !routeObj.__lp.dkey) {
				return true;
			}
			if (routeObj.__lp.dkey && prevMatched.dynamicParams[index] != matched.dynamicParams[index]) {
				return false;
			} else if (r.queryParams && matched.refreshModel) {
				r.queryParams.every(function (key) {
					if (same && r.__lp.qpdef[key].refreshModel && (matched.queryParams || prevMatched.queryParams) && matched.queryParams[key] != prevMatched.queryParams[key]) {
						return same = false;
					} else {
						return true;
					}
				});
			}
			return same;
		}

		var basicHooks = [beforeModelStr, modelStr, afterModelStr, redirectStr, renderTemplateStr, afterRenderStr];
		function constructRunLoop(processed) {
			t(constructRunLoopStr);
			var transComp = processed.transComp,
			    runLoop = [],
			    forceFetch = {},
			    beforeLoad = [],
			    req = [],
			    b4Exit = [],
			    willTransit = [],
			    didTransit = [];

			if (processed.previous) {
				var b4RouteTrans = [{ hook: beforeRouteTransitionStr }];
				if (prevTrans) {
					for (var i = prevTrans.matched.route.length - 1, r; r = prevTrans.matched.route[i]; i--) {
						var r1 = trans.matched._routes[i];
						if (!r1 || r1.join('.') != prevTrans.matched._routes[i].join('.')) {
							b4Exit.push({ hook: beforeExitStr, index: i });
						}
						willTransit.push({ hook: willTransitionStr, index: i });
					}
					t(constructRunLoopStr);
					return { previous: willTransit.concat(b4RouteTrans).concat(b4Exit), current: b4Exit };
				}
				t(constructRunLoopStr);
				return { previous: b4RouteTrans };
			}
			if (transComp.rendered && transComp.rendered.length) {
				transComp.rendered.forEach(function (hook, index) {
					trans.routes[index].__ltp.rendered = true;
					runLoop.push({ hook: redirectStr, index: index });
					didTransit.push({ hook: didTransitionStr, index: trans.matched.route.length - index - 1 });
				});
			}
			if (transComp.unRendered && transComp.unRendered.length) {
				// beforeLoad.push({hook : beforeLoadStr, index : transComp.rendered.length});
				transComp.unRendered.forEach(function (hook, orgIndex) {
					var index = transComp.rendered.length + orgIndex;
					if (!transComp.redirected || transComp.redirected && transComp.redirected.index != index) {
						beforeLoad.push({ hook: beforeLoadStr, index: index });
						req = req.concat([{ hook: getDependenciesStr, index: index }, { hook: getResourcesStr, index: index }]);
					}
					var routeInstance = trans.routes[index];
					if (_typeof(routeInstance.forceFetch) == functionStr ? callHookWithoutPromise.call(this, routeInstance.forceFetch, routeInstance, "forceFetch", index, params(index)) : routeInstance.forceFetch) {
						forceFetch[index] = [{ hook: beforeModelStr, index: index }, { hook: modelStr, index: index }, { hook: afterModelStr, index: index }];
						newTrans.routes[index].__ltp.fetchStatus = pendingStr;
						[redirectStr, renderTemplateStr, afterRenderStr].forEach(function (h) {
							runLoop.push({ hook: h, index: index });
							if (h == renderTemplateStr && transComp.unRendered[orgIndex + 1]) {
								runLoop.push({ hook: beforeLoadStr, index: index + 1 });
							}
						});
					} else {
						basicHooks.forEach(function (h) {
							if (transComp.redirected && transComp.redirected.index == index && h != redirectStr) {
								if ([beforeModelStr, modelStr, afterModelStr].indexOf(h) == -1) {
									runLoop.push({ hook: h, index: index });
								}
								if (h == renderTemplateStr && transComp.unRendered[orgIndex + 1]) {
									runLoop.push({ hook: beforeLoadStr, index: index + 1 });
								}
							} else {
								runLoop.push({ hook: h, index: index });
								if (h == renderTemplateStr && transComp.unRendered[orgIndex + 1]) {
									runLoop.push({ hook: beforeLoadStr, index: index + 1 });
								}
							}
						});
					}
					didTransit.push({ hook: didTransitionStr, index: trans.matched.route.length - index - 1 });
				});
			}

			runLoop = {
				previous: [],
				current: [{ hook: onBeforeLoadStr }].concat(beforeLoad).concat(req.concat(runLoop).concat(didTransit)),
				forceFetch: forceFetch
			};
			runLoop.templateToRemove = prevTrans && prevTrans.runLoop.templateToRemove ? prevTrans.runLoop.templateToRemove : [];
			if (transComp.templateToRemove != undefined) {
				runLoop.templateToRemove.push({ index: transComp.templateToRemove, routes: visibleTrans.routes });
			}
			t(constructRunLoopStr);
			return runLoop;
		}

		function invoke(processed) {
			newTrans = new Transition(processed);
			newTrans.url = processed.path;
			newTrans.runLoop = {};
			newTrans._trans = limitTransition(newTrans);
			Lyte.extendEventListeners(newTrans._trans);
			newTrans.routes = initRoute(processed);
			if (historyObj) {
				newTransInfo = historyObj;
				newTransInfo.url = processed.path;
				newTrans._trans.data = getData() || {};
				newTransInfo.replace = true;
				historyObj = undefined;
			} else if (newTrans._trans.data) {
				LR.history.replaceState(newTrans._trans.data);
			}
		}

		function _getObj(arr, obj) {
			if (!obj) {
				return;
			} else if (!arr) {
				return obj;
			} else if (!Array.isArray(arr) && typeof arr == 'string') {
				arr = dotSerperator(arr);
			}
			arr.every(function (key) {
				if (obj && obj[key]) {
					obj = obj[key];
					return true;
				}
				return obj = false;
			});
			return obj;
		}

		function abortRunningPromises(trans) {
			if (trans.runningProm) {
				trans.runningProm.reject(abortedStr);
			}
			if (trans.fRunningProm) {
				trans.fRunningProm.reject(abortedStr);
			}
		}

		var transId = 0;
		function Transition(processed) {
			this.transId = transId = transId + 1;
			this.matched = processed.matched;
			this.target = processed.matched.target;
			this.fns = [];
			this.pending = {
				dependencies: new Set(),
				resources: new Set(),
				forceFetch: new Set()
			};
			this.info = {
				route: processed.matched.target,
				queryParams: processed.matched.queryParams,
				dynamicParams: processed.matched.dynamicParams.filter(_arrayClean)
			};
			if (processed.matched.fragment) {
				this.info.fragment = processed.matched.fragment;
			}
			this.R = processed.R;
			this.running = this.aborted = this.paused = false;
			this.abort = function (obj) {
				if (newTransInfo && newTransInfo.goValue) {
					fromHistoryGo = false;
				}
				this.abort = emptyFn;
				abortRunningPromises(this);
				this.aborted = true;
				if (!obj) {
					obj = { state: 308 };
				}
				if (this.running) {
					log(TransitionAbortedStr, routeStr);
				}
				// if(this.running && newTransInfo && !newTransInfo.replace) {
				// 	historyLength--;
				// }
				if (!obj.iAbort) {
					delete this.runLoop.templateToRemove;
					// if(prevTrans && prevTrans.url != getLocation() && this.state == 201) {
					// if(prevTrans && visibleTrans && prevTrans.url != getLocation() && trans != visibleTrans) {
					// fromHistoryGo = true;
					// if(getMeta() && getMeta().index != undefined && getMeta().index+1 == history.length) {
					// 	history.go(1);
					// } else {
					// 	history.go(-1);
					// }
					// }  
				}
				transitionCompleted(obj);
			}.bind(this);
			this.pause = function (obj) {
				log(TransitionPausedStr, routeStr);
				if (obj && obj.iPause) {
					this.iPause = true;
				} else {
					this.iPause = false;
					this.state = this._trans.state = 307;
					this._trans.triggerEvent(stateChangeStr, this.state);
				}
				this.paused = trans.prom || true;
				this.resume = this._trans.resume = function (t) {
					t = t || this;
					if (t.prom != t.eProm) {
						if (!t.pendingResume) {
							t.pendingResume = t.resume;
							delete t._trans.resume;
							delete t.resume;
						}
						return;
					}
					delete t._trans.resume;
					delete t.resume;
					log(TransitionResumedStr, routeStr);
					if (t.paused) {
						var state,
						    prom = t.prom;
						if (t.paused != true) {
							state = t.paused.state;
						}
						if (t.runLoop[state]) {
							if (state == "forceFetch") {
								var newProm = t.runLoop.forceFetch[prom.index];
								if (newProm[0] && prom.hook == newProm[0].hook) {
									newProm.splice(0, 1);
								}
							} else if (t.runLoop[state][0] && t.runLoop[state][0].hook == t.paused.hook && t.runLoop[state][0].index == t.paused.index) {
								removeHook(t.runLoop[state], t.paused.hook, t.paused.index);
							}
						}
						t.iPause = t.paused = false;
						t.state = t._trans.state = 102;
						this._trans.triggerEvent(stateChangeStr, t.state);
						if (this.forceFetchRunning) {
							if (t.runLoop.forceFetch[prom.index][0]) {
								t.run(t.runLoop.forceFetch[prom.index][0]);
							} else {
								t.routes[prom.index].__ltp.fetchStatus = completedStr;
								if (t.pending.waitingForFF != undefined && t.pending.waitingForFF == prom.index) {
									delete t.pending.waitingForFF;
									t.run();
								}
							}
						} else {
							if (state && state == "forceFetch" && !t.runLoop.forceFetch[prom.index][0]) {
								t.routes[prom.index].__ltp.fetchStatus = completedStr;
							}
							t.run();
						}
					}
				}.bind(this);
				return this._trans;
			}.bind(this);
		}

		function debugLog() {
			if (Lyte.debug) {
				console.log.apply(this, Array.from(arguments));
			}
		}

		function getRequirements(object) {
			/* download files that are returned from getResources and getDependencies */
			var every = function every() {};
			every.internal = {};
			var r = object.r,
			    reqType = object.reqType,
			    index = object.index,
			    ins = r.__lp,
			    hook = every.internal.hook = trans.prom.hook;
			every.internal.route = ins.objPath;
			debugLog(reqType + ' before inject', this.transId, ins.objPath);
			Lyte.injectResources(ins[reqType], every, function (successFiles, errorFiles) {
				if (!config.execRouteRequirementsOnDemand) {
					if (!trans.aborted || ins.objPath == this.routes[index].__lp.objPath && trans.transComp.redirected && index <= trans.transComp.common.length - 1 || Processed && Processed.transComp.redirected && index <= Processed.transComp.common.length - 1) {
						if (trans.aborted) {
							trans = !LR.__lp.trans.aborted ? !LR.__lp.trans.aborted : newTrans;
							ins = trans.routes[index].__lp;
						}
						var fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources";
						var errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources";
						if (trans.pending[reqType].has(index)) {
							ins = trans.routes[index].__lp;
							ins[reqType + 'Loaded'] = true;
							delete ins[fnType];
							trans.pending[reqType].delete(index);
							if (!errorFiles.length) {
								debugLog(reqType + ' inject completed', 'success', trans.transId, ins.objPath);
								if (trans.pending.forceFetch.has(index)) {
									trans.pending.forceFetch.delete(index);
									nestedForcedPromises.call(trans, trans.runLoop.forceFetch, trans.fRunningProm.resolve, trans.runLoop.forceFetch[index][0]);
								} else {
									nestedPromises.call(trans, trans.runLoop, "current", trans.runningProm.resolve);
								}
							} else {
								debugLog(reqType + ' inject completed', 'failure', trans.transId);
								if (!trans.paused) {
									trans.pause({ iPause: true });
								}
								run[onErrorStr].call(trans, hook, index, r.__lp[errorType] = errorFiles, 424);
							}
						} else {
							trans.routes[index].__lp[fnType] = function () {
								if (errorFiles.length) {
									debugLog(reqType + ' inject completed', 'failure', trans.transId, this.objPath);
									trans.routes[index].__lp[reqType + 'Loaded'] = true;
									delete trans.routes[index].__lp[fnType];
									// ins[reqType+'Loaded'] = true;
									// delete this[fnType];
									if (!trans.paused) {
										trans.pause({ iPause: true });
									}
									run[onErrorStr].call(trans, hook, index, r.__lp[errorType] = errorFiles, 424);
									return false;
								} else {
									trans.routes[index].__lp[reqType + 'Loaded'] = true;
									delete trans.routes[index].__lp[fnType];
									// this[reqType+'Loaded'] = true;
									// delete this[fnType];
								}
							};
						}
						// if(!errorFiles.length) {
						// 	ins[reqType+'Loaded'] = true;
						// 	delete ins[fnType];
						// 	debugLog(reqType+' inject completed','success',trans.transId)
						// 	var pos = trans.pending[reqType].indexOf(index);
						// 	if(pos != -1) {
						// 		delete trans.pending[reqType].splice(pos,1);
						// 		if(trans.pending.forceFetch != undefined && trans.pending.forceFetch == index) {
						// 			delete trans.pending.forceFetch;
						// 			nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
						// 		}
						// 		nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
						// 	}
						// } else {
						// 	ins[fnType] = function() {
						// 		debugLog(reqType+' inject completed','failure',trans.transId);
						// 		ins[reqType+'Loaded'] = true;
						// 		delete ins[fnType];
						// 		if(!trans.paused) {
						// 			trans.pause({iPause : true});  
						// 		}
						// 		run[onErrorStr].call(trans,hook,index, (r.__lp[errorType] = errorFiles), 424);  
						// 	}
						// }
					}
				}
			}.bind(trans), {
				defer: function (opt) {
					// if(!this.aborted) {
					var injectJS = opt.injectJS,
					    files = opt.files,

					// errorFiles = opt.errorFiles,
					fnType = hook == getDependenciesStr ? "loadDependencies" : "loadResources",
					    errorType = hook == getDependenciesStr ? "errorDependencies" : "errorResources",
					    completed = function completed(errorFiles) {
						/* completed callback */
						trans.routes[index].__lp[reqType + 'Loaded'] = true;
						if (!errorFiles.length) {
							debugLog(reqType + ' inject completed', 'success', trans.transId, ins.objPath);
							if (trans.pending[reqType].has(index)) {
								trans.pending[reqType].delete(index);
								if (trans.pending.forceFetch.has(index)) {
									trans.pending.forceFetch.delete(index);
									nestedForcedPromises.call(trans, trans.runLoop.forceFetch, trans.fRunningProm.resolve, trans.runLoop.forceFetch[index][0]);
								} else {
									nestedPromises.call(trans, trans.runLoop, "current", trans.runningProm.resolve);
								}
							}
						} else {
							debugLog(reqType + ' inject completed', 'failure', trans.transId, ins.objPath);
							if (!trans.paused) {
								trans.pause({ iPause: true });
							}
							run[onErrorStr].call(trans, hook, index, r.__lp[errorType] = errorFiles, 424);
						}
					};
					if (ins[fnType] == 'pending') {
						if (!trans.aborted || trans.transComp.redirected && index <= trans.transComp.common.length - 1) {
							injectJS(files, function (successFiles, errorFiles) {
								debugLog(reqType + ' after inject', trans.transId, this.objPath);
								// delete this[fnType];
								delete trans.routes[index].__lp[fnType];
								completed(errorFiles);
							});
						}
					} else {
						ins[fnType] = function () {
							injectJS(files, function (successFiles, errorFiles) {
								debugLog(reqType + ' after inject', trans.transId, this.objPath);
								delete trans.routes[index].__lp[fnType];
								completed(errorFiles);
							});
						};
					}
					// }
				}.bind(trans)
			});
		}

		var requirements = {
			get: function get(ins, type) {
				var status = ins.__lp[type + 'Loaded'] == true;
				var fnType = type == dependenciesStr ? "loadDependencies" : "loadResources";
				if (!ins.__lp[fnType] || typeof ins.__lp[fnType] != 'function' || status) {
					return status;
				} else {
					var err = ins.__lp[fnType]();
					return err == false ? false : ins.__lp[type + 'Loaded'] == true;
				}
			}
		};

		function templateDelete(arr) {
			/* clears outlet, from parent to child */
			for (var i = 0, l = arr.length, obj; i < l; i++) {
				obj = arr[i];
				for (var inst, j = obj.routes.length - 1; j >= obj.index; j--) {
					inst = obj.routes[j];
					// delete inst.__lp.rendered;  
					if (inst.outlet) {
						triggerTemplateDestroy({ outlet: inst.outletName, route: inst }, true);
						inst.outlet.innerHTML = "";
						if (!trans.routes[j] || trans.routes[j].__lp.objPath != inst.__lp.objPath) {
							callDidDestroy.call(this, inst, j, obj);
						}
					}
				}
			}
		}

		function triggerTemplateDestroy(obj, bool) {
			// if(!obj.route.__lp.triggeredTemplateDestroy) {
			Lyte.triggerEvent(beforeTemplateDestroyStr, obj);
			// obj.route.__lp.triggeredTemplateDestroy = bool;
			// }
		}

		function callDidDestroy(inst, index, obj) {
			log(didDestroyStr + " of " + inst.routeName, routeStr, fontColor);
			callHookWithoutPromise.call(this, inst.didDestroy, inst, didDestroyStr, index, inst.currentModel, params(index, obj));
		}

		var stoppableHooks = [getDependenciesStr, getResourcesStr, beforeModelStr, modelStr, afterModelStr];
		// error in these hooks should pause transition and call onerror action
		function errorStoppableHook(hook) {
			return _presence(stoppableHooks, hook);
		}

		function callHookWithPromise(callback, instance) {
			/* executes route hooks which will returns promise */
			if (callback) {
				var args = arguments,
				    resp,
				    t = trans,
				    prom = trans.prom,
				    hook = prom.hook,
				    index = prom.index,
				    stopTrans = errorStoppableHook(hook),
				    self = this;
				return new Promise(function (resolve, reject) {
					try {
						var result = callback.apply(instance, Array.from(args).slice(2));
						if (stopTrans && result) {
							result = Lyte.resolvePromises(result);
						}
						resp = Promise.resolve(result);
					} catch (err) {
						processError.call(self, { hook: hook, index: index, stopTrans: stopTrans, err: err, instance: instance, promise: { resolve: resolve, reject: reject } });
						return;
					}
					resp.then(function (data) {
						if (prom.state != "previous" && trans._trans != instance.transition) {
							reject("old transition's promise rejected");
						} else {
							resolve(data);
							callback.then && callback.then.success.apply(this, arguments);
						}
					}, function (err) {
						t.prom = prom;
						reject(err);
						callback.then && callback.then.failure.apply(this, arguments);
						processError.call(self, { hook: hook, index: index, stopTrans: stopTrans, err: err, instance: instance, PR: true });
					});
				});
			} else {
				return Promise.resolve();
			}
		}

		function callHookWithoutPromise(callback, instance, hook, index) {
			/* executes route hooks which wont return promise  */
			if (callback) {
				var stopTrans = errorStoppableHook(hook);
				try {
					return callback.apply(instance, Array.from(arguments).slice(4));
				} catch (err) {
					processError.call(this, { hook: hook, index: index, stopTrans: stopTrans, err: err, instance: instance });
					return;
				}
			}
		}

		function callAction(hook, index, args) {
			/* executes route's actions  */
			var action,
			    routeInstance = this.routes[index];
			if (routeInstance.actions && (action = routeInstance.actions[hook])) {
				try {
					if (action.apply(routeInstance, args) == false) {
						return false;
					}
				} catch (e) {
					consoleErrorFromCallback(e, hook, routeInstance.routeName);
					return false;
				}
			}
		}

		function consoleErrorFromCallback(err, hook, routeName, state, options) {
			if (typeof err == "string" || (typeof err === 'undefined' ? 'undefined' : _typeof(err)) == "object" && err.stack && !err.$) {
				if (!err.stack) {
					err = Error(err);
				}
				err.$ = true;
				var internalErr = getError(state || 420, hook, routeName);
				err.stack = err.stack.replace(err.message, err.message = err.message + "\n\t" + internalErr);
				consoleError(err);
			} else {
				consoleError(state, hook, routeName, err, options && options.PR);
			}
		}

		function processError(options) {
			/* handles error in hooks */
			var instance = options.instance,
			    stopTrans = options.stopTrans,
			    err = options.err,
			    hook = options.hook,
			    index = options.index;
			if (stopTrans) {
				trans.pause();
				run[onErrorStr].call(this, hook, index, err, 420, options);
			} else {
				consoleErrorFromCallback(err, hook, instance.routeName);
				// if(_presence([willTransitionStr,didTransitionStr,beforeExitStr,redirectStr],hook)) {
				if (options.promise) {
					options.promise.resolve();
				}
				// } else {
				// trans.abort({state : 4, iAbort : true});
				// }
			}
		}

		function runLoopPromise(fn, fnName, loop, success, failure) {
			success = success || emptyFn;
			failure = failure || function (error) {
				if (error != abortedStr) {
					consoleError(error);
				}
			};
			new Promise(function (resolve, reject) {
				if (fnName == "nestedForcedPromises") {
					this.fRunningProm = { resolve: resolve, reject: reject };
					fn.call(this, this.runLoop.forceFetch, resolve);
				} else {
					this.runningProm = { resolve: resolve, reject: reject };
					fn.call(this, this.runLoop, loop, resolve);
				}
			}.bind(this)).then(success, failure);
		}

		Transition.prototype.run = function (pausedForcedProm) {
			if (pausedForcedProm) {
				nestedForcedPromises.call(this, this.runLoop.forceFetch, this.fRunningProm.resolve, pausedForcedProm);
				return;
			}
			processRunLoop.call(this);
			d.title = this.title = this.routes[this.routes.length - 1].title || d.title;
		};

		function processRunLoop() {
			runLoopPromise.call(this, nestedPromises, "nestedPromises", 'previous', function () {
				if (processedDispatch && !trans.running && !trans.aborted) {
					trans.state = trans._trans.state = 102;
					trans._trans.triggerEvent(stateChangeStr, trans.state);
					if (newTransInfo) {
						if (config.preserveUrlOnBrowserNavigation) {
							if (newTransInfo.fromHistory && !!newTransInfo.goValue) {
								fromHistoryGo = true;
								history.go(-newTransInfo.goValue);
							}
							newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
							newTransInfoClone = Lyte.deepCopyObject(newTransInfo);
							trans.stateObj = newTransInfo.state;
							var newTransInfoTimer = setInterval(function () {
								if (!newTransInfoClone) {
									clearInterval(newTransInfoTimer);
									return;
								}
								if (!fromHistoryGo) {
									clearInterval(newTransInfoTimer);
									addToHistory(newTransInfoClone);
									newTransInfoClone = undefined;
								}
							}, 0);
						} else {
							newTransInfo.state.data = trans._trans.data || newTransInfo.state.data;
							addToHistory(newTransInfo);
							trans.stateObj = newTransInfo.state;
						}
					}
					LR.__lp.trans = trans;
					processedDispatch.previous = false;
					trans.runLoop = constructRunLoop(processedDispatch);
					setParamsInInst(processedDispatch, trans.info);
					processedDispatch = newTransInfo = undefined;
					trans.running = true;
				}
				runLoopPromise.call(this, nestedPromises, "nestedPromises", 'current');
			}.bind(this));
		}

		function setPendingResume(promise) {
			trans.eProm = promise;
			if (this.pendingResume) {
				var resume = this.pendingResume;
				delete this.pendingResume;
				resume();
			}
		}

		function nestedForcedPromises(forcedLoop, resolve, promise) {
			if (validateTransition(this) && forcedLoop) {
				if (!promise) {
					for (var key in forcedLoop) {
						var routeLoop = forcedLoop[key],
						    p = routeLoop[0];
						if (p) {
							if (!p.running) {
								nestedForcedPromises.call(this, forcedLoop, resolve, p);
							}
						}
					}
					return;
				}
				var r = this.R[promise.index],
				    routeInstance = this.routes[promise.index];
				promise.state = "forceFetch";
				trans.prom = promise;
				if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
					this.pending.dependencies.add(promise.index);
					this.pending.forceFetch.add(promise.index);
					return;
					// var fn = r.__lp.loadDependencies;
					// r.__lp.loadDependencies = 'pending';
					// if(fn) {
					// 	fn();
					// 	// delete r.__lp.loadDependencies;
					// }
					// if(r.__lp.loadDependencies) {
					// 	this.pausedRunloop = true;
					// 	return;
					// }
				}
				logCallbacks(promise);
				forcedLoop[promise.index][0].running = true;
				forcedLoop[promise.index].splice(0, 1);
				run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
					setPendingResume.call(trans, trans.prom);
					if (promise.hook == afterModelStr) {
						routeInstance.__ltp.fetchStatus = completedStr;
						if (this.pending.waitingForFF != undefined && this.pending.waitingForFF == promise.index) {
							delete this.pending.waitingForFF;
							nestedPromises.call(this, this.runLoop, "current", this.runningProm.resolve);
						}
					} else if (promise.hook == modelStr) {
						if (forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve, forcedLoop[promise.index][0]);
						}
					} else {
						if (forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
							nestedForcedPromises.call(this, forcedLoop, resolve, forcedLoop[promise.index][0]);
						}
					}
				}.bind(this), function () {
					debugger;
				});
			} else {
				this.forceFetchRunning = false;
			}
		}

		function logCallbacks(promise) {
			if (Lyte.debug) {
				var hook = promise.hook,
				    index = promise.index;
				if ([beforeRouteTransitionStr, onBeforeLoadStr].indexOf(promise.hook) != -1) {
					log(hook, routeStr, fontColor);
					return;
				}
				var route = promise.state == "previous" ? prevTrans.R[index] : trans.R[index];
				log(hook + ' of route ' + route.routeName, routeStr, fontColor);
			}
		}

		function nestedPromises(loop, state, resolve) {
			if (validateTransition(this)) {
				var runLoop = loop[state];
				if (runLoop && runLoop.length) {
					var promise = runLoop[0],
					    r = this.R[promise.index],
					    routeInstance = this.routes[promise.index];
					var cond;
					if (promise.hook == beforeModelStr) {
						cond = requirements.get(routeInstance, dependenciesStr);
					}
					if (promise.hook == beforeModelStr && !cond) {
						this.pending.dependencies.add(promise.index);
						return;
						// this.pending.dependencies.push(promise.index);
						// var fn = r.__lp.loadDependencies;
						// r.__lp.loadDependencies = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadDependencies
						// } 
						// if(r.__lp.loadDependencies) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if (promise.hook == renderTemplateStr && !requirements.get(routeInstance, resourcesStr)) {
						this.pending.resources.add(promise.index);
						return;
						// this.pending.resources.push(promise.index);
						// var fn = r.__lp.loadResources;
						// r.__lp.loadResources = 'pending';
						// if(fn) {
						// 	fn();
						// 	// delete r.__lp.loadResources
						// } 
						// if(r.__lp.loadResources) {
						// 	this.pausedRunloop = true;
						// 	return;
						// }
					} else if (promise.hook == redirectStr && r.forceFetch && routeInstance.__ltp.fetchStatus == pendingStr) {
						if (!this.forceFetchRunning) {
							this.forceFetchRunning = true;
							runLoopPromise.call(this, nestedForcedPromises, "nestedForcedPromises");
						}
						this.pending.waitingForFF = promise.index;
						return;
					} else {
						promise.state = state;
						trans.prom = promise;
						logCallbacks(promise);
						t(promise.hook + promise.index);
						run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
							setPendingResume.call(trans, trans.prom);
							t(promise.hook + promise.index);
							if (this.runningProm.resolve == resolve) {
								removeHook(loop[state], promise.hook, promise.index);
								nestedPromises.call(this, loop, state, resolve);
							}
						}.bind(this));
					}
				} else if (resolve) {
					resolve();
				}
			} else if (this.paused && this.runningProm) {
				this.runningProm.reject(abortedStr);
			}
		}

		function removeHook(loop, hook, index) {
			for (var i = 0, obj; obj = loop[i]; i++) {
				if (obj.hook == hook) {
					if (index != undefined) {
						if (index == obj.index) {
							loop.splice(i, 1);
							break;
						}
					} else {
						loop.splice(i, 1);
						i--;
					}
				}
			}
		}

		function frameQueryParams(url) {
			if (url) {
				var qp = {},
				    split,
				    params = _presence(url, "?") ? url.split("?")[1] : url;
				params = _presence(params, "&") ? params.split(/&/g) : [params];
				for (var i = 0, l = params.length; i < l; i++) {
					qp[(split = params[i].split('='))[0]] = split[1] ? decodeURIComponent(split[1]) : split[1];
				}
				return qp;
			}
		}

		function frameDynamicParams(url, matched) {
			var routesObj = config.routes,
			    dynamicParam,
			    fdp,
			    framedDP = [],
			    urlSplit = _splitPath(url.split('?')[0]);
			for (var i = 0, l = matched.route.length, r; i < l; i++) {
				r = matched.route[i];
				routesObj = _getObj([r], routesObj);
				var routeObj = routesObj.__lp;
				if (routeObj.wildcard) {
					if (routeObj.sufix.length) {
						var dp = urlSplit.slice(0, urlSplit.indexOf(routeObj.sufix[0]));
						fdp = decodeURI(dp.join('/'));
						_pop(dp.concat(routeObj.sufix), urlSplit);
					} else {
						fdp = decodeURI(urlSplit.join('/'));
					}
				} else if (routeObj.dkey) {
					dynamicParam = urlSplit[routeObj.dIndex];
					_pop(_splitPath(routeObj.path), urlSplit);
					fdp = decodeURI(dynamicParam);
				} else {
					_pop(_splitPath(routeObj.path), urlSplit);
					fdp = undefined;
				}
				framedDP.push(fdp);
			};
			return framedDP;
		}

		function _pop(path, urlSplit) {
			for (var i = 0, l = path.length; i < l; i++) {
				urlSplit.shift();
			};
		}

		function _presence(str, char) {
			return str.indexOf(char) != -1;
		}

		function transitionCompleted(obj) {
			/* called after a atransition is completed or aborted*/
			if (trans.running) {
				if (trans == newTrans) {
					newTrans = undefined;
				}
				if (newTransInfoClone) {
					clearInterval(newTransInfoTimer);
					addToHistory(newTransInfoClone);
					newTransInfoClone = undefined;
				}
				setActiveClassForLink(trans.info);
				for (var i = 0, l = trans.fns.length; i < l; i++) {
					clearTimeout(trans.fns[i]);
				};
				trans.pendingResume = undefined;
				trans.running = false;
				trans.state = trans._trans.state = obj.state;
				trans._trans.triggerEvent(stateChangeStr, trans.state);
				if (initialLoad || trans.state == 200) {
					LR.__lp.prevTrans = prevTrans = trans;
					t(RouteTransitionStr);
					log(TransitionComletedStr, routeStr);
					if (config.history && trans.info.fragment) {
						var elem;
						if ((elem = d.getElementById(trans._trans.info.fragment)) && elem.scrollIntoView && LR.beforeScroll(trans._trans) != false) {
							elem.scrollIntoView();
						}
					}
					run[afterRouteTransitionStr](trans._trans);
				} else if (obj.iAbort || visibleTrans == trans) {
					LR.__lp.prevTrans = prevTrans = trans;
					if (trans.state && trans.state != 201) {
						run[afterRouteTransitionStr](trans._trans);
					}
				} else {
					if (trans.state && trans.state != 201) {
						run[afterRouteTransitionStr](trans._trans);
					}
					LR.__lp.trans = trans = prevTrans;
				}
				if (initialLoad) {
					initialLoad = false;
				}
			} else if (prevTrans) {
				LR.__lp.trans = trans = prevTrans;
			}
		}

		function _delimit(seg) {
			return seg[0] == "/" ? seg : "/" + seg;
		}

		function _splitPath(path) {
			return path.match(/[^/?]+/g) || [];
		}

		function validateURL(url) {
			url = url.replace(/\/\//g, '/');
			url = url.replace(/\/\?/g, '?');
			return url;
		}

		function getError() {
			var args = arguments,
			    error;
			switch (args[0]) {
				case 400:
					error = args[1] ? "url '" + args[1] + "' is not defined in router." : "Base path of url is not specified.";
					break;
				case 405:
					error = "Method not allowed before router initialization.";
					break;
				case 422:
					error = "There is no route definition for the route " + args[1].splice(0, args[2] + 1).join('.') + ".";
					break;
				case 424:
					error = "File not loaded in " + args[1] + " of route " + args[2] + ".\n" + args[3][0].target.outerHTML;
					break;
				case 498:
					error = "Invalid argument " + args[1] + (args[2] ? " provided in " + args[2] : ".");
					break;
				case 499:
					error = args[1] ? "Dynamic params for the route " + args[1] + " is not provided" + (args[2] && args[2].outerHTML ? " in " + args[2].outerHTML : ".") : "Transition tried without arguments.";
					break;
				case 420:
					error = (args[3] ? "Promise rejected" : "Error") + " in " + args[1] + " of route " + args[2] + ".";
					break;
				case 428:
					error = "There is no outlet named " + args[1] + ".";
					break;
				case 203:
					error = "Data provided for component is not valid.";
					break;
			}
			return 'LR ' + args[0] + ': ' + error;
		}

		function consoleError() {
			Lyte.error(arguments[0].stack ? arguments[0] : getError.apply(this, arguments), arguments[3]);
		}

		function traverse(path, get) {
			if (!path) {
				consoleError(400, '');
				return;
			}
			var selectedPaths = [],
			    fragment;
			if (config.history) {
				var fragSplit = path.split('#');
				if (fragment = fragSplit[1]) {
					path = fragSplit[0];
				}
			}
			var pathSplit = path.split('?');
			path = decodeURI(pathSplit[0]);
			if (path == '/') {
				if (_getObj(['/'], config.routeHash)) {
					selectedPaths.push([path]);
				} else {
					consoleError(400, path);
					return;
				}
			} else {
				var findPossibleMatch = function findPossibleMatch(mapObj) {
					for (var mapPath in mapObj) {
						if (!exactMatch) {
							var pathObj = mapObj[mapPath],
							    innerLevel;
							if (mapPath != "__lp") {
								var mapPathSplit = _splitPath(mapPath);
								if (mapPathSplit) {
									if ((innerLevel = checkArrayMatch(mapPathSplit, pathSplitArr, pathLevel, pathObj, matchedPath)) !== false) {
										pathArrLevel.push(innerLevel);
										pathLevel = pathArrLevel[pathArrLevel.length - 1];
										if (pathSplitArr.length == pathLevel) {
											var path = Array.from(matchedPath.concat(mapPath));
											if (pathObj["/"]) {
												path = path.concat('/');
											}
											selectedPaths.push(path);
											if (pathObj.__lp.wildcard || pathObj.__lp.dkey) {
												pathArrLevel.pop();
												pathLevel = pathArrLevel[pathArrLevel.length - 1];
											} else {
												if (!/[:*]/.test(path.join(''))) {
													exactMatch = path;
												}
												return;
											}
										} else {
											var innerRoutes = Object.keys(pathObj);
											matchedPath.push(mapPath);
											if (pathSplitArr[pathLevel]) {
												if (pathObj.__lp.wildcard && !pathObj.__lp.sufix.length && innerRoutes.length == 1) {
													var wildcard = Array.from(matchedPath);
													if (pathObj["/"]) {
														wildcard = wildcard.concat('/');
													}
													selectedPaths.push(wildcard);
												} else if (innerRoutes.length > 1) {
													findPossibleMatch(pathObj);
												}
											}
											matchedPath.pop();
											pathArrLevel.pop();
											pathLevel = pathArrLevel[pathArrLevel.length - 1];
										}
									}
								}
							}
						}
					}
				};

				var params = pathSplit[1],
				    pathSplitArr = _splitPath(path);
				var pathLevel = 0,
				    pathArrLevel = [0],
				    exactMatch,
				    matchedPath = [];
				matchedPath.dynamicParams = [];
				findPossibleMatch(config.routeHash);
			}
			if (exactMatch) {
				return pathProcessor(get, exactMatch, path, params, fragment);
			} else if (selectedPaths.length == 1) {
				return pathProcessor(get, selectedPaths[0], path, params, fragment);
			} else if (selectedPaths.length) {
				var getBestMatch = function getBestMatch(staticMatches, selectedPaths, position) {
					position = position || 0;
					var traversedStaticMatch = traversedStaticMatch || traverseArray(staticMatches),
					    maxStaticSeg = Math.max.apply(Math, _toConsumableArray(traversedStaticMatch[position])),
					    duplicatePos;
					while (duplicatePos = checkForArrayDuplicates(traversedStaticMatch[position], maxStaticSeg, selectedPaths, staticMatches)) {
						position = position + 1;
						var newSelectedPaths = [],
						    newStaticMatches = [];
						for (var i = 0, l = duplicatePos.length; i < l; i++) {
							newSelectedPaths.push(selectedPaths[i]);
							newStaticMatches.push(staticMatches[i]);
						}
						var newSelectedPathsFiltered = [],
						    newStaticMatchesFiltered = [];
						for (var i = 0, l = newStaticMatches.length; i < l; i++) {
							if (newStaticMatches[i][position] != undefined) {
								newSelectedPathsFiltered.push(newSelectedPaths[i]);
								newStaticMatchesFiltered.push(newStaticMatches[i]);
							}
						}
						if (!newSelectedPathsFiltered.length) {
							return newSelectedPaths[0];
						} else if (newSelectedPathsFiltered.length == 1) {
							return newSelectedPathsFiltered[0];
						}
						return getBestMatch(newStaticMatchesFiltered, newSelectedPathsFiltered, position);
					}
					return selectedPaths[traversedStaticMatch[position].indexOf(maxStaticSeg)];
				};

				var getStaticMatches = function getStaticMatches(selectedPaths) {
					var staticSegmentsInMatch = [];
					for (var i = 0, l = selectedPaths.length; i < l; i++) {
						var arr = Array.from(selectedPaths[i]),
						    staticPath = 0,
						    result = [];
						if (arr[0] == "/") {
							arr.shift();
						}
						if (arr[arr.length - 1] == "/") {
							arr.pop();
						}
						var counter = -1;
						arr.every(function (seg, i) {
							var noWildcard = true;
							_splitPath(seg).every(function (innerSeg, j) {
								counter++;
								if (innerSeg == pathSplitArr[counter]) {
									staticPath++;
									if (arr.length == i + 1) {
										result.push(staticPath);
									}
									return true;
								} else if (innerSeg.indexOf(':') != -1) {
									result.push(staticPath);
									staticPath = 0;
									return true;
								} else {
									if (innerSeg.indexOf('*') != -1) {
										noWildcard = false;
									}
									result.push(staticPath);
									return false;
								}
							});
							return noWildcard;
						});
						staticSegmentsInMatch.push(result);
					}
					return staticSegmentsInMatch;
				};

				return pathProcessor(get, getBestMatch(getStaticMatches(selectedPaths), selectedPaths), path, params, fragment);
			} else {
				consoleError(400, path);
			}
		}

		function checkArrayMatch(arr1, arr2, l, pathObj, matchedPath) {
			if (!(pathObj.__lp.wildcard || pathObj.__lp.dkey)) {
				var prevObj;
				if (prevObj = _getObj(matchedPath, config.routeHash).__lp) {
					if (prevObj.wildcard) {
						var pathArr = arr2.slice(l);
						if (!(l += pathArr.indexOf(arr1[0]))) {
							return false;
						}
					}
				}
			}
			for (var i = 0, a1; a1 = arr1[i]; i++, l++) {
				if (a1 != arr2[l] && !dynamicRouteCheck(a1)) {
					if (wildcardRouteCheck(a1)) {
						if (pathObj.__lp.sufix.length) {
							l = arr2.indexOf(pathObj.__lp.sufix[0]) - 1;
						}
					} else if (arr1[l] == '/') {
						l--;
					} else {
						return false;
					}
				}
			}
			return l;
		}

		function checkForArrayDuplicates(arr, value, selectedPaths, staticMatches) {
			var pos = [];
			for (var i = 0, l = arr.length; i < l; i++) {
				if (arr[i] == value) {
					pos.push(i);
				}
			}
			return pos.length == 1 ? false : pos;
		}

		function traverseArray(arr) {
			var res = [],
			    maxArrLen = 0;
			for (var i = 0, l = arr.length; i < l; i++) {
				var a = arr[i];
				maxArrLen = a.length > maxArrLen ? a.length : maxArrLen;
			}
			for (var i = 0, a; a = arr[i]; i++) {
				for (var j = 0; j < maxArrLen; j++) {
					res[j] = res[j] || [];
					res[j][i] = a[j];
				}
			}
			return res;
		}

		function pathProcessor(get, selectedPath, path, params, fragment) {
			var newURL,
			    orgMatched,
			    newMatched,
			    matched = {
				route: _getObj(selectedPath, config.routeHash).__lp.route,
				queryParams: params ? frameQueryParams(params) : {}
			};
			if (config.history) {
				matched.fragment = fragment;
			}
			matched.dynamicParams = frameDynamicParams(path, matched);
			if (get) {
				return matched;
			}
			matched.dpProcessed = true;
			var transInfo = normalizeMatchedObj(matched);
			if (transInfo != false) {
				orgMatched = Lyte.deepCopyObject(transInfo.matched);
				newMatched = Lyte.deepCopyObject(transInfo.matched);
				if (!transInfo.matched.hasOwnProperty('refreshModel')) {
					constructURLFromRoute(transInfo.matched);
				}
				newURL = constructURLFromRoute(newMatched);
				if (!_compareObj(newMatched.queryParams, orgMatched.queryParams)) {
					addToHistory({ replace: true, state: window.history.state, url: newURL, fromHistory: true });
					transInfo.path = newURL;
				}
			}
			return transInfo;
		}

		function setParamsInInst(processed, transInfo) {
			if (config.linkActiveClass) {
				config.activeLinkTags.forEach(function (tag) {
					tag.classList.remove(config.linkActiveClass);
				});
			}
			config.activeLinkTags = [];
			var R,
			    r,
			    matched = processed.matched;
			try {
				var linkTagPush = function linkTagPush(tag) {
					if (tag.getAttribute('lt-prop-route') == matched.target && activeLinkTags.indexOf(tag) == -1) {
						activeLinkTags.push(tag);
					}
				};

				var pushQP = function pushQP(key) {
					r.__ltp.queryParams[key] = R.__lp.qpdef[key].cipher && config.cipher.decryptor ? config.cipher.decryptor(matched.queryParams[key]) : matched.queryParams[key];
				};

				for (var i = 0, l = trans.R.length; i < l; i++) {
					R = trans.R[i];
					r = trans.routes[i];
					if (R.queryParams) {
						R.queryParams.forEach(pushQP);
					}
					r.__ltp.dynamicParam = matched.dynamicParams[i];
					if (i + 1 == l) {
						R.__lp.linkTags.forEach(linkTagPush);
					}
				}
				setActiveClassForLink(transInfo);
			} catch (e) {
				consoleError(e);
			}
			return;
		}

		function setActiveClassForLink(transInfo) {
			if (config.linkActiveClass && config.allLinks[transInfo.route]) {
				config.allLinks[transInfo.route].forEach(function (tag) {
					var tagDp = tag.getAttribute(pDp);
					if (checkIfSameDp(transInfo.dynamicParams, tagDp ? JSON.parse(tagDp) : [])) {
						tag.classList.add(config.linkActiveClass);
						config.activeLinkTags.push(tag);
						var aTag = tag.getElementsByTagName('A')[0];
						if (aTag) {
							aTag.setAttribute("href", LR.getURL(tag.getMatchedObject()));
						}
					}
				});
			}
		}

		function assignMixin(options, fns, dir, lazyload) {
			if (options && options.mixins) {
				if (!Array.isArray(options.mixins)) {
					options.mixins = [options.mixins];
				}
				options.mixins.forEach(function (mixin) {
					if (Lyte.registeredMixins[mixin]) {
						mixin = Lyte.registeredMixins[mixin];
						if (lazyload) {
							var prevTransRouteInstance = LR.getRouteInstance(dir, prevTrans),
							    transRouteInstance = LR.getRouteInstance(dir, trans),
							    newTransInstance = newTrans && LR.getRouteInstance(dir, newTrans);
							if (prevTransRouteInstance || transRouteInstance) {
								prevTransRouteInstance = prevTransRouteInstance || {};
								transRouteInstance = transRouteInstance || {};
								setMixinPropInDefandIns(mixin, fns, prevTransRouteInstance, transRouteInstance, newTransInstance);
							} else {
								setMixinPropInDef(mixin, fns);
							}
						} else {
							setMixinPropInDef(mixin, fns);
						}
					} else if (!lazyload) {
						Lyte.$.requiredMixins(mixin, dir, "router");
					}
				});
			}
		}

		// function setServicePropInDef(dir) {
		// 	var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
		// 	transRouteInstance = LR.getRouteInstance(dir,trans);
		// 	if(prevTransRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: prevTransRouteInstance});
		// 	}
		// 	if(transRouteInstance) {
		// 		Lyte.extendService({services : serv, type:"route", name : dir, ins: transRouteInstance});	
		// 	}
		// }

		Lyte.$.requiredMixins.router = function (mixin, dir) {
			dir.forEach(function (d) {
				var fns = LR.__lp.getDefinition(d);
				if (mixin && fns) {
					assignMixin(fns.__lp.options, fns, d, true);
				}
			});
		};

		Lyte.$.injectServices.router = function (key, name, type, ins, cIns, data) {
			var obj = {};
			obj.as = key;
			obj.service = name;
			// Lyte.extendService({services : [obj], type:"route", ins: arr});
			includeServices({ services: [obj] }, undefined, undefined, getDefinitionArr(), true, data);
		};

		function includeServices(options, fns, dir, def, isGlobal, data) {
			if (options && options.services) {
				var toBeUsed = [],
				    laterToBeUsed = [];
				options.services.forEach(function (itm) {
					if (typeof itm == "string") {
						toBeUsed.push(itm);
					} else if (itm && (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == "object") {
						if (isGlobal || !itm.scope || itm.scope && itm.scope == "static") {
							toBeUsed.push(itm);
						} else {
							laterToBeUsed.push(itm);
						}
					}
				});
			}
			if (toBeUsed && toBeUsed.length) {
				assignService(toBeUsed, fns, dir, def, isGlobal, data);
			}
			if (laterToBeUsed && laterToBeUsed.length) {
				var arr = getFnsAndIns(dir, fns);
				arr.forEach(function (itm) {
					if (itm && itm.__lp) {
						itm.__lp.toBeUsed = laterToBeUsed;
					}
				});
			}
		}

		function assignService(servArr, fns, dir, def, isGlobal, data) {
			var arr = getFnsAndIns(dir, fns);
			Lyte.extendService({ services: servArr || [], type: "route", ins: def || arr, isGlobal: isGlobal, data: data, callback: function callback(serv, key, aName, serName) {
					var obj = {};
					obj.as = key;
					obj.service = serName;
					Lyte.extendService({ services: [obj], type: "route", isGlobal: isGlobal, ins: dir ? getFnsAndIns(dir, fns) : getDefinitionArr() });
				} });
		}

		function getFnsAndIns(dir, fns) {
			var arr = [fns],
			    ins;
			[prevTrans, newTrans, trans].forEach(function (t) {
				if (t && (ins = LR.getRouteInstance(dir, t))) {
					arr.push(ins);
				}
			});
			// var prevTransRouteInstance = LR.getRouteInstance(dir,prevTrans),
			// transRouteInstance = LR.getRouteInstance(dir,trans);
			// if(prevTransRouteInstance) {
			// 	arr.push(prevTransRouteInstance)
			// }
			// if(transRouteInstance) {
			// 	arr.push(transRouteInstance)
			// }
			return arr;
		}

		function getDefinitionArr(def, arr) {
			var parent = !def;
			def = def || config.routes;
			arr = arr || [];
			for (var key in def) {
				if (key == "__lp") {
					if (def.__lp.def) {
						arr.push(def.__lp.def);
					}
				} else {
					getDefinitionArr(def[key], arr);
				}
			}
			if (parent) {
				if (prevTrans && prevTrans != trans) {
					arr = arr.concat(prevTrans.routes);
				}
				if (trans) {
					arr = arr.concat(trans.routes);
				}
				return arr;
			}
		}

		function setMixinPropInDef(mixin, fns) {
			for (var key in mixin) {
				if (key == "actions") {
					fns.actions = Object.assign(fns.actions || {}, mixin.actions);
				} else if (key == "queryParams") {
					fns[key] = Lyte.deepCopyObject(mixin[key]);
				} else {
					fns[key] = mixin[key];
				}
			}
		}

		function setMixinPropInDefandIns(mixin, fns, prev, curr, newTrans) {
			for (var key in mixin) {
				if (key == "actions") {
					if (!fns.actions) {
						curr.actions = prev.actions = fns.actions = {};
					}
					prev.actions = curr.actions = Object.assign(fns.actions, mixin.actions);
					if (newTrans) {
						newTrans.actions = prev.actions;
					}
				} else {
					prev[key] = curr[key] = fns[key] = mixin[key];
					if (newTrans) {
						newTrans[key] = prev[key];
					}
				}
			}
		}

		this.registerRoute = function () {
			if (config.routes) {
				registerRoute.apply({}, arguments);
			} else {
				this.__lp.pendingReg.push(arguments);
			}
		};

		function registerRoute(dir, fns, options) {
			assignMixin(options, fns, dir);
			fns.__lp = {
				options: options,
				objPath: dir.replace(/\//g, '.'),
				stickyLinks: [],
				linkTags: []
			};
			includeServices(options, fns, dir);
			if (Lyte.toBeInjectedServices) {
				var tbServ = Lyte.toBeInjectedServices,
				    arr = [];
				for (var key in tbServ) {
					arr.push({ as: key, service: tbServ[key] });
				}
				includeServices({ services: arr }, fns, dir, undefined, true);
			}

			var sticky = config.queryParamOptions.sticky;
			if (fns.queryParams) {
				fns.__lp.qpdef = {};
				fns.queryParams.forEach(function (qp, i) {
					if (typeof qp == "string") {
						fns.__lp.qpdef[qp] = {
							sticky: sticky,
							refreshModel: true
						};
						if (config.stickyRoutes[dir] == undefined && sticky) {
							config.stickyRoutes[dir] = sticky;
						}
					} else if ((typeof qp === 'undefined' ? 'undefined' : _typeof(qp)) == "object") {
						for (var key in qp) {
							fns.__lp.qpdef[key] = {
								cipher: qp[key].cipher,
								sticky: qp[key].hasOwnProperty('sticky') ? qp[key].sticky : sticky,
								refreshModel: qp[key].hasOwnProperty('refreshModel') ? qp[key].refreshModel : true
							};
							if (!config.stickyRoutes[dir] && fns.__lp.qpdef[key].sticky) {
								config.stickyRoutes[dir] = true;
							}
						}
						fns.queryParams[i] = key;
					}
				});
			}
			dir = dotSerperator(dir);
			fns.routeName = dir[dir.length - 1];
			setRouteDef(dir, fns);
		}

		var transPredefined = ['runLoop', 'running', 'paused', 'R', 'routes', abortedStr, 'prom', 'run', pendingStr, 'matched', 'fns'];

		function limitTransition(int) {
			var _trans = new transition(int);
			int.state = _trans.state = 201;
			return _trans;
		}

		function dummy() {
			/*
   Dont delete this function.
   This one is to avoid function to be merged during minification.
   */
			var _trans = new transition(int);
		}

		function transition(int) {
			for (var prop in int) {
				if (transPredefined.indexOf(prop) == -1) {
					if (prop == 'info') {
						this.info = Lyte.deepCopyObject(int[prop]);
					} else {
						this[prop] = int[prop];
					}
				}
			}
		}

		function dynamicRouteCheck(route) {
			return _presence(route, ":");
		}

		function wildcardRouteCheck(route) {
			return _presence(route, "*");
		}

		function _compareObj(obj1, obj2) {
			var obj1keys = Object.keys(obj1),
			    obj2keys = Object.keys(obj2);
			if (obj1keys.length != obj2keys.length) {
				return false;
			} else {
				for (var key in obj1) {
					if (obj1[key] != obj2[key]) {
						return false;
					}
				}
				return true;
			}
		}

		this.getRouteInstance = function (routeName, t) {
			var newTrans;
			if (LR && !LR.init && (newTrans = t || LR.__lp && LR.__lp.trans || trans) && newTrans.routes) {
				var routeLen = newTrans.routes.length;
				if (!routeName) {
					return newTrans.routes[routeLen - 1];
				} else if (routeName == "*") {
					return newTrans.routes;
				} else {
					var reqRouteLen = routeName.split('.').length - 1,
					    reqRoute = newTrans.routes[reqRouteLen];
					return reqRoute && reqRoute.__lp.objPath == routeName ? reqRoute : undefined;
				}
			}
		};

		function normalizeTransitionParams(obj) {
			// To normalize argument for transition, returns matched obj from obj or native tranisitionTo argument.
			var params;
			if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object") {
				params = obj;
			} else {
				params = {
					queryParams: {},
					dynamicParams: []
				};
				Array.from(arguments).forEach(function (arg, index) {
					if (Array.isArray(arg)) {
						consoleError(498, JSON.stringify(arg));
						return;
					} else {
						if (index == 0) {
							params.route = arg;
						} else if (arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) == "object") {
							params.queryParams = Lyte.deepCopyObject(arg);
						} else {
							params.dynamicParams.push(arg);
						}
					}
				});
			}
			return params;
		}

		function normalizeMatchedObj(obj) {
			// To construct dynamic params array.
			if (obj.route) {
				var routesObj = config.routes,
				    matched,
				    def,
				    R = [],
				    errorCheck = function errorCheck(route, i) {
					routesObj = _getObj(route, routesObj);
					if (!routesObj) {
						throw Error(getError(400, matched.target));
					}
					if (!(def = routesObj.__lp.def)) {
						throw Error(getError(422, matched.route, i));
					}
					R.push(def);
				};
				if (obj._routes) {
					matched = obj;
				} else {
					var matched = {
						route: Array.isArray(obj.route) ? obj.route : dotSerperator(obj.route),
						queryParams: obj.queryParams || {},
						dynamicParams: [],
						fragment: obj.fragment,
						target: "",
						refreshRoute: obj.refreshRoute,
						startFrom: obj.startFrom,
						_routes: []
					};
					if (obj.dynamicParams) {
						if (obj.dpProcessed) {
							matched.dynamicParams = Array.from(obj.dynamicParams);
						} else {
							var dynamicParams = Array.from(obj.dynamicParams);
						}
					}
				}
				try {
					matched.route.forEach(obj._routes ? errorCheck : function (route, i) {
						matched.target = matched.target ? matched.target + '.' + route : route;
						matched._routes.push(dotSerperator(matched.target));
						errorCheck(route, i);
						if (dynamicParams) {
							matched.dynamicParams.push(routesObj.__lp.dkey ? dynamicParams.shift() : undefined);
						}
					});
					if (dynamicParams && dynamicParams.length) {
						Lyte.error('Extra dynamic params found. Provide exact numbers dynamic params required for the transition ' + JSON.stringify(dynamicParams));
					}
				} catch (e) {
					consoleError(e);
					return false;
				}
				return {
					matched: matched,
					R: R
				};
			} else {
				if (this.tagName == LINKTOStr) {
					consoleError(498, pRoute, this.outerHTML);
				} else {
					consoleError(499);
				}
			}
		}

		function initRoute(processed) {
			var routeObj,
			    matched = processed.matched,
			    routes = [],
			    refMatch = processed.prevTrans,
			    similarRoute = true;

			for (var i = 0, route; route = matched.route[i]; i++) {
				routeObj = LR.__lp.getDefinition(newTrans.matched._routes[i]);
				if (!routeObj) {
					return false;
				}
				if (refMatch && similarRoute && refMatch.matched && refMatch.matched.route[i] == route) {
					routes.push(new Route(routes, routeObj, i, processed, refMatch.routes[i]));
				} else {
					routes[i] = new Route(routes, routeObj, i, processed);
					similarRoute = false;
				}
			}
			refMatch = undefined;
			return routes;
		}

		var routePredefined = [getDependenciesStr, getResourcesStr, beforeModelStr, modelStr, afterModelStr, redirectStr, renderTemplateStr, afterRenderStr, beforeExitStr],
		    Route = function Route(routes, fns, index, processed, prevInstance) {
			var self = this;
			var src = prevInstance || fns;
			for (var key in src) {
				if (prevInstance || !_presence(routePredefined, key)) {
					if (key == "__lp") {
						this.__lp = Lyte.deepCopyObject(src.__lp);
					} else {
						this[key] = src[key];
					}
				}
			}
			if (processed.transComp && !processed.transComp.rendered[index] && processed.transComp.redirected && processed.transComp.redirected.index < index) {
				delete this.__lp.loadDependencies;
				delete this.__lp.loadResources;
				this.$ = {};
				delete this.currentModel;
			}
			this.__ltp = {
				queryParams: {}
			};
			if (this.__lp && this.__lp.toBeUsed && this.__lp.toBeUsed.length) {
				var self = this;
				Lyte.extendService({ services: this.__lp.toBeUsed || [], type: "route", ins: this, callback: function callback(serv, key, aName, serName) {
						var obj = {};
						obj.key = key;
						obj.service = serName;
						Lyte.extendService({ services: [obj], type: "route", ins: self });
					} });
			}
			this.transition = newTrans._trans;
			this.parent = routes[index - 1];
			if (!prevInstance) {
				this.$ = {};
				if (this.init) {
					this.init();
				}
				this.throwEvent = typeof Lyte.Component !== "undefined" && Lyte.Component.throwEvent;
			}
			this.replaceWith = LR.replaceWith;
			this.transitionTo = LR.transitionTo;
			this.removeFromCache = function (arr) {
				Lyte.removeFromCache.assign(arr);
			};
			this.refresh = function (obj) {
				var refreshFrom = dotSerperator(this.__lp.objPath).length - 1,
				    route = Array.from(trans.matched.route),
				    processed = {
					matched: trans.matched,
					R: trans.R,
					transComp: {
						unRendered: route.splice(refreshFrom),
						rendered: route
					}
				};
				trans.abort({ state: 308, iAbort: true });
				newTransInfo = { replace: true, data: trans.data, fromHistory: false, url: trans.url };
				dispatch(trans.url, processed);
				if (obj && obj.refreshTemplate) {
					for (var i = refreshFrom, r; r = newTrans.routes[i]; i++) {
						delete r.component;
					}
				}
				return newTrans._trans;
			};
			this.setTitle = function (title) {
				d.title = this.title = title;
			};
			this.getQueryParams = function () {
				return this.__ltp.queryParams || {};
			};
			this.getDynamicParam = function () {
				return this.__ltp.dynamicParam;
			};
			Object.defineProperty(self, '$lg', {
				value: Lyte.__gl
			});
			this.getRouteInstance = function (routeName) {
				return LR.getRouteInstance(routeName);
			};
			this.setDynamicParam = function (value) {
				if (value && this.__ltp.dynamicParam && this.__ltp.dynamicParam != value) {
					var dynamicParams = Array.from(trans.matched.dynamicParams);
					dynamicParams.splice(this.__lp.objPath.split(".").length - 1, 1, value);
					return paramChangeTrans(cloneMatchedObj(trans.matched, { dynamicParams: dynamicParams }));
				}
				return trans._trans;
			};
			function paramChangeTrans(matched) {
				var url = constructURLFromRoute(matched),
				    processed = {
					matched: matched,
					R: trans.R
				};
				newTransInfo = {
					data: trans.data,
					url: url,
					fromHistory: false
				};
				dispatch(url, decideTransition(processed));
				return newTrans._trans;
			}
			this.setQueryParams = function (key, value, options) {
				var obj = {},
				    refresh;
				if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) == "object") {
					obj = key;
					options = value;
				} else {
					obj[key] = value;
				}
				if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) == "object") {
					refresh = options.refresh;
				}
				refresh = options;
				var matched = cloneMatchedObj(trans.matched, { queryParams: Object.assign({}, trans.matched.queryParams, obj) });
				if (!_compareObj(trans.matched.queryParams, matched.queryParams)) {
					matched.refreshModel = matched.refreshModel == undefined ? refresh : matched.refreshModel;
					return paramChangeTrans(matched);
				}
				return trans._trans;
			};
		};

		function cloneMatchedObj(matched, data) {
			var obj = Object.assign({}, matched);
			obj.route = data.route || Array.from(matched.route);
			obj.dynamicParams = data.dynamicParams || Array.from(matched.dynamicParams);
			obj.queryParams = data.queryParams || Object.assign(matched.queryParams);
			return obj;
		}

		function dispatchTransition(processed) {
			// processed = setParamsInDef(newMatch);
			var url = constructURLFromRoute(processed.matched);
			if (url) {
				processed.path = newTransInfo.url = url;
				dispatch(url, decideTransition(processed));
			}
			return url;
		}

		var allHooks = [getDependenciesStr, getResourcesStr, beforeModelStr, modelStr, afterModelStr, redirectStr, renderTemplateStr, afterRenderStr];
		function decideTransition(processed) {
			/* determines which transition to consider as previous transition */
			if (trans) {
				if (trans.running) {
					var matched = processed.matched;
					if (trans.state == 102 && trans.prom && trans.prom.hook == redirectStr) {
						var transComp = getTransitionDiffernce(trans, matched, processed.R),
						    transitioningRoute = allHooks.indexOf(trans.prom.hook) <= 5 ? trans.prom.index : trans.prom.index + 1,
						    visibleTransComparison = getTransitionDiffernce(visibleTrans, matched, processed.R);
						if (transComp.common.length < visibleTransComparison.common.length) {
							if (transComp.rendered.length < visibleTransComparison.rendered.length) {
								processed.prevTrans = visibleTrans;
								if (trans.runLoop.templateToRemove.length) {
									trans.runLoop.templateToRemove.pop();
								}
							}
							transComp = visibleTransComparison;
							if (trans.prom.index <= visibleTransComparison.common.length - 1) {
								transComp.redirected = trans.prom;
							}
						} else if (transComp.common.length - 1 >= transitioningRoute) {
							if (trans.prom.index <= transComp.common.length - 1) {
								processed.prevTrans = trans;
								transComp.redirected = trans.prom;
							}
						}
					}
					var info = {
						route: matched.target,
						queryParams: matched.queryParams,
						dynamicParams: matched.dynamicParams.filter(_arrayClean)
					};
					if (LR.checkIfSameRoute(trans.info, info) && !trans.aborted) {
						trans.pause({ iPause: true });
					} else {
						trans.abort({ state: 409, iAbort: true });
					}
					processed.transComp = transComp;
				} else if (trans && !trans.aborted) {
					trans.abort({ state: 409, iAbort: true });
				}
			}
			return processed;
		}

		// function getRequirements(object) {
		// 	/* download files that are returned from getResources and getDependencies */
		// 	var every = function() {};
		// 	every.internal = {};
		// 	var reqType = object.reqType,
		// 	r = object.r,
		// 	index = object.index,
		// 	hook = every.internal.hook = trans.prom.hook,
		// 	errorType = reqType == dependenciesStr ? "errorDependencies" : "errorResources",
		// 	self = this;
		// 	every.internal.route = r.__lp.objPath;
		// 	Lyte.injectResources(
		// 	r.__lp[reqType],
		// 	every,
		// 	function(successFiles,errorFiles) {
		// 		/* completed callback */
		// 		r.__lp[reqType+'Loaded'] = true;
		// 		if(!errorFiles.length) {
		// 			var pending;
		// 			if(trans.pending && (pending = trans.pending[reqType]) != undefined && pending == index) {
		// 				delete trans.pending[reqType];
		// 				if((pending = trans.pending.forceFetch) != undefined && pending == index && trans.forceFetchRunning) {
		// 					delete trans.pending.forceFetch;
		// 					nestedForcedPromises.call(trans, trans.runLoop.forceFetch , trans.fRunningProm.resolve ,trans.runLoop.forceFetch[index][0]);
		// 				}
		// 				nestedPromises.call(trans,trans.runLoop,"current",trans.runningProm.resolve);
		// 			}
		// 		} else {
		// 			if(!self.aborted) {
		// 				if(!self.paused) {
		// 					self.pause({iPause : true});  
		// 				}
		// 				run[onErrorStr].call(self,hook,index, (r.__lp[errorType] = errorFiles), 424);  
		// 		}
		// 		}         
		// 	}
		// 	);
		// }

		// function nestedPromises(loop,state,resolve) {
		// 	if(validateTransition(this)) {
		// 	var runLoop = loop[state];
		// 	if(runLoop && runLoop.length) {
		// 		var promise = runLoop[0],
		// 		r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		if(promise.hook == beforeModelStr && !requirements.get(r,dependenciesStr)) {
		// 		this.pending[dependenciesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == renderTemplateStr && !requirements.get(r,resourcesStr)) {
		// 		this.pending[resourcesStr] = promise.index;
		// 		return;
		// 		} else if(promise.hook == redirectStr && r.forceFetch && routeInstance.__lp.fetchStatus == pendingStr) {
		// 		if(!this.forceFetchRunning) {
		// 			this.forceFetchRunning = true;
		// 			runLoopPromise.call(this,nestedForcedPromises,"nestedForcedPromises");
		// 		}
		// 		this.pending.forceFetch = promise.index;
		// 		return;
		// 		} else {
		// 		promise.state = state;
		// 		trans.prom = promise;
		// 		logCallbacks(promise);
		// 		t(promise.hook+promise.index);
		// 		run[promise.hook].call(this,promise.hook,promise.index).then(function(data) {
		// 			setPendingResume.call(trans,trans.prom);
		// 			t(promise.hook+promise.index);
		// 			// if(promise.hook == modelStr) {
		// 			// 	routeInstance.currentModel = data;
		// 			// }
		// 			if(this.runningProm.resolve == resolve) {
		// 			removeHook(loop[state],promise.hook,promise.index);
		// 			nestedPromises.call(this,loop,state,resolve);  
		// 			}
		// 		}.bind(this));
		// 		}
		// 	} else if(resolve) {
		// 		resolve();
		// 	}
		// 	} else if(this.paused && this.runningProm) {
		// 	this.runningProm.reject(abortedStr);  
		// 	}
		// }

		// function nestedForcedPromises(forcedLoop, resolve, promise) {
		// 	if (validateTransition(this) && forcedLoop) {
		// 		if(!promise) {
		// 			for(var key in forcedLoop) {
		// 			var routeLoop = forcedLoop[key],
		// 			p = routeLoop[0];
		// 			if(p) {
		// 				if(requirements.get(this.R[p.index],dependenciesStr)) {
		// 				if(!routeLoop[0].running) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,routeLoop[0]);    
		// 				}
		// 				} else {
		// 				this.pending[dependenciesStr] = p.index;
		// 				} 
		// 			}
		// 			}
		// 			return;
		// 		}
		// 		var r = this.R[promise.index],
		// 		routeInstance = this.routes[promise.index];
		// 		promise.state = "forceFetch";
		// 		trans.prom = promise;
		// 		if (promise.hook == beforeModelStr && !requirements.get(routeInstance, dependenciesStr)) {
		// 			this.pending[dependenciesStr] = promise.index;
		// 			return;
		// 		}
		// 		logCallbacks(promise);
		// 		forcedLoop[promise.index][0].running = true;
		// 		forcedLoop[promise.index].splice(0, 1);
		// 		run[promise.hook].call(this, promise.hook, promise.index).then(function (data) {
		// 			setPendingResume.call(trans, trans.prom);
		// 			if(promise.hook == afterModelStr) {
		// 				routeInstance.__lp.fetchStatus = completedStr;
		// 				if (this.pending.forceFetch != undefined && this.pending.forceFetch == promise.index) {
		// 				delete this.pending.forceFetch;
		// 				nestedPromises.call(this,this.runLoop,"current",this.runningProm.resolve);
		// 				}
		// 			} else if(promise.hook == modelStr) {
		// 				routeInstance.currentModel = data;
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == afterModelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			} else {
		// 				if(forcedLoop[promise.index][0] && forcedLoop[promise.index][0].hook == modelStr) {
		// 					nestedForcedPromises.call(this, forcedLoop, resolve,forcedLoop[promise.index][0]);	
		// 				}
		// 			}
		// 		}.bind(this));
		// 	} else {
		// 	this.forceFetchRunning = false;
		// 	}
		// }

		return this;
	}
	Lyte.Router = new Router();
})(window);
(function (window) {
	// For minification
	var _Lyte = Lyte;
	//security
	_Lyte.Security = {
		"_ourSanitizerInstance_": {},
		"_userSanitizerInstance_": {},
		"_eM": {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;',
			'`': '&#x60;',
			'=': '&#x3D;'
		},
		"_eR": /[&<>"'`=]/g,
		"_eF": function _eF(str) {
			return this._eM[str];
		},
		"escape": function escape(string) {
			if (typeof string !== 'string') {
				string = '' + string;
			}
			return string.replace(this._eR, this._eF.bind(this));
		}
	};
	var sec = { "GLOBAL_TAGS": [], "GLOBAL_ATTRIBUTES": [], "FORBID_TAGS": [], "FORBID_ATTR": [], REUSE_CONFIG: true };
	_Lyte.Security._ourSanitizerInstance_ = ZWAF['7_0_0'].HTMLPurifier(sec);
	_Lyte.Security._ourSanitizerInstance_._GLOBAL_TAGS = sec.GLOBAL_TAGS;
	_Lyte.Security._ourSanitizerInstance_._GLOBAL_ATTRIBUTES = sec.GLOBAL_ATTRIBUTES;
	sec.GLOBAL_ATTRIBUTES.push("is", "yield-name", "lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target", "lt-prop-td", "lt-prop-custom", "lt-prop-target", "lt-prop-id", "lt-prop-class", "lt-prop-style", "lt-prop-rel", "lt-prop-title");
	sec.GLOBAL_TAGS.push("link-to");
	_Lyte.Security._ourSanitizerInstance_._FORBID_TAGS = sec.FORBID_TAGS;
	_Lyte.Security._ourSanitizerInstance_._FORBID_ATTR = sec.FORBID_ATTR;
	_Lyte.Security.createSanitizer = function (obb) {
		if (!obb.GLOBAL_ATTRIBUTES) {
			obb.GLOBAL_ATTRIBUTES = [];
		}
		if (!obb.FORBID_TAGS) {
			obb.FORBID_TAGS = [];
		}
		if (!obb.FORBID_ATTR) {
			obb.FORBID_ATTR = [];
		}
		if (!obb.GLOBAL_TAGS) {
			obb.GLOBAL_TAGS = [];
		}
		obb.REUSE_CONFIG = true;
		obb.GLOBAL_ATTRIBUTES.push("is", "yield-name", "lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target", "lt-prop-td", "lt-prop-custom", "lt-prop-target", "lt-prop-id", "lt-prop-class", "lt-prop-style", "lt-prop-rel", "lt-prop-title");
		obb.GLOBAL_TAGS.push("link-to");
		var globalTagArr = Array.from(obb.GLOBAL_TAGS);
		var attr = [];
		for (var a = 0; a < globalTagArr.length; a++) {
			if (_LC._registeredComponents[globalTagArr[a]]) {
				attr = _LC._registeredComponents[globalTagArr[a]].observedAttributes;
			} else if (Lyte.registeredCustomComponent[globalTagArr[a]]) {
				attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
			}
			for (var i = 0; i < attr.length; i++) {
				if (obb.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1) {
					obb.GLOBAL_ATTRIBUTES.push(attr[i]);
				}
			}
		}
		_Lyte.Security._userSanitizerInstance_ = ZWAF['7_0_0'].HTMLPurifier(obb);
		_Lyte.Security._userSanitizerInstance_._GLOBAL_TAGS = obb.GLOBAL_TAGS;
		_Lyte.Security._userSanitizerInstance_._GLOBAL_ATTRIBUTES = obb.GLOBAL_ATTRIBUTES;
		_Lyte.Security._userSanitizerInstance_._FORBID_TAGS = obb.FORBID_TAGS;
		_Lyte.Security._userSanitizerInstance_._FORBID_ATTR = obb.FORBID_ATTR;
		return _Lyte.Security._userSanitizerInstance_;
	};
	//var toArrayLyte = "toArrayLyte";
	//var bindStr = "_bindings";
	//var compStr = "component";
	//var forHelperStr = "_forHelpers";
	//var dynamicNodesStr = "_dynamicNodes";
	//var calleeStr = "_callee";
	//var getAttributeStr = "getAttribute";
	//var hasAttributeStr = "hasAttribute";
	//var removeAttributeStr ="removeAttribute";
	//var setAttributeStr = "setAttribute";
	//var parentNodeStr = "parentNode";
	//var nodeNameStr = "nodeName";
	//var ownerElementStr = "ownerElement";
	var globalDOMEvents = ["focus", "focusin", "focusout", "resize", "scroll", "click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "change", "select", "submit", "keydown", "keypress", "keyup", "contextmenu"];
	var registerHelperStr = "registerHelper";
	var delStr = "delete";

	function defProp() {
		Object.defineProperty.apply(Object, arguments);
	}

	function makeSet(obj, key) {
		if (!obj[key]) {
			defProp(obj, key, {
				value: new Set(),
				enumerable: false,
				writable: true,
				configurable: true
			});
		}
	}
	function addBindings(bindings, property) {
		bindings.add(property);
	}

	function makeArray(obj, key) {
		if (!obj[key]) {
			defProp(obj, key, {
				value: [],
				enumerable: false,
				writable: true,
				configurable: true
			});
		}
	}

	function createDocFragment() {
		return document.createDocumentFragment();
	}

	function createElement(elm) {
		return document.createElement(elm);
	}

	function _insertBefore(parent, newNode, refNode) {
		parent.insertBefore(newNode, refNode);
	}

	function deleteBindingCheckSize(obj, key, valToDelete) {
		obj[key][delStr](valToDelete);
		if (!obj[key].size) {
			delete obj[key];
		}
	}
	_Lyte.registerErrorCodes({
		"LC001": "Error while parsing custom prop handler attribute {0}. Check if the value provided is a valid JSON",
		"LC002": "{0} Component is not compiled. Please compile using Lyte CLI",
		"LC003": "Helper named {0} is not defined",
		"LC004": "Action named {0} doesn't exists",
		"LC005": "Lyte.objectUtils doesn't support {0} function",
		"LC006": "Lyte.arrayUtils doesn't support {0} function",
		"LC007": "Component name not specified in Lyte.Component.render",
		"LC008": "Specified outlet {0} doesn't exists - Lyte.Component.render",
		"LC009": "Method named {0} doesn't exists in {1} component",
		"LC010": "Parent Node / reference Node not provided for insertBefore method"
	});

	/*	IE Browser
 	_Lyte._ie 
 	Edge Browser
 	_Lyte._ed 
 	Replace with needed;
 	_Lyte._rwpf 
 	IE / Edge Browser
 	_Lyte._ms
 */

	var userAgent = navigator.userAgent;
	//temporary fix for IE 11
	if (userAgent.match(/rv:11/)) {
		_Lyte._ie = true;
		window.action = function () {
			return;
		};
	}
	if (userAgent.match('Edge')) {
		var s = createElement("div");
		s.innerHTML = "<template><div>c</div></template>";
		if (s.querySelector("template").childNodes.length) {
			_Lyte._ie = true;
		} else {
			_Lyte._ed = true;
		}
		s.remove();
	}

	var Test = function (_HTMLElement2) {
		_inherits(Test, _HTMLElement2);

		function Test() {
			_classCallCheck(this, Test);

			var _this2 = _possibleConstructorReturn(this, (Test.__proto__ || Object.getPrototypeOf(Test)).call(this));

			if (!_this2.attributes.t) {
				_LC.frSpecial = true;
			}
			return _this2;
		}

		return Test;
	}(HTMLElement);

	if (_Lyte._ie || _Lyte._ed) {
		var doc = createDocFragment();
		doc.appendChild(document.createTextNode("  dummy "));
		doc.childNodes[0].replaceWith(document.createTextNode("changed"));
		if (doc.childNodes[0].textContent !== "changed") {
			_Lyte._rwpf = true;
		}
		_Lyte._ms = true;
	}

	_Lyte.Component = {};
	Lyte.Compile = {};
	var _LyteComponent = _Lyte.Component;

	_Lyte.arrayUtils = function () {
		//arrayFunctions
		return _LC.aF.apply(_LC, arguments);
	};
	_Lyte.objectUtils = function () {
		//objectFunctions
		return _LC.oF.apply(_LC, arguments);
	};
	Object.defineProperty(_LyteComponent, "register", {
		get: function get() {
			Lyte._preRegister();
			return _LC.registerComponentWrapper;
		}
	});
	_LyteComponent.getComponentClass = function (compName) {
		return _LC._registeredComponents[compName];
	};
	_LyteComponent.registerHelper = function () {
		_LC.registerHelper.apply(_LC, arguments);
	};
	_LyteComponent.set = function () {
		_LC.set.apply(_LC, arguments);
	};
	_LyteComponent.registeredHelpers = {};
	_LyteComponent.registeredComponents = {};
	function noop() {}
	_LyteComponent.registerCustomPropHandler = function (propName) {
		var dasherized = _LC.String.dasherize(propName);
		propName = _LC.String.toCamelCase(propName);
		if (_LC.customPropHandlers.indexOf(propName) === -1) {
			_LC.customPropHandlers.push(propName);
			customElementPrototype.prototype[propName] = function () {
				var argsLength = arguments.length;
				var arg0 = arguments[0];
				var options = arguments[2];
				var compData = this.component.data;
				if (!arg0) {
					//Read all the values
					var _obj2 = {};
					for (var _key3 in compData) {
						if (_key3.startsWith(propName)) {
							var objKey = _key3.substring(propName.length);
							objKey = _LC.String.lowerCaseFirstLetter(objKey);
							_obj2[objKey] = compData[_key3];
						}
					}
					return _obj2;
				} else if (typeof arg0 === "string") {
					if (argsLength > 1) {
						//Set a value
						this.set(propName + _LC.String.upperCaseFirstLetter(arg0), arguments[1], options);
					} else {
						//Read a value
						var actKey = propName + _LC.String.upperCaseFirstLetter(arg0);
						return compData[actKey];
					}
				} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
					//Write a set of values
					for (var _key4 in arg0) {
						var _objKey = propName + _LC.String.upperCaseFirstLetter(_key4);
						this.set(_objKey, arg0[_key4], arguments[1]);
					}
				}
			};
			_LC.customPropRegex = new RegExp("^(" + _LC.customPropHandlers.join("|") + ")");
		}
	};
	_LyteComponent.unregisterComponent = function (componentName) {
		if (_LyteComponent.registeredComponents[componentName]) {
			var comp = _LC._registeredComponents[componentName];
			if (comp.activeInstances > 0) {
				_Lyte.warn("There are active instances of the component " + componentName + " and hence cannot be unregistered");
			} else {
				//Do the unregisteration here
				comp._properties = {};
				comp.component = comp._mixins = comp._actions = comp._template = comp._dynamicNodes = null;
				comp._callBacks = {};
				comp._observers = [];
				comp._data = undefined;
				comp._methods = {};
				comp.prototype.get = noop;
				comp.prototype.set = noop;
				// delete comp.prototype.setData;
				// delete comp.prototype.getData;
				Object.defineProperty(comp.prototype, "setData", {
					configurable: true,
					writable: true,
					value: function value(arg0, arg1) {
						this._initProperties = this._initProperties || {};
						if (typeof arg0 === "string") {
							this._initProperties[arg0] = arg1;
						} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
							for (var _key5 in arg0) {
								this._initProperties[_key5] = arg0[_key5];
							}
						}
					}
				});

				Object.defineProperty(comp.prototype, "setMethods", {
					configurable: true,
					writable: true,
					value: function value(arg0, arg1) {
						this._initMethods = this._initMethods || {};
						if (typeof arg0 === "string") {
							this._initMethods[arg0] = arg1;
						} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
							for (var _key6 in arg0) {
								this._initMethods[_key6] = arg0[_key6];
							}
						}
					}
				});

				delete _LyteComponent.registeredComponents[componentName];
				var template = document.querySelector("template[tag-name=" + componentName + "]");
				if (template) {
					template.remove();
				}
				// lyteht -> lyteHelperTemplates
				var helperTemplate = comp._helperTemplate;
				if (helperTemplate) {
					helperTemplate.remove();
				}
				if (comp._depthTemp) {
					comp._depthTemp.remove();
				}
			}
		} else {
			_Lyte.warn("Component " + componentName + " not yet registered");
		}
	};
	Lyte.createCustomElement = function (customElementName, definition) {
		var constructor = definition.constructor;
		delete definition.constructor;
		var _connectedCallback = definition.connectedCallback;
		delete definition.connectedCallback;
		var _attributeChangedCallback = definition.attributeChangedCallback;
		delete definition.attributeChangedCallback;
		var _disconnectedCallback = definition.disconnectedCallback;
		delete definition.disconnectedCallback;

		this.defProperty = function (obj, key, val) {
			var obj1 = {};
			if (val.get) {
				obj1.get = val.get;
			}
			if (val.set) {
				obj1.set = val.set;
			}
			Object.defineProperty(obj, key, obj1);
		};

		var classDef = function (_HTMLElement3) {
			_inherits(classDef, _HTMLElement3);

			function classDef() {
				_classCallCheck(this, classDef);

				var _this3 = _possibleConstructorReturn(this, (classDef.__proto__ || Object.getPrototypeOf(classDef)).call(this));

				if (_this3.isNewComp(customElementName)) {
					_this3.executeCallbacks(constructor, arguments);
				} else {
					_this3.__lyteIgnore = true;
				}
				return _this3;
			}

			_createClass(classDef, [{
				key: 'connectedCallback',
				value: function connectedCallback() {
					if (this.__lyteIgnore || this.hasAttribute("lyte-rendered-ce")) {
						return;
					}
					this.executeCallbacks(_connectedCallback, arguments);
					this.setAttribute("lyte-rendered-ce", "");
				}
			}, {
				key: 'attributeChangedCallback',
				value: function attributeChangedCallback() {
					if (!this.__lyteIgnore) {
						this.executeCallbacks(_attributeChangedCallback, arguments);
					}
				}
			}, {
				key: 'disconnectedCallback',
				value: function disconnectedCallback() {
					if (!LyteComponent.ignoreDisconnect && !this.__lyteIgnore) {
						this.executeCallbacks(_disconnectedCallback, arguments);
					}
				}
			}, {
				key: 'executeCallbacks',
				value: function executeCallbacks(callBack, argArr) {
					if (callBack) {
						callBack.apply(this, Array.from(argArr));
					}
				}
			}, {
				key: 'isNewComp',
				value: function isNewComp(customElementName) {
					if (this.hasAttribute("lyte-rendered-ce")) {
						return false;
					}
					return true;
				}
			}]);

			return classDef;
		}(HTMLElement);

		var staticDef = definition.static;
		if (staticDef) {
			for (var key in staticDef) {
				if (_typeof(staticDef[key]) === "object") {
					this.defProperty(classDef, key, staticDef[key]);
				} else {
					Object.defineProperty(classDef, key, {
						value: staticDef[key]
					});
				}
			}
			delete definition.static;
		}
		for (var key in definition) {
			if (_typeof(definition[key]) === "object") {
				this.defProperty(classDef.prototype, key, definition[key]);
			} else {
				Object.defineProperty(classDef.prototype, key, { writable: true, value: definition[key] });
			}
		}
		definition.static = staticDef;
		definition.constructor = constructor;
		definition.connectedCallback = _connectedCallback;
		definition.attributeChangedCallback = _attributeChangedCallback;
		definition.disconnectedCallback = _disconnectedCallback;
		if (document.readyState === "complete" || document.readyState === "interactive") {
			// document is already ready to go
			customElements.define(customElementName, classDef);
		} else {
			LyteComponent.toBeRegistered.push({ name: customElementName, def: classDef });
		}
		Lyte.registeredCustomComponent[customElementName] = classDef;
	};
	var elementPrototype = typeof HTMLElement !== "undefined" ? HTMLElement : Element;

	_Lyte.appendTemplateDiv = function () {
		document.body.appendChild(_LC.tDiv);
		document.body.appendChild(_LC.h1Div);
	};

	function onDomContentForLyte() {
		// document.head.appendChild(Lyte.$.assetsDiv);
		if (!_Lyte._ie) {
			document.body.appendChild(_LC.lyteComponentsDiv);
			//document.body.appendChild(_LC.tDiv);
		}
		document.body.appendChild(_LC.hDiv);
		var bodyEvents = globalDOMEvents;
		for (var _i3 = 0; _i3 < bodyEvents.length; _i3++) {
			var evnt = bodyEvents[_i3];
			document.body.addEventListener(evnt, globalEventHandler, true);
		}

		var comp = _LC.toBeRegistered;
		if (comp.length) {
			for (var j = 0; j < comp.length; j++) {
				customElements.define(comp[j].name, comp[j].def);
			}
			_LC.toBeRegistered = [];
		}
		if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
			var style = createElement("style");
			style.innerHTML = "* { cursor : pointer}";
			document.head.appendChild(style);
		}
	}

	document.addEventListener("change", function (event) {
		var target = event.target || event.srcElement;
		if (!target._attributeDetails) {
			return;
		}
		var attributeName = "value";
		if (target.type === "checkbox" || target.type === "radio") {
			attributeName = "checked";
		}
		var contextSwitchArray = [];
		var attrNode;
		var attrDetail = target._attributeDetails[attributeName];
		if (!attrDetail || !attrDetail.isLbind) {
			return;
		}
		//attrNode = (attributeName === "checked") ? target._attributeDetails[attributeName].bindedNode : target.getAttributeNode(attributeName);
		var callee = target;
		if (!target._callee) {
			while (callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
				if (callee.tagName === "BODY") {
					callee = null;
					break;
				}
				callee = callee.parentNode;
			}
			if (callee && callee.tagName === "LYTE-YIELD") {
				target._callee = callee._registerYield._callee;
			} else {
				target._callee = callee;
			}
		}
		var self = target._callee;
		if (target) {
			_LC.adCx(target, contextSwitchArray);
		}
		var obj = _LC.getNew(self.component.data, attrDetail.dynamicValue);
		if (!obj.context) {
			return;
		}
		var lastKeyIndex = +obj.lastKey;
		if (Array.isArray(obj.context) && typeof lastKeyIndex == "number") {
			var callReplaceAt = lastKeyIndex < obj.context.length;
			if (obj.context[lastKeyIndex] !== target[attributeName] || !callReplaceAt) {
				_LC.aF(obj.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, target[attributeName]);
			}
		} else {
			_LC.set(obj.context, obj.lastKey, target[attributeName]);
		}
		// _LC.set(obj.context, obj.lastKey, target[attributeName]);
		if (target) {
			_LC.rmCx(target, contextSwitchArray);
		}
	});
	var globalEventHandler = function globalEventHandler(ev) {
		var evnt = ev.type;
		var target = ev.target,
		    toRemove;
		if (/^(click|dblclick)$/.test(evnt) && target.getAttribute && target.getAttribute("lyte-state") != null) {
			ev.preventDefault();
			return;
		}
		if (ev.currentTarget !== document.body) {
			target = ev.currentTarget;
		}
		if (!window.event) {
			toRemove = true;
			window.event = ev;
		}
		var eventStopped = false;
		while (target && target.getAttribute && (!target.getAttribute(evnt) || target.hasAttribute("disabled") && evnt != "blur") && target.tagName != "BODY") {
			if (_LC.hasLyteEvents(target, evnt)) {
				eventStopped = _LC.handleLyteEvents(target, ev);
				if (eventStopped) {
					break;
				}
			}
			target = target.parentNode;
		}
		if (eventStopped || !target) {
			return;
		}
		var callee = target;
		if (!target._callee) {
			while (callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
				if (callee.tagName === "BODY") {
					callee = null;
					break;
				}
				callee = callee.parentNode;
			}
			if (callee && callee.tagName === "LYTE-YIELD") {
				target._callee = callee._registerYield._callee;
			} else {
				target._callee = callee === target ? undefined : callee;
			}
		}
		if (target._evBoundEvents && target._evBoundEvents[evnt]) {
			//Not needed - but check and remove
			var actions = target._callee ? target._callee.constructor._actions : target.constructor._actions;
			//let actions = target.constructor._actions;
			var actObj = target._evBoundEvents[evnt];
			var cloneActObj = _Lyte.deepCopyObject(actObj);
			_LC.skipArgProcessing(cloneActObj, ev, target);
			_LC.throwAction.call(target, target, evnt, cloneActObj, undefined, undefined, target, ev, undefined, true);
		} else if (target.getAttribute && target.getAttribute(evnt) && target._boundEvents && target._boundEvents[evnt]) {
			var _actions = target._callee.constructor._actions;
			var func = target.getAttribute(evnt).split(" => ")[1];
			var _actObj = target._boundEvents[evnt];
			var _cloneActObj = _Lyte.deepCopyObject(_actObj);
			_LC.skipArgProcessing(_cloneActObj, ev, target);
			_LC.throwAction.call(target._callee, target._callee, evnt, _cloneActObj, undefined, undefined, target, ev);
		}
		if (target.tagName === "LABEL") {
			var input = target.querySelector("input");
			if (input && input.getAttribute(evnt)) {
				var _actions2 = target._callee.constructor._actions;
				var _func = input.getAttribute(evnt).split(" => ")[1];
				//	let actObj = target._callee.constructor.getHelper(func);
				var _actObj2 = target._boundEvents[evnt];
				var _cloneActObj2 = _Lyte.deepCopyObject(_actObj2);
				_LC.skipArgProcessing(_cloneActObj2, ev, target);
				_LC.throwAction.call(target._callee, target._callee, evnt, _cloneActObj2, undefined, undefined, input, ev);
			}
		}
		if (toRemove) {
			window.event = undefined;
		}
	};

	var LyteYield = function (_HTMLElement4) {
		_inherits(LyteYield, _HTMLElement4);

		function LyteYield() {
			_classCallCheck(this, LyteYield);

			return _possibleConstructorReturn(this, (LyteYield.__proto__ || Object.getPrototypeOf(LyteYield)).apply(this, arguments));
		}

		_createClass(LyteYield, [{
			key: 'connectedCallback',
			value: function connectedCallback() {
				this._callee = this._callee || _LC.getCallee(this.parentNode, this);
				if (!this._registerYield && this._callee) {
					var yieldName;
					if (this._callee._fR && this._callee._fR._yieldCallee) {
						this._registerYield = { "_callee": this._callee._fR._yieldCallee.component.$node };
					} else if (this._callee._yields && (yieldName = this.attributes["yield-name"]) && (yieldName = yieldName.nodeValue) && this._callee._yields[yieldName]) {
						this._registerYield = { "_callee": this._callee._yields[yieldName]._callee };
					}
				}
			}
		}, {
			key: 'disconnectedCallback',
			value: function disconnectedCallback() {
				if (_LC.ignoreDisconnect || this._deleted) {
					return;
				}
				this._deleted = true;
				if (!this._properties) {
					return;
				}
				var nodeContextSwitchArray = [];
				_LC.adCx(this, nodeContextSwitchArray);
				_LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
				var node = this._registerYield;
				if (!node) {
					_LC.rmCx(this, nodeContextSwitchArray);
					return;
				}
				var toAppendContextSwitchArray = [];
				//newContext not needed
				var del = "delete"; //for ie 11.0
				_LC.adCx(node, toAppendContextSwitchArray);
				for (var _key7 in this._dynamicProperty) {
					if (this._dynamicProperty[_key7].isActualNode) {
						this._dynamicProperty[_key7].isActualNode._helperNodes[del](this);
					} else {
						var helperNodes = node._callee.getProperty(_key7)._helperNodes;
						if (helperNodes) {
							helperNodes[del](this);
						}
					}
				}
				this._dynamicProperty = {};
				for (var _i4 = 0; _i4 < this._helpers.length; _i4++) {
					node._callee.removeHelpers(this._helpers[_i4]);
				}
				this._helpers = [];
				_LC.rmCx(node, toAppendContextSwitchArray);
				_LC.rmCx(this, nodeContextSwitchArray);
				// var self = this;
				// setTimeout(function() {
				//     self._registerYield = null
				//     self._callee = null;
				// },0);
			}
		}, {
			key: 'getProperty',
			value: function getProperty(key) {
				var arr = key.match(/([^[\].]+|\[\])/g);
				var property = this;
				if (!property._properties[arr[0]]) {
					property._properties[arr[0]] = {};
				}
				property = property._properties[arr[0]];

				defProp(property, '_path', { enumerable: false, value: arr[0] });
				for (var _i5 = 1; _i5 < arr.length; _i5++) {
					if (arr[_i5].startsWith("'") || arr[_i5].startsWith('"')) {
						//added check
						arr[_i5] = arr[_i5].substring(1, arr[_i5].length - 1);
					}
					if (!property[arr[_i5]]) {
						property[arr[_i5]] = {};
						defProp(property[arr[_i5]], '_path', { enumerable: false, value: property._path + "." + arr[_i5] });
					}
					property = property[arr[_i5]];
				}
				return property;
			}
		}]);

		return LyteYield;
	}(HTMLElement);

	customElements.define("lyte-yield", LyteYield);

	var customElementPrototype = function (_elementPrototype) {
		_inherits(customElementPrototype, _elementPrototype);

		function customElementPrototype() {
			_classCallCheck(this, customElementPrototype);

			var _this5 = _possibleConstructorReturn(this, (customElementPrototype.__proto__ || Object.getPrototypeOf(customElementPrototype)).call(this));

			if (_this5.hasAttribute("lyte-rendered") || _this5._ccCalled) {
				_this5.__lyteIgnore = true;
				return _possibleConstructorReturn(_this5);
			} else if (!_LyteComponent.registeredComponents[_this5.localName]) {
				_this5.__lyteIgnore = true;
				var origClass = _LC._registeredComponents[_this5.localName];
				origClass._pendingComponents = origClass._pendingComponents || [];
				origClass._pendingComponents.push(_this5);
				return _possibleConstructorReturn(_this5);
			}
			_this5.actualConstructor();
			return _this5;
		}

		_createClass(customElementPrototype, [{
			key: 'actualConstructor',
			value: function actualConstructor() {
				this.constructor.activeInstances++;
				var fastRenderIndex = void 0;
				var lytePropAttr = this.attributes._lyteprop;
				lytePropAttr = lytePropAttr ? lytePropAttr.nodeValue : undefined;
				var fastRenderedProp = (fastRenderIndex = lytePropAttr) ? _LC.fRP[fastRenderIndex] : undefined;
				var compInstance = this.component = fastRenderedProp ? fastRenderedProp.component : new this.constructor.component();
				this._properties = {};
				// compInstance.methods = {};
				// this._methods = compInstance.methods;

				compInstance._config = this.constructor._config;
				//        this.component.data = this.constructor._data ? this.constructor._data() : {};
				var compData = void 0;
				//comment the following two when return cli update is done.

				var act = compInstance.actions;
				Object.defineProperty(compInstance, "actions", {
					get: function get() {
						Lyte.warn("Accessing actions directly is deprecated. Move the required common code from action block to a common function and access it.");
						return act;
					}
				});
				if (!fastRenderedProp) {
					compData = compInstance.data = {};
					var data = this.constructor._data ? this.constructor._data.apply(compInstance) : {};
					var def = "default";
					defProp(compData, '__component__', {
						value: this,
						configurable: true,
						writable: true,
						enumerable: false
					});
					compData.errors = {};
					compInstance.__data = data;
					for (var _key8 in data) {
						var obj = data[_key8];
						compData[_key8] = obj[def];
						var customDtype;
						if (Lyte.Transform[obj.type]) {
							var customDataType = Lyte.Transform[obj.type];
							if (/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))) {
								customDtype = true;
							}
						}
						if (/^(object|array)$/.test(obj.type) && obj.watch || customDtype) {
							Lyte.establishObjectBinding(compData, _key8, false, undefined, undefined, obj.watch ? true : undefined);
						}
					}
					if (this.constructor._serviceToBeUsed) {
						for (var serKey in this.constructor._serviceToBeUsed) {
							var serName = this.constructor._serviceToBeUsed[serKey];
							if (Lyte.registeredServices.hasOwnProperty(serName)) {
								this.component[serKey] = new Lyte.registeredServices[serName]();
							} else {
								this.__toRemoveLazy = this.__toRemoveLazy || {};
								var self = this;
								var id = Lyte.$.requiredServices(serKey, serName, function (serviceData, serviceKey, _sname, servName) {
									self.component[serviceKey] = new serviceData();
									var _toRemove = self.__toRemoveLazy[servName];
									_toRemove.forEach(function (id) {
										Lyte.$.toRemoveFromRequiredServices(id);
									});
									delete self.__toRemoveLazy[servName];
								});
								this.__toRemoveLazy[serName] = this.__toRemoveLazy[serName] || [];
								this.__toRemoveLazy[serName].push(id);
							}
						}
					}
				}

				// for(let key in this.constructor._methods) {
				//     compInstance.methods[key] = this.constructor._methods[key];
				// }
				// var met = compInstance.methods;
				// Object.defineProperty(compInstance,"methods",{
				//     get : function() {
				// 		Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
				// 		return met;
				// 	},
				//     set : function(value){
				//         met = value
				//     }   
				// });
				if (compInstance.$node) {
					for (var key in compInstance.$node) {
						if (key != "localName") {
							this[key] = compInstance.$node[key];
						}
					}
				}
				this.initializeMethod(this, this.constructor._methods);
				compInstance.$node = this;
				var _config_flag = void 0;
				if (compInstance._config) {
					_config_flag = compInstance._config.clientLifeCycleHooks == true || (_typeof(compInstance._config.clientLifeCycleHooks) == 'object' ? compInstance._config.clientLifeCycleHooks.includes('constructor') : false);
				}
				var _overrides = void 0;

				if (!fastRenderedProp) {
					this.callback("constructor");
					this._actions = this._actions ? this._actions : {};
					this._callee = this._callee || this.getCallee(this.parentNode);

					//check if it is called from server || to ssr bind

					//check if it has ssr contructor for ssr
					//ssrcode_client              
					if (_config_flag || !this.hasAttribute('server-rendered')) {
						if (_overrides && _overrides.constructor && this.serverCall) {
							_overrides.constructor.apply(this);
						} else {
							this.callback("constructor");
						}
					}

					//checking lyte.attr ytpe and given default value type
					for (var key in compData) {
						var error = _LC.handleValidation(compData, key, compData[key], compInstance, true);
						if (error) {
							compData[key] = undefined;
						}
					}
				} else {
					this._fR = fastRenderedProp;
					delete _LC.fRP[fastRenderIndex];
					// _LC.pushFrc(fastRenderIndex);
				}
			}
		}, {
			key: 'getMethods',
			value: function getMethods(arg0) {
				return this.component.getMethods(arg0);
			}
		}, {
			key: 'hasAction',
			value: function hasAction(arg0) {
				return this.component.hasAction(arg0);
			}
		}, {
			key: 'setActions',
			value: function setActions(arg0, arg1) {
				return this.component.setActions(arg0, arg1);
			}
		}, {
			key: 'setMethods',
			value: function setMethods(arg0, arg1) {
				return this.component.setMethods(arg0, arg1);
			}
			// getData(arg0) {
			//     return this.component.getData(arg0);
			// }
			// setData(arg0, arg1 ,options) {
			//     return this.component.setData(arg0, arg1, options);
			// }

		}, {
			key: 'getCallee',
			value: function getCallee(callee) {
				return _LC.getCallee(callee, this);
			}
		}, {
			key: 'afterConnected',
			value: function afterConnected(fastRenderProp, ssrBind) {
				var constr = this.constructor;
				//initProperties is used because, we may have cases where the component wouldn't have been registered but 
				//it would be in dom already with some attributes. In those cases we can store the data in _initProperties as key, value.
				//These properties would then be applied to the component, once it gets instantiated. 

				//This is done, in order to solve when on a string value update of an if helper, the binding in the true or false case must be established. 
				//Without this, we won't establish the _properties in the component to the actual Data. 
				if (this.getAttribute("_lyteprop")) {
					return "";
				}
				var obsattr = constr._observedAttributes;
				for (var _i6 = 0; _i6 < obsattr.length; _i6++) {
					var _key9 = obsattr[_i6];
					var prop = this.getProperty(_key9);
					defProp(prop, '__fromComponent', {
						value: true,
						enumerable: false
					});
				}
				this.getProperty("errors");
				var $lg = Lyte.__gl,
				    compInstance = this.component,
				    compData = compInstance.data;
				compData.$lg = $lg;
				if (this._initProperties) {
					var initProperties = this._initProperties;
					for (var _key10 in initProperties) {
						var actVal = void 0;
						var _field2 = compInstance.__data[_key10];
						if (_field2 && _field2.type !== _LC.getDataType(initProperties[_key10]) && (initProperties[_key10] !== undefined || _field2.type === "boolean")) {
							actVal = _LC.typeCast(initProperties[_key10], compInstance.__data[_key10].type);
						} else {
							actVal = initProperties[_key10];
						}
						// if(field){
						var error = _LC.handleValidation(compData, _key10, actVal, compInstance, true);
						if (!error) {
							compData[_key10] = actVal;
							var customDtype;
							if (_field2 && Lyte.Transform[_field2.type]) {
								var customDataType = Lyte.Transform[_field2.type];
								if (/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))) {
									customDtype = true;
								}
							}
							if (_field2 && /^(object|array)$/.test(_field2.type) && _field2.watch || customDtype) {
								Lyte.establishObjectBinding(compData, _key10, undefined, undefined, undefined, _field2.watch ? true : undefined);
							}
						}
						// }
					}
					this._initProperties = undefined;
				}
				// if(compData.errors && Object.keys(compData.errors).length){
				//     Lyte.error("Error in data passed to component-"+this.component.$node.localName+" for the properties-"+Object.keys(this.component.data.errors).toString());
				// }
				if (this._initMethods) {
					var initMethods = this._initMethods;
					for (var _key11 in initMethods) {
						compInstance.$node._methods[_key11] = initMethods[_key11];
					}
					this._initMethods = undefined;
				}

				var _config_flag = void 0;
				if (compInstance._config) {
					if (compInstance._config.clientLifeCycleHooks != undefined) {
						_config_flag = compInstance._config.clientLifeCycleHooks == true || (_typeof(compInstance._config.clientLifeCycleHooks) == 'object' ? compInstance._config.clientLifeCycleHooks.includes('init') : false);
					}
				}
				var _overrides = void 0;

				//ssrcode client
				ssrBind && this.cmpBind(fastRenderProp);
				if (_config_flag || !this.hasAttribute('server-rendered')) {
					if (_overrides && _overrides.init && this.serverCall) {
						_overrides.init.apply(this);
					} else {
						this.callback('init');
					}
					this.onCallBack('init');
				}
				this.registerYields();
				if (compData.lyteUnbound) {
					_LC.unbound = true;
				}
				var content = "";
				var unboundBeta = compData.lyteFastRender;

				//to bind in ssr

				if (!unboundBeta) {
					content = this.renderNodes(constr._template, constr._dynamicNodes, undefined, undefined, undefined, undefined, this.constructor._tC);
				} else {
					content = this.renderFast(constr._dynamicNodes, constr._sta, compInstance);
					requestAnimationFrame(function () {
						requestAnimationFrame(function () {
							_LC.callCC();
						});
					});
				}
				return content;
			}
		}, {
			key: 'initializeMethod',
			value: function initializeMethod(node, actMethods) {
				var compInstance = void 0;
				if (node.component) {
					compInstance = node.component;
				} else {
					compInstance = node;
					node = compInstance.$node;
				}
				compInstance.methods = {};
				node._methods = compInstance.methods;
				for (var _key12 in actMethods) {
					compInstance.methods[_key12] = actMethods[_key12];
				}
				var met = compInstance.methods;
				Object.defineProperty(compInstance, "methods", {
					get: function get() {
						Lyte.warn("Accessing methods directly is deprecated. Kindly make use of 'this.executeMethod' Api.");
						return met;
					},
					set: function set(value) {
						met = value;
					}
				});
			}
		}, {
			key: 'renderComponent',
			value: function renderComponent(dynNode, preDefObj) {
				var componentName = dynNode.componentName;
				var staticAttrs = dynNode.staticAttrs;
				var constr = LyteComponent._registeredComponents[componentName];
				if (!constr) {
					return "";
				}
				var component = new constr.component();
				preDefObj.component = component;
				component.data = {};
				var data = constr._data ? constr._data.apply(component) : {};
				var def = "default";
				for (var _key13 in data) {
					component.data[_key13] = data[_key13][def];
				}
				component.data.errors = {};
				component.__data = data;
				// if(component.constructor) {
				// 	component.constructor.apply(component);
				// }
				var obsAttrs = LyteComponent._registeredComponents[componentName]._observedAttributes;
				preDefObj.data = preDefObj.data || {};
				for (var key in staticAttrs) {
					if (obsAttrs.indexOf(key) !== -1) {
						preDefObj.data[key] = staticAttrs[key];
					}
				}
				var initProperties = preDefObj.data;
				if (initProperties) {
					for (var _key14 in initProperties) {
						var actVal = void 0;
						if (component.__data[_key14] && component.__data[_key14].type !== _LC.getDataType(initProperties[_key14]) && (initProperties[_key14] !== undefined || component.__data[_key14].type === "boolean")) {
							actVal = _LC.typeCast(initProperties[_key14], component.__data[_key14].type);
						} else {
							actVal = initProperties[_key14];
						}
						var error = _LC.handleValidation(component.data, _key14, actVal, component);
						if (!error) {
							component.data[_key14] = actVal;
						}
					}
				}
				if (true) {
					// component.methods = {};
					// for(var key in constr._methods) {
					//     component.methods[key] = constr._methods[key];
					// }
					// // debugger;
					// component._methods = component.methods;
					// component.constructor._methods = constr._methods;
					component.$node = { "querySelector": noop, "localName": componentName };
					this.initializeMethod(component, constr._methods);
					if (component.init) {
						component.init.apply(component);
					}
					var initCallbacks = void 0;
					if (constr._callBacks && (initCallbacks = constr._callBacks.init)) {
						for (var _i7 = 0; _i7 < initCallbacks.length; _i7++) {
							initCallbacks[_i7].value.apply(component);
						}
					}
					preDefObj.unbound = true;
					delete component.$node.querySelector;
					return this.renderFast(LyteComponent._registeredComponents[componentName]._dynamicNodes, LyteComponent._registeredComponents[componentName]._sta, component, preDefObj);
				}
				return "";
			}
		}, {
			key: 'renderFast',
			value: function renderFast(dynamicNodes, arr, comp, compPreDef) {
				var _this6 = this;

				var fastRenderIndex;
				var prevComp;
				if (comp) {
					prevComp = this.component;
					this.component = comp;
				}
				var compData = this.component.data;
				var str = "";
				var dynamicCompile = arr;
				var dynamicCompileNodes = arr.cc;
				var removeFirstChar = false;
				for (var i = 0; i < dynamicCompileNodes.length; i++) {
					if (dynamicCompileNodes[i] != undefined) {
						var inte = dynamicCompileNodes[i];
						var dynNode = dynamicNodes[inte];
						if (dynNode.dynamicValue) {
							var locVal = _LC.getDD(compData, dynNode.newDynamicValue);
							locVal = locVal == undefined || locVal == null ? "" : locVal;
							// str = str + ZSEC.Encoder.encodeForHTML(locVal);
							str = str + Lyte.Security.escape(locVal);
						} else if (dynNode.helperInfo) {
							_LC.ffr = true;
							var helperVal = this.processHelper({ name: dynNode.helperInfo.name, args: this.processArgs(this, dynNode, [], undefined, undefined, true) }, undefined);
							_LC.ffr = false;
							helperVal = helperVal == undefined || helperVal == null ? "" : helperVal;
							//  str = str + ( (dynNode.helperInfo.name === "unescape") ? helperVal : ZSEC.Encoder.encodeForHTML(helperVal) );
							str = str + (dynNode.helperInfo.name === "unescape" ? helperVal : Lyte.Security.escape(helperVal));
						} else if (dynNode.type) {
							switch (dynNode.type) {
								case "for":
									{
										var prevDynamic = dynamicNodes[inte - 1].attr.items;
										var items;
										if (prevDynamic.dynamicValue) {
											items = _LC.getDD(compData, prevDynamic.newDynamicValue);
										} else if (prevDynamic.helperInfo) {
											items = this.processHelper({ name: prevDynamic.helperInfo.name, args: this.processArgs(this, prevDynamic, [], undefined, undefined, true) }, undefined);
										}
										var itemKey = dynNode._args.item || "item";
										var indexKey = dynNode._args.index || "index";
										var renderedStr = "";
										if (items && items.length) {
											var initialItemValue = compData[itemKey];
											var initialIndexValue = compData[indexKey];
											for (var indexInd = 0; indexInd < items.length; indexInd++) {
												var item = items[indexInd];
												compData[itemKey] = item;
												compData[indexKey] = indexInd;
												renderedStr += this.renderFast(dynNode.dynamicNodes, dynNode._sta, undefined, compPreDef);
											}
											compData[itemKey] = initialItemValue;
											compData[indexKey] = initialIndexValue;
										}
										str += renderedStr;
									}
									break;
								case "forIn":
									{
										var _prevDynamic = dynamicNodes[inte - 1].attr.object;
										var object;
										if (_prevDynamic.dynamicValue) {
											object = _LC.getDD(compData, _prevDynamic.newDynamicValue);
										} else if (_prevDynamic.helperInfo) {
											object = this.processHelper({ name: _prevDynamic.helperInfo.name, args: this.processArgs(this, _prevDynamic, [], undefined, undefined, true) }, undefined);
										}
										var valueKey = dynNode._args.value || "value";
										var keyKey = dynNode._args.key || "key";
										var _renderedStr = "";
										var objKeys = void 0;
										if (object && (objKeys = Object.keys(object))) {
											var initialValueValue = compData[valueKey];
											var initialKeyValue = compData[keyKey];
											for (var keyIndex = 0; keyIndex < objKeys.length; keyIndex++) {
												var _key15 = objKeys[keyIndex];
												compData[valueKey] = object[_key15];
												compData[keyKey] = _key15;
												_renderedStr += this.renderFast(dynNode.dynamicNodes, dynNode._sta, undefined, compPreDef);
											}
											compData[itemKey] = initialValueValue;
											compData[indexKey] = initialKeyValue;
										}
										str += _renderedStr;
									}
									break;
								case "if":
								case "switch":
									{
										var _prevDynamic2 = dynamicNodes[inte - 1].attr.value;
										var value;
										if (_prevDynamic2.dynamicValue) {
											value = _LC.getDD(compData, _prevDynamic2.newDynamicValue);
										} else if (_prevDynamic2.helperInfo) {
											value = this.processHelper({ name: _prevDynamic2.helperInfo.name, args: this.processArgs(this, _prevDynamic2, [], undefined, undefined, true) }, undefined);
										}
										var currentCaseName;
										if (value) {
											currentCaseName = dynNode.type === "if" ? "true" : value.toString();
										} else {
											if (dynNode.type === "if") {
												currentCaseName = "false";
											} else {
												switch (value) {
													case undefined:
														currentCaseName = "undefined";
														break;
													case null:
														currentCaseName = "null";
														break;
													case false:
														currentCaseName = "false";
														break;
													case "":
														currentCaseName = '""';
														break;
												}
											}
										}
										var _scope = dynNode.cases[currentCaseName];
										if (!_scope) {
											if ((_scope = dynNode.default) && _scope._sta) {
												str += this.renderFast(_scope.dynamicNodes, _scope._sta, undefined, compPreDef);
											}
										} else {
											while (_scope) {
												str += this.renderFast(_scope.dynamicNodes, _scope._sta, undefined, compPreDef);
												if (_scope.additional) {
													if (_scope.additional.next) {
														_scope = dynNode.cases[_scope.additional.next];
													} else {
														_scope = dynNode.default;
													}
												} else {
													break;
												}
											}
										}
									}
									break;
								case "attr":
									{
										var nextDynamic = void 0;
										var fastRenderProp = void 0;
										var dynLength = dynamicNodes.length;
										for (var _k = inte + 1; _k < dynLength; _k++) {
											var locDyn = dynamicNodes[_k];
											if (locDyn.type !== "registerYield" && locDyn.type !== "componentDynamic" && locDyn.type !== "insertYield" && locDyn.type !== "component") {
												break;
											} else {
												if (dynamicNodes[_k].type === "componentDynamic" || dynamicNodes[_k].type === "insertYield" || dynamicNodes[_k].type === "component") {
													if (dynamicNodes[_k].position.toString() == dynamicNodes[inte].position.toString()) {
														if (dynamicNodes[_k].type == "componentDynamic") {
															if (_LyteComponent.registeredComponents[dynamicNodes[_k].componentName]) {
																nextDynamic = dynamicNodes[_k];
																break;
															}
														} else {
															nextDynamic = dynamicNodes[_k];
															break;
														}
													}
												}
											}
										}
										var setAttr = void 0;
										if (nextDynamic) {
											setAttr = nextDynamic.type !== "component";
											fastRenderIndex = _LC.fRC++;
											fastRenderProp = _LC.fRP[fastRenderIndex] = { "data": {} };
										}
										if (!nextDynamic || nextDynamic.type !== "component") {
											str = str.substring(0, str.length - 11);
										}
										var attr = dynNode.attr;
										var actionObj = {};
										for (var key in attr) {
											if (attr[key].dynamicValue) {
												// let nodeValue = this.get(attr[key].dynamicValue);
												var _nodeValue = attr[key].newDynamicValue ? _LC.getDD(compData, attr[key].newDynamicValue) : this.get(attr[key].dynamicValue);

												if (fastRenderProp) {
													fastRenderProp.data[attr[key].camelCase] = _nodeValue;
													if (typeof _nodeValue == "string" && setAttr) {
														_nodeValue = this.formatValue(key, _nodeValue);
														str = str + _nodeValue + " ";
													}
												} else {
													_nodeValue = this.formatValue(key, _nodeValue);
													str = str + _nodeValue + " ";
												}
											} else if (attr[key].helperInfo) {
												if (attr[key].helperInfo.name === "action") {
													var actionName = attr[key].helperInfo.args[0];
													var boundName = void 0;
													if (actionName.startsWith('"') || actionName.startsWith("'")) {
														boundName = actionName.substring(1, actionName.length - 1);
													} else {
														_Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
														boundName = actionName;
													}
													var actArgs = this.processArgs(this, attr[key], [], "__lyteEvent__", "__lyteNode__");
													var actualAttrName = attr[key].globalEvent ? attr[key].name : attr[key].name.indexOf("-") !== -1 ? attr[key].name : attr[key].name.substr(2);
													actionObj[actualAttrName] = { "name": boundName, "args": attr[key].helperInfo.args, "actArgs": actArgs, "globalEvent": attr[key].globalEvent ? true : false, "skipArgProcessing": true };
												} else if (attr[key].helperInfo.name === "method") {
													var methodsObj = compPreDef ? compPreDef.methods : this._methods;
													if (fastRenderProp) {
														var methodFunc;

														(function () {
															var methods = fastRenderProp.methods = fastRenderProp.methods || {};
															var parentComp = compPreDef ? compPreDef.component : _this6.component;
															var actArgs = _this6.processArgs(_this6, attr[key], [], "__lyteEvent__", "__lyteNode__");

															methodFunc = function methodFunc() {
																//eslint-disable-line no-loop-func
																var node = this.$node;
																var args = actArgs.slice(1);
																var functionName = actArgs[0];
																var customArgs = Array.from(arguments);
																var mainArgs = args.concat(customArgs);
																return parentComp.$node._methods[functionName].apply(parentComp, mainArgs);
															};

															methods[attr[key].camelCase] = methodFunc;
														})();
													}
												} else {
													var _nodeValue2 = this.processHelper({ name: attr[key].helperInfo.name, args: this.processArgs(this, attr[key], [], undefined, undefined, true) }, undefined);
													if (fastRenderProp) {
														fastRenderProp.data[attr[key].camelCase] = _nodeValue2;
														if (typeof _nodeValue2 == "string" && setAttr) {
															_nodeValue2 = this.formatValue(key, _nodeValue2);
															str = str + _nodeValue2 + " ";
														}
													} else {
														_nodeValue2 = this.formatValue(key, _nodeValue2);
														str = str + _nodeValue2 + " ";
													}
												}
											}
										}
										if (Object.keys(actionObj).length) {
											var locIndex = _LC.fRC++;
											str = str + "lyteaction=" + locIndex + " ";
											_LC.fRP[locIndex] = actionObj;
											actionObj.componentName = this.component.$node.localName || "undefined";
											//str = str + "lyteaction=" + ZSEC.Encoder.encodeForHTMLAttribute(JSON.stringify(actionObj)) + " ";
										}
										if (fastRenderProp && nextDynamic.type !== "component" && nextDynamic.type !== "insertYield") {
											str = str + "_lyteprop=" + fastRenderIndex + " ";
										}
										if (!dynNode.attrHandling) {
											dynamicCompile[i + 1] = dynamicCompile[i + 1].substr(1);
											dynNode.attrHandling = true;
										}
									}
									break;
								case "insertYield":
									{
										var preDefObj = fastRenderIndex !== undefined ? _LC.fRP[fastRenderIndex] : undefined;
										if (preDefObj) {
											delete _LC.fRP[fastRenderIndex];
											// _LC.pushFrc(fastRenderIndex);
										}
										fastRenderIndex = undefined;
										var yieldObj = void 0;
										var yieldName = dynNode.yieldName || preDefObj.data.yieldName;
										if (preDefObj) {
											delete preDefObj.data.yieldName;
										}
										var yieldCallee = void 0;
										if (!compPreDef || !compPreDef.yields) {
											yieldObj = this._yields[yieldName];
											if (yieldObj) {
												yieldCallee = yieldObj._callee;
											} else {
												break;
											}
										} else {
											yieldObj = compPreDef.yields[yieldName];
											yieldCallee = compPreDef._yieldCallee;
										}
										if (yieldObj) {
											var parentScope = void 0;
											var locComp = void 0;
											if (yieldCallee instanceof HTMLElement) {
												parentScope = yieldCallee;
											} else {
												parentScope = this;
												locComp = this.component;
												this.component = yieldCallee.component;
											}
											var contextSwitch = {};
											var contextSwitchArray = [];
											if (yieldObj._cx) {
												_LC.adCx(yieldObj, contextSwitchArray);
											}
											if (preDefObj) {
												for (var key in preDefObj.data) {
													contextSwitch[key] = parentScope.component.data[key];
													parentScope.component.data[key] = preDefObj.data[key];
												}
											}
											var componentScope = parentScope.component;
											if (prevComp && prevComp.$node == yieldCallee) {
												componentScope = prevComp;
											}
											// if(componentScope == this.component) {
											//     componentScope = prevComp;
											// }
											str = str + parentScope.renderFast(yieldObj.dynamicNodes || yieldObj._dynamicNodes, yieldObj._sta, componentScope, yieldCallee);
											for (var _key16 in contextSwitch) {
												parentScope.component.data[_key16] = contextSwitch[_key16];
											}
											if (yieldObj._cx) {
												_LC.rmCx(yieldObj, contextSwitchArray);
											}
											if (locComp) {
												parentScope.component = locComp;
											}
										}
										//str = str + this.renderComponent(dynNode, preDefObj, compData);
									}
									break;
								case "component":
									{
										if (fastRenderIndex !== undefined) {
											var _preDefObj = _LC.fRP[fastRenderIndex];
											var componentName = _preDefObj.data.componentName;
											if (componentName) {
												if (_LyteComponent.registeredComponents[componentName]) {
													str = str + "<" + componentName + " _lyteprop=" + fastRenderIndex + ">";
													fastRenderIndex = undefined;
													str = str + this.renderComponent({ "componentName": componentName }, _preDefObj, compData);
													str = str + "</" + componentName + ">";
												} else {
													str = str + "component not registered";
													// Handle case where component has not been registered yet. 
												}
											}
										}
									}
									break;
								case "componentDynamic":
									{
										var _preDefObj2 = fastRenderIndex !== undefined ? _LC.fRP[fastRenderIndex] : {};
										fastRenderIndex = undefined;
										str = str + this.renderComponent(dynNode, _preDefObj2, compData);
									}
									break;
								case "registerYield":
									{
										var _preDefObj3 = void 0;
										if (fastRenderIndex !== undefined) {
											_preDefObj3 = _LC.fRP[fastRenderIndex];
										} else {
											fastRenderIndex = _LC.fRC++;
											_preDefObj3 = _LC.fRP[fastRenderIndex] = {};
										}
										_preDefObj3.yields = _preDefObj3.yields || {};
										_preDefObj3.yields[dynNode._args["yield-name"]] = dynNode;
										if (!_preDefObj3._yieldCallee) {
											_preDefObj3._yieldCallee = compPreDef ? compPreDef : { "component": this.component };
										}
									}
							}
						} else {
							str = str + dynamicCompile[i];
						}
					} else {
						str = str + dynamicCompile[i];
					}
				}
				if (comp) {
					this.component = prevComp;
				}
				return str;
			}
		}, {
			key: 'formatValue',
			value: function formatValue(key, nodeValue) {
				var type = typeof nodeValue === 'undefined' ? 'undefined' : _typeof(nodeValue);
				if (nodeValue === "") {
					type = "undefined";
				}
				var retVal = void 0;
				var isSpecialAttr = key == "src" || key == "href";
				switch (type) {
					case "boolean":
						return nodeValue ? key : "";
					case "object":
						retVal = typeof Record != "undefined" && nodeValue instanceof Record ? JSON.stringify(nodeValue.$.toJSON()) : JSON.stringify(nodeValue);
						// return key + "=" + (isSpecialAttr ? retVal : ZSEC.Encoder.encodeForHTMLAttribute(retVal));
						return key + "=\"" + (isSpecialAttr ? retVal : Lyte.Security.escape(retVal)) + "\"";
					case "undefined":
						return key;
					default:
						{
							// return key + "=" + (isSpecialAttr ? nodeValue : ZSEC.Encoder.encodeForHTMLAttribute(nodeValue) );
							return key + "=\"" + (isSpecialAttr ? nodeValue : Lyte.Security.escape(nodeValue)) + "\"";
						}
				}
			}

			//RN
			//ssroverrides

		}, {
			key: 'renderNodes',
			value: function renderNodes(toAppend, dynamicNodes, helperNode, options, establishBindings, returnVal, templateContent) {
				options = options || {};
				var content = void 0;
				var constr = this.constructor;
				/*if(_Lyte._ie){
        let newFrag = toAppend.cloneNode(true, "lyte");
        this.constructor.splitTextNodes(newFrag);
        content = newFrag;
    }
    else{
        content = toAppend.cloneNode(true, "lyte");
    }*/
				var templateDepthHandlingNeeded = false;
				if (_Lyte._ms || !toAppend) {
					templateDepthHandlingNeeded = true;
					content = _LC.getContentForIE(templateContent, constr);
				} else if (toAppend.hasAttribute("depth")) {
					templateDepthHandlingNeeded = true;
					content = _LC.getContentForIE(toAppend, constr);
				} else {
					content = toAppend.content.cloneNode(true, "lyte");
				}
				var updateHelpers = [],
				    processLast = [],
				    helperFunc = void 0,
				    stoppedNode = void 0;

				//to get bindings in ssr components

				// componentDynamic = "1" , text ="2" , attr = "3" , for = "4" , forIn = "5", component = "6" , if = "7" , switch = "8" , registeryield = "9" , insertyield = "10" , action = "A1" , method = "M2", forContent = "4C"
				var toBeInsMap = new Map();
				for (var _i8 = 0; _i8 < dynamicNodes.length; _i8++) {
					var info = dynamicNodes[_i8],
					    type = info.type,
					    pos = info.position,
					    dynamicN = content,
					    helperInfo = void 0;
					dynamicN = getDynamicNode(dynamicN, pos);
					if (!dynamicNodes._cache) {
						dynamicNodes._cache = {};
					}
					if (type === "componentDynamic") {
						if (options.node) {
							dynamicN._cx = options;
						} else if (helperNode) {
							dynamicN._cx = helperNode._cx;
						}

						//to bind componentDynamic in ssr components
					} else if (type === "text") {
						this.bindNode(dynamicN, undefined, helperNode, options, dynamicNodes[_i8], processLast, establishBindings, undefined, dynamicNodes._cache, type, undefined, toBeInsMap);
					} else if (type === "attr") {
						dynamicN._attributeDetails = info.attr;
						if (dynamicN.nodeName === "LYTE-YIELD") {
							dynamicN._callee = this;
							dynamicN.component = {};
							dynamicN.component.data = {};
							defProp(dynamicN.component.data, "__component__", {
								value: dynamicN,
								configurable: true,
								writable: true,
								enumerable: false
							});
							dynamicN._properties = {};
							for (var j = 0; j < dynamicN.attributes.length; j++) {
								var attr = dynamicN.attributes[j];
								if (attr.nodeName !== "is" && attr.nodeName !== "yield-name") {
									dynamicN._properties[_LC.String.toCamelCase(attr.nodeName)] = {};
								}
							}
						}
						var toBeRemoved = [];
						for (var _key17 in info.attr) {
							var _attr2 = info.attr[_key17];
							_attr2._depthTemp = info._depthTemp;
							var attrName = _key17;
							if (_attr2 && (_attr2.dynamicValue || _attr2.helperInfo)) {
								if (options.node) {
									dynamicN._cx = options;
								} else if (helperNode) {
									dynamicN._cx = helperNode._cx;
								}
								var actionName = void 0,
								    boundName = void 0;
								if (_attr2.helperInfo && _attr2.helperInfo.name === "action") {
									dynamicN._boundEvents = dynamicN._boundEvents || {};
									actionName = _attr2.helperInfo.args[0];
									if (actionName.startsWith('"') || actionName.startsWith("'")) {
										boundName = actionName.substring(1, actionName.length - 1);
									} else {
										// _Lyte.warn("Deprecation warning. Action name " + actionName + " must be in quotes");
										boundName = actionName;
									}
									var actualAttrName = _attr2.globalEvent ? attrName : attrName.indexOf("-") !== -1 ? attrName : attrName.substr(2);
									dynamicN._boundEvents[actualAttrName] = { "name": boundName, "args": _attr2.helperInfo.args };

									//to bind actions in ssr components
									var id = void 0;
									// if( dynamicN.hasAttribute( "bindId" ) ){
									//    id = dynamicN.getAttribute( "bindId" );
									// }else{
									//    id = type + Math.floor( Math.random() * 1000 );
									//    dynamicN.setAttribute( "bindId", id );
									// }
									id = "A1_" + Math.floor(Math.random() * 1000);
								}
								if (!_attr2.globalEvent) {
									/*this.bindNode(dynamicN.getAttributeNode(attrName), toBeRemoved, helperNode, options, attr, undefined, establishBindings);
          */
									if (!dynamicN.hasAttribute(attrName)) {
										dynamicN.setAttribute(attrName, "{{dummy}}");
									}
									var node = this.bindNode(dynamicN.attributes.getNamedItem(attrName), toBeRemoved, helperNode, options, _attr2, undefined, establishBindings, undefined, dynamicNodes._cache, type, _i8);
									if (node !== dynamicN.attributes.getNamedItem(attrName)) {
										dynamicN._removedAttributes = dynamicN._removedAttributes || {};
										dynamicN._removedAttributes[attrName] = node;
									}
								}
							}
						}
						//Added now
						if (info.attr && Object.keys(info.attr).length) {
							dynamicN._callee = this;
						}
						for (var d = 0; d < toBeRemoved.length; d++) {
							dynamicN.removeAttribute(toBeRemoved[d]);
						}
					} else if (/^(for|forIn|component)$/.test(type)) {
						if (options.node) {
							dynamicN._cx = options;
						} else if (helperNode) {
							dynamicN._cx = helperNode._cx;
						}
						dynamicN._dynamicNodes = info.dynamicNodes;
						if (_Lyte._ms) {
							dynamicN._tC = info.templateContent;
						}
						if (info.actualTemplate) {
							dynamicN._tC = info.actualTemplate;
						}
						var _returnVal = void 0;
						switch (type) {
							case "for":
								dynamicN._ht = info._ht;
								_returnVal = this.updateForHelper(dynamicN, { "type": "default" }, options.node ? options : undefined, establishBindings, info._sta);
								break;
							case "forIn":
								dynamicN._ht = info._ht;
								_returnVal = this.updateForInHelper(dynamicN, { "type": "default" }, options.node ? options : undefined, establishBindings);
								break;
							case "component":
								_returnVal = this.updateDynamicComponent(dynamicN, false, options.node ? options : undefined, establishBindings, _i8, helperNode);
						}
						if (_returnVal) {
							updateHelpers.push(_returnVal);
						}
					} else if (/^(if|switch)$/.test(type)) {
						var def = "default";
						dynamicN._cases = info.cases;
						dynamicN._default = info[def];
						dynamicN._ht = info._ht;
						if (options.node) {
							dynamicN._cx = options;
						} else if (helperNode) {
							dynamicN._cx = helperNode._cx;
						}
						if (info.actualTemplate) {
							dynamicN._tC = info.actualTemplate;
							if (!dynamicN._origTemplate) {
								if (_Lyte._ie) {
									dynamicN._origTemplate = createElement("template");
								} else {
									dynamicN._origTemplate = info._depthTemp.cloneNode(true);
								}
								if (dynamicN.hasAttribute("value")) {
									dynamicN._origTemplate.setAttribute("value", dynamicN.getAttribute("value"));
								}
							}
						}

						//to bind if/switch in ssr components
						var _id = void 0;

						var _returnVal2 = this.updateSwitchHelper(type, dynamicN, options.node ? options : undefined, undefined, establishBindings, _id, toBeInsMap);
						if (_returnVal2) {
							updateHelpers.push(_returnVal2);
							var isBreak = _returnVal2.toAppendMain.querySelector("template[is=break]");
							if (isBreak) {
								dynamicN._isStopped = "break";
								content = Lyte.Compile.getTrimmedContent(content, info.position, undefined);
								stoppedNode = info.position;
								break;
							}
							var isContinue = _returnVal2.toAppendMain.querySelector("template[is=continue]");
							if (isContinue) {
								dynamicN._isStopped = "continue";
								content = Lyte.Compile.getTrimmedContent(content, info.position, undefined);
								//                		stoppedNode = info.position;
								break;
							}
						}
					} else if (type === "registerYield") {
						if (options.node) {
							dynamicN._cx = options;
						} else if (helperNode) {
							dynamicN._cx = helperNode._cx;
						}

						dynamicN._dynamicNodes = info.dynamicNodes;
						dynamicN._sta = info._sta;
						dynamicN._ht = info._ht;
						if (_Lyte._ms) {
							dynamicN._tC = info.templateContent;
						}
						//                updateHelpers.push(dynamicN);
						//Added now                
						dynamicN._callee = this;
					} else if (type === "insertYield") {
						if (options.node) {
							dynamicN._cx = options;
						} else if (helperNode) {
							dynamicN._cx = helperNode._cx;
						}
						dynamicN.component = dynamicN.component || { "data": {} };
						dynamicN._properties = dynamicN._properties || {};
						//to bind insertYield in ssr components

						dynamicN.component = dynamicN.component || { "data": {} };
						dynamicN._properties = dynamicN._properties || {};
						for (var x = 0; x < dynamicN.attributes.length; x++) {
							var attrObj = dynamicN.attributes[x];
							var _attrName = attrObj.name;
							var attrValue = attrObj.value;
							if (_attrName !== "yield-name") {
								if (dynamicN._properties && !dynamicN._properties[_attrName]) {
									dynamicN._properties[_attrName] = {};
								}
								if (dynamicN._attributeDetails && !dynamicN._attributeDetails[_attrName]) {
									dynamicN.component.data[_attrName] = attrValue;
								}
							}
						}
						this.updateYield(dynamicN, false, options.node ? options : undefined);
					}
				}
				dynamicNodes._cache = undefined;
				for (var _i9 = 0; _i9 < processLast.length; _i9++) {
					var dynamicPosition = processLast[_i9].dynamicPositions;
					var processNode = dynamicPosition.initialNode;
					var _nodeValue3 = dynamicPosition.dynamicNodeValue;
					var childLen = _nodeValue3.childNodes.length;
					if (!childLen) {
						_nodeValue3.appendChild(document.createTextNode(""));
						childLen = 1;
					}
					var startingNode = _nodeValue3.childNodes[0];
					if (_Lyte._rwpf && processNode.parentNode.nodeName === "#document-fragment") {
						while (_nodeValue3.childNodes.length) {
							_insertBefore(processNode.parentNode, _nodeValue3.childNodes[0], processNode);
						}
						processNode.remove();
					} else {
						processNode.replaceWith.apply(processNode, _nodeValue3.childNodes);
					}
					processLast[_i9].dynamicPositions = { startingNode: startingNode, length: childLen };
				}
				if (toBeInsMap.size) {
					toBeInsMap.forEach(function (val, key) {
						val.pN.insertBefore(key, val.cN);
						if (val.cN.nextSibling) {
							val.pN.insertBefore(document.createElement("textend"), val.cN.nextSibling);
						} else {
							val.pN.appendChild(document.createElement("textend"));
						}
					});
				}
				if (stoppedNode) {
					returnVal = returnVal || {};
					returnVal.stop = true;
				}
				if (helperNode) {
					if (options.type) {
						helperNode._helpers[options.itemIndex] = updateHelpers;
						if (templateDepthHandlingNeeded) {
							content = constr.createDocFragment1(content);
						}
						return content;
					} else {
						helperNode._helpers = helperNode._helpers || [];
						helperNode._helpers.push.apply(helperNode._helpers, updateHelpers);
						if (templateDepthHandlingNeeded) {
							content = constr.createDocFragment1(content);
						}
						return content;
					}
				}
				this.executeBlockHelpers(updateHelpers);
				if (templateDepthHandlingNeeded) {
					content = constr.createDocFragment1(content);
				}
				return content;
			}
		}, {
			key: 'executeBlockHelpers',
			value: function executeBlockHelpers(updateHelpers, node) {
				for (var _i10 = 0; _i10 < updateHelpers.length; _i10++) {
					var lastNode = updateHelpers[_i10].lastNode;
					var parentNode = lastNode.parentNode;

					if (lastNode._placeHolder) {
						lastNode = lastNode._placeHolder;
						parentNode = lastNode.parentNode;
					}
					//parentNode = updateHelpers[i].lastNode.parentNode || updateHelpers[i].lastNode._placeHolder.parentNode;
					_insertBefore(parentNode, updateHelpers[_i10].toAppendMain, lastNode);
					updateHelpers[_i10] = updateHelpers[_i10].lastNode;
					// updateHelpers[i].lastNode.parentNode.insertBefore(updateHelpers[i].toAppendMain, updateHelpers[i].lastNode);
					// updateHelpers[i] = updateHelpers[i].lastNode;
					//updateHelpers[i]._parentIf = node;
					//	    		if(!updateHelpers[i]._cx && node) {
					//	    			updateHelpers[i]._cx = node._cx;
					//	    		}
				}
			}
		}, {
			key: 'updateBlockHelpers',
			value: function updateBlockHelpers(updateHelpers, contextSwitchInfo) {
				for (var _i11 = 0; _i11 < updateHelpers.length; _i11++) {
					switch (updateHelpers[_i11].getAttribute('is')) {
						case "for":
							this.updateForHelper(updateHelpers[_i11], { "type": "default" }, contextSwitchInfo);
							break;
						case "if":
							this.updateSwitchHelper("if", updateHelpers[_i11], contextSwitchInfo);
							break;
						case "forIn":
							this.updateForInHelper(updateHelpers[_i11], { "type": "default" }, contextSwitchInfo);
							break;
						case "switch":
							this.updateSwitchHelper("switch", updateHelpers[_i11], contextSwitchInfo);
							break;
						case "component":
							this.updateDynamicComponent(updateHelpers[_i11], false, contextSwitchInfo);
							break;
						case "insertYield":
							//              this.updateYield(updateHelpers[i], false, contextSwitchInfo);
							break;
						case "yield":
						case "registerYield":
							if (contextSwitchInfo) {
								updateHelpers[_i11]._cx = contextSwitchInfo;
							}
							break;
						default:
							if (updateHelpers[_i11].tagName === "LYTE-YIELD") {
								this.updateYield(updateHelpers[_i11], false, contextSwitchInfo);
							}

					}
				}
			}
			//AttributeChangedCallback will be called for the attributes mentioned in the this._observedAttributes array. 

		}, {
			key: 'attributeChangedCallback',


			//Callback from browser, whenever any of the observed attribute changes. 
			//We call the component set, in order to affect the related changes. 
			value: function attributeChangedCallback(attr, oldValue, newValue) {
				var constr = this.constructor;
				if (constr._observedMethodAttributes && constr._observedMethodAttributes[attr] || this.__lyteIgnore) {
					return;
				}
				var actualAttr = _LC.String.toCamelCase(attr);
				var isCustomProp = _LC.customPropHandlers.indexOf(actualAttr);
				if (isCustomProp !== -1) {
					var propValue = _LC.customPropHandlers[isCustomProp];
					var lyteProps = newValue;
					if (lyteProps) {
						try {
							lyteProps = JSON.parse(lyteProps);
							for (var _key18 in lyteProps) {
								var actKey = propValue + _LC.String.upperCaseFirstLetter(_key18);
								this.set(actKey, lyteProps[_key18]);
							}
						} catch (e) {
							_Lyte.error("LC001", attr);
						}
					}
					return;
				}
				if (oldValue === newValue) {
					return;
				}
				var attrNode = this.attributes.getNamedItem(attr);
				if (attrNode) {
					if (attrNode.__lyteIgnore) {
						this.attributes.getNamedItem(attr).__lyteIgnore = false;
						return;
					}
				} else if (this["__" + attr]) {
					this["__" + attr] = false;
					return;
				}
				var compInstance = this.component;
				var dataDef = compInstance.__data[actualAttr];
				if (dataDef && dataDef.type) {
					var dataType = dataDef.type;
					if (dataType !== "string") {
						var _obj3 = { "attr": attr, "tagName": this.tagName };
						newValue = _LC.typeCast(newValue, dataType, _obj3);
						if (_obj3.isError) {
							_Lyte.warn("data type of the value provided for attribute " + attr + " of " + this.tagName + " is not valid");
							return;
						}
					}
				}

				var compData = compInstance.data;
				if (compData[actualAttr] !== newValue) {
					// Null check is done because when we do a removeAttribute directly on a component, the corresponding value expected is that of undefined and not null.
					this.set(actualAttr, newValue === null ? undefined : newValue);
				} else {
					_LC.clearError(compData, actualAttr);
				}
			}

			//Used to remove helpers of specific index in a for helper. 

		}, {
			key: 'removeHelpersSpecificIndex',
			value: function removeHelpersSpecificIndex(node, index) {
				if (node._helpers[index]) {
					for (var j = 0; j < node._helpers[index].length; j++) {
						this.removeHelpers(node._helpers[index][j]);
					}
				}
				if (node._forContent[index]) {
					for (var _i12 = 0; _i12 < node._forContent[index].length; _i12++) {
						node._forContent[index][_i12].remove();
					}
					var self = this;
					Object.keys(node._items[index]._dynamicProperty).forEach(function (key) {
						node._dynProps[key]--;
						if (!node._dynProps[key]) {
							var prop = self.getProperty(key);
							if (prop._helperNodes) {
								prop._helperNodes[delStr](node);
							}
						}
					});
					node._items[index] = { "_dynamicProperty": {}, "itemProperty": {}, "indexProperty": {} };
				}
			}
			//Used to remove all the helpers within an helper. 

		}, {
			key: 'removeHelpers',
			value: function removeHelpers(node, update, direct) {
				if (!direct) {
					node.remove();
					var helpersObj = node.getAttribute("is") === "component" ? this.__dc : this.__h;
					var nodeId = node.__lyteId;
					delete helpersObj[nodeId];
				}

				var del = "delete";
				var parent = void 0;
				var contextSwitchArray = [];
				_LC.adCx(node, contextSwitchArray);
				if (node._forContent) {
					if (node.getAttribute("is") === "for") {
						if (node._helpers) {
							for (var _i13 = 0; _i13 < node._helpers.length; _i13++) {
								for (var j = 0; j < node._helpers[_i13].length; j++) {
									this.removeHelpers(node._helpers[_i13][j]);
								}
								node._helpers[_i13] = [];
							}
						}
						for (var _s = 0; _s < node._forContent.length; _s++) {
							for (var _i14 = 0; _i14 < node._forContent[_s].length; _i14++) {
								node._forContent[_s][_i14].remove();
							}
						}
						var _key19 = node.getAttribute("item");
						if (node._items.length) {
							var prop = node._items[0].itemProperty;
							for (var _i15 = 0; _i15 < node._items.length; _i15++) {
								var dynProp = node._items[_i15]._dynamicProperty;
								for (var dP in dynProp) {
									var property = this.getProperty(dP);
									if (property._helperNodes) {
										property._helperNodes[del](node);
									}
								}
							}
							if (prop) {
								for (var _i16 = 0; _i16 < node._items.length; _i16++) {
									this.removeBindings(_defineProperty({}, _key19, node._items[_i16].itemProperty), _defineProperty({}, _key19, node._attributes.items[_i16]));
								}
							}
						}
						if (!update) {
							if (node._actualBinding) {
								if (node._attributes.items && node._attributes.items._bindings && node._actualBinding._createdBinding) {
									node._attributes.items._bindings[del](node._actualBinding);
								}
								if (node._actualBinding._forHelpers) {
									node._actualBinding._forHelpers[del](node);
								}
								var multiplePrpty = node._removedAttributes.items._multipleProperty;
								if (node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
									multiplePrpty[0].actProp._forHelpers[del](node);
								}
							}
						}
						node._items = [];
					} else {
						if (node._helpers) {
							var keys = Object.keys(node._helpers);
							for (var _i17 = 0; _i17 < keys.length; _i17++) {
								for (var _j = 0; _j < node._helpers[keys[_i17]].length; _j++) {
									this.removeHelpers(node._helpers[keys[_i17]][_j]);
								}
								node._helpers[keys[_i17]] = [];
							}
						}
						for (var ind in node._forContent) {
							for (var _i18 = 0; _i18 < node._forContent[ind].length; _i18++) {
								node._forContent[ind][_i18].remove();
							}
						}
						var items = node._items;
						var _key20 = node.getAttribute("key");
						for (var index in items) {
							var item = items[index];
							var _prop = item.itemProperty;
							var dynamicProp = item._dynamicProperty;
							for (var _dP in dynamicProp) {
								var _property = this.getProperty(_dP);
								if (_property._helperNodes) {
									_property._helperNodes[del](node);
								}
							}
							if (_prop) {
								this.removeBindings(_defineProperty({}, _key20, node._items[index].itemProperty), _defineProperty({}, _key20, node._attributes.object[index]));
							}
						}
						if (!update) {
							if (node._actualBinding) {
								if (node._attributes.object && node._attributes.object._bindings && node._actualBinding._createdBinding) {
									node._attributes.object._bindings[del](node._actualBinding);
								}
								if (node._actualBinding._forHelpers) {
									node._actualBinding._forHelpers[del](node);
								}
							}
							var multiplePrpty = node._removedAttributes.object._multipleProperty;
							if (node._removedAttributes.object && !node._removedAttributes.object.helperValue && multiplePrpty && multiplePrpty[0].actProp._forHelpers) {
								multiplePrpty[0].actProp._forHelpers[del](node);
							}
							if (node._propBindingObject && node._attributes.object && node._attributes.object._bindings) {
								node._attributes.object._bindings[del](node._propBindingObject);
							}
						}
						node._items = {};
					}
				} else if (node._caseContent || node._yieldContent) {
					if (node._helpers) {
						for (var _j2 = 0; _j2 < node._helpers.length; _j2++) {
							this.removeHelpers(node._helpers[_j2]);
						}
						node._helpers = [];
					}
					if (node._caseContent) {
						for (var _i19 = 0; _i19 < node._caseContent.length; _i19++) {
							node._caseContent[_i19].remove();
						}
						for (var _key21 in node._dynamicProperty) {
							if (node._dynamicProperty[_key21].isActualNode) {
								node._dynamicProperty[_key21].isActualNode._helperNodes[del](node);
							} else {
								var helperNodes = this.getProperty(_key21)._helperNodes;
								if (helperNodes) {
									helperNodes[del](node);
								}
							}
						}
						node._dynamicProperty = {};
						//node._parentIf = null;
					} else {
						for (var _i20 = 0; _i20 < node._yieldContent.length; _i20++) {
							node._yieldContent[_i20].remove();
						}
						node._dynamicProperty = {};
					}
					var pve = _LC.pendingViewPortElements;
					if (node._inPve && pve.length) {
						var _ind = pve.indexOf(_LC.getFakeTemplate(node));
						if (_ind != -1) {
							pve.splice(_ind, 1);
						}
					}
				} else if (node._renderedComponent) {
					for (var _key22 in node._renderedComponent) {
						if (node._renderedComponent[_key22]) {
							node._renderedComponent[_key22].remove();
							node._renderedComponent[_key22] = null;
						}
					}
				}
				_LC.rmCx(node, contextSwitchArray);
			}
		}, {
			key: 'updateYield',
			value: function updateYield(node, update, contextSwitchInfo) {
				var constr = this.constructor;
				if (!node._callee) {
					node._callee = this;
				}
				var toAppend = node._callee._yields[node.getAttribute("yield-name")];
				if (!toAppend) {
					return;
				}
				node._registerYield = toAppend;
				//ADded now
				var parentScope = toAppend._callee || node._callee._callee;
				if (!parentScope) {
					if (_Lyte._ms) {
						var div = createElement("div");
						div.innerHTML = toAppend.outerHTML;
						if (_Lyte._ie) {
							div.firstChild.innerHTML = toAppend.innerHTML;
						}
						var content1 = div.childNodes[0];
						constr.splitTextNodes(content1);
						content1 = constr.createDocFragment1(content1);
						node.appendChild(content1);
					} else {
						node.appendChild(toAppend.content.cloneNode(true, "lyte"));
					}

					node._helpers = [];
					return;
				}
				if (!toAppend._callee) {
					toAppend._callee = parentScope;
				}
				node._dynamicProperty = node._dynamicProperty || {};
				//set values from child component. 
				var obj = {},
				    contextSwitchingArray = {},
				    self = this,
				    contextSwitchArray = [];
				_LC.adCx(toAppend, contextSwitchArray);
				Object.keys(node._properties).forEach(function (key) {
					contextSwitchingArray[key] = {};
					contextSwitchingArray[key].value = parentScope.component.data[key];
					contextSwitchingArray[key].property = parentScope._properties[key];
					parentScope._properties[key] = node._properties[key];
					parentScope.component.data[key] = node.component.data[key];
				});
				// htA -> helpertemplateApplied
				if (!_Lyte._ms && toAppend._ht && !toAppend._htA) {
					toAppend._htA = true;
					toAppend.content.append(toAppend._ht.content.cloneNode(true));
				}
				var content = parentScope.renderNodes(toAppend, toAppend._dynamicNodes || [], node, { "node": node }, true, undefined, toAppend._tC);
				if (!node.component.data.lyteUnbound) {
					_LC.establishBindings(node._properties, node.component.data);
				}
				parentScope.executeBlockHelpers(node._helpers);
				Object.keys(node._properties).forEach(function (key) {
					parentScope.component.data[key] = contextSwitchingArray[key].value;
					parentScope._properties[key] = contextSwitchingArray[key].property;
				});
				_LC.rmCx(toAppend, contextSwitchArray);
				node.appendChild(content);
			}

			// It constructs/updates the dynamicComponent creation
			//upddc

		}, {
			key: 'updateDynamicComponent',
			value: function updateDynamicComponent(node, update, contextSwitchInfo, establishBindings, idx, helperNode) {
				var returnVal = void 0;
				node._callee = this;
				var keepAlive = node.hasAttribute("lyte-keep-alive");
				if (!node._renderedComponent) {
					node._renderedComponent = {};
					var id = _LC.createLyteId(this);
					this.__dc[id] = node;
					node.__lyteId = id;
				}

				node._cx = contextSwitchInfo || node._cx;
				node._dynamicProperty = node._dynamicProperty || {};
				var componentName = node.getAttribute("component-name") || (node._attributes ? node._attributes["component-name"] : undefined);
				if (!componentName) {
					return;
				}
				var component = void 0,
				    newComponent = false;
				if (update) {
					if (keepAlive) {
						_LC.ignoreDisconnect = true;
					}
					if (node._renderedComponent[node._currentComponent]) {
						var activeComponent = node._renderedComponent[node._currentComponent];
						keepAlive ? _LC.hDiv.content.appendChild(activeComponent) : activeComponent.remove();
					}
					_LC.ignoreDisconnect = false;
					if (!keepAlive) {
						node._dynamicProperty = {};
					}
					if (node._renderedComponent[componentName] && keepAlive) {
						component = node._renderedComponent[componentName];
					} else {
						component = createElement(componentName);
						newComponent = true;
					}
				} else {
					component = createElement(componentName);
					newComponent = true;
				}
				if (!keepAlive && node._currentComponent) {
					node._renderedComponent[node._currentComponent] = null;
				}
				if (newComponent) {
					//          let componentData = {};
					for (var _i21 = 0; _i21 < node.attributes.length; _i21++) {
						if (node.attributes[_i21].name !== "is" && node.attributes[_i21].name !== "component-name" && node.attributes[_i21].name !== "lyte-keep-alive") {
							component.setAttribute(node.attributes[_i21].name, node.attributes[_i21].value);
						}
					}
					//          componentData = component._attributes;
					if (node._attributes) {
						for (var key in node._attributes) {
							if (key !== "component-name") {
								component.setData(_LC.String.toCamelCase(key), node._attributes[key]);
							}
						}
					}
					var toAppend = this.renderNodes(node, node._dynamicNodes, node, undefined, establishBindings, undefined, node._tC);
					component.appendChild(toAppend);
				}
				if (newComponent) {
					component._toRegEvnts = node._toRegEvnts;
				}
				if (!update) {
					returnVal = { "toAppendMain": component, "lastNode": node };
				} else {
					_LC.ignoreDisconnect = true;
					_insertBefore(node.parentNode, component, node);
					_LC.ignoreDisconnect = false;
				}
				node._renderedComponent[componentName] = component;
				node._currentComponent = componentName;
				component._callee = this;

				component._actions = node._actions;
				component.setMethods(node._initMethods);
				component._attributeDetails = node._attributeDetails;
				component._boundEvents = node._boundEvents;
				component._cx = node._cx;
				return returnVal;
			}
			//updFH
			// It constructs/updates the for helper. 

		}, {
			key: 'updateForHelper',
			value: function updateForHelper(node, options, contextSwitchInfo, establishBindings, staticTempArr) {
				if (node.tagName !== "TEMPLATE") {
					Object.keys(node).forEach(function (item) {
						if (item !== "innerHTML" && item !== "innerText") {
							node._origTemplate[item] = node[item];
						}
					});
					if (_Lyte._ie) {
						var div = createElement("div");
						div.innerHTML = node._tC;
						node._origTemplate.innerHTML = div.children[0].innerHTML;
						this.constructor.splitTextNodes(node._origTemplate);
						if (node.hasAttribute("depth")) {
							node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
						}
					}
					var placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
					node._origTemplate.setAttribute("item", node.getAttribute("item"));
					node._origTemplate.setAttribute("index", node.getAttribute("index"));

					if (node.hasAttribute("unbound")) {
						//What if unbound is dynamic attribute ? It will be set in _attributes of node._origTemplate -> So No worries (y)
						node._origTemplate.setAttribute("unbound", "true");
					}
					//node.replaceWith(node._origTemplate._placeHolder);
					_LC.replaceWithPf(node, node._origTemplate._placeHolder);
					node = _LC.replaceWithOrigTemplate(node);
					// node = node._origTemplate;
					node.setAttribute("is", "for");
					_LC.apdNode(node, this);
					placeHolder._helper = node;
				}
				// datasumma
				else if (!node._placeHolder) {
						// var emptyTextNode = document.createTextNode("");
						//node.replaceWith(emptyTextNode);
						//to bind in ssr
						var emptyTextNode, tnode;

						emptyTextNode = document.createTextNode("");

						_LC.replaceWithPf(node, emptyTextNode);
						node._placeHolder = emptyTextNode;
						emptyTextNode._helper = node;
						_LC.apdNode(node, this);
					}
				node._sta = node._sta || staticTempArr;
				var callee = this;
				node._callee = this;
				node._attributes = node._attributes || {};
				if (options.type === "update" && node._currentItems === node._attributes.items) {
					return {};
				}
				node._cx = contextSwitchInfo || node._cx;
				var indexValue = node.getAttribute("index");
				if (!indexValue) {
					node.setAttribute("index", "index");
					indexValue = "index";
				}
				var itemValue = node.getAttribute("item");
				if (!itemValue) {
					node.setAttribute("item", "item");
					itemValue = "item";
				}
				var initialItemValue = callee.component.data[itemValue],
				    initialIndexValue = callee.component.data[indexValue];
				var initialItemProp = callee._properties[itemValue],
				    initialIndexProp = callee._properties[indexValue];
				callee._properties[itemValue] = callee._properties[indexValue] = {};
				var items = node._attributes.items,
				    content = node.content,
				    dynamicNodes = node._dynamicNodes,
				    lastNode = node;
				if (!node._items) {
					node._items = [];
				}
				node._dynProps = node._dynProps || {};
				var lastIndexForIteration = void 0;
				var firstIndexForIteration = void 0;
				var firstIndex = options.firstIndex;
				var secondIndex = options.secondIndex;
				var thirdIndex = options.thirdIndex;
				var totalNodeIndex = firstIndex + secondIndex;
				var updateIndexProperty = true;
				var indexPropertyStartIndex = 0;
				if (options) {
					switch (options.type) {
						case "remove":
							{
								lastIndexForIteration = firstIndex;
								indexPropertyStartIndex = firstIndex;
								for (var _i22 = firstIndex, v = secondIndex; v > 0; v--, _i22++) {
									this.removeHelpersSpecificIndex(node, _i22);
								}
								//ln
								/*for(let i=(firstIndex)?firstIndex-secondIndex:firstIndex;i<node._items.length;i++) {
            let forItem = node._items[i].itemProperty;
            if(forItem._helperNodes){
                for (var item of forItem._helperNodes){
                    let ind = item._cx.itemIndex;
                    item._cx.itemIndex = (ind)? ind- secondIndex : ind;
                }
            }
        }*/
								for (var _i23 = firstIndex + secondIndex; _i23 < node._items.length; _i23++) {
									node._items[_i23]._cx.itemIndex = node._items[_i23]._cx.itemIndex - secondIndex;
								}
								node._items.splice(firstIndex, secondIndex);
								node._helpers.splice(firstIndex, secondIndex);
								node._forContent.splice(firstIndex, secondIndex);
								break;
							}
						case "insert":
							{
								firstIndexForIteration = firstIndex;
								lastIndexForIteration = secondIndex;
								indexPropertyStartIndex = firstIndex + secondIndex;
								if (node._forContent[firstIndex]) {
									lastNode = node._forContent[firstIndex][0];
								}
								var newArr = [],
								    newObj = [],
								    newArr1 = [];
								for (var _v = secondIndex, _k2 = firstIndex; _v > 0; _v--, _k2++) {
									newArr.push([]);
									newObj.push({});
									newArr1.push([]);
								}
								node._helpers.splice.apply(node._helpers, [firstIndex, 0].concat(newArr));
								node._items.splice.apply(node._items, [firstIndex, 0].concat(newObj));
								//ln
								//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
								//                      let forItem = node._items[i].itemProperty;
								//                      for (var item of forItem._helperNodes){
								//                          item._cx.itemIndex = item._cx.itemIndex + secondIndex;
								//                      }
								//                  }
								for (var _i24 = firstIndex + secondIndex; _i24 < node._items.length; _i24++) {
									node._items[_i24]._cx.itemIndex = node._items[_i24]._cx.itemIndex + secondIndex;
								}
								node._forContent.splice.apply(node._forContent, [firstIndex, 0].concat(newArr1));
							}
							break;
						case "replace":
							{
								firstIndexForIteration = firstIndex;
								lastIndexForIteration = secondIndex;
								indexPropertyStartIndex = firstIndex + secondIndex;
								this.removeHelpersSpecificIndex(node, firstIndex);
								var _toAppendMain = createDocFragment();
								if (node._forContent[firstIndex + 1]) {
									lastNode = node._forContent[firstIndex + 1][0];
								}
								var _newArr = [],
								    _newObj = [],
								    _newArr2 = [];
								for (var _v2 = secondIndex, _k3 = firstIndex; _v2 > 0; _v2--, _k3++) {
									_newArr.push([]);
									_newArr2.push([]);
									_newObj.push({});
								}
								node._helpers.splice.apply(node._helpers, [firstIndex, 1].concat(_newArr));
								node._items.splice.apply(node._items, [firstIndex, 1].concat(_newObj));
								//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
								//                      let forItem = node._items[i].itemProperty._forItem;
								//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
								//                  }
								for (var _i25 = firstIndex + secondIndex; _i25 < node._items.length; _i25++) {
									node._items[_i25]._cx.itemIndex = node._items[_i25]._cx.itemIndex + secondIndex - 1;
								}
								node._forContent.splice.apply(node._forContent, [firstIndex, 1].concat(_newArr2));
								if (options.secondIndex == 1) {
									updateIndexProperty = false;
								}
								break;
							}
						case "splice":
							{
								firstIndexForIteration = firstIndex;
								lastIndexForIteration = secondIndex;
								indexPropertyStartIndex = firstIndex + secondIndex;
								for (var _i26 = thirdIndex, j = 0; _i26 > 0; _i26--, j++) {
									this.removeHelpersSpecificIndex(node, firstIndex + j);
								}
								var _toAppendMain2 = createDocFragment();
								if (node._forContent[firstIndex + thirdIndex]) {
									lastNode = node._forContent[firstIndex + thirdIndex][0];
								}
								var _newArr3 = [],
								    _newObj2 = [],
								    _newArr4 = [];
								for (var _v3 = secondIndex, _k4 = firstIndex; _v3 > 0; _v3--, _k4++) {
									_newArr3.push([]);
									_newArr4.push([]);
									_newObj2.push({});
								}
								node._helpers.splice.apply(node._helpers, [firstIndex, thirdIndex].concat(_newArr3));
								node._items.splice.apply(node._items, [firstIndex, thirdIndex].concat(_newObj2));
								//                  for(let i=firstIndex + secondIndex;i<node._items.length;i++) {
								//                      let forItem = node._items[i].itemProperty._forItem;
								//                      forItem.itemIndex = forItem.itemIndex + secondIndex - 1 ;
								//                  }
								for (var _i27 = firstIndex + secondIndex; _i27 < node._items.length; _i27++) {
									node._items[_i27]._cx.itemIndex = node._items[_i27]._cx.itemIndex + secondIndex - thirdIndex;
								}
								node._forContent.splice.apply(node._forContent, [firstIndex, thirdIndex].concat(_newArr4));
								if (options.secondIndex == options.thirdIndex) {
									updateIndexProperty = false;
								}
								break;
							}
							break;
						case "update":
							{
								var _key23 = node.getAttribute("item");
								//                  this.removeHelpers(node, true);
								for (var _i28 = 0; _i28 < node._items.length; _i28++) {
									this.removeHelpersSpecificIndex(node, _i28);
								}
								//                  if(node._attributes.items) {
								//                      for(let i=0;i<node._attributes.items.length && node._items[i];i++) {
								//                          _LC.removeSelectedBindingDeep(node._items[i].itemProperty[key], node._attributes.items[i]);
								//                      }
								//                  }
								node._items = [];
							}
						case "default":
							{
								node._forContent = [];
								node._helpers = [];
								firstIndexForIteration = 0;
								lastIndexForIteration = items ? items.length : 0;
								indexPropertyStartIndex = items ? items.length : 0;
							}
							break;
						default:
							_Lyte.error("Error in updateForHelper");
					}
				}
				if (!lastNode) {
					lastNode = node;
				}
				if (lastNode != node && node._helpers.length > 0 && (options.type == "insert" || "replace" || "splice")) {
					lastNode = _LC.findLastNodeL(lastNode, totalNodeIndex, node);
				}
				var returnVal = void 0;
				var localUnbound = false;
				var initialUnbound = _LC.unbound;
				if (node.hasAttribute("unbound") || node._attributes && node._attributes.unbound && node._attributes.unbound !== "false") {
					localUnbound = true;
					_LC.unbound = true;
				}
				if (!node._fRender && (node.getAttribute("unbound") == "lyteFastRender" || node._attributes && node._attributes.unbound == "lyteFastRender")) {
					node._fRender = true;
				}
				node._currentItems = items;
				if (!_Lyte._ms && lastIndexForIteration - firstIndexForIteration > 0) {
					if (node._ht && !node._htA) {
						node.content.append(node._ht.content.cloneNode(true));
						node._htA = true;
					}
				}
				if (options.type !== "remove") {
					var totalString = "";
					var domArr = [];
					var toAppendMain = createDocFragment();
					for (var _k5 = firstIndexForIteration, _v4 = lastIndexForIteration; _v4 > 0; _k5++, _v4--) {
						node._helpers[_k5] = [];
						node._items[_k5] = { "_dynamicProperty": {}, "itemProperty": {}, "indexProperty": {} };
						callee.component.data[itemValue] = items[_k5];
						callee.component.data[indexValue] = _k5;
						var cacheData = {};
						cacheData[itemValue] = {};
						cacheData[itemValue]._data = items[_k5];
						cacheData[itemValue]._dyn = [itemValue];
						cacheData[indexValue] = {};
						cacheData[indexValue]._data = _k5;
						cacheData[indexValue]._dyn = [indexValue];
						callee._properties[itemValue] = {};
						callee._properties[indexValue] = {};
						var optns = { "itemValue": itemValue, "itemIndex": _k5, "type": "for", "node": node, "indexValue": indexValue };
						//                  defProp(callee._properties[itemValue], '_forItem', {
						//                      enumerable: false, 
						//                      writable: true, 
						//                      configurable: true, 
						//                      value : optns
						//                  });
						node._items[_k5]._cx = optns;
						var breakCheck = {};
						var toAppend = void 0;
						if (node._fRender) {
							var str = this.renderFast(dynamicNodes, node._sta, this.component);
							totalString = totalString + str;
							// var template = document.createElement("template");
							// template.innerHTML = str;
							// toAppend = template.content;
						} else {
							dynamicNodes._cache = cacheData;
							toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, breakCheck, node._tC);
						}

						//to bind in ssr components

						var dynProps = Object.keys(node._items[_k5]._dynamicProperty);
						for (var d = 0; d < dynProps.length; d++) {
							var _key24 = dynProps[d];
							node._dynProps[_key24] ? node._dynProps[_key24]++ : node._dynProps[_key24] = 1;
						}
						node._items[_k5].itemProperty = this.getProperty(itemValue);
						node._items[_k5].indexProperty = this.getProperty(indexValue);
						//                  if(options.type !== "default") {
						if (!_LC.unbound) {
							_LC.establishBindings(_defineProperty({}, itemValue, node._items[_k5].itemProperty), _defineProperty({}, itemValue, node._attributes.items[_k5]));
						}
						//                  }
						if (!node._fRender) {
							node._forContent[_k5] = Array.from(toAppend.childNodes);
						} else {
							domArr.push(node._forContent[_k5] = []);
						}
						//Needs to revisit this and make sure it happen within renderNodes function itself;
						//                  if(options.type !== "update") {
						this.executeBlockHelpers(node._helpers[_k5], node);
						if (!node._fRender) {
							toAppendMain.appendChild(toAppend);
						}
						if (breakCheck.stop) {
							break;
						}
					}
					if (node._fRender) {
						var s = document.createElement("template");
						s.innerHTML = totalString;
						toAppendMain.appendChild(s.content);
						_LC.processAction(toAppendMain);
						var childrenArr;
						if (_Lyte._ie) {
							childrenArr = [];
							var childNodes = toAppendMain.childNodes;
							for (var i = 0; i < childNodes.length; i++) {
								if (childNodes[i].nodeType == 1) {
									childrenArr.push(childNodes[i]);
								}
							}
						} else {
							childrenArr = toAppendMain.children;
						}
						for (var i = 0; i < domArr.length; i++) {
							domArr[i].push(childrenArr[i]);
						}
						requestAnimationFrame(function () {
							requestAnimationFrame(function () {
								_LC.callCC();
							});
						});
					}
					//Provided so that before appending the component to DOM it is reset to previous value
					_LC.unbound = initialUnbound;
					if (options.type === "default") {
						returnVal = { "toAppendMain": toAppendMain, "lastNode": lastNode };
					} else {
						//lastNode.parentNode.insertBefore(toAppendMain, lastNode);
						if (lastNode._placeHolder) {
							_insertBefore(lastNode._placeHolder.parentNode, toAppendMain, lastNode._placeHolder);
						} else {
							_insertBefore(lastNode.parentNode, toAppendMain, lastNode);
						}
					}
					if (!localUnbound && node._removedAttributes && node._removedAttributes.items && !node._removedAttributes.items.helperValue && node._removedAttributes.items._multipleProperty) {
						_LC.establishBindings({ "items": node._removedAttributes.items._multipleProperty[0].actProp }, { "items": items });
					}
				}
				_LC.unbound = initialUnbound;
				if (updateIndexProperty) {
					for (var _i29 = indexPropertyStartIndex; _i29 < node._items.length; _i29++) {
						if (node._items[_i29].indexProperty) {
							_LC.affectChanges(node._items[_i29].indexProperty);
						}
					}
				}
				callee.component.data[itemValue] = initialItemValue;
				callee.component.data[indexValue] = initialIndexValue;
				callee._properties[itemValue] = initialItemProp;
				callee._properties[indexValue] = initialIndexProp;
				node._currentItems = items;
				return returnVal;
			}
			//It constructs/updates forIn Helper.
			//updFIH

		}, {
			key: 'updateForInHelper',
			value: function updateForInHelper(node, options, contextSwitchInfo, establishBindings) {
				if (node.tagName !== "TEMPLATE") {
					Object.keys(node).forEach(function (item) {
						if (item !== "innerHTML" && item !== "innerText") {
							node._origTemplate[item] = node[item];
						}
					});
					if (_Lyte._ie) {
						var div = createElement("div");
						div.innerHTML = node._tC;
						node._origTemplate.innerHTML = div.children[0].innerHTML;
						this.constructor.splitTextNodes(node._origTemplate);
						if (node.hasAttribute("depth")) {
							node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
						}
					}
					var placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
					node._origTemplate.setAttribute("key", node.getAttribute("key"));
					node._origTemplate.setAttribute("value", node.getAttribute("value"));
					if (node.hasAttribute("unbound")) {
						//What if unbound is dynamic attribute ? 
						node._origTemplate.setAttribute("unbound", "true");
					}

					//node.replaceWith(node._origTemplate._placeHolder);
					_LC.replaceWithPf(node, node._origTemplate._placeHolder);
					node = _LC.replaceWithOrigTemplate(node);
					// node = node._origTemplate;
					node.setAttribute("is", "forIn");
					_LC.apdNode(node, this);
					placeHolder._helper = node;
				} else if (!node._placeHolder) {
					// var emptyTextNode = document.createTextNode("");
					//node.replaceWith(emptyTextNode);
					//to bind in ssr
					var emptyTextNode;

					emptyTextNode = document.createTextNode("");

					_LC.replaceWithPf(node, emptyTextNode);
					node._placeHolder = emptyTextNode;
					_LC.apdNode(node, this);
					emptyTextNode._helper = node;
				}
				var callee = this;
				node._callee = this;
				node._attributes = node._attributes || {};
				if (options.type === "update" && node._currentObject === node._attributes.object) {
					return {};
				}
				contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
				node._cx = contextSwitchInfo;
				var key = node.getAttribute("key");
				if (!key) {
					key = "key";
					node.setAttribute("key", "key");
				}
				var value = node.getAttribute("value");
				if (!value) {
					value = "value";
					node.setAttribute("value", "value");
				}
				var initialKeyValue = callee.component.data[key];
				var initialValueValue = callee.component.data[value];
				var initialKeyProp = callee._properties[key];
				var initialValueProp = callee._properties[value];
				callee._properties[key] = callee._properties[value] = {};
				var object = node._attributes.object;
				var content = node.content;
				var dynamicNodes = node._dynamicNodes;
				var lastNode = node;
				var keysArray = [];
				if (!node._items) {
					node._items = {};
				}
				node._dynProps = node._dynProps || {};
				if (options) {
					switch (options.type) {
						case "delete":
							{
								this.removeHelpersSpecificIndex(node, options.property);
								var delIndex = node._keysArray.indexOf(options.property);
								if (delIndex > -1) {
									node._keysArray.splice(delIndex, 1);
								}
								if (node._helpers) {
									delete node._helpers[options.property];
								}
								delete node._propBindingObject[options.property];
							}
							break;
						case "add":
							{
								keysArray = [options.property];
								node._keysArray.push(options.property);
							}
							break;
						case "update":
							{
								node._keysArray.forEach(function (itemKey, index, array) {
									this.removeHelpersSpecificIndex(node, itemKey);
								}, this);
								node._keysArray = keysArray = object ? Object.keys(object) : [];
								node._helpers = {};
								node._items = {};
								node._propBindingObject = {};
							}
							break;
						case "default":
							{
								node._forContent = {};
								node._helpers = {};
								node._keysArray = keysArray = object ? Object.keys(object) : [];
								//                  keysArray = Object.keys(object);
							}
							break;
						default:
							_Lyte.error("Error in updateForHelper");

					}
				}
				var returnVal = void 0;
				if (!object) {
					var _toAppendMain3 = createDocFragment();
					if (options.type !== "default") {
						_insertBefore(lastNode.parentNode, _toAppendMain3, lastNode);
					} else {
						returnVal = { "toAppendMain": _toAppendMain3, "lastNode": lastNode };
					}
				}
				var localUnbound = false;
				var initialUnbound = _LC.unbound;
				if (node.hasAttribute("unbound") || node._attributes && node._attributes.unbound) {
					localUnbound = true;
					_LC.unbound = true;
				}
				node._currentObject = object;
				if (!_Lyte._ms && keysArray.length && node._ht && !node._htA) {
					node.content.append(node._ht.content.cloneNode(true));
					node._htA = true;
				}
				if (object && options.type !== "remove") {
					var toAppendMain = createDocFragment();
					node._propBindingObject = node._propBindingObject || {};
					keysArray.forEach(function (itemKey, index, array) {
						node._helpers[itemKey] = [];
						node._items[itemKey] = { "_dynamicProperty": {}, "itemProperty": {} };
						callee.component.data[key] = itemKey;
						callee.component.data[value] = object[itemKey];
						callee._properties[key] = {};
						callee._properties[value] = {};
						var cacheData = {};
						cacheData[key] = {};
						cacheData[key]._data = itemKey;
						cacheData[key]._dyn = [key];
						cacheData[value] = {};
						cacheData[value]._data = object[itemKey];
						cacheData[value]._dyn = [value];
						var optns = { "itemIndex": itemKey, "itemValue": value, "keyValue": key, "type": "forIn", "node": node };
						node._items[itemKey]._cx = optns;
						dynamicNodes._cache = cacheData;
						var toAppend = this.renderNodes(node.hasAttribute("depth") ? node._depthTemp : node, dynamicNodes, node, optns, establishBindings, undefined, node._tC);
						Object.keys(node._items[itemKey]._dynamicProperty).forEach(function (key) {
							node._dynProps[key] ? node._dynProps[key]++ : node._dynProps[key] = 1;
						});
						node._items[itemKey].itemProperty = this.getProperty(value);
						node._propBindingObject[itemKey] = node._items[itemKey].itemProperty;
						node._forContent[itemKey] = Array.from(toAppend.childNodes);
						//                    this.updateBlockHelpers(node._helpers[itemKey], optns);
						this.executeBlockHelpers(node._helpers[itemKey], node);

						//to bind in ssr components

						toAppendMain.appendChild(toAppend);
					}, this);
					//              if(options.type !== "update") {
					if (!_LC.unbound) {
						makeSet(node._attributes.object, "_bindings");
						addBindings(node._attributes.object._bindings, node._propBindingObject);
						_LC.establishBindings(node._propBindingObject, node._attributes.object);
					}
					//              }
					_LC.unbound = initialUnbound;
					if (options.type !== "default") {
						//lastNode.parentNode.insertBefore(toAppendMain, lastNode);
						if (lastNode._placeHolder) {
							_insertBefore(lastNode._placeHolder.parentNode, toAppendMain, lastNode._placeHolder);
						} else {
							_insertBefore(lastNode.parentNode, toAppendMain, lastNode);
						}
					} else {
						returnVal = { "toAppendMain": toAppendMain, "lastNode": lastNode };
					}
				}
				_LC.unbound = initialUnbound;
				callee.component.data[key] = initialKeyValue;
				callee.component.data[value] = initialValueValue;
				callee._properties[key] = initialKeyProp;
				callee._properties[value] = initialValueProp;
				node._currentObject = object;
				return returnVal;
			}
			//updSH

		}, {
			key: 'updateSwitchHelper',
			value: function updateSwitchHelper(type, node, contextSwitchInfo, update, establishBindings, id, toBeInsMap) {
				if (!_Lyte._ms && node._ht && !node._htA) {
					node.content.append(node._ht.content.cloneNode(true));
					node._htA = true;
				}
				if (node.tagName !== "TEMPLATE") {
					Object.keys(node).forEach(function (item) {
						if (item !== "innerHTML" && item !== "innerText") {
							node._origTemplate[item] = node[item];
						}
					});
					if (_Lyte._ie) {
						var div = createElement("div");
						div.innerHTML = node._tC;
						node._origTemplate.innerHTML = div.children[0].innerHTML;
						this.constructor.splitTextNodes(node._origTemplate);
						if (node.hasAttribute("depth")) {
							node._origTemplate.setAttribute("depth", node.getAttribute("depth"));
						}
					}
					var placeHolder = node._origTemplate._placeHolder = document.createTextNode("");
					//node.replaceWith(node._origTemplate._placeHolder);
					_LC.replaceWithPf(node, node._origTemplate._placeHolder);
					// node = node._origTemplate;
					node = _LC.replaceWithOrigTemplate(node);
					node.setAttribute("is", type);
					_LC.apdNode(node, this);
					placeHolder._helper = node;
				} else if (!node._placeHolder) {
					var emptyTextNode;
					//node.replaceWith(emptyTextNode);

					emptyTextNode = document.createTextNode("");

					_LC.replaceWithPf(node, emptyTextNode);
					node._placeHolder = emptyTextNode;
					emptyTextNode._helper = node;
					_LC.apdNode(node, this);
				}
				var isNew = false;
				var lastNode = node;
				if (!node._callee) {
					node._callee = this;
					isNew = true;
				}
				contextSwitchInfo = contextSwitchInfo ? contextSwitchInfo : node._cx;
				node._cx = contextSwitchInfo;
				node._dynamicProperty = node._dynamicProperty ? node._dynamicProperty : {};
				var currentCaseName = void 0;
				var value = void 0;
				if (node.getAttribute("value") === "" || node.getAttribute("value")) {
					value = node.getAttribute("value");
				} else if (node._attributes) {
					value = node._attributes.value;
				}
				// if(node._currentCase && value === node._currentCase){
				//     return;
				// }
				if (value) {
					currentCaseName = type === "if" ? "true" : value.toString();
				} else {
					if (type === "if") {
						currentCaseName = "false";
					} else {
						switch (value) {
							case undefined:
								currentCaseName = "undefined";
								break;
							case null:
								currentCaseName = "null";
								break;
							case false:
								currentCaseName = "false";
								break;
							case "":
								currentCaseName = '""';
								break;
							case 0:
								currentCaseName = '0';
						}
					}
				}
				if (currentCaseName === node._currentCase) {
					return;
				}
				node._currentCase = currentCaseName;
				var nodeTemp = node._depthTemp || node;
				//        let currentCase = node.content.querySelector('[case=\''+currentCaseName+'\']'),scope;
				var scope = node._cases[currentCaseName];
				var defaultContent = void 0;
				if (!scope) {
					scope = node._default;
					defaultContent = _Lyte._ms ? scope.templateContent : nodeTemp.content.querySelector('[default]');
					if (!_Lyte._ms && scope._ht && !defaultContent._htA) {
						defaultContent._htA = true;
						defaultContent.content.append(scope._ht.content.cloneNode(true));
					}
					node._isDefault = true;
					if (!defaultContent) {
						if (node._caseContent && node._caseContent.length) {
							this.removeHelpers(node, undefined, true);
						}
						node._caseContent = [];
						var _emptyTextNode = document.createTextNode("");
						node._caseContent.push(_emptyTextNode);
						node._currentCaseName = currentCaseName;
						node._helpers = node._helpers || [];
						if (update) {
							//lastNode.parentNode.insertBefore(emptyTextNode, node);
							if (lastNode._placeHolder) {
								_insertBefore(lastNode._placeHolder.parentNode, _emptyTextNode, lastNode._placeHolder);
							} else {
								_insertBefore(lastNode.parentNode, _emptyTextNode, node);
							}
							return;
						} else {
							var _toAppendMain4 = createDocFragment();
							_toAppendMain4.append(_emptyTextNode);
							return { lastNode: lastNode, toAppendMain: _toAppendMain4 };
						}
					}
				}

				//        if(currentCase) {
				//              if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
				//                  currentCase = currentCase.content;
				//              } else {
				//                  let temp = createElement('template');
				//                  let clone = currentCase.cloneNode(true);
				//                  temp.content.appendChild(clone);
				//                  currentCase.removeAttribute('slot');
				//                  currentCase = temp.content;
				//              }
				//              scope.content = currentCase;
				//        }

				if (node._caseContent && node._caseContent.length) {
					this.removeHelpers(node, undefined, true);
				}
				var dummyScope = scope;
				var additionalContentArr = [];
				var cnt = 0;
				var dummyCaseName = currentCaseName;
				var template = void 0;
				if (defaultContent) {
					template = defaultContent;
				} else {
					template = _Lyte._ms ? {} : nodeTemp.content.querySelector('[case=\'' + _LC.cssEscape(dummyCaseName) + '\']');
				}
				var contentArr = [];
				while (dummyScope) {
					if (!_Lyte._ms && dummyScope._ht && !template._htA) {
						template._htA = true;
						template.content.append(dummyScope._ht.content.cloneNode(true));
					}
					var dynamicNodes = dummyScope.dynamicNodes;
					var processedContent = this.renderNodes(template, dynamicNodes, node, undefined, establishBindings, undefined, dummyScope.templateContent);

					//to bind ssr in if/switch


					contentArr.push(processedContent);
					if (dummyScope.additional) {
						if (dummyScope.additional.next) {
							template = _Lyte._ms ? {} : node.content.querySelector('[case=\'' + _LC.cssEscape(dummyScope.additional.next) + '\']');
							dummyScope = node._cases[dummyScope.additional.next];
						} else {
							template = _Lyte._ms ? {} : node.content.querySelector('[default]');
							dummyScope = node._default;
						}
					} else {
						break;
					}
				}
				node._caseContent = [];
				var toAppendMain = createDocFragment();;
				for (var _i30 = 0; _i30 < contentArr.length; _i30++) {
					if (contentArr[_i30].nodeType == 11) {
						//                for(let j=0;j<contentArr[i].childNodes.length;j++) {
						//                    node._caseContent.push(contentArr[i].childNodes[j]);
						//                }
						node._caseContent = node._caseContent.concat(Array.from(contentArr[_i30].childNodes));
					} else {
						node._caseContent.push(contentArr[_i30]);
					}
					toAppendMain.append(contentArr[_i30]);
					//            node.parentNode.insertBefore(contentArr[i], node);
				}
				this.executeBlockHelpers(node._helpers, node);
				if (update) {
					var returnVal = void 0;
					if (toAppendMain.querySelector("template[is=break]")) {
						returnVal = "break";
					} else if (toAppendMain.querySelector("template[is=continue]")) {
						returnVal = "continue";
					}
					//node.parentNode.insertBefore(toAppendMain, node);
					if (node._placeHolder) {
						_insertBefore(node._placeHolder.parentNode, toAppendMain, node._placeHolder);
					} else {
						_insertBefore(node.parentNode, toAppendMain, node);
					}
					return returnVal;
				} else {
					return { "toAppendMain": toAppendMain, "lastNode": node };
				}
			}
		}, {
			key: 'dummy',
			value: function dummy(a, b) {
				var dummy = this.constructor._properties[boundValue].observer;
			}
		}, {
			key: 'callObservers',
			value: function callObservers(boundValue, key) {
				var property = this.constructor._properties[boundValue];
				var observers = property ? property.observer : undefined;
				if (observers) {
					for (var _i31 = 0; _i31 < observers.length; _i31++) {
						if (key.indexOf('.') === -1 || observers[_i31].path === key) {
							this["_" + observers[_i31].functionName].apply(this);
						}
					}
				}
			}
		}, {
			key: 'bindNode',

			//It registers the binding of the node with the properties with which the dynamicNode depends. 
			value: function bindNode(node, toBeRemoved, helperNode, options, nodeInfo, processLast, establishBindings, isTemplate, cache, type, idx, toBeInsMap) {
				var itemValue = options.itemValue;
				var forIndex = options.itemIndex;
				var forType = options.type;
				var indexValue = options.indexValue;
				var dynamicValue = nodeInfo.dynamicValue;
				var helperFunc = nodeInfo.helperInfo;
				var nodeValue = void 0,
				    ownerElement = node.ownerElement;
				var dynamicValuesArray = [];
				//        if(node.nodeType === 2 && _LC.isCustomElement(node.ownerElement,true) ) {
				//          node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue};
				//        }
				if (node.nodeType === 2) {
					node = { nodeName: node.nodeName, ownerElement: node.ownerElement, nodeType: 2, nodeValue: node.nodeValue, _attributeDetails: node._attributeDetails };
				}
				var hel_name = helperFunc ? helperFunc.name : undefined;
				//to get bindings in ssr components

				node._callee = this;
				var isHelper = false;
				if (helperFunc && Object.keys(helperFunc).length) {
					isHelper = true;
					var attrName = node.nodeName;
					nodeValue = node.helperValue = helperFunc;
					var helperArgs = [];
					if (helperFunc.name === "action") {
						var actName = helperFunc.args[0];
						helperFunc.args[0] = actName.startsWith("'") ? actName.replace(/'/g, '') : actName;
						actName = helperFunc.args.slice(0, 1)[0];
						var args = helperFunc.args.slice(1, helperFunc.args.length),
						    isCustom = false;
						var _attrName2 = node.nodeName;
						if (_attrName2.indexOf("-") != -1) {
							isCustom = true;
						}
						helperArgs = [ownerElement, _attrName2, isCustom, { name: actName, args: args }];
						this.processHelper({ "name": helperFunc.name, "args": helperArgs }, node);
						return;
					} else {
						if (helperFunc.name === "method") {
							helperArgs = helperFunc.args;
						} else {
							helperArgs = this.processArgs(this, { "helperInfo": helperFunc }, dynamicValuesArray, undefined, node, undefined, cache);
						}
					}
					nodeValue = this.processHelper({ "name": helperFunc.name, "args": helperArgs }, node);
					if (helperFunc.name === "unescape") {
						//              let test = node.replaceWith.apply(node,nodeValue.childNodes);
						var _obj4 = { initialNode: node, dynamicNodeValue: nodeValue };
						node = { dynamicPositions: _obj4, "_callee": node._callee, helperValue: node.helperValue };
						nodeValue = undefined;
						processLast.push(node);
					}
				} else {
					helperFunc = {};
					node.syntaxValue = dynamicValue;
					var dynamicValues = [];
					nodeValue = _LC.get(this.component.data, dynamicValue, dynamicValues, cache);
					dynamicValuesArray.push(dynamicValues);
				}
				//if(node.nodeType === 2 && ( (typeof nodeValue !== "string" && (_LC.isCustomElement(node.ownerElement,true) || typeof nodeValue === "boolean") ) || _LC.isControlHelper(node.ownerElement) )) {
				//	let bindedNode = node;
				//node = {nodeName : node.nodeName, ownerElement: ownerElement, nodeType : 2, nodeValue : node.nodeValue, _callee : this, syntaxValue : node.syntaxValue, helperValue : node.helperValue, _attributeDetails : node._attributeDetails};
				if (node.nodeType == 2) {
					var tagName = node.ownerElement.tagName;
					if (tagName == "INPUT" || tagName == "TEXTAREA" || tagName == "DIV" && node.ownerElement.hasAttribute("contenteditable")) {
						var rA = node.ownerElement._rA = node.ownerElement._rA || [];
						node.ownerElement._rA.push(node);
					}
					if (!ownerElement._origTemplate) {
						if ((ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin")) && ownerElement.tagName !== "TEMPLATE") {
							if (_Lyte._ie) {
								node.ownerElement = createElement("template");
								node.ownerElement.setAttribute("is", nodeInfo._depthTemp);
							} else {
								node.ownerElement = nodeInfo._depthTemp.cloneNode(true);
							}
							ownerElement._origTemplate = node.ownerElement;
						}
					} else {
						node.ownerElement = ownerElement._origTemplate;
					}
					//	node.ownerElement._attributeDetails[node.nodeName].bindedNode = node;
					//}
				}
				var actMultiProp = void 0;
				if (helperFunc.name !== "unbound" && !_LC.unbound) {
					var dynamicProp = void 0;
					if (helperNode) {
						dynamicProp = forType ? helperNode._items[forIndex]._dynamicProperty : helperNode._dynamicProperty;
					}
					var _obj5 = void 0,
					    helperId = void 0;
					for (var d = 0; d < dynamicValuesArray.length; d++) {
						var _dynamicValues = dynamicValuesArray[d];

						for (var v = 0; v < _dynamicValues.length; v++) {
							//to get binding in ssr components
							var _nes = false;

							var actProperty = this.getProperty(_dynamicValues[v]);
							if (helperNode) {
								var ind = _dynamicValues[v].search(/\W/);
								var _boundValue = void 0;
								if (ind !== -1) {
									_boundValue = _dynamicValues[v].substring(0, ind);
								} else {
									_boundValue = _dynamicValues[v];
								}
								if (_boundValue !== itemValue && _boundValue !== indexValue && (!options.node || !options.node._properties || !options.node._properties[_boundValue])) {
									//to bind for in ssr
									// obj._type = "nestedIf";

									makeSet(actProperty, "_helperNodes");
									actProperty._helperNodes.add(helperNode);
									dynamicProp[_dynamicValues[v]] ? dynamicProp[_dynamicValues[v]].push(node) : (dynamicProp[_dynamicValues[v]] = []).push(node);
								} else {
									node._cx = options;
									//            				if(!actProperty._dynamicNodes) {
									//            					actProperty._dynamicNodes = [];
									//            					defProp(actProperty, '_dynamicNodes', {
									//            						value: [],
									//            						enumerable: false, 
									//            						writable: true, 
									//            						configurable: true
									//            					});
									//            				}
									makeArray(actProperty, "_dynamicNodes");
									actProperty._dynamicNodes.push(node);
									if (_boundValue !== indexValue) {
										actMultiProp = actProperty;
									}
								}
							} else {
								//            			if(!actProperty._dynamicNodes) {
								//            				defProp(actProperty, '_dynamicNodes', {
								//            					value : [], 
								//            					enumerable: false, 
								//            					writable: true,
								//            					configurable: true
								//            				});
								//            			}
								makeArray(actProperty, "_dynamicNodes");
								actProperty._dynamicNodes.push(node);
							}
							if (ownerElement && (ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin")) || ownerElement && ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(ownerElement.getAttribute("is")) && !isHelper) {
								var _type = ownerElement.getAttribute("is");
								if (_type === "for" && node.nodeName === "items" || _type === "forIn" && node.nodeName === "object") {
									if (!actProperty._forHelpers) {
										makeSet(actProperty, "_forHelpers");
									}
									//to bind for in ssr

									node.ownerElement._actualBinding = actProperty;
									actProperty._forHelpers.add(node.ownerElement);
								}
							}
							if (establishBindings) {
								_LC.establishSelectedBinding(actProperty, this.component.data, this);
							}
							//to get ssr bindings 
						}
						if (_dynamicValues.length > 1) {

							node._multipleProperty = node._multipleProperty || [];
							node._multipleProperty.push({ "dynamicProp": actMultiProp ? undefined : dynamicProp, "actProp": this.getProperty(_dynamicValues[0]), "helperNode": helperNode, "dynamicValues": _dynamicValues, index: d });
						}
					}
				}
				nodeValue = !(typeof nodeValue === 'undefined' ? 'undefined' : _typeof(nodeValue)) === "boolean" && !(typeof nodeValue === 'undefined' ? 'undefined' : _typeof(nodeValue)) === "number" ? nodeValue ? nodeValue : "" : nodeValue;
				if (node.nodeType === 2) {
					var parentNode = node._parentNode ? node._parentNode : node.ownerElement;
					if (parentNode.tagName) {
						var is = parentNode.getAttribute("is");
					}
					var isCustomElement = _LC.isCustomElement(parentNode, true);
					if (isCustomElement) {
						if (parentNode.set) {
							parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue);
						} else {
							parentNode._initProperties = parentNode._initProperties || {};
							parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] = nodeValue;
						}
					}
					var origNodeValue = nodeValue;
					//!== "string"
					if (isCustomElement && typeof nodeValue !== "string" && !isTemplate) {
						parentNode._attributes = parentNode._attributes || {};
						parentNode._attributes[node.nodeName] = nodeValue;
						if (parentNode.nodeName === "TEMPLATE" && isHelper) {
							if (parentNode.getAttribute("is") === "for" && node.nodeName === "items" || parentNode.getAttribute("is") === "forIn" && node.nodeName === "object" && !_LC.unbound) {
								//node._actualBinding = {"_forHelpers" : new Set().add(parentNode)};
								node.ownerElement._actualBinding = { "_forHelpers": new Set().add(parentNode), "_createdBinding": true };
								if (nodeValue) {
									makeSet(nodeValue, "_bindings");
									addBindings(nodeValue._bindings, node.ownerElement._actualBinding);
								}
							}
						}
						toBeRemoved.push(node.nodeName);
					} else {
						if (typeof nodeValue === "boolean") {
							parentNode._attributes = node.ownerElement._attributes || {};
							parentNode._attributes[node.nodeName] = nodeValue;
							if (!nodeValue) {
								//                      node.ownerElement.removeAttribute(node.nodeName);
								toBeRemoved.push(node.nodeName);
							} else {
								parentNode.setAttribute(node.nodeName, "");
							}
						} else {
							if (nodeValue && (typeof nodeValue === 'undefined' ? 'undefined' : _typeof(nodeValue)) === "object") {
								var res;
								if (typeof Record != "undefined" && nodeValue instanceof Record) {
									res = JSON.stringify(nodeValue.$.toJSON());
								} else {
									try {
										res = JSON.stringify(nodeValue);
									} catch (exp) {
										Lyte.error("Data passed for property '" + node.nodeName + "' of '" + node.ownerElement.nodeName.toLocaleLowerCase() + "' cannot be serialized. The component '" + node.ownerElement.nodeName.toLocaleLowerCase() + "' might not be registered before its use.");
									}
								}
							} else if (nodeValue == null || nodeValue == undefined) {
								res = "";
							} else {
								res = nodeValue;
							}
							nodeValue = res;
							if (_LC.isControlHelper(node.ownerElement)) {
								parentNode._attributes = node.ownerElement._attributes || {};
								parentNode._attributes[node.nodeName] = nodeValue;
								toBeRemoved.push(node.nodeName);
							} else {
								var locNodeVal = nodeValue === undefined ? "" : nodeValue;
								//if(node.nodeName === "style") {
								//   node.ownerElement.setAttribute("style",locNodeVal);
								//} else {
								//   node.nodeValue = locNodeVal;
								//}
								node.ownerElement.setAttribute(node.nodeName, locNodeVal);
							}
						}
					}
					if (parentNode.tagName === "LYTE-YIELD" /*parentNode.getAttribute("is") === "insertYield"*/) {
							parentNode.component.data[_LC.String.toCamelCase(node.nodeName)] = origNodeValue;
						}
					if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
						if (node.nodeName === "value") {
							parentNode.value = nodeValue === undefined ? "" : nodeValue;
						} else if (node.nodeName === "checked") {
							parentNode.checked = nodeValue;
						}
					}
					if (!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
						toBeRemoved.push(node.nodeName);
					}
				} else {
					node.nodeValue = nodeValue === undefined ? '' : nodeValue;
				}
				return node;
			}
		}, {
			key: 'debounce',
			value: function debounce(func, threshold) {
				var timeout;
				return function debounced() {
					var obj = this,
					    args = arguments;
					function delayed() {
						func.apply(obj, args);
						timeout = null;
					};
					if (timeout) {
						clearTimeout(timeout);
					}
					timeout = setTimeout(delayed, threshold || 100);
					//console.log(timeout,threshold);
				};
			}
		}, {
			key: 'getProperty',
			value: function getProperty(key) {
				var arr = key.match(/([^[\].]+|\[\])/g);
				var property = this;
				if (!property._properties[arr[0]]) {
					property._properties[arr[0]] = {};
				}
				property = property._properties[arr[0]];

				defProp(property, '_path', { enumerable: false, value: arr[0] });
				for (var _i32 = 1; _i32 < arr.length; _i32++) {
					if (arr[_i32].startsWith("'") || arr[_i32].startsWith('"')) {
						//added check
						arr[_i32] = arr[_i32].substring(1, arr[_i32].length - 1);
					}
					if (!property[arr[_i32]]) {
						property[arr[_i32]] = {};
						defProp(property[arr[_i32]], '_path', { enumerable: false, value: property._path + "." + arr[_i32] });
					}
					property = property[arr[_i32]];
				}
				return property;
			}
			//updN

		}, {
			key: 'updateNode',
			value: function updateNode(node, updatePath) {
				var compInstance = this.component;
				var del = "delete";
				var multiplePropNode = [];
				var multipleProp = void 0;
				if (node._multipleProperty) {
					for (var i = 0; i < node._multipleProperty.length; i++) {
						if (node._multipleProperty[i] && node._multipleProperty[i].dynamicValues.lastIndexOf(updatePath) > 0) {
							multiplePropNode[i] = false;
							multipleProp = node._multipleProperty[i];
							var nodes = void 0;
							if (multipleProp.dynamicProp) {
								multiplePropNode[i] = multipleProp;
								nodes = multipleProp.dynamicProp[multipleProp.actProp._path];
								if (nodes) {
									var index = nodes.indexOf(node);
									nodes.splice(index, 1);
								}
								var helperNode = multipleProp.helperNode;
								if (nodes.length === 0) {
									if (helperNode.getAttribute("is") === "if") {
										multipleProp.actProp._helperNodes[del](helperNode);
										delete multipleProp.dynamicProp[multipleProp.actProp._path];
									} else {
										delete multipleProp.dynamicProp[multipleProp.actProp._path];
										if (helperNode._items) {
											var removeHelper = true;
											for (var _i33 = 0; _i33 < helperNode._items.length; _i33++) {
												if (helperNode._items[_i33]._dynamicProperty && helperNode._items[_i33]._dynamicProperty[multipleProp.actProp._path]) {
													removeHelper = false;
													break;
												}
											}
											if (removeHelper) {
												multipleProp.actProp._helperNodes[del](helperNode);
												//console.log('for helper is removed');
											}
										}
									}
								}
							}
							if (!multiplePropNode[i]) {
								multiplePropNode[i] = "dynamicNodes";
								nodes = multipleProp.actProp._dynamicNodes;
								if (nodes) {
									var _index2 = nodes.indexOf(node);
									nodes.splice(_index2, 1);
									if (!nodes.length) {
										delete multipleProp.actProp._dynamicNodes;
									}
								}
							}
						}
					}
				}
				if (!node.syntaxValue && !node.helperValue) {
					return;
				}
				var contextSwitchInfo = void 0;
				var isYieldContext = void 0;
				if (node._cx || node.nodeType === 2 && node.ownerElement._cx) {
					contextSwitchInfo = node._cx || node.ownerElement._cx;
					var contextSwitchArray = [];
					_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
				} else if (node.tagName === "LYTE-YIELD" && node._callee._cx) {
					isYieldContext = true;
					contextSwitchInfo = node._callee._cx;
					var contextSwitchArray = [];
					_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
				}
				var nodeValue = void 0;
				var dynamicValues = [];
				var isHelper = false;
				if (node.helperValue) {
					isHelper = true;
					nodeValue = node.helperValue;
					var helperFunc = nodeValue;
					var helperRetVal = this.processHelper({ name: helperFunc.name, args: this.processArgs(this, { "helperInfo": helperFunc }, dynamicValues, undefined, node) }, node);
					nodeValue = helperRetVal;
					if (helperFunc.name === "unescape") {
						var oldDynamicPosition = node.dynamicPositions;
						var oldStartingNode = oldDynamicPosition.startingNode;
						var oldChldLen = oldDynamicPosition.length;
						while (oldChldLen > 1) {
							var next = oldStartingNode.nextSibling;
							oldStartingNode.remove();
							oldStartingNode = next;
							oldChldLen--;
						}
						var childLen = nodeValue.childNodes.length;
						if (!childLen) {
							nodeValue.appendChild(document.createTextNode(""));
							childLen = 1;
						}
						var startingNode = nodeValue.childNodes[0];
						oldStartingNode.replaceWith.apply(oldStartingNode, nodeValue.childNodes);
						var _obj6 = { startingNode: startingNode, length: childLen };
						node.dynamicPositions = _obj6;
						nodeValue = undefined;
					}
				} else {
					var _boundValue2 = node.syntaxValue;
					var path = void 0;
					if (_boundValue2.indexOf('.') !== -1 || _boundValue2.indexOf('[') !== -1) {
						path = _boundValue2;
						_boundValue2 = _boundValue2.substring(0, _boundValue2.indexOf('.'));
					}
					var _value = path ? _LC.get(compInstance.data, path, dynamicValues) : compInstance.data[_boundValue2];
					nodeValue = !(typeof _value === 'undefined' ? 'undefined' : _typeof(_value)) === "boolean" && !(typeof _value === 'undefined' ? 'undefined' : _typeof(_value)) === "number" ? _value ? _value : "" : _value;
				}
				if (!(dynamicValues[0] instanceof Array)) {
					dynamicValues = [dynamicValues];
				}

				if (multiplePropNode) {
					for (var i = 0; i < multiplePropNode.length; i++) {
						if (multiplePropNode[i]) {
							var _multipleProp = node._multipleProperty[i];
							var dynamicValIndex = node._multipleProperty[i].index;
							var prop = this.getProperty(dynamicValues[dynamicValIndex][0]);
							var totalProp = this.getProperty(dynamicValues[dynamicValIndex][0].substring(0, dynamicValues[dynamicValIndex][0].indexOf('.')));
							var value = this.getData(dynamicValues[dynamicValIndex][0].substring(0, dynamicValues[dynamicValIndex][0].indexOf('.')));
							if (multiplePropNode[i] === "dynamicNodes") {
								//	                    if(!prop._dynamicNodes) {
								//	                        defProp(prop, '_dynamicNodes', {
								//	                            value: [],
								//	                            enumerable: false, 
								//	                            writable: true,
								//	                            configurable: true
								//	                        });
								//	                    }
								makeArray(prop, "_dynamicNodes");
								prop._dynamicNodes.push(node);
							} else {
								makeSet(prop, "_helperNodes");
								prop._helperNodes.add(_multipleProp.helperNode);
								var dynamicProp = _multipleProp.dynamicProp;
								dynamicProp[prop._path] ? dynamicProp[prop._path].push(node) : (dynamicProp[prop._path] = []).push(node);
							}
							if (node.ownerElement && (node.ownerElement.hasAttribute("lyte-for") || node.ownerElement.hasAttribute("lyte-if") || node.ownerElement.hasAttribute("lyte-switch") || node.ownerElement.hasAttribute("lyte-forin")) || node.ownerElement && node.ownerElement.tagName === "TEMPLATE" && /^(for|forIn)$/.test(node.ownerElement.getAttribute("is")) && !isHelper) {
								var type = node.ownerElement.getAttribute("is");
								if (type === "for" && node.nodeName === "items" || type === "forIn" && node.nodeName === "object") {
									if (_multipleProp.actProp._forHelpers.has(node.ownerElement)) {
										_multipleProp.actProp._forHelpers.delete(node.ownerElement);
									}
									if (!prop._forHelpers) {
										makeSet(prop, "_forHelpers");
									}
									node.ownerElement._actualBinding = prop;
									prop._forHelpers.add(node.ownerElement);
								}
							}
							if (value != undefined) {
								_LC.establishBindings(totalProp, value);
							}
							node._multipleProperty[i].actProp = prop;
							node._multipleProperty[i].dynamicValues = dynamicValues[dynamicValIndex];
						}
					}
				}

				if (node.nodeType === 2) {
					var parentNodes = [];
					var pN = node._parentNode ? node._parentNode : node.ownerElement;
					if (pN.tagName === "TEMPLATE" && pN.getAttribute("is") === "component" && node.nodeName !== "component-name") {
						var isKeepAlive = pN.hasAttribute("lyte-keep-alive");
						if (isKeepAlive) {
							for (var key in pN._renderedComponent) {
								parentNodes.push(pN._renderedComponent[key]);
							}
						} else {
							var compName = pN._currentComponent;
							if (compName && pN._renderedComponent[compName]) {
								parentNodes.push(pN._renderedComponent[compName]);
							}
						}
					}
					parentNodes.push(pN);
					for (var _i34 = 0; _i34 < parentNodes.length; _i34++) {
						var parentNode = parentNodes[_i34];
						if (parentNode.set) {
							parentNode.set(_LC.String.toCamelCase(node.nodeName), nodeValue, undefined, true);
						} else {
							parentNode._initProperties = parentNode._initProperties || {};
							parentNode._initProperties[_LC.String.toCamelCase(node.nodeName)] = nodeValue;
						}
						if (parentNode.tagName === "LYTE-YIELD" && parentNode.component.data && node.nodeName && parentNode.component.data[node.nodeName] !== nodeValue /*parentNode.getAttribute("is") === "insertYield"*/) {
								_LC.set(parentNode.component.data, _LC.String.toCamelCase(node.nodeName), nodeValue, undefined, undefined, parentNode);
							}
						parentNode._attributes = parentNode._attributes || {};
						//!== "string"
						if (_LC.isCustomElement(parentNode, true) && typeof nodeValue !== "string") {
							if (node.ownerElement.nodeName === "TEMPLATE") {
								if (node.helperValue) {
									if (node.ownerElement.getAttribute("is") === "for" && node.nodeName === "items" || node.ownerElement.getAttribute("is") === "forIn" && node.nodeName === "object") {
										var oldValue = node.ownerElement._attributes[node.nodeName];
										var newValue = nodeValue;
										_LC.removeSelectedBindingDeep(node.ownerElement._actualBinding, oldValue);
										if (newValue) {
											makeSet(newValue, "_bindings");
											addBindings(newValue._bindings, node.ownerElement._actualBinding);
											_LC.establishBindings(node.ownerElement._actualBinding, newValue);
										}
										if (node.nodeName === "object") {
											_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, oldValue);
										}
										//console.log("old Value ", oldValue, " new Value ", newValue);
									}
								} else {
									if (node.ownerElement.getAttribute("is") === "for" && node.nodeName === "items" || node.ownerElement.getAttribute("is") === "forIn" && node.nodeName === "object") {
										var _oldValue = node.ownerElement._attributes[node.nodeName];
										if (node.nodeName === "object") {
											_LC.removeSelectedBindingDeep(node.ownerElement._propBindingObject, _oldValue);
										}
									}
								}
								parentNode["__" + node.nodeName] = true;
								parentNode.removeAttribute(node.nodeName);
							} else {
								//Needs revisiting
								//parentNode.removeAttribute(node.nodeName);
							}
						} else {
							if (typeof nodeValue === "boolean") {
								parentNode._attributes = parentNode._attributes || {};
								parentNode._attributes[node.nodeName] = nodeValue;
								if (!nodeValue) {
									parentNode.removeAttribute(node.nodeName);
								} else {
									parentNode.setAttribute(node.nodeName, "");
								}
							} else {
								if (nodeValue && (typeof nodeValue === 'undefined' ? 'undefined' : _typeof(nodeValue)) === "object") {
									var res;
									if (typeof Record != "undefined" && nodeValue instanceof Record) {
										res = JSON.stringify(nodeValue.$.toJSON());
									} else {
										try {
											res = JSON.stringify(nodeValue);
										} catch (exp) {
											Lyte.error("Data passed for property '" + node.nodeName + "' of '" + node.ownerElement.nodeName.toLocaleLowerCase() + "' cannot be serialized. The component '" + node.ownerElement.nodeName.toLocaleLowerCase() + "' might not be registered before its use.");
										}
									}
								} else if (nodeValue == null || nodeValue == undefined) {
									res = "";
								} else {
									res = nodeValue;
								}
								nodeValue = res;
								var locNodeVal = nodeValue === undefined ? "" : nodeValue;
								// if(node.nodeName === "style") {
								//     node.ownerElement.setAttribute("style",locNodeVal);
								// } else {
								//     node.nodeValue = locNodeVal;
								// }

								// if(node instanceof Node) {
								//Check safari issue once
								var oE = node.ownerElement;
								if (oE.hasAttribute(node.nodeName)) {
									if (oE.tagName != "INPUT" || node.nodeName != "value" || !oE.validity.badInput) {
										oE.setAttribute(node.nodeName, locNodeVal);
									}
								} else {
									node.nodeValue = locNodeVal;
								}
							}
						}
						parentNode._attributes[node.nodeName] = nodeValue;
						if (/^(INPUT|TEXTAREA|SELECT)$/.test(parentNode.nodeName)) {
							if (node.nodeName === "value") {
								var val = nodeValue === undefined ? "" : nodeValue;
								if (parentNode.value !== val) {
									parentNode.value = val;
								}
							} else if (node.nodeName === "checked") {
								parentNode.checked = nodeValue;
							}
						}
						if (!nodeValue && _LC.booleanAttrList.indexOf(node.nodeName) !== -1) {
							parentNode.removeAttribute(node.nodeName);
						}
						var isStopped = parentNode._isStopped;
						var _result = void 0;
						switch (parentNode.getAttribute("is")) {
							case "for":
								this.updateForHelper(parentNode, { "type": "update" });
								break;
							case "if":
								_result = this.updateSwitchHelper("if", parentNode, undefined, true, true);
								break;
							case "forIn":
								this.updateForInHelper(parentNode, { "type": "update" });
								break;
							case "switch":
								this.updateSwitchHelper("switch", parentNode, undefined, true, true);
								break;
							case "component":
								if (node.nodeName === "component-name") {
									this.updateDynamicComponent(parentNode, "update");
								}
								break;
							default:
						}
						var handleBreakOptions = void 0;
						if (isStopped && isStopped !== _result) {
							//console.log("new value is stopped");
							if (!_result) {
								//console.log("new value is not stopped");
								if (isStopped === "break") {
									handleBreakOptions = "SM";
								} else {
									handleBreakOptions = "SS";
								}
							} else if (_result === "break") {
								handleBreakOptions = "MS";
								//console.log("old value is continue and new value is break");
							} else {
								handleBreakOptions = "SM";
								//console.log("old value is break and new value is continue");
							}
						} else if (_result === "break") {
							handleBreakOptions = "MS";
							//console.log("old value not stopped and new value is break");
							//                		this.handleBreak(parentNode._cx, "break");
						} else if (_result === "continue") {
							handleBreakOptions = "SS";
							//console.log("old value not stopped and new value is continue");
							//                		this.handleBreak1(parentNode._cx , "continue");
						}
						if (handleBreakOptions) {
							this.handleBreak(parentNode._cx, handleBreakOptions);
						}
					}
				} else {
					node.nodeValue = nodeValue === undefined ? '' : nodeValue;
				}
				if (contextSwitchInfo) {
					_LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
				}
			}
		}, {
			key: 'handleBreak',
			value: function handleBreak(contextSwitchInfo, options) {
				if (contextSwitchInfo) {
					var forTemplate = contextSwitchInfo.node;
					var breakIndex = contextSwitchInfo.itemIndex;
					var itemValue = forTemplate.getAttribute("item");
					var forContent = contextSwitchInfo.node._forContent;
					var endIndex = options[0] === "M" ? forContent.length : breakIndex + 1;
					for (var j = breakIndex; j < endIndex; j++) {
						var currentForContent = forContent[j];
						for (var _i35 = 0; _i35 < currentForContent.length; _i35++) {
							currentForContent[_i35].remove();
							if (currentForContent[_i35]._forContent || currentForContent[_i35]._caseContent) {
								this.removeHelpers(currentForContent[_i35]);
							}
						}
						forContent[j] = [];
						_LC.removeSelectedBindingDeep(forTemplate._items[j].itemProperty, forTemplate._attributes.items[j]);
						forTemplate._helpers[j] = [];
						forTemplate._items[j] = { "_dynamicProperty": {}, "itemProperty": {}, "indexProperty": {} };
					}
					var length = forTemplate._attributes.items.length;
					if (options[1] === "M") {
						this.updateForHelper(forTemplate, { firstIndex: breakIndex, secondIndex: length - breakIndex, "type": "replace" }, undefined, {});
					} else {
						this.updateForHelper(forTemplate, { firstIndex: breakIndex, secondIndex: 1, "type": "replace" }, undefined, {});
					}
				}
			}
		}, {
			key: 'createCustomEvent',
			value: function createCustomEvent(eventName, parentNode, actObj) {
				var customEvent = new CustomEvent(eventName);
				parentNode._actions[eventName] = customEvent;
				parentNode._actions[eventName].processAction = actObj;
			}
		}, {
			key: 'isEmptyString',
			value: function isEmptyString(str) {
				return !(typeof str === "string") || str === "";
			}
		}, {
			key: 'processArgs',
			value: function processArgs(scope, dynN, dynamicValues, event, node, newCompile, cache) {
				var args = dynN.newHelperInfo && newCompile ? dynN.newHelperInfo.args : dynN.helperInfo.args;
				var helpers = void 0,
				    j = void 0;
				dynamicValues = dynamicValues || [];
				args = Array.isArray(args) ? Array.from(args) : args;
				for (var _i36 = 0; _i36 < args.length; _i36++) {
					if (args[_i36] && args[_i36].type) {
						this.internalHelpers(scope, args, _i36, dynamicValues, event, node, newCompile, cache);
					} else {
						if (!this.isEmptyString(args[_i36])) {
							if (args[_i36].startsWith("'") && args[_i36].endsWith("'")) {
								args[_i36] = args[_i36].substr(1, args[_i36].length - 2);
							} else {
								args[_i36] = args[_i36].trim();
								var dynamicVals = [];
								if (args[_i36] === "event" && event) {
									args[_i36] = event;
								} else if (args[_i36] === "this" && node) {
									args[_i36] = node.nodeType === 2 ? node.ownerElement : node;
								} else {
									args[_i36] = _LC.get(scope.component.data, args[_i36], dynamicVals, cache);
								}
								dynamicValues.push(dynamicVals);
							}
						} else if (newCompile) {
							if (args[_i36] instanceof Array) {
								args[_i36] = _LC.getDD(scope.component.data, args[_i36]);
							}
						}
					}
				}
				return args;
			}
		}, {
			key: 'internalHelpers',
			value: function internalHelpers(scope, args, i, dynamicValues, event, node, newCompile, cache) {
				//helperFunc = this.constructor.getHelper(args[i]);
				var helperFunc = args[i].value;
				var helperVal = this.processHelper({ "name": helperFunc.name, "args": this.processArgs(scope, { "helperInfo": helperFunc }, dynamicValues, event, node, newCompile, cache) });
				args[i] = helperVal;
			}
		}, {
			key: 'processHelper',
			value: function processHelper(helperFunc, node) {
				var args = [];
				var helperName = helperFunc.name;
				if (!_LyteComponent.registeredHelpers[helperName]) {
					_Lyte.error("LC003", helperFunc.name);
					return;
				}
				switch (helperFunc.name) {
					case "method":
						args.push(this, node);
						break;
					case "lbind":
						args.push(this, node.ownerElement);
						break;
					case "lyteViewPort":
						if (node && node.ownerElement) {
							args.push(node.ownerElement);
							if (!helperFunc.args.length) {
								args.push(false);
							}
						} else {
							return false;
						}
				}
				return _LyteComponent.registeredHelpers[helperFunc.name].apply(this, args.concat(helperFunc.args));
			}
		}, {
			key: 'getActionProperty',
			value: function getActionProperty(prop) {
				var hostProp = this._properties;
				var value = hostProp ? hostProp[prop].value : undefined;
				return value;
			}
		}, {
			key: 'hasInternalBindings',
			value: function hasInternalBindings(content) {
				return content.match(/[(]{1}[^)]+[)]{1}/);
			}
		}, {
			key: 'getArgValues',
			value: function getArgValues(argNames, properties) {
				var argValueArray = [];
				for (var _i37 = 0; _i37 < argNames.length; _i37++) {
					argValueArray.push(properties[argNames[_i37]].value);
				}
				return argValueArray;
			}
		}, {
			key: 'createEventListeners',
			value: function createEventListeners(node, actionType, actObj) {
				var self = this;
				if (!node._callee && node !== this) {
					node._callee = this;
				}
				if (globalDOMEvents.indexOf(actionType) == -1) {
					var infoAttr = actionType.substr(2);
					var infoAttrVal = node.getAttribute(infoAttr);
					// var evntListener = function(event) {
					// 	var toRemove;
					//     if(!window.event) {
					//         window.event = event;
					//         toRemove = true;
					//     }
					//     _LC.throwAction.call(self,self,actionType.substr(2),actObj, undefined, undefined, node, event);
					//     if(toRemove) {
					//         window.event = undefined;
					//     }
					// };
					if (_LyteComponent.registeredComponents[node.localName] && !node.component || node.tagName === "TEMPLATE" && node.getAttribute("is") === "component") {
						node._toRegEvnts = node._toRegEvnts || {};
						node._toRegEvnts[actionType.substr(2)] = { "listener": globalEventHandler, "attrVal": this.tagName.toLowerCase() + " => " + actObj.name };
					} else {
						node.setAttribute(infoAttr, this.tagName.toLowerCase() + " => " + actObj.name);
						//Event is not in capture phase because, in capture phase, multiple event listeners in hierarchy are called from parent to child (since registration is done in that order)
						node.addEventListener(actionType.substr(2), globalEventHandler);
					}
					if (node.hasAttribute(actionType)) {
						node[actionType] = undefined;
					}
					node.removeAttribute(actionType);
				}
			}
		}, {
			key: 'registerParentYield',
			value: function registerParentYield(yieldName) {
				var parentYield = this._callee._yields[yieldName];
				var locYield = void 0;
				if (parentYield) {
					if (_Lyte._ie) {
						locYield = document.createElement("div");
						locYield.innerHTML = parentYield.outerHTML;
						locYield = locYield.childNodes[0];
						this.constructor.splitTextNodes(locYield);
					} else {
						locYield = parentYield.cloneNode(true);
					}
					Object.keys(parentYield).forEach(function (item) {
						//eslint-disable-line no-loop-func
						locYield[item] = parentYield[item];
					});
					this._yields[yieldName] = locYield;
				}
			}
		}, {
			key: 'registerYields',
			value: function registerYields() {
				this._yields = {};
				var yields = this.querySelectorAll('template[is=registerYield],template[is=yield]');
				var lazyYields = [];
				for (var _i38 = 0; _i38 < yields.length; _i38++) {
					while (yields[_i38].hasChildNodes()) {
						yields[_i38].content.appendChild(yields[_i38].childNodes[0]);
					}
					if (yields[_i38].hasAttribute("from-parent") && this._callee) {
						if (this._callee._yields) {
							this.registerParentYield(yields[_i38].getAttribute("yield-name"));
						} else {
							lazyYields.push(yields[_i38]);
						}
					} else {
						this._yields[yields[_i38].getAttribute("yield-name")] = yields[_i38];
					}
				}
				if (lazyYields.length && this._callee) {
					var self = this;
					this.lazyYield = function () {
						if (self._callee) {
							for (var j = 0; j < lazyYields.length; j++) {
								var lYield = lazyYields[j];
								self.registerParentYield(lYield.getAttribute("yield-name"));
							}
							self._callee.removeEventListener("onReady", self.lazyYield);
							delete self.lazyYield;
						}
					};
					this._callee.addEventListener("onReady", this.lazyYield);
				}
			}
		}, {
			key: 'connectedCallback',
			value: function connectedCallback() {
				if (this.hasAttribute("lyte-rendered") || !_LyteComponent.registeredComponents[this.localName] || this._ccCalled) {
					return;
				}
				var fastRenderProp = this._fR;
				if (!fastRenderProp) {
					this._callee = this._callee || this.getCallee(this.parentNode);
				}
				this.__h = {};
				this.__counter = 0;
				this.__dc = {};
				if (fastRenderProp) {
					var methods = fastRenderProp.methods;
					if (methods) {
						this.setMethods(methods);
					}
					_LC.ccDelay.push(this);
					this._ccCalled = true;
				} else {
					this.actualConnectedCallback();
				}
				var isViewPort;
				if (this._initProperties && this._initProperties.hasOwnProperty('lyteViewPort')) {
					isViewPort = this._initProperties.lyteViewPort;
				} else {
					isViewPort = this.component.data.lyteViewPort;
				}
				if (isViewPort) {
					if (!_LC.isViewPortPending) {
						requestAnimationFrame(function () {
							requestAnimationFrame(function () {
								_LC.executePendingViewPort();
							});
						});
						_LC.isViewPortPending = true;
					}
					_LC.pendingViewPortElements.push(this);
				}
			}
		}, {
			key: 'cmpBind',
			value: function cmpBind(fastRenderProp) {
				var compData = this.component.data;
				if (!_LC.unbound && !fastRenderProp) {
					Lyte.establishObserverBindings.call(this, this.constructor._observers);
					Lyte.establishWatchScope.call(this, this.constructor._deepWatchProperties);
					//this.establishObserverBindings();
					makeSet(compData, "_bindings");
					addBindings(compData._bindings, this._properties);
					_LC.establishBindings(this._properties, compData);
				}
			}
		}, {
			key: 'actualConnectedCallback',
			value: function actualConnectedCallback() {
				var compData = this.component.data;
				var fastRenderProp = this._fR;
				if (fastRenderProp) {
					this._callee = this._callee || this.getCallee(this.parentNode);
				}
				var templateAttributes = this.constructor._templateAttributes;
				if (templateAttributes && templateAttributes.attr) {
					for (var _key25 in templateAttributes.attr) {
						//        		let attr = templateAttributes.attr[i];
						var attr = templateAttributes.attr[_key25];
						if (!this.hasAttribute(attr.name) && !compData.hasOwnProperty(attr.name) || attr.globalEvent) {
							if (attr.helperInfo && attr.helperInfo.name === "action") {
								this._evBoundEvents = this._evBoundEvents || {};
								var actionName = attr.helperInfo.args[0];
								var boundName = void 0;
								if (actionName.startsWith('"') || actionName.startsWith("'")) {
									boundName = actionName.substring(1, actionName.length - 1);
								} else {
									//_Lyte.warn("Deprecation warning. Action name should be in quotes");
									boundName = actionName;
								}
								var actualAttrName = attr.globalEvent ? attr.name : attr.name.indexOf("-") !== -1 ? attr.name : attr.name.substr(2);
								this._evBoundEvents[actualAttrName] = { "name": boundName, "args": attr.helperInfo.args, "from": "component" };
								var prevAttribute = this.getAttribute(attr.name);
								var currentAttribute = this.constructor._template.getAttribute(attr.name);
								//this.setAttribute("ev:"+attr.name, this.constructor._template.getAttribute(attr.name));
								this.setAttribute(attr.name, currentAttribute + (prevAttribute ? " ; " + prevAttribute : ""));
							}
							if (!attr.globalEvent) {
								attr.from = "component";
								if (attr.staticValue) {
									this.setAttribute(templateAttributes.attr[_key25].name, attr.staticValue);
								} else {
									this.setAttribute(templateAttributes.attr[_key25].name, "{{dummy}}");
									this.bindNode(this.attributes.getNamedItem(templateAttributes.attr[_key25].name), [], undefined, {}, templateAttributes.attr[_key25], undefined, undefined, true);
								}
							}
						}
					}
				}
				for (var _key26 in this._toRegEvnts) {
					this.addEventListener(_key26, this._toRegEvnts[_key26].listener);
					if (this.hasAttribute(_key26)) {
						this.setAttribute(_key26, this.getAttribute(_key26) + " ; " + this._toRegEvnts[_key26].attrVal);
					} else {
						this.setAttribute(_key26, this._toRegEvnts[_key26].attrVal);
					}
				}
				this._toRegEvnts = {};
				var initialUnbound = _LC.unbound;

				var ssrBind = this.getAttribute("ssrbindservernode");
				if (ssrBind && !this.component.data.lyteUnbound) {
					this.bindServerData();
					this.removeAttribute("ssrbindservernode");
				}
				var content = this.afterConnected(fastRenderProp, ssrBind);
				!ssrBind && this.cmpBind(fastRenderProp);

				_LC.unbound = initialUnbound;
				if (typeof content === "string") {
					if (content) {
						if (_LC.frSpecial) {
							var temp = document.createElement("template");
							temp.innerHTML = content;
							this.innerHTML = "";
							this.appendChild(temp.content);
						} else {
							this.innerHTML = content;
						}
					}
					_LC.processAction(this);
				} else {
					if (this.component.data.lyteViewPort) {
						this._vpc = true;
						if (_Lyte._ie) {
							for (var i = 0; i < content.childNodes.length; i++) {
								if (content.childNodes[i].tagName) {
									this._dummyViewPortF = content.childNodes[i];
									break;
								}
							}
							for (var i = content.childNodes.length - 1; i >= 0; i--) {
								if (content.childNodes[i].tagName) {
									this._dummyViewPortL = content.childNodes[i];
									break;
								}
							}
						} else {
							this._dummyViewPortF = content.children[0];
							this._dummyViewPortL = content.children[content.children.length - 1];
						}
					}
					this.appendChild(content);
				}
				var dataDef = this.component.__data;
				var attributes = this.attributes;
				this.__lyteIgnore = true;
				for (var _i39 = attributes.length - 1; _i39 > -1; _i39--) {
					var camelCase = LyteComponent.String.toCamelCase(attributes[_i39].nodeName);
					if (dataDef[camelCase] && dataDef[camelCase].hideAttr) {
						this.removeAttribute(attributes[_i39].nodeName);
					}
				}
				this.__lyteIgnore = false;

				if (this._callee && this._callee.serverCall) {
					this.serverCall = true;
				}
				//to bind in ssr
				if (this.serverCall && !this.hasAttribute("server-rendered")) {
					this.setAttribute("server-rendered", "");
					var newData = LyteComponent.sendtoclient.call(this, this, true, this.component.__data);
					this.setAttribute("component-data", JSON.stringify(newData));
				}
				if (!this.hasAttribute("server-rendered")) {
					this.setAttribute("lyte-rendered", "");
				}
				if (!fastRenderProp && !Lyte._ignoreOnReady) {
					this.dispatchEvent(new CustomEvent("onReady"));
				}
				var _config_flag = void 0;
				if (this.component._config) {
					if (this.component._config.clientLifeCycleHooks != undefined) {
						_config_flag = this.component._config.clientLifeCycleHooks == true || (_typeof(this.component._config.clientLifeCycleHooks) == 'object' ? this.component._config.clientLifeCycleHooks.includes('didConnect') : false);
					}
				}
				var _overrides = this.component._ssr ? this.component._ssr.overrides : undefined;
				if (!this.hasAttribute("server-rendered") || this.serverCall || _config_flag) {
					if (_overrides && _overrides.didConnect && this.serverCall) {
						_overrides.didConnect.apply(this);
					} else {
						this.callback("didConnect");
					}
					this.onCallBack("didConnect");
				}

				if (this.serverCall == undefined) {
					this.callback("didRender");
				}
				if (fastRenderProp) {
					this.removeAttribute("_lyteprop");
				}
			}
		}, {
			key: 'onCallBack',
			value: function onCallBack(name) {
				var callbacks = this.constructor._callBacks[name];
				if (callbacks) {
					for (var _i40 = 0; _i40 < callbacks.length; _i40++) {
						try {
							callbacks[_i40].value.call(this.component);
						} catch (e) {
							_Lyte.error(e);
						}
					}
				}
			}
		}, {
			key: 'callback',
			value: function callback(name) {
				var func = this.component[name];
				var args;
				if (func) {
					if (arguments.length > 1) {
						args = Array.from(arguments);
						args.splice(0, 1);
					}
					try {
						func.apply(this.component, args || []);
					} catch (e) {
						_Lyte.error(e);
					}
				}
			}
		}, {
			key: 'establishObserverBindings',
			value: function establishObserverBindings() {
				var observers = this.constructor._observers;
				for (var _i41 = 0; _i41 < observers.length; _i41++) {
					var props = observers[_i41].properties;
					for (var j = 0; j < props.length; j++) {
						var actProp = void 0;
						var isArrayObserver = false;
						if (props[j].indexOf('.[]') !== -1) {
							isArrayObserver = true;
							actProp = this.getProperty(props[j].substring(0, props[j].indexOf('.[]')));
						} else {
							actProp = this.getProperty(props[j]);
						}
						makeSet(actProp, "_observers");
						actProp._observers.add({ callee: this, observer: observers[_i41], isArrayObserver: isArrayObserver });
					}
				}
			}
		}, {
			key: 'removeBindings',
			value: function removeBindings(properties, actualData) {
				var del = "delete";
				for (var _i42 in properties) {
					var actData = actualData[_i42];
					if (actData && actData._bindings) {
						actData._bindings[del](properties[_i42]);
						//Error while trying to delete _bindings from actData when actData is of type Array
						/*  if(!actData._bindings.size) {
          delete actData._bindings;
      } */
					}
					if (_typeof(properties[_i42]) === "object" && actData) {
						this.removeBindings(properties[_i42], actData);
					}
				}
			}
		}, {
			key: 'actualDisconnected',
			value: function actualDisconnected() {
				var self = this;
				if (!self.component) {
					return;
				}
				self._cx = null;
				self._callee = null;
				self.component.$node = null;
				self.component.__data = null;
				self.component.data.__component__ = null;
				self.component.data = null;
				self.component = null;
				self.__dc = self.__dc || {};
				self.__h = self.__h || {};
				for (key in self.__dc) {
					var helper = self.__dc[key];
					//helper.remove();
					if (helper.hasAttribute("lyte-keep-alive")) {
						var objKeys = Object.keys(helper._renderedComponent);
						for (var j = 0; j < objKeys.length; j++) {
							var _key27 = objKeys[j];
							if (_key27 !== helper._currentComponent) {
								// Will remove from hDiv.
								helper._renderedComponent[_key27].remove();
							}
						}
					}
				}
				for (key in self.__h) {
					self.__h[key].remove();
				}
				self.__h = {};
				self.__dc = {};
				var yields = self._yields;
				for (var key in yields) {
					yields[key]._callee = null;
				}
				self = null;
			}
		}, {
			key: 'disconnectedCallback',
			value: function disconnectedCallback() {
				if (_LC.ignoreDisconnect || !this.component) {
					return;
				}
				var pve = _LC.pendingViewPortElements;
				if (this.component.data.lyteViewPort) {
					var index = pve.indexOf(this);
					if (index != -1) {
						pve.splice(index, 1);
					}
				}
				if (_LyteComponent.viewPortSettings.handlePendingItems && this._vpc) {
					_LC.executeVpe = true;
				}
				if (pve.length) {
					for (var _i43 = 0; _i43 < pve.length; _i43++) {
						var actTemp = _LC.getActViewPortTemplate(pve[_i43]);
						if (actTemp && actTemp.tagName == "TEMPLATE" && actTemp.getAttribute("is") == "if" && actTemp._callee == this) {
							pve.splice(_i43, 1);
							_i43--;
						}
					}
				}
				this._destroyed = true;
				if (this.__toRemoveLazy) {
					for (var __key in this.__toRemoveLazy) {
						var __arr = this.__toRemoveLazy[__key];
						__arr.forEach(function (id) {
							Lyte.$.toRemoveFromRequiredServices(id);
						});
					}
					delete this.__toRemoveLazy;
				}
				this.component._bindings = null;
				var scpObj = this.__scpObj;
				if (scpObj) {
					for (var key in scpObj) {
						var propData = this.component.data[key],
						    id = scpObj[key],
						    idArr = id.split("_");
						if (propData) {
							Lyte.removeNestScp(this.component.data[key], idArr[0], idArr[1], undefined, this);
						}
					}
				}
				if (!this._fR) {
					_LC.removeSelectedBindingDeep(this._properties, this.component.data, true);
				}
				var h = this.__h;
				for (key in h) {
					if (h[key]._actualBinding) {
						this.removeHelpers(h[key]);
					}
				}
				h = {};
				//      _LC.removeBindings(this._properties, this.component);
				for (var _key28 in this._properties) {
					this._properties[_key28] = {};
				}
				this.callback('didDestroy');
				this.onCallBack('didDestroy');
				if (!_LC.dcc) {
					_LC.dcc = [];
					requestAnimationFrame(function () {
						requestAnimationFrame(function () {
							try {
								if (_LC.executeVpe) {
									_LyteComponent.viewPortSettings.executePendingViewPortElements();
									_LC.executeVpe = false;
								}
								for (var i = 0, item; item = _LC.dcc[i]; i++) {
									item.actualDisconnected();
								}
							} catch (e) {}
							_LC.dcc = undefined;
						});
					});
				}
				_LC.dcc.push(this);
				// var self = this;
				// setTimeout(function() {
				//     self.actualDisconnected();
				// },0);
				if (this.lazyYield) {
					this.removeEventListener("onReady", this.registerParentYield);
				}
				this.constructor.activeInstances--;
			}
		}], [{
			key: 'updateValue',
			value: function updateValue(property, path, value) {
				var pathVals = path.split('.');
				var context = property;
				for (var _i44 = 0; _i44 < pathVals.length - 1; _i44++) {
					context = context[pathVals[_i44]];
				}
				context[pathVals[i]] = value;
			}

			//    static createDocFragment(template){
			//        let childNodes = template.cloneNode(true,"lyte").childNodes;
			////           let childNodes = template.childNodes;
			//        let frag = document.createDocumentFragment();
			//        let len = childNodes.length;
			//        for(let i=0; i<len; i++){
			//            frag.appendChild(childNodes[0]);
			//        }
			//        return frag;
			//    }

		}, {
			key: 'createDocFragment1',
			value: function createDocFragment1(template) {
				if (template.content) {
					return template.content;
				}
				var childNodes = template.childNodes;
				var frag = createDocFragment();
				var len = childNodes.length;
				for (var _i45 = 0; _i45 < len; _i45++) {
					frag.appendChild(childNodes[0]);
				}
				return frag;
			}
		}, {
			key: '_registerComponent',
			value: function _registerComponent(a, b) {
				var componentsDiv = _LC.lyteComponentsDiv;
				var styleDiv = _Lyte.$.assetsDiv;
				var origTemplateValue = this._template;
				var clonedDummyTemp;
				if (this._template && typeof this._template === "string") {
					this._template.replace(/\\'/g, "'");
					var div = createElement("div");
					div.innerHTML = this._template;
					while (div.firstChild) {
						if (div.firstChild.nodeName === "STYLE") {
							if (styleDiv.querySelector("style[from-component='" + a + "']")) {
								styleDiv.querySelector("style[from-component='" + a + "']").remove();
							}
							div.firstChild.setAttribute("from-component", a);
							styleDiv.appendChild(div.firstChild);
						} else {
							componentsDiv.appendChild(div.firstChild);
						}
					}
					/*        } else if(document.querySelector("#" + a)) { */
				} else if (document.querySelector("template[tag-name='" + a + "']")) {
					componentsDiv.appendChild(document.querySelector("template[tag-name='" + a + "']"));
				}
				this._template = componentsDiv.querySelector("template[tag-name='" + a + "']");
				this._helperTemplate = document.createElement("template");
				this._helperTemplate.setAttribute("_lyteht", a);
				_LC.h1Div.content.appendChild(this._helperTemplate);
				if (!this._template) {
					return;
				}
				if (_LC.needDummyComponentsDiv) {
					if (_Lyte._ie) {
						var temp = _Lyte.Compile.getTemplateFromString(origTemplateValue);
						_LC.dummyLyteComponentsDiv.appendChild(temp);
					} else {
						clonedDummyTemp = this._template.cloneNode(true);
					}
				}
				if (this._template && !this._template.content) {
					//            var frag = document.createDocumentFragment();
					//            let childNodes = this._template.cloneNode(true,"lyte").childNodes;
					//            //let childNodes = this._template.childNodes;
					//            let len = childNodes.length;
					//            for(let i=0; i<len; i++){
					//                frag.appendChild(childNodes[0]);
					//            }
					//            this._template.content = frag;
				}
				var hasUnbound = this._observedAttributes.indexOf("lyteUnbound") !== -1;
				var s = _Lyte._ie ? this._template : this._template.content; //)?this._template.content:document.createDocumentFragment(this._template);
				//This is used to split text nodes which contain multiple dynamic values 
				//Eg." Name is {{name}} and age is {{age}} "
				var newCompile;
				if (hasUnbound) {
					if (_Lyte._ie) {
						newCompile = document.createElement("div");
						newCompile.innerHTML = this._template.outerHTML;
						newCompile = newCompile.childNodes[0];
					} else {
						newCompile = this._template.cloneNode(true);
					}
				}
				this.splitTextNodes(s);
				if (hasUnbound) {
					this.splitTextNodes(newCompile);
				}
				//This is used to find the dynamicNodes and helper nodes for the given component. 
				if (!this._dynamicNodes) {
					if (_Lyte.Compile.getDynamicNodes) {
						var returnVal = _Lyte.Compile.getDynamicNodes(a, undefined, _Lyte._ie ? s : undefined);
						if (returnVal.errors) {
							console.error("Error in the component", returnVal.componentName, returnVal.errors);
							return false;
						} else {
							this._dynamicNodes = returnVal.dynamicNodes;
						}
					} else {
						_Lyte.error("LC002", a);
					}
				}
				if (this._dynamicNodes) {
					doCompile(s, this._dynamicNodes, a, this, newCompile ? _Lyte._ie ? newCompile : newCompile.content : undefined);
					if (_Lyte._ed) {
						this._tC = this._template.outerHTML;
					} else if (_Lyte._ie) {
						this._tC = s.outerHTML;
					}
					this._templateAttributes = this._templateAttributes || { type: "attr", "attr": {}, position: [] };
					var ta = [this._templateAttributes];
					doCompile(this._template, ta, a, this);
					this._templateAttributes = ta[0];
					if (this._templateAttributes && this._templateAttributes.attr) {
						var attributesT = this._template.attributes;
						try {
							for (var _i46 = 0; _i46 < attributesT.length; _i46++) {
								var attrName = attributesT[_i46].name;
								if (!this._templateAttributes.attr[attrName] && attrName !== "tag-name" && attrName !== "use-strict") {
									this._templateAttributes.attr[attrName] = { "name": attrName, "staticValue": attributesT[_i46].value };
									this._template.removeAttribute(attrName);
									clonedDummyTemp && clonedDummyTemp.removeAttribute(attrName);
									_i46--;
								}
							}
						} catch (e) {
							_Lyte.error("Error with templateAttributes. ");
						}
					}
				}
				clonedDummyTemp && _LC.dummyLyteComponentsDiv.appendChild(clonedDummyTemp);
				this._sta = newCompile ? _LC.processStatic(newCompile) : undefined;
			}
			//This is used to split text nodes which contain multiple dynamicNodes. 

		}, {
			key: 'splitTextNodes',
			value: function splitTextNodes(node) {
				if (node && node.childNodes && node.childNodes.length) {
					for (var _i47 = node.childNodes.length - 1; _i47 >= 0; _i47--) {
						this.splitTextNodes(node.childNodes[_i47]);
					}
				}
				if (node.tagName === "TEMPLATE" && !_Lyte._ie) {
					this.splitTextNodes(node.content);
				}
				if (node.nodeType === node.TEXT_NODE) {
					var _nodeValue4 = node.nodeValue;
					if (_nodeValue4) {
						var mustacheValues = _nodeValue4.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
						if (!mustacheValues) {
							return;
						}
						var newNodeArray = [];
						for (var _i48 = 0; _i48 < mustacheValues.length; _i48++) {
							var mustacheStartIndex = _nodeValue4.indexOf(mustacheValues[_i48]);
							var mustacheEndIndex = mustacheStartIndex + mustacheValues[_i48].length;
							if (mustacheStartIndex) {
								newNodeArray.push(document.createTextNode(_nodeValue4.substring(0, mustacheStartIndex)));
							}
							newNodeArray.push(document.createTextNode(_nodeValue4.substring(mustacheStartIndex, mustacheEndIndex)));
							_nodeValue4 = _nodeValue4.substring(mustacheEndIndex);
						}
						if (!(!_nodeValue4.trim() && node.nextSibling && node.nextSibling.nodeType === 3 && !node.nextSibling.nodeValue.trim())) {
							newNodeArray.push(document.createTextNode(_nodeValue4));
						}
						//Fix for IE Edge issue with higher versions where node.replaceWith is not working when the parent is a doc fragment.
						if (_Lyte._rwpf && node.parentNode.nodeName === "#document-fragment") {
							for (var _i49 = 0; _i49 < newNodeArray.length; _i49++) {
								_insertBefore(node.parentNode, newNodeArray[_i49], node);
							}
							node.remove();
						} else {
							node.replaceWith.apply(node, newNodeArray);
						}
					}
				}
			}
		}, {
			key: 'observedAttributes',
			get: function get() {
				var newArr = [];
				for (var _i50 = 0; _i50 < this._observedAttributes.length; _i50++) {
					newArr[_i50] = _LC.String.dasherize(this._observedAttributes[_i50]);
				}

				_LC.customPropHandlers.forEach(function (item, index) {
					newArr.push(_LC.String.dasherize(item));
				});
				return newArr;
			}
		}]);

		return customElementPrototype;
	}(elementPrototype);

	var LyteComponent = {
		"fRP": {},
		"fRC": 0,
		// "frcUnused" : [],
		"customPropRegex": "",
		// "pushFrc" : function(fastRenderIndex) {
		//     this.frcUnused.push(fastRenderIndex);
		//     delete _LC.fRP[fastRenderIndex];
		// },
		// "getFrc" : function() {
		//     let frcIndex;
		//     if(this.frcUnused.length) {
		//         frcIndex = this.frcUnused.shift()
		//     } else {
		//         frcIndex = this.fRC++;
		//     }
		//     return frcIndex;
		// },
		"customPropHandlers": [],
		"_registeredComponents": {},
		"_reRegisteredComponents": [],
		"toBeRegistered": [],
		"updateCustomCrmComponent": function updateCustomCrmComponent(def, customCrmComponent) {
			for (var _key29 in def) {
				if (def[_key29] && def[_key29].type === "observer") {
					def[_key29].fnName = _key29;
					customCrmComponent._observers.push(def[_key29]);
				} else if (def[_key29] && def[_key29].type === "callBack") {
					var props = def[_key29].properties;
					for (var k = 0; k < props.length; k++) {
						if (!customCrmComponent._callBacks[props[k]]) {
							customCrmComponent._callBacks[props[k]] = [];
						}
						def[_key29].fnName = _key29;
						customCrmComponent._callBacks[props[k]].push(def[_key29]);
					}
					if (def[_key29].observes) {
						def[_key29].observes.fnName = _key29;
						customCrmComponent._observers.push(def[_key29].observes);
					}
				} else {
					customCrmComponent.component.prototype[_key29] = def[_key29];
				}
			}
			return def;
		},
		"dataFromMixin": function dataFromMixin(mixinsToBeUsed, actionsFromMixin, methodsFromMixin, newDefinition) {
			var mixinslen = mixinsToBeUsed.length;
			for (var _i51 = 0; _i51 < mixinslen; _i51++) {
				for (var item in mixinsToBeUsed[_i51]) {
					if (item === "actions") {
						Object.assign(actionsFromMixin, mixinsToBeUsed[_i51][item]);
					} else if (item === "methods") {
						Object.assign(methodsFromMixin, mixinsToBeUsed[_i51][item]);
					} else {
						newDefinition[item] = mixinsToBeUsed[_i51][item];
					}
				}
			}
			return { "actionsFromMixin": actionsFromMixin, "methodsFromMixin": methodsFromMixin, "newDefinition": newDefinition };
		},
		"throwEvent": function throwEvent(eventName) {
			var self = this.$node ? this.$node : this;
			var evt = self._actions ? self._actions[eventName] : undefined;
			var customArgs = [];
			if (arguments.length > 1) {
				for (var _i52 = 1; _i52 < arguments.length; _i52++) {
					customArgs.push(arguments[_i52]);
				}
			}
			//wait for release
			//eventName = _LC.String.toCamelCase(eventName);
			_LC.throwAction.call(self, self._callee, eventName, undefined, true, customArgs, self);
			if (this.$node) {
				self.dispatchEvent(evt ? evt : new CustomEvent(eventName, { "detail": customArgs }));
			}
		},
		//this and scope reference should be either a node or a route.
		"throwAction": function throwAction(scope, eventName, actObj, isCustom, customArgs, node, event, hasHandled, fromEv) {
			var actionsObj = void 0;
			if (this._route && isCustom) {
				scope = _Lyte.Router.getRouteInstance(this._route);
				actionsObj = scope.actions || (scope.actions = {});
			} else if (this.routeName) {
				//process for the parent route and get the current component and proceed;
				var parentRoute = this.parent;
				if (parentRoute) {
					if (parentRoute.component) {
						scope = parentRoute.component;
						actionsObj = scope.constructor._actions;
					} else {
						scope = parentRoute;
						actionsObj = scope.actions || (scope.actions = {});
					}
				}
			} else if (scope) {
				actionsObj = scope.constructor._actions;
			}
			if (!scope) {
				//Only warning is thrown because, we can have a eventListener for the dom directly. 
				if (!hasHandled) {
					_Lyte.warn("Nothing handled the action " + eventName + ".");
				}
				return;
			}
			actObj = actObj ? actObj : this._actions && this._actions[eventName] ? this._actions[eventName].processAction : void 0;
			//wait for release
			/* 
   var dasherizedEventName = _LC.String.dasherize(eventName);
   actObj = (actObj) ? actObj : this._actions && this._actions[dasherizedEventName]? this._actions[dasherizedEventName].processAction : void 0;     
   */
			var args = customArgs ? customArgs : [];
			if (actObj) {
				var contextSwitchArray = [];
				if (node) {
					_LC.adCx(node, contextSwitchArray);
				}
				var concatArgs = void 0;
				if (actObj.skipArgProcessing) {
					// concatArgs = _Lyte.deepCopyObject(actObj.args);
					// concatArgs.shift();
					// var eventIndex = concatArgs.indexOf("__lyteEvent__");
					// var nodeIndex = concatArgs.indexOf("__lyteNode__");
					// if(eventIndex !== -1) {
					//     concatArgs[eventIndex] = event;
					// } 
					// if(nodeIndex !== -1) {
					//     concatArgs[nodeIndex] = target;
					// }
					concatArgs = actObj.args;
				} else {
					concatArgs = this.processArgs(scope, { "helperInfo": actObj }, undefined, event, node);
				}
				args.splice.apply(args, [0, 0].concat(concatArgs));
				if (node) {
					_LC.rmCx(node, contextSwitchArray);
				}
				if (actionsObj[actObj.name]) {
					if (!isCustom) {
						//args.unshift(window.event);
						var parent = node.parentNode;
						var val = actionsObj[actObj.name].apply(this.component, args);
						if (event.currentTarget !== document.body && !fromEv) {
							val = false;
						}
						hasHandled = true;
						if (val !== false && !event.cancelBubble) {
							if (actObj.from && node.getAttribute(event.type) && node._boundEvents && node._boundEvents[event.type]) {
								var actions = node._callee.constructor._actions;
								var _actObj3 = node._boundEvents[event.type];
								var cloneActObj = _Lyte.deepCopyObject(_actObj3);
								// cloneActObj.args.shift();
								_LC.skipArgProcessing(cloneActObj, event, node);
								_LC.throwAction.call(node._callee, node._callee, event.type, cloneActObj, undefined, undefined, node, event, hasHandled);
							} else {
								if (_LC.hasLyteEvents(node, eventName)) {
									var eventStopped = _LC.handleLyteEvents(node, event);
									val = eventStopped ? false : true;
								}
								if (val === false) {
									return;
								}
								if (_LC.isCustomElement(node)) {
									scope = parent;
								}
								if (parent) {
									var _eventStopped = void 0;
									while (parent && (!parent.getAttribute(eventName) || parent.hasAttribute("disabled")) && parent.tagName != "BODY") {
										if (_LC.hasLyteEvents(parent, eventName)) {
											_eventStopped = _LC.handleLyteEvents(parent, event);
											if (_eventStopped) {
												break;
											}
										}
										parent = parent.parentNode;
									}
									if (_eventStopped || !parent || parent.tagName === "BODY") {
										return;
									}
									if (!parent._callee) {
										parent._callee = parent.getCallee ? parent.getCallee(parent) : _LC.getCallee(parent);
									}
									if (parent && event.type === eventName && !event.cancelBubble) {
										if (parent._evBoundEvents && parent._evBoundEvents[eventName]) {
											var _actObj4 = parent._evBoundEvents[eventName];
											var _cloneActObj3 = _Lyte.deepCopyObject(_actObj4);
											//    cloneActObj.args.shift();
											_LC.skipArgProcessing(_cloneActObj3, event, parent);
											_LC.throwAction.call(parent, parent, eventName, _cloneActObj3, undefined, undefined, parent, event, hasHandled);
										} else if (parent && parent._boundEvents && parent._boundEvents[eventName]) {
											var _actObj5 = parent._boundEvents[eventName];
											var _cloneActObj4 = _Lyte.deepCopyObject(_actObj5);
											_LC.skipArgProcessing(_cloneActObj4, event, parent);
											_LC.throwAction.call(parent._callee, parent._callee, eventName, _cloneActObj4, undefined, undefined, parent, event, hasHandled);
										}
									}
								}
							}
						}
					} else {
						actionsObj[actObj.name].apply(this._callee.component, args);
						hasHandled = true;
					}
				} else {
					_Lyte.error("LC004", actObj.name);
				}
			} else if (isCustom) {
				var eventsObj = actionsObj[eventName] || actionsObj[_LC.String.toCamelCase(eventName)] || actionsObj[_LC.String.dasherize(eventName)];
				if (eventsObj) {
					var scopeS = _LC.isCustomElement(scope) ? scope.component : scope;
					var _val = eventsObj.apply(scopeS, args);
					//let val = eventsObj.apply(_LC.isCustomElement(scope)? scope.component : scope, args);
					hasHandled = true;
					if (_val !== false) {
						_LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
					}
				} else {
					_LC.throwAction.call(scope, scope._callee, eventName, actObj, isCustom, customArgs, undefined, undefined, hasHandled);
				}
			}
		},
		"isControlHelper": function isControlHelper(ownerElement) {
			return ownerElement.tagName === "TEMPLATE" && ownerElement.getAttribute("is") && ownerElement.getAttribute("is") !== "component" || ownerElement.hasAttribute("lyte-for") || ownerElement.hasAttribute("lyte-if") || ownerElement.hasAttribute("lyte-switch") || ownerElement.hasAttribute("lyte-forin");
		},
		"isCustomElement": function isCustomElement(node, isTemplate) {
			return node.hasAttribute && ((node.tagName === "TEMPLATE" || node.attributes["lyte-for"] || node.attributes["lyte-if"] || node.attributes["lyte-switch"] || node.attributes["lyte-forin"]) && isTemplate || node.nodeName && node.nodeName.indexOf('-') !== -1 && (_LyteComponent.registeredComponents[node.localName] || node.tagName === "LYTE-YIELD"));
		},
		"componentSet": function componentSet(key, value, options, forceExecute, fromParent) {
			if (!forceExecute && this.get(key) === value) {
				_LC.clearError(this.data, key);
				return;
			}
			//temporary fix
			_LC.set(this.data, key, value, options, undefined, fromParent);
		},
		"componentGet": function componentGet(key) {
			return key ? _LC.get(this.data, key) : this.data;
		},
		"nodeGet": function nodeGet(key) {
			return key ? this.component.get(key) : this.component.data;
		},
		"nodeSet": function nodeSet(key, value, options, fromParent) {
			this.component.set(key, value, options, undefined, fromParent);
		},
		"registerComponentWrapper": function registerComponentWrapper() {
			try {
				var rt = _LC.registerComponent.apply(_LC, arguments);
				Lyte._postRegister();
				return rt;
			} catch (e) {
				Lyte._postRegister();
			}
		},
		"registerComponent": function registerComponent(componentName, definition, options) {
			if (_LC._reRegisteredComponents.indexOf(componentName) == -1 && _LyteComponent.registeredComponents[componentName]) {
				_Lyte.warn("Component " + componentName + " already registered");
				return;
			}
			var customCrmComponent = void 0;
			var alreadyRegistered = void 0;
			if (_LC._registeredComponents[componentName]) {
				customCrmComponent = _LC._registeredComponents[componentName];
				alreadyRegistered = true;
			} else {
				customCrmComponent = function (_customElementPrototy) {
					_inherits(customCrmComponent, _customElementPrototy);

					function customCrmComponent() {
						_classCallCheck(this, customCrmComponent);

						return _possibleConstructorReturn(this, (customCrmComponent.__proto__ || Object.getPrototypeOf(customCrmComponent)).apply(this, arguments));
					}

					return customCrmComponent;
				}(customElementPrototype);
				customCrmComponent._properties = {};
				customCrmComponent.activeInstances = 0;
				customCrmComponent._depthTemp = document.createElement("template");
				customCrmComponent.prototype.throwAction = this.throwAction;
				customCrmComponent.compName = componentName;
			}
			// customCrmComponent.prototype.setData = function(arg0, arg1 ,options) {
			//     return this.component.setData(arg0, arg1, options);
			// }
			// customCrmComponent.prototype.getData = function(arg0) {
			//     return this.component.getData(arg0);
			// }
			Object.defineProperty(customCrmComponent.prototype, "setData", {
				configurable: true,
				writable: true,
				value: function value(arg0, arg1, options) {
					return this.component.setData(arg0, arg1, options);
				}
			});

			Object.defineProperty(customCrmComponent.prototype, "getData", {
				configurable: true,
				writable: true,
				value: function value(arg0) {
					return this.component.getData(arg0);
				}
			});

			Object.defineProperty(customCrmComponent.prototype, "setMethods", {
				configurable: true,
				writable: true,
				value: function value(arg0, arg1) {
					return this.component.setMethods(arg0, arg1);
				}
			});

			customCrmComponent.prototype.get = this.nodeGet;
			customCrmComponent.prototype.set = this.nodeSet;
			customCrmComponent._bindsIds = [];
			options = options ? options : {};
			var mixinsToBeUsed = [];
			// let serviceToBeUsed = {};
			var laterToBeUsed = {};

			var toBeUsed = {};
			// serviceToBeUsed = Object.assign({},Lyte.toBeInjectedServices);
			for (var key in options) {
				if (key == "services") {
					toBeUsed[key] = {};
					options.services.forEach(function (service) {
						if (typeof service == "string") {
							toBeUsed[key][service] = service;
						} else if (service && (typeof service === 'undefined' ? 'undefined' : _typeof(service)) === "object") {
							var srKey = service.as,
							    srVal = service.service;
							if (!Lyte._keywords.is(srKey, "component")) {
								if (!service.scope || service.scope == "static") {
									toBeUsed[key][srKey] = srVal;
								} else if (service.scope == "instance") {
									var srKey = service.as,
									    srVal = service.service;
									laterToBeUsed[key] = laterToBeUsed[key] || {};
									laterToBeUsed[key][srKey] = srVal;
								}
							} else {
								Lyte.warn("Service cannot be used in any keywords of Lyte.");
							}
						}
					});
				}
				if (key == "mixins") {
					toBeUsed[key] = [];
					options.mixins.forEach(function (element) {
						if (Lyte.Mixin.exists(element)) {
							toBeUsed[key].push(Lyte.registeredMixins[element]);
						} else {
							Lyte.$.requiredMixins(element, componentName, "component");
						}
					});
				}

				if (key == "ssr") {
					customCrmComponent._ssr = options[key];
					if (options[key].config) {
						customCrmComponent._config = options[key].config;
					}
				}
			}
			function Component() {
				this.$ = {
					"validate": function validate() {
						var compInstance = this._ins;
						var data = compInstance.data;
						for (var key in data) {
							_LC.handleValidation(data, key, data[key], compInstance);
						}
					},
					getError: function getError(path) {
						return _LC.getErrorStructure(this.ins, path);
					}
				};
				this.$._ins = this;
			}
			customCrmComponent.component = Component;
			var compPrototype = Component.prototype;
			compPrototype.$lg = Lyte.__gl;
			compPrototype.set = this.componentSet;
			compPrototype.get = this.componentGet;
			if (window.requireValidateInComponent) {
				compPrototype.validate = function () {
					var data = this.data;
					for (var key in data) {
						_LC.handleValidation(data, key, data[key], this);
					}
				};
			}
			compPrototype.throwEvent = this.throwEvent;
			compPrototype.executeMethod = _LC.executeMethod;
			compPrototype.getData = _LC.componentGetData;
			compPrototype.setData = _LC.componentSetData;
			compPrototype.getMethods = _LC.componentGetMethods;
			compPrototype.setMethods = _LC.componentSetMethods;
			compPrototype.hasAction = _LC.componentHasAction;
			compPrototype.setActions = _LC.componentsetActions;
			customCrmComponent._mixins = options.mixins;
			customCrmComponent._serviceToBeUsed = laterToBeUsed ? laterToBeUsed.services : undefined;
			var actionsFromMixin = {};
			var ltInjServ = Lyte.toBeInjectedServices;
			if (ltInjServ) {
				for (var injServ in ltInjServ) {
					Lyte.$.injectServices.component(injServ, ltInjServ[injServ], undefined, Lyte.__gS[injServ], customCrmComponent);
				}
			}
			for (var tKey in toBeUsed) {
				if (tKey == "mixins") {
					var aFromMixin = {},
					    methodsFromMixin = {},
					    newDefinition = {};
					_LC.dataFromMixin(toBeUsed.mixins, actionsFromMixin, methodsFromMixin, newDefinition);
					definition = Object.assign(newDefinition, definition);
					actionsFromMixin = Object.assign(actionsFromMixin, aFromMixin);
				} else if (tKey == "services") {
					var serviceToBeUsed = toBeUsed[tKey];
					for (var serv in serviceToBeUsed) {
						if (Lyte.registeredServices.hasOwnProperty(serviceToBeUsed[serv])) {
							definition[serv] = new Lyte.registeredServices[serviceToBeUsed[serv]]();
						} else {
							Lyte.$.requiredServices(serv, serviceToBeUsed[serv], function (serviceData, serviceKey) {
								var customCrmComponent = _LC._registeredComponents[componentName];
								customCrmComponent.component.prototype[serviceKey] = new serviceData();
							});
						}
					}
				}
			}
			customCrmComponent._actions = Object.assign({}, actionsFromMixin, definition.actions);
			customCrmComponent._template = definition._template;
			delete definition._template;
			customCrmComponent._dynamicNodes = definition._dynamicNodes;
			delete definition._dynamicNodes;
			customCrmComponent._templateAttributes = definition._templateAttributes;
			delete definition._templateAttributes;
			customCrmComponent._callBacks = {};
			customCrmComponent._observers = [];
			//            let properties = definition.data ? definition.data : {};
			var properties = definition.data ? definition.data : undefined;
			var methods = Object.assign({}, methodsFromMixin, definition.methods);
			//            customCrmComponent._observedAttributes = Object.keys(properties);
			customCrmComponent._observedAttributes = definition._observedAttributes || [];
			customCrmComponent._observedMethodAttributes = definition._observedMethodAttributes || {};
			customCrmComponent._deepWatchProperties = definition._deepWatchProperties || {};
			delete definition._observedAttributes;
			delete definition._observedMethodAttributes;
			delete definition.data;
			delete definition.methods;
			definition = _LC.updateCustomCrmComponent(definition, customCrmComponent);
			customCrmComponent._data = properties;
			customCrmComponent._methods = methods;
			customCrmComponent._registerComponent(componentName, customCrmComponent);
			_LyteComponent.registeredComponents[componentName] = true;
			if (!_LC._registeredComponents[componentName]) {
				if (document.readyState === "complete" || document.readyState === "interactive") {
					// document is already ready to go
					customElements.define(componentName, customCrmComponent);
				} else {
					_LC.toBeRegistered.push({ name: componentName, def: customCrmComponent });
				}
			}
			var depthTemp = customCrmComponent._depthTemp;
			if (!_LC._ie && depthTemp && depthTemp.content.childNodes.length) {
				depthTemp.setAttribute("data-id", "depthTemp_" + componentName);
				_LC.lyteComponentsDiv.appendChild(depthTemp);
			} else {
				delete customCrmComponent._depthTemp;
			}
			_LC._registeredComponents[componentName] = customCrmComponent;
			if (alreadyRegistered) {
				var pendingComps = customCrmComponent._pendingComponents || [];
				pendingComps.forEach(function (item) {
					delete item.__lyteIgnore;
					item.actualConstructor();
					var arr = Array.from(item.attributes);
					arr.forEach(function (attr) {
						if (item.constructor.observedAttributes.indexOf(attr.name) != -1) {
							item.attributeChangedCallback(attr.name, null, attr.value);
						}
					});
					item.connectedCallback();
				});
				customCrmComponent._pendingComponents = [];
			}
			return customCrmComponent;
		},
		"registerHelper": function registerHelper(name, helper) {
			_LyteComponent.registeredHelpers[name] = helper;
		},
		"registerMixin": function registerMixin(name, mixin) {
			_Lyte.Mixin.register.call(_Lyte, name, mixin);
		},
		"typeCast": function typeCast(value, dataType, obj) {
			if (value === null) {
				return value;
			}
			try {
				switch (dataType) {
					case "string":
						return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === "object" ? JSON.stringify(value) : value.toString();
						break;
					case "number":
						{
							if (value == "") {
								return undefined;
							}
							var val = +value;
							if (isNaN(val)) {
								throw "TypeCast exception";
							}
							return val;
						}
						break;
					case "array":
					case "object":
						return JSON.parse(value);
						break;
					case "boolean":
						return !value && value !== "" || value === "false" ? false : true;
						break;
					default:
						return value;
				}
			} catch (e) {
				if (obj) {
					obj.isError = true;
				}
				return value;
			}
		},
		"sendtoclient": function sendtoclient(prop, server, node) {
			var data = server ? prop.component.data : prop;
			var newData = {};
			var data_prop = node;
			for (var i in data) {
				if (server) {
					var def = prop.component.__data[i];
					if (i == "bindIds") {
						newData[i] = { value: data[i] };
					}
					if (def && /^(object|array)$/.test(def.type) && prop._attributeDetails && prop._attributeDetails.hasOwnProperty(LyteComponent.String.dasherize(i))) {
						newData[i] = { "fP": true };
					} else if (data[i] instanceof Date) {
						newData[i] = { "value": data[i], "type": "Date" };
					} else if (data_prop[i]) {
						newData[i] = { "value": data[i], "type": data_prop[i].type };
					} else {
						var type = _typeof(data[i]);
						if (data[i] == undefined) {
							type = undefined;
						}
						newData[i] = { "value": data[i], "type": type };
					}
				} else {
					if (data[i].type == "Date") {
						newData[i] = new Date(data[i].value);
					} else if (!data[i].fP) {
						newData[i] = data[i].value;
					}
				}
			}
			return newData;
		},
		"getDataType": function getDataType(value) {
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			if (type === "object") {
				if (Array.isArray(value)) {
					return "array";
				}
			}
			return type;
		},
		"handleValidation": function handleValidation(object, property, value, component, init) {
			var error = _Lyte.validate(object, property, value, component, init);
			if (error) {
				_LC.set(component.data.errors, property, error);
				if (component.$node.callback) {
					component.$node.callback("onError", property, error);
				}
			} else {
				_LC.clearError(object, property);
			}
			return error;
		},
		"clearError": function clearError(data, property) {
			if (data.errors && data.errors[property]) {
				_Lyte.objectUtils(data.errors, "delete", property);
			}
		},
		"createLyteId": function createLyteId(comp) {
			comp.__counter++;
			return "__lyteId" + comp.__counter;
		},
		"apdNode": function apdNode(node, comp) {
			_LC.tDiv.content.appendChild(node);
			var id = this.createLyteId(comp);
			comp.__h[id] = node;
			node.__lyteId = id;
		},
		"update": function update(object, property, value, options, fromStore, oldValue, setterScope, actualProperty, fromParent, storeRecord) {
			var fromComponent = object.__component__;
			var updateAttr = true;
			var dataType = void 0,
			    dataDef = void 0,
			    estObjBind = false;
			if (!oldValue) {
				oldValue = object[property];
				if (fromComponent && fromComponent.tagName !== "LYTE-YIELD") {
					dataDef = fromComponent.component.__data[property];
					if (dataDef && (dataType = dataDef.type)) {
						updateAttr = !dataDef.hideAttr;
						if (dataType !== _LC.getDataType(value) && (value !== undefined || dataType === "boolean")) {
							value = _LC.typeCast(value, dataType);
						}
					}
					if (value === oldValue) {
						_LC.clearError(object, property);
						return;
					}
					if (!options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) == "object" && options.skipValidation != true) {
						var error = _LC.handleValidation(object, property, value, fromComponent.component);
						if (error) {
							return;
						}
					}
				}
				//object[property] = value;
				if (!object.hasOwnProperty(property) && !Array.isArray(object)) {
					_LC.oF(object, "add", property, value, true);
				} else {
					object[property] = value;
				}
			}
			var toBeExecuted = fromComponent ? true : false;
			var dasherizedAttr = _LC.String.dasherize(property);
			var callDeepObs = false;
			if (object._scp) {
				if (!Lyte.cmpData(oldValue, value)) {
					callDeepObs = true;
				}
				if (oldValue && (Array.isArray(oldValue) || (typeof oldValue === 'undefined' ? 'undefined' : _typeof(oldValue)) == "object")) {
					var keys = Array.from(object._scp.keys());
					keys.forEach(function (id) {
						var nestObj = Lyte.nestScp[id];
						var isCyclic = nestObj.cyclic;
						Lyte.removeNestScp(oldValue, id);
						if (isCyclic) {
							Lyte.bindObj(nestObj._data, undefined, id, [], new Map(), undefined, undefined, true);
						}
					});
				}
			}
			if (Lyte.isRecord(object) && object.$.__scpObj || object.hasOwnProperty("__component__") && object.__component__.__scpObj) {
				var _scpObj, kmpKey;
				if (Lyte.isRecord(object)) {
					_scpObj = object.$.__scpObj;
					kmpKey = object;
				} else {
					_scpObj = object.__component__.__scpObj;
					kmpKey = object.__component__;
				}
				if (_scpObj.hasOwnProperty(property)) {
					var _sId = _scpObj[property].split("_");
					Lyte.removeNestScp(oldValue, _sId[0], _sId[1], undefined, kmpKey, undefined, Lyte.isRecord(value) || Array.isArray(value) && value.model && value.add ? value : undefined);
					delete _scpObj[property];
				}
			}
			var customDtype;
			if (dataDef && Lyte.Transform[dataDef.type]) {
				var customDataType = Lyte.Transform[dataDef.type];
				if (/^(object|array)$/.test(customDataType.extends) && (customDataType.hasOwnProperty("properties") || customDataType.hasOwnProperty("items"))) {
					customDtype = true;
				}
			}
			if (fromStore && Lyte.isRecord(object) || object && object.hasOwnProperty("_scp") && object._scp.size || dataDef && /^(object|array)$/.test(dataDef.type) && dataDef.watch == true || customDtype) {
				Lyte.establishObjectBinding(object, property, fromStore, true, storeRecord, dataDef && dataDef.watch ? dataDef.watch : undefined);
			}
			if (fromComponent && actualProperty && (typeof value === "string" && fromComponent.getAttribute(dasherizedAttr) !== value || fromComponent.hasAttribute(dasherizedAttr))) {
				if ((!_LC.customPropRegex.exec(property) || fromComponent.hasAttribute(dasherizedAttr)) && updateAttr) {
					if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === "object") {
						var jsonString = void 0;
						try {
							jsonString = JSON.stringify(value);
							fromComponent.attributes.getNamedItem(dasherizedAttr).__lyteIgnore = true;
							fromComponent.setAttribute(dasherizedAttr, jsonString);
						} catch (e) {}
					} else {
						var attributeString = _LC.typeCast(value, "string");
						if (fromComponent.getAttribute(dasherizedAttr) !== attributeString) {
							var detAttr = fromComponent.attributes.getNamedItem(dasherizedAttr);
							if (detAttr) {
								detAttr.__lyteIgnore = true;
							}
							attributeString = attributeString || "";
							fromComponent.setAttribute(dasherizedAttr, attributeString);
						}
					}
				}
			}
			if (value && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
				//newValue is of type object 

				if (oldValue && (typeof oldValue === 'undefined' ? 'undefined' : _typeof(oldValue)) === "object" && oldValue._bindings) {
					//Both oldValue and newValue are objects. 
					if (!value._bindings) {
						defProp(value, "_bindings", {
							enumerable: false,
							writable: true,
							value: new Set(),
							configurable: true
						});
					}
					//for changing only child component
					if (fromComponent && fromComponent.component.data === object && property.indexOf('.') === -1) {
						var bindings = fromComponent.getProperty(property);
						this.removeSelectedBindingDeep(bindings, oldValue);
						addBindings(value._bindings, bindings);
						this.establishBindings(bindings, value);
						//For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
						if (bindings._forHelpers) {
							var bindfor = bindings._forHelpers.toArrayLyte();
							for (var i = 0; i < bindfor.length; i++) {
								var item = bindfor[i];
								if (item._propBindingObject) {
									this.removeSelectedBindingDeep(item._propBindingObject, oldValue);
									//                                  value._bindings.add(item._propBindingObject);
									//                                  this.establishBindings(item._propBindingObject, value);
								}
							}
						}
						this.affectChanges(bindings, undefined, oldValue, setterScope, object[property]);
					} else {
						//To change only the bindings present in the object and not all the bindings present in the oldValue.
						if (object._bindings) {
							var oldbind = object._bindings.toArrayLyte();
							for (var _i53 = 0; _i53 < oldbind.length; _i53++) {
								var _item = oldbind[_i53][property];
								if (_item) {
									this.removeSelectedBindingDeep(_item, oldValue);
									addBindings(value._bindings, _item);
									this.establishBindings(_item, value);
									//For removing binding in the object due to forIn Helper ( actual object binding and not the _dynamicNodes binding).
									if (_item._forHelpers) {
										var forbind = _item._forHelpers.toArrayLyte();
										for (var j = 0; j < forbind.length; j++) {
											var itemBinding = forbind[j];
											if (itemBinding._propBindingObject) {
												this.removeSelectedBindingDeep(itemBinding._propBindingObject, oldValue);
											}
										}
									}
									this.affectChanges(_item, undefined, oldValue, setterScope, object[property]);
								}
							}
						}
					}
				} else {
					//newValue is object and oldValue is string. Hence establish bindings from oldValue's object and place it in the newValue. 
					if (object._bindings) {
						makeSet(value, "_bindings");
						var objbind = object._bindings.toArrayLyte();
						for (var _i54 = 0; _i54 < objbind.length; _i54++) {
							var _item2 = objbind[_i54];
							if (_item2[property]) {
								addBindings(value._bindings, _item2[property]);
								this.establishBindings(_item2[property], value);
								this.affectChanges(_item2[property], undefined, oldValue, setterScope, object[property]);
							}
						}
					}
				}
				dataDef = dataDef || (fromComponent && fromComponent.tagName !== "LYTE-YIELD" ? fromComponent.component.__data[property] : undefined);
				if (fromStore && Lyte.isRecord(object) || object && object.hasOwnProperty("_scp") && object._scp.size || dataDef && /^(object|array)$/.test(dataDef.type) && (dataDef.watch || dataDef.hasOwnProperty("items") || dataDef.hasOwnProperty("properties"))) {
					estObjBind = true;
				}
			} else {
				//newValue is string

				if (oldValue && (typeof oldValue === 'undefined' ? 'undefined' : _typeof(oldValue)) === "object" && oldValue._bindings && object._bindings) {
					//newValue is string and oldValue is object 
					var _objbind = object._bindings.toArrayLyte();
					for (var _i55 = 0; _i55 < _objbind.length; _i55++) {
						var _item3 = _objbind[_i55];
						if (_item3[property]) {
							//oldValue._bindings.delete(item[property]);
							//if(oldValue._bindings.size === 0) {
							//  delete oldValue._bindings;
							//  break;
							//}
							this.removeSelectedBindingDeep(_item3[property], oldValue);
							if (_item3[property]._forHelpers) {
								var _forbind = _item3[property]._forHelpers.toArrayLyte();
								for (var _j3 = 0; _j3 < _forbind.length; _j3++) {
									var _itemBinding = _forbind[_j3];
									if (_itemBinding._propBindingObject) {
										this.removeSelectedBindingDeep(_itemBinding._propBindingObject, oldValue);
									}
								}
							}
						}
					}
				}

				//when newValue and oldValue , both are string, no need to change bindings. 
				if (object._bindings) {
					var _objbind2 = object._bindings.toArrayLyte();
					for (var _i56 = 0; _i56 < _objbind2.length; _i56++) {
						var _item4 = _objbind2[_i56];
						if (_item4[property]) {
							this.affectChanges(_item4[property], undefined, oldValue, setterScope, object[property]);
						}
					}
				}
			}
			if (callDeepObs && object._scp) {
				this.callDeepObservers(object, { type: "deepChange", oldValue: oldValue, newValue: value }, property);
			}
			if (toBeExecuted && !fromParent && fromComponent._attributeDetails && fromComponent._callee) {
				//let syntaxValue = fromComponent.getAttributeNode(property).syntaxValue;
				var attrDetail = fromComponent._attributeDetails[_LC.String.dasherize(property)];
				var syntaxValue = void 0;
				if (attrDetail && attrDetail.isLbind) {
					syntaxValue = attrDetail.dynamicValue;
				}
				if (syntaxValue) {
					var contextSwitchArray = void 0;
					if (fromComponent._cx) {
						contextSwitchArray = [];
						_LC.changeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx);
					}
					var _obj7 = _LC.getNew(fromComponent._callee.component.data, syntaxValue);
					if (!_obj7.context) {
						return;
					}
					var exec = false;
					if (_obj7.context === fromComponent._callee.component.data) {
						if (fromComponent._callee._properties[_obj7.lastKey] && fromComponent._callee._properties[_obj7.lastKey].__fromComponent) {
							exec = true;
						}
					} else {
						exec = true;
					}
					//self.setData(this._lbind,this.value);
					if (exec) {
						var lastKeyIndex = +_obj7.lastKey;
						if (Array.isArray(_obj7.context) && typeof lastKeyIndex == "number") {
							var callReplaceAt = lastKeyIndex < _obj7.context.length;
							if (_obj7.context[lastKeyIndex] !== value || !callReplaceAt) {
								_LC.aF(_obj7.context, callReplaceAt ? "replaceAt" : "insertAt", lastKeyIndex, value);
							}
						} else {
							_LC.set(_obj7.context, _obj7.lastKey, value, options);
						}
					}
					if (contextSwitchArray) {
						_LC.removeContext(fromComponent._cx.node, contextSwitchArray, fromComponent._cx);
					}
				}
			}
		},
		"getContentForIE": function getContentForIE(content, constr, newlyCreated, info) {
			if (typeof content === "string") {
				newlyCreated = true;
				var div = createElement("div");
				div.innerHTML = content;
				content = div.childNodes[0];
				constr.splitTextNodes(content);
			}
			if (content.getAttribute && content.getAttribute("depth")) {
				if (Lyte._ms && info) {
					info._content = div;
				}
				var itr = parseInt(content.getAttribute("depth"));
				content = _Lyte._ie ? content : newlyCreated ? content.content : content.content.cloneNode(true);
				for (var i = 0; i < itr; i++) {
					content = content.childNodes[0];
				}
			}
			return content;
		},
		"replaceWithPf": function replaceWithPf(node1, node2) {
			if (_Lyte._rwpf) {
				_insertBefore(node1.parentNode, node2, node1);
				node1.remove();
			} else {
				node1.replaceWith(node2);
			}
		},
		"getCallee": function getCallee(callee, self) {
			while (callee && !_LC.isCustomElement(callee) && callee.tagName !== "LYTE-YIELD") {
				if (callee.tagName === "BODY") {
					callee = null;
					break;
				}
				callee = callee.parentNode;
			}
			if (callee && callee.tagName === "LYTE-YIELD") {
				return callee._registerYield ? callee._registerYield._callee : undefined;
			}
			return self === callee ? undefined : callee;
		},
		"set": function set(object, property, value, options, fromStore, fromParent) {
			var lastIndex = -1;
			var s_rec,
			    check = {},
			    recDottedProp;
			if (Lyte.isRecord(object) && fromStore) {
				s_rec = object;
			}
			if (!((typeof property === 'undefined' ? 'undefined' : _typeof(property)) === "object") || !property) {
				property = property + "";
				lastIndex = property.lastIndexOf('.');
			}
			var actualProperty = property;
			if (lastIndex !== -1) {
				var outerPropertyPath = property.substring(0, lastIndex);
				property = property.substring(lastIndex + 1);
				object = _LC.get(object, outerPropertyPath);
				recDottedProp = true;
			}
			if (typeof property === "string" && object[property] === value) {
				if (object.__component__) {
					_LC.clearError(object, property);
				} else if (_Lyte.isRecord(object) && !object.$.isCloned) {
					store.$.clrRecErr(object.$, property);
					object.$.emit ? object.$.emit("set", [object, property]) : undefined;
					object.$.model && object.$.model.emit ? object.$.model.emit("set", [object.$.model._name, object, property]) : undefined;
					store.emit ? store.emit("set", [object.$.model._name, object, property]) : undefined;
				}
				return;
			}
			var oldValues = [];
			if (object._setterScope) {
				var setterScope = object._setterScope;
			}
			var checkSim = false,
			    watch = [];
			if (object._scp && object._scp.size) {
				var keys = Array.from(object._scp.keys());
				keys.forEach(function (id) {
					var _obj = object._scp.get(id);
					obj = _obj.paths;
					var recObj = Lyte.nestScp[id],
					    model,
					    field,
					    rec,
					    attr,
					    wobj = {};
					var pathArr = Object.keys(obj),
					    aPath;
					if (pathArr.length > 1) {
						aPath = "*";
					} else if (pathArr.length == 1) {
						aPath = pathArr[0];
					}
					wobj.path = aPath;
					wobj.id = id;
					if (pathArr.length > 1) {
						wobj.paths = pathArr;
					}
					wobj.attr = attr;
					wobj.data = recObj.data;
					wobj.PropsInfo = recObj.PropsInfo || undefined;
					if (recObj.model) {
						var mMap = recObj.model;
						wobj.Error = recObj.Error;
						var mKeys = Array.from(recObj.model.keys());
						for (var i = 0; i < mKeys.length; i++) {
							var mName = mKeys[i];
							var pkMap = mMap.get(mName);
							if (pkMap) {
								var pkArr = Array.from(pkMap.keys());
								var pkLen = pkArr.length;
								for (var j = 0; j < pkLen; j++) {
									var mPk = pkArr[j];
									var attrMap = pkMap.get(mPk);
									var attrArr = Array.from(attrMap.keys());
									var attrLen = attrArr.length;
									for (k = 0; k < attrLen; k++) {
										var mAttr = attrArr[k];
										var mObj = Object.assign({}, wobj);
										var mRec = store.peekRecord(mName, mPk);
										if (mRec) {
											model = mRec.$.model;
											field = model.fieldList[mAttr];
											if (field && (field.properties || field.items || field.watch == true || Lyte.Transform[field.type])) {
												mObj.data = Lyte.deepCopyObject(mRec[mAttr]);
												mObj.rec = mRec;
												mObj.isRec = true;
												mObj.attr = mAttr;
												mObj.dtype = model.fieldList[mAttr];
												mObj._cmpErr = mRec.$.error;
												mObj.key = mAttr;
											}
											watch.push(mObj);
										}
									}
								}
							}
						}
					} else {
						watch.push(wobj);
					}
					// var isAttr = rec.$._attributes.hasOwnProperty(attr);
					// if(!isAttr){
					//     rec.$._attributes[attr] = Lyte.deepCopyObject(rec[attr]);
					// }
					// else{
					//     checkSim = true;
					// }
					// rec.$.isModified = true;          
				});
				watch.forEach(function (val) {
					if (!options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) == "object" && options.skipValidation != true) {
						var id = val.id,
						    path = val.path.split("."),
						    dtype = val.dtype,
						    errs;
						if (val.isRec) {
							if (fromStore) {
								path = actualProperty.split(".");
								path.splice(-1);
								path.shift();
							}
							path = path.length == 1 && path[0] == property ? [] : path;
							check.Prop = dtype;
							Lyte.checkNestedProp(id, path, dtype, val, object, property, value, check, fromStore);
						}
						if (val.PropsInfo) {
							val.PropsInfo.forEach(function (props) {
								props.path = val.path;
								props.attr = val.attr;
								dtype = props.dtype;
								check.Prop = dtype;
								Lyte.checkNestedProp(id, path, dtype, props, object, property, value, check, fromStore);
							});
						}
					}
				});
				if (check.value && check.value.code) {
					_Lyte.error("ERR35", check.Prop.type);
					return;
				}
			}
			actualProperty = actualProperty === property ? actualProperty : undefined;
			var shareObj = {};
			if ((typeof property === 'undefined' ? 'undefined' : _typeof(property)) === "object") {
				if (_Lyte.isRecord(object) && !fromStore && !object.$.isCloned) {
					// for(let key in property){
					//     if(Array.isArray(object[key])){
					//         oldValues.push({key:key,oldValue:object[key].slice(0)});    
					//     }
					//     else{
					//         oldValues.push({key:key,oldValue:object[key]});
					//     }
					// }
					for (var _key30 in property) {
						var locValue = property[_key30];
						var dataType = object.$.model.fieldList[_key30];
						dataType = dataType ? dataType.type : undefined;
						if (dataType && (locValue !== undefined || dataType === "boolean") && dataType !== _LC.getDataType(locValue)) {
							property[_key30] = _LC.typeCast(locValue, dataType);
						}
					}
					var record = store.$.setData(object.$, property, undefined, options, undefined, undefined, shareObj);
					if (record.$.isError) {
						return record;
					}
					// for(let i=0; i<oldValues.length; i++){
					//     _LC.update(object,oldValues[i].key,object[oldValues[i].key],fromStore,(oldValues[i].oldValue === undefined)?null:oldValues[i].oldValue ,setterScope, actualProperty, fromParent);
					// }
				} else {
					//object[property] =  value;
					for (var _key31 in property) {
						//_LC.update(object,key,property[key],fromStore,undefined,setterScope, actualProperty, fromParent);
						//value is option here
						_LC.set(object, _key31, property[_key31], value, fromStore, fromParent);
					}
				}
			} else {
				if (_Lyte.isRecord(object) && (!fromStore || fromStore && recDottedProp) && !object.$.isCloned) {
					var old = object[property];
					var _dataType = object.$.model.fieldList[property];
					_dataType = _dataType ? _dataType.type : undefined;
					if (_dataType && (value !== undefined || _dataType === "boolean") && _dataType !== _LC.getDataType(value)) {
						value = _LC.typeCast(value, _dataType);
					}
					var _record2 = store.$.setData(object.$, property, value, options, undefined, undefined, shareObj);
					if (_record2.$.isError) {
						return _record2;
					}
					//Commented because update will happend when "set" is called from setData of store. 
					//_LC.update(object,property,value,fromStore,(old === undefined) ? null : old,setterScope , actualProperty);    
				} else {
					_LC.update(object, property, value, options, fromStore, undefined, setterScope, actualProperty, fromParent, s_rec);
				}
			}
			if (watch && watch.length) {
				watch.forEach(function (obj) {
					if (obj.isRec) {
						store.$.deepValueChange(obj.rec, obj.attr, obj.rec[obj.attr], obj);
					}
				});
			}
		},
		"adCx": function adCx(node, contextSwitchArray) {
			var isYield = node.tagName === "LYTE-YIELD";
			if (node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
				_LC.changeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
			} else if (isYield && node._callee._cx) {
				_LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
			}
		},
		"rmCx": function rmCx(node, contextSwitchArray) {
			var isYield = node.tagName === "LYTE-YIELD";
			if (node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
				_LC.removeContext(node._cx.node, contextSwitchArray, node._cx, isYield);
			} else if (isYield && node._callee._cx) {
				_LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx, true);
			}
		},
		"changeContext": function changeContext(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
			if (!contextSwitchInfo) {
				return;
			}
			var isYield = node.tagName === "LYTE-YIELD";
			if (node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
				_LC.changeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
			} else if ((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
				_LC.changeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);
			}
			if (isYield) {
				var insertYield = node._registerYield;
				var callee = insertYield._callee;
				if (callee && callee._cx) {
					_LC.changeContext(callee._cx.node, contextSwitchArray, callee._cx);
				}
			}
			var indexValue = void 0,
			    itemValue = void 0;
			if (contextSwitchInfo.type) {
				if (contextSwitchInfo.type === "for") {
					indexValue = node.getAttribute("index");
					itemValue = node.getAttribute("item");
					if (node._items.length === 0) {
						return;
					}
				} else {
					indexValue = node.getAttribute("key");
					itemValue = node.getAttribute("value");
					if (Object.keys(node._items).length === 0) {
						return;
					}
				}
				var _callee = node._callee;
				var initialItemValue = _callee.component.data[itemValue];
				var initialIndexValue = _callee.component.data[indexValue];
				var initialItemProp = _callee._properties[itemValue];
				var initialIndexProp = _callee._properties[indexValue];
				var items = contextSwitchInfo.type === "for" ? node._currentItems : node._currentObject;
				// let items = contextSwitchInfo.type === "for" ? node._attributes.items : node._attributes.object;
				_callee.component.data[itemValue] = items[contextSwitchInfo.itemIndex];
				_callee.component.data[indexValue] = contextSwitchInfo.itemIndex;
				_callee._properties[itemValue] = node._items[contextSwitchInfo.itemIndex].itemProperty;
				_callee._properties[indexValue] = node._items[contextSwitchInfo.itemIndex].indexProperty;
				var dummyObject = { "initialItemValue": initialItemValue, "initialIndexValue": initialIndexValue, "initialItemProp": initialItemProp, "initialIndexProp": initialIndexProp };
				contextSwitchArray.push(dummyObject);
			} else {
				//handling for yield
				var _dummyObject = {};
				var _callee2 = node._registerYield._callee;
				Object.keys(contextSwitchInfo.node._properties).forEach(function (key) {
					_dummyObject[key] = {};
					_dummyObject[key].value = _callee2.component.data[key];
					_dummyObject[key].property = _callee2._properties[key];
					_callee2._properties[key] = contextSwitchInfo.node._properties[key];
					_callee2.component.data[key] = contextSwitchInfo.node.component.data[key];
				});
				contextSwitchArray.push(_dummyObject);
			}
		},
		"removeContext": function removeContext(node, contextSwitchArray, contextSwitchInfo, proceedFurther) {
			if (!contextSwitchInfo) {
				return;
			}
			var isYield = node.tagName === "LYTE-YIELD";
			if (node._cx && (!isYield || node._cx.node.tagName !== "LYTE-YIELD")) {
				_LC.removeContext(node._cx.node, contextSwitchArray, node._cx, node.tagName === "LYTE-YIELD" || proceedFurther);
			} else if ((node.tagName === "LYTE-YIELD" || proceedFurther) && node._callee && node._callee._cx) {
				_LC.removeContext(node._callee._cx.node, contextSwitchArray, node._callee._cx);
			}
			if (isYield) {
				var insertYield = node._registerYield;
				var callee = insertYield._callee;
				if (callee && callee._cx) {
					_LC.removeContext(callee._cx.node, contextSwitchArray, callee._cx);
				}
			}
			var indexValue = void 0,
			    itemValue = void 0;
			if (contextSwitchInfo.type) {
				if (contextSwitchInfo.type === "for") {
					indexValue = node.getAttribute("index");
					itemValue = node.getAttribute("item");
					if (node._items.length === 0) {
						return;
					}
				} else {
					indexValue = node.getAttribute("key");
					itemValue = node.getAttribute("value");
					if (Object.keys(node._items).length === 0) {
						return;
					}
				}
				var _callee3 = node._callee;
				var items = node._attributes.items;
				var removedObject = contextSwitchArray.shift();
				_callee3.component.data[itemValue] = removedObject.initialItemValue;
				_callee3.component.data[indexValue] = removedObject.initialIndexValue;
				_callee3._properties[itemValue] = removedObject.initialItemProp;
				_callee3._properties[indexValue] = removedObject.initialIndexProp;
			} else {
				var _callee4 = node._registerYield._callee;
				var _removedObject = contextSwitchArray.shift();
				Object.keys(contextSwitchInfo.node._properties).forEach(function (key) {
					_callee4.component.data[key] = _removedObject[key].value;
					_callee4._properties[key] = _removedObject[key].property;
				});
			}
		},
		"sortCommands": function sortCommands(array1, arrayB) {
			var retVal = {};
			var arrayA = array1.slice();
			retVal.origianlArray = array1;
			var commands = [];

			for (var _i57 = 0; _i57 < arrayB.length; _i57++) {
				// var targetIndex = arrayA.findIndex((element) => element === arrayB[i]);
				var targetIndex = arrayA.indexOf(arrayB[_i57]);

				if (targetIndex === -1) {
					commands.push({
						type: 'Add',
						element: arrayB[_i57],
						toIndex: _i57
					});
					arrayA.splice(_i57, 0, arrayB[_i57]);
				} else {
					if (targetIndex !== _i57) {
						commands.push({
							type: 'Move',
							element: arrayB[_i57],
							fromIndex: targetIndex,
							toIndex: _i57
						});
						arrayA.splice(targetIndex, 1);
						arrayA.splice(_i57, 0, arrayB[_i57]);
					}
				}
			}

			for (var _i58 = arrayA.length - 1; _i58 >= arrayB.length; _i58--) {
				commands.push({
					type: 'Remove',
					element: arrayA[_i58]
				});
				arrayA.splice(_i58, 1);
			}
			retVal.commands = commands;
			retVal.changedArray = arrayB;
			return retVal;
		},
		"oF": function oF() {
			var object = arguments[0];
			var functionName = arguments[1];
			var property = arguments[2];
			var newValue = arguments[3];
			var fromComponent = arguments[4];
			var fromStore = arguments[5];
			if (functionName === "add" && !fromComponent) {
				_LC.set(object, property, newValue, undefined, fromStore);
				return;
			}
			var options = {};
			options.type = functionName;
			options.property = property;
			if (!/^(add|delete)$/.test(functionName)) {
				_Lyte.error("LC005", functionName);
				return;
			}
			var bindings = object._bindings;
			if (functionName === "delete") {
				_LC.set(object, property, undefined, undefined, fromStore);
			} else {
				object[property] = newValue;
			}
			if (bindings) {
				var bind = bindings.toArrayLyte();
				for (var _i59 = 0; _i59 < bind.length; _i59++) {
					var binding = bind[_i59];
					var forHelpers = binding._forHelpers;
					if (forHelpers) {
						var helperBind = forHelpers.toArrayLyte();
						for (var j = 0; j < helperBind.length; j++) {
							var forHelper = helperBind[j];
							if (forHelper.getAttribute("is") != "forIn") {
								continue;
							}
							var itemValue = forHelper.getAttribute("key");
							//Need to check
							//                            _LC.removeSelectedBindingDeep({[itemValue] :                        forHelper._items[property].itemProperty}, {[itemValue] : object[property]});
							var contextSwitchArray = [];
							if (functionName === "add") {
								_LC.adCx(forHelper, contextSwitchArray);
							}
							forHelper._callee.updateForInHelper(forHelper, options);
							if (functionName === "add") {
								_LC.rmCx(forHelper, contextSwitchArray);
							}
						}
					}
				}
			}
			if (functionName === "delete") {
				delete object[property];
			}
		},
		"aF": function aF() {
			var array = arguments[0];
			var initialArrLength = array.length;
			var callLengthObserver = true;
			var functionName = arguments[1];
			var value = arguments[3],
			    check = {};
			if (/^(replaceAt|removeAt|shift)$/.test(functionName) && !array.length) {
				_Lyte.warn(functionName + " operation cannot be performed on empty array");
				return;
			}
			var commands = void 0;
			if (functionName == "sort") {
				var originalArray = arguments[0];
				var sortFunction = arguments[2];
				var addedArguments = arguments[3] || [];
				var dummyArray = originalArray.slice();
				addedArguments.forEach(function (item) {
					dummyArray.push(item);
				});
				if (typeof arguments[2] == "function") {
					dummyArray.sort(sortFunction);
				} else {
					var sorting = function sorting(item1, item2) {
						var item1 = key ? item1[key] : item1;
						var item2 = key ? item2[key] : item2;
						if (item1 > item2) {
							return order ? 1 : -1;
						} else if (item1 < item2) {
							return order ? -1 : 1;
						} else {
							return 0;
						}
					};

					var obj = arguments[2];
					var key = obj.sortBy;
					var order = obj.sortOrder;

					dummyArray.sort(sorting);
				}
				commands = this.sortCommands(originalArray, dummyArray).commands;
			}
			var commArgs = arguments[2],
			    oldVal = void 0,
			    obsObj = void 0,
			    watch = [];
			if (array._scp && /^(replaceAt|splice|removeAt|remove|insertAt)$/.test(functionName)) {
				array._scp.forEach(function (_obj, id) {
					var rec,
					    attr,
					    wobj = {};
					var recObj = Lyte.nestScp[id];
					var obj = _obj.paths;
					var pathArr = Object.keys(obj),
					    aPath;
					if (pathArr.length > 1) {
						aPath = "*";
					} else if (pathArr.length == 1) {
						aPath = pathArr[0];
					}
					wobj.path = aPath;
					wobj.id = id;
					if (pathArr.length > 1) {
						wobj.paths = pathArr;
					}
					wobj.attr = attr;
					wobj.data = recObj.data;
					wobj.reInit = Lyte.isRecord(recObj.data) || Array.isArray(recObj.data) && recObj.data.model && recObj.data.add;
					wobj.PropsInfo = recObj.PropsInfo || undefined;
					wobj.index = commArgs;
					if (recObj.model) {
						var mMap = recObj.model;
						wobj.Error = recObj.Error;
						var mKeys = Array.from(recObj.model.keys());
						for (var i = 0; i < mKeys.length; i++) {
							var mName = mKeys[i];
							var pkMap = mMap.get(mName);
							if (pkMap) {
								var pkArr = Array.from(pkMap.keys());
								var pkLen = pkArr.length;
								for (var j = 0; j < pkLen; j++) {
									var mPk = pkArr[j];
									var attrMap = pkMap.get(mPk);
									var attrArr = Array.from(attrMap.keys());
									var attrLen = attrArr.length;
									for (k = 0; k < attrLen; k++) {
										var mAttr = attrArr[k];
										var mObj = Object.assign({}, wobj);
										var mRec = store.peekRecord(mName, mPk);
										if (mRec) {
											model = mRec.$.model;
											field = model.fieldList[mAttr];
											if (field && (field.properties || field.items || field.watch == true || Lyte.Transform[field.type])) {
												mObj.data = Lyte.deepCopyObject(mRec[mAttr]);
												mObj.rec = mRec;
												mObj.isRec = true;
												mObj.attr = mAttr;
												mObj.dtype = model.fieldList[mAttr];
												mObj._cmpErr = mRec.$.error;
												mObj.key = mAttr;
											}
											// mObj.reInit = true;
											watch.push(mObj);
										}
									}
								}
							}
						}
					} else {
						wobj.reInit = Lyte.isRecord(recObj.data) || Array.isArray(recObj.data) && recObj.data.model && recObj.data.add;
						watch.push(wobj);
					}
				});
				watch.forEach(function (val) {
					var id = val.id,
					    path = val.path == "" ? [] : val.path.split("."),
					    dtype = val.dtype || undefined;
					if (val.isRec) {
						// path.shift();
						// path = path.length == 1 && path[0] == property ? []:path;
						check.Prop = dtype;
						Lyte.checkNestedProp(id, path, dtype, val, array, val.index, value, check);
					}
					if (val.PropsInfo) {
						val.PropsInfo.forEach(function (props) {
							props.path = val.path;
							dtype = props.dtype;
							props.index = val.index;
							check.Prop = dtype;
							Lyte.checkNestedProp(id, path, dtype, props, array, val.index, value, check);
						});
					}
				});
				if (check.value && check.value.code) {
					_Lyte.error("ERR35", check.Prop.type);
					return;
				}
			}
			switch (functionName) {
				case "replaceAt":
					{
						var index = parseInt(arguments[2]);
						if (index > array.length) {
							_Lyte.warn("index provided for replaceAt is greater than array length");
							return [];
						}
						//let args = Array.prototype.slice.call(arguments, 3);
						var args = arguments[3];
						if (!Array.isArray(args)) {
							args = [args];
						}
						var deletedItems = array.splice.apply(array, [index, 1].concat(args));
						var options = { "firstIndex": index, "secondIndex": args.length, "type": "replace" };
						//All references updated by now
						if (options.secondIndex == 1) {
							callLengthObserver = false;
						}
						//remove binding from previous object
						if (array._bindings) {
							var objbind = array._bindings.toArrayLyte();
							for (var _i60 = 0; _i60 < objbind.length; _i60++) {
								var item = objbind[_i60];
								if (item._forHelpers) {
									var helperbind = item._forHelpers.toArrayLyte();
									for (var _j4 = 0; _j4 < helperbind.length; _j4++) {
										var helper = helperbind[_j4];
										if (helper.getAttribute("is") != "for") {
											continue;
										}
										/*if(helper.hasAttribute("unbound")) {
          continue;
          }*/
										var finalIndex = index + deletedItems.length;
										var itemValue = helper.getAttribute("item");
										for (var _i61 = index, _j5 = 0; _i61 < finalIndex; _i61++, _j5++) {
											_LC.removeSelectedBindingDeep(_defineProperty({}, itemValue, helper._items[_i61].itemProperty), _defineProperty({}, itemValue, deletedItems[_j5]));
										}
										var contextSwitchArray = [];
										_LC.adCx(helper, contextSwitchArray);
										helper._callee.updateForHelper(helper, options);
										_LC.rmCx(helper, contextSwitchArray);
									}
								}
								for (var _key32 in item) {
									var parsedKey = parseInt(_key32);
									var _cond = options.secondIndex == 1 ? parsedKey == options.firstIndex : parsedKey >= options.firstIndex;
									if (!isNaN(parsedKey) && _cond) {
										var diff = parsedKey - options.firstIndex;
										var _oldObject = void 0;
										if (diff < 1) {
											_oldObject = deletedItems[diff];
										} else {
											_oldObject = array[options.firstIndex - 1 + options.secondIndex + diff];
										}
										this.removeSelectedBindingDeep(item[_key32], _oldObject);
										if (item[_key32]._forHelpers) {
											var bindfor = item[_key32]._forHelpers.toArrayLyte();
											for (var j = 0; j < bindfor.length; j++) {
												var item1 = bindfor[j];
												if (item1._propBindingObject) {
													this.removeSelectedBindingDeep(item1._propBindingObject, _oldObject);
													//                                          value._bindings.add(item._propBindingObject);
													//                                          this.establishBindings(item._propBindingObject, value);
												}
											}
										}
										if (array[parsedKey] && _typeof(array[parsedKey]) === "object") {
											makeSet(array[parsedKey], "_bindings");
											this.establishBindings({ "dummy": item[_key32] }, { "dummy": array[parsedKey] });
										}
										this.affectChanges(item[_key32], undefined, _oldObject, undefined, array[parsedKey]);
										if (options.secondIndex == 1) {
											break;
										}
									}
								}
							}
						}
						obsObj = { type: "array", insertedItems: args, removedItems: deletedItems, index: index };
						_LC.bindWatchObj(watch, array, args, deletedItems, index);
						_LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
						return deletedItems[0];
					}
					break;
				case "splice":
					{
						var _index3 = parseInt(arguments[2]);
						if (_index3 > array.length) {
							_Lyte.warn("index provided is greater than array length");
							return [];
						}
						var toBeDeleted = arguments.length > 3 ? arguments[3] : array.length - _index3;
						var _args = arguments.length > 4 ? arguments[4] : [];
						if (!Array.isArray(_args)) {
							_args = [_args];
						}
						var _deletedItems = array.splice.apply(array, [_index3, toBeDeleted].concat(_args));
						var _options = { "firstIndex": _index3, "secondIndex": _args.length, "thirdIndex": toBeDeleted, "type": "splice" };
						//All references updated by now
						if (_options.secondIndex == _options.thirdIndex) {
							callLengthObserver = false;
						}
						//remove binding from previous object
						if (array._bindings) {
							var _objbind3 = array._bindings.toArrayLyte();
							for (var _i62 = 0; _i62 < _objbind3.length; _i62++) {
								var _item5 = _objbind3[_i62];
								if (_item5._forHelpers) {
									var _helperbind = _item5._forHelpers.toArrayLyte();
									for (var _j6 = 0; _j6 < _helperbind.length; _j6++) {
										var _helper = _helperbind[_j6];
										/*if(helper.hasAttribute("unbound")) {
          continue;
          }*/
										if (_helper.getAttribute("is") != "for") {
											continue;
										}
										var _finalIndex = _index3 + _deletedItems.length;
										var _itemValue = _helper.getAttribute("item");
										for (var _i63 = _index3, _j7 = 0; _i63 < _finalIndex; _i63++, _j7++) {
											_LC.removeSelectedBindingDeep(_defineProperty({}, _itemValue, _helper._items[_i63].itemProperty), _defineProperty({}, _itemValue, _deletedItems[_j7]));
										}
										var _contextSwitchArray = [];
										_LC.adCx(_helper, _contextSwitchArray);
										_helper._callee.updateForHelper(_helper, _options);
										_LC.rmCx(_helper, _contextSwitchArray);
									}
								}
								for (var _key33 in _item5) {
									var _parsedKey = parseInt(_key33);
									var cond = _options.secondIndex == _options.thirdIndex ? _key33 >= _options.firstIndex && _key33 < _options.firstIndex + _options.secondIndex : _parsedKey >= _options.firstIndex;
									if (!isNaN(_parsedKey) && cond) {
										var _diff = _parsedKey - _options.firstIndex;
										var _oldObject2 = void 0;
										if (_diff < _options.thirdIndex) {
											_oldObject2 = _deletedItems[_diff];
										} else {
											_oldObject2 = array[_options.firstIndex - _options.thirdIndex + _options.secondIndex + _diff];
										}
										this.removeSelectedBindingDeep(_item5[_key33], _oldObject2);
										if (_item5[_key33]._forHelpers) {
											var _bindfor = _item5[_key33]._forHelpers.toArrayLyte();
											for (var j = 0; j < _bindfor.length; j++) {
												var _item6 = _bindfor[j];
												if (_item6._propBindingObject) {
													this.removeSelectedBindingDeep(_item6._propBindingObject, _oldObject2);
													//                                          value._bindings.add(item._propBindingObject);
													//                                          this.establishBindings(item._propBindingObject, value);
												}
											}
										}
										if (array[_parsedKey] && _typeof(array[_parsedKey]) === "object") {
											makeSet(array[_parsedKey], "_bindings");
											this.establishBindings({ "dummy": _item5[_key33] }, { "dummy": array[_parsedKey] });
										}
										this.affectChanges(_item5[_key33], undefined, _oldObject2, undefined, array[_parsedKey]);
									}
								}
							}
						}
						obsObj = { type: 'array', index: _index3, insertedItems: _args, removedItems: _deletedItems };
						_LC.bindWatchObj(watch, array, _args, _deletedItems, _index3);
						_LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
						return _deletedItems;
					}
					break;
				case "push":
					{
						var toPush = arguments[2];
						if (!Array.isArray(toPush)) {
							toPush = [toPush];
						}
						_LC.aF(array, 'insertAt', array.length, toPush);
					}
					break;
				case "pop":
					return _LC.aF(array, 'remove', array.length - 1)[0];
					break;
				case "shift":
				case "shiftObject":
					return _LC.aF(array, 'remove', 0)[0];
					break;
				case "removeAt":
				case "remove":
					{
						var _index4 = parseInt(arguments[2]);
						if (_index4 > array.length) {
							_Lyte.warn("index provided for removeAt is greater than array length");
							return [];
						}
						var length = arguments[3] ? parseInt(arguments[3]) : 1;
						var _options2 = { "firstIndex": _index4, "secondIndex": length, "type": "remove" };
						var _deletedItems2 = array.splice(_index4, length);
						if (array._bindings) {
							var _objbind4 = array._bindings.toArrayLyte();
							for (var _i64 = 0; _i64 < _objbind4.length; _i64++) {
								var _item7 = _objbind4[_i64];
								if (_item7._forHelpers) {
									var _helperbind2 = _item7._forHelpers.toArrayLyte();
									for (var _j8 = 0; _j8 < _helperbind2.length; _j8++) {
										var _helper2 = _helperbind2[_j8];
										/*if(helper.hasAttribute("unbound")) {
          continue;
          }*/
										if (_helper2.getAttribute("is") != "for") {
											continue;
										}
										var _finalIndex2 = _index4 + _deletedItems2.length;
										var _itemValue2 = _helper2.getAttribute("item");
										for (var _i66 = _index4, _j9 = 0; _i66 < _finalIndex2; _i66++, _j9++) {
											_LC.removeSelectedBindingDeep(_defineProperty({}, _itemValue2, _helper2._items[_i66].itemProperty), _defineProperty({}, _itemValue2, _deletedItems2[_j9]));
										}
										var _contextSwitchArray2 = [];
										_LC.adCx(_helper2, _contextSwitchArray2);
										_helper2._callee.updateForHelper(_helper2, _options2);
										_LC.rmCx(_helper2, _contextSwitchArray2);
									}
								}
								for (var _key34 in _item7) {
									var _parsedKey2 = parseInt(_key34);
									if (!isNaN(_parsedKey2) && _parsedKey2 >= _options2.firstIndex) {
										var _diff2 = _parsedKey2 - _options2.firstIndex;
										var _oldObject3 = void 0;
										if (_diff2 < _options2.secondIndex) {
											_oldObject3 = _deletedItems2[_diff2];
										} else {
											_oldObject3 = array[_options2.firstIndex - _options2.secondIndex + _diff2];
										}
										this.removeSelectedBindingDeep(_item7[_key34], _oldObject3);
										if (_item7[_key34]._forHelpers) {
											var _bindfor2 = _item7[_key34]._forHelpers.toArrayLyte();
											for (var j = 0; j < _bindfor2.length; j++) {
												var _item8 = _bindfor2[j];
												if (_item8._propBindingObject) {
													this.removeSelectedBindingDeep(_item8._propBindingObject, _oldObject3);
													//                                          value._bindings.add(item._propBindingObject);
													//                                          this.establishBindings(item._propBindingObject, value);
												}
											}
										}
										if (array[_parsedKey2] && _typeof(array[_parsedKey2]) === "object") {
											makeSet(array[_parsedKey2], "_bindings");
											this.establishBindings({ "dummy": _item7[_key34] }, { "dummy": array[_parsedKey2] });
										}
										this.affectChanges(_item7[_key34], undefined, _oldObject3, undefined, array[_parsedKey2]);
									}
								}
							}
						}
						obsObj = { type: "array", removedItems: _deletedItems2, index: _index4 };
						_LC.bindWatchObj(watch, array, undefined, _deletedItems2, _index4);
						_LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
						return _deletedItems2;
					}
					break;
				case "removeObject":
					commArgs = [commArgs];
				case "removeObjects":
					if (!Array.isArray(commArgs)) {
						commArgs = [commArgs];
					}
					if (commArgs == array) {
						commArgs = Array.from(commArgs); // both array are same instance so cloning
					}
					for (var i = 0; i < commArgs.length; i++) {
						var inde = array.indexOf(commArgs[i]);
						if (inde !== -1) {
							_LC.aF(array, 'removeAt', inde);
						}
					}
					//_Lyte.arrayUtils(array, 'removeObject', actObj);
					//_Lyte.arrayUtils(array, 'removeObjects', []);
					break;
				case "unshift":
				case "unshiftObject":
				case "unshiftObjects":
					//_LC.aF.apply(_LC, [array, 'insertAt', 0].concat(Array.prototype.slice.call(arguments, 2)));
					{
						var _toPush = arguments[2];
						if (!Array.isArray(_toPush)) {
							_toPush = [_toPush];
						}
						_LC.aF(array, 'insertAt', 0, _toPush);
					}
					break;
				case "insertAt":
					{
						var _index5 = parseInt(arguments[2]);
						//let args = Array.prototype.slice.call(arguments, 3);
						var _args2 = arguments[3];
						var len = _args2.length;
						if (!Array.isArray(_args2)) {
							_args2 = [_args2];
						}
						for (var _i67 = _index5; _i67 > array.length; _i67--) {
							_args2.unshift(undefined);
							_index5--;
						}
						var _options3 = { "firstIndex": _index5, "secondIndex": _args2.length, "type": "insert" };
						array.splice.apply(array, [_index5, 0].concat(_args2));
						if (array._bindings) {
							var arrbind = array._bindings.toArrayLyte();
							for (var _i68 = 0; _i68 < arrbind.length; _i68++) {
								var _item9 = arrbind[_i68];
								if (_item9._forHelpers) {
									var forbind = _item9._forHelpers.toArrayLyte();
									for (var _j10 = 0; _j10 < forbind.length; _j10++) {
										/*if(forbind[j].hasAttribute("unbound")) {
          	continue;
          }*/
										var _helper3 = forbind[_j10];
										if (_helper3.getAttribute("is") != "for") {
											continue;
										}
										var _contextSwitchArray3 = [];
										_LC.adCx(_helper3, _contextSwitchArray3);
										_helper3._callee.updateForHelper(_helper3, _options3);
										_LC.rmCx(_helper3, _contextSwitchArray3);
									}
								}
								for (var _key35 in _item9) {
									var _parsedKey3 = parseInt(_key35);
									if (!isNaN(_parsedKey3) && _parsedKey3 >= _options3.firstIndex) {
										this.removeSelectedBindingDeep(_item9[_key35], array[_parsedKey3 + _options3.secondIndex]);
										if (_item9[_key35]._forHelpers) {
											var _bindfor3 = _item9[_key35]._forHelpers.toArrayLyte();
											for (var j = 0; j < _bindfor3.length; j++) {
												var _item10 = _bindfor3[j];
												if (_item10._propBindingObject) {
													this.removeSelectedBindingDeep(_item10._propBindingObject, oldObject);
													//                                          value._bindings.add(item._propBindingObject);
													//                                          this.establishBindings(item._propBindingObject, value);
												}
											}
										}
										if (array[_parsedKey3] && _typeof(array[_parsedKey3]) === "object") {
											makeSet(array[_parsedKey3], "_bindings");
											this.establishBindings({ "dummy": _item9[_key35] }, { "dummy": array[_parsedKey3] });
										}
										this.affectChanges(_item9[_key35], undefined, array[_parsedKey3 + _options3.secondIndex], undefined, array[_parsedKey3]);
									}
								}
							}
						}
						var position = parseInt(arguments[2]);
						obsObj = { type: "array", insertedItems: !Array.isArray(arguments[3]) ? [arguments[3]] : arguments[0].slice(position, position + len), index: position };
						_LC.bindWatchObj(watch, array, _args2, undefined, position);
						_LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
					}
					break;
				case "concat":
					//_LC.aF.apply(_LC, [array, 'insertAt',array.length].concat(arguments[2]));
					_LC.aF(array, 'insertAt', array.length, arguments[2]);
					break;
				case "sort":
					{
						var optionsArray = [];
						commands.forEach(function (command) {
							switch (command.type) {
								case "Remove":
									{
										var removedItems = array.splice(command.toIndex, 1);
										optionsArray.push({ "firstIndex": command.toIndex, "secondIndex": 1, "type": "remove", "removedItem": removedItems[0] });
									}
									break;
								case "Move":
									{
										var _removedItems = array.splice(command.fromIndex, 1);
										array.splice(command.toIndex, 0, command.element);
										optionsArray.push({ "firstIndex": command.fromIndex, "secondIndex": 1, "type": "remove", "removedItem": _removedItems[0] });
										// optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
										optionsArray.push({ "firstIndex": command.toIndex, "secondIndex": 1, "type": "insert" });
									}
									break;
								case "Add":
									{
										array.splice(command.toIndex, 0, command.element);
										// optionsArray.push({"firstIndex" : command.toIndex, "secondIndex" : 1, "thirdIndex" : 0, "type" : "splice"});
										optionsArray.push({ "firstIndex": command.toIndex, "secondIndex": 1, "type": "insert" });
									}
									break;
							}
						});
						if (array._bindings) {
							var _arrbind = array._bindings.toArrayLyte();
							for (var _i69 = 0; _i69 < _arrbind.length; _i69++) {
								var _item11 = _arrbind[_i69];
								if (_item11._forHelpers) {
									var _forbind2 = _item11._forHelpers.toArrayLyte();
									for (var _j11 = 0; _j11 < _forbind2.length; _j11++) {
										/*if(forbind[j].hasAttribute("unbound")) {
          	continue;
          }*/
										var _helper4 = _forbind2[_j11];
										if (_helper4.getAttribute("is") != "for") {
											continue;
										}
										var _contextSwitchArray4 = [];
										_LC.adCx(_helper4, _contextSwitchArray4);
										for (var _j12 = 0; _j12 < optionsArray.length; _j12++) {
											var optionItem = optionsArray[_j12];
											// Removal of bindings
											var _itemValue3 = _helper4.getAttribute("item");
											if (optionItem.type == "remove") {
												this.removeSelectedBindingDeep(_defineProperty({}, _itemValue3, _helper4._items[optionItem.firstIndex].itemProperty), _defineProperty({}, _itemValue3, optionItem.removedItem));
											}
											_helper4._callee.updateForHelper(_helper4, optionItem);
										}
										_LC.rmCx(_helper4, _contextSwitchArray4);
									}
								}
								//                         for(let key in item) {
								//                             let parsedKey = parseInt(key);
								//                             if(!isNaN(parsedKey) && parsedKey >= options.firstIndex) {
								//                                 this.removeSelectedBindingDeep(item[key], array[parsedKey+options.secondIndex]);
								//                                 if(item[key]._forHelpers) {
								//                                     let bindfor = item[key]._forHelpers.toArrayLyte();
								//                                     for(var j=0;j<bindfor.length;j++){
								//                                         let item1 = bindfor[j];
								//                                         if(item1._propBindingObject) {
								//                                             this.removeSelectedBindingDeep(item1._propBindingObject, oldObject);
								// //                                          value._bindings.add(item._propBindingObject);
								// //                                          this.establishBindings(item._propBindingObject, value);
								//                                         }
								//                                     }
								//                                 }
								//                                 if(array[parsedKey] && typeof array[parsedKey] === "object") {
								//                                 	makeSet(array[parsedKey], "_bindings");
								//                                 this.establishBindings({"dummy" : item[key]},{"dummy" : array[parsedKey]});    
								//                                 }
								//                                 this.affectChanges(item[key],undefined,array[parsedKey + options.secondIndex],undefined,array[parsedKey]);
								//                             }
								//                         }
							}
						}
						if (Array.isArray(arguments[3]) && arguments[3].length) {
							obsObj = { type: "array", insertedItems: arguments[3] };
							var indices = [];
							arguments[3].forEach(function (item) {
								indices.push(array.indexOf(item));
							});
							obsObj.indices = indices;
							_LC.callArrayObservers(array, obsObj, callLengthObserver, initialArrLength);
						}
					}
					break;
				default:
					_Lyte.error("LC006", functionName);
					return;
			}
		},
		"callDeepObservers": function callDeepObservers(data, args, property, callLengthObserver) {
			var self = this;
			var keys = Array.from(data._scp.keys());
			keys.forEach(function (id) {
				var _scp = data._scp.get(id),
				    scp = _scp.paths,
				    pathArr = Object.keys(scp),
				    aPath;
				if (pathArr.length == 1) {
					aPath = pathArr[0];
				} else if (pathArr.length > 1) {
					aPath = pathArr;
				}
				var recObj = Lyte.nestScp[id],
				    attr,
				    rec,
				    isRec = false;
				if (recObj.model) {
					var mMap = recObj.model;
					var mKeys = Array.from(recObj.model.keys());
					for (var i = 0; i < mKeys.length; i++) {
						var mName = mKeys[i];
						var pkMap = mMap.get(mName);
						if (pkMap) {
							var pkArr = Array.from(pkMap.keys());
							var pkLen = pkArr.length;
							for (var j = 0; j < pkLen; j++) {
								var mPk = pkArr[j];
								var attrMap = pkMap.get(mPk);
								var attrArr = Array.from(attrMap.keys());
								var attrLen = attrArr.length;
								for (k = 0; k < attrLen; k++) {
									var mAttr = attrArr[k];
									var mRec = store.peekRecord(mName, mPk);
									self.deepObsBind(mRec, true, mAttr, args, pathArr, aPath, data, property, callLengthObserver);
								}
							}
						}
					}
				} else {
					rec = recObj.data;
					self.deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver);
				}
			});
		},
		"deepObsBind": function deepObsBind(rec, isRec, attr, args, pathArr, aPath, data, property, callLengthObserver) {
			var type = args.type;
			var watchPath, propPath;
			if (rec._bindings) {
				var newArgs = Object.assign({}, args);
				var objbind = rec._bindings.toArrayLyte();
				for (var _i65 = 0; _i65 < objbind.length; _i65++) {
					propPath = aPath;
					var binding = objbind[_i65],
					    obj = undefined;
					watchPath = objbind[_i65]._path;
					if (isRec) {
						if (binding.hasOwnProperty(attr) && binding[attr].hasOwnProperty("*")) {
							obj = binding[attr]["*"];
							watchPath = binding[attr]._path;
						}
					} else if (binding.hasOwnProperty("*")) {
						obj = binding["*"];
					}
					if (obj) {
						var obsbind = obj._observers ? obj._observers.toArrayLyte() : [],
						    path;
						if (property) {
							if (pathArr.length > 1) {
								var len = pathArr.length,
								    nPathArr = [];
								for (var i = 0; i < len; i++) {
									nPathArr.push(pathArr[i] ? pathArr[i] + "." + property : property);
								}
								propPath = nPathArr;
							} else if (pathArr.length == 1) {
								propPath = aPath ? aPath.concat("." + property) : property;
							}
						}
						for (var j = 0; j < obsbind.length; j++) {
							var observer = obsbind[j];
							newArgs.path = propPath;
							newArgs.type = "deepChange";
							newArgs.data = rec;
							var argPath = obj._path.split('.');
							argPath.pop();
							newArgs.item = argPath.join('.');
							var exactPath = newArgs.index != undefined ? (propPath != "" ? propPath + "." : propPath) + newArgs.index : propPath;
							if (observer.callee && observer.callee.component) {
								//  observer.observer.value.call(observer.callee.component, newArgs);
								var calldeep = true;
								var _data = observer.callee.component.__data[newArgs.item];
								var _watch = _data ? _data.watch : undefined;
								if (_data && typeof _watch != "boolean") {
									var watchArr = obsbind[j].observer.Jpath[watchPath];
									calldeep = Lyte.checkWatchPath(exactPath, watchArr);
								}
								if (calldeep) {
									observer.observer.value.call(observer.callee.component, newArgs);
								}
							} else {
								var scope = data._setterScope ? data._setterScope : window;
								if (Array.isArray(scope)) {
									var sLen = scope.length;
									for (var k = 0; k < sLen; k++) {
										var itm = scope[k];
										var calldeep = true;
										if (newArgs.data && newArgs.hasOwnProperty("item")) {
											var watchArr = newArgs.data.$.model._fldGrps.watch[newArgs.item].watch;
											if (Array.isArray(watchArr)) {
												watchArr = obsbind[j].observer.Jpath[watchPath];
												calldeep = Lyte.checkWatchPath(exactPath, watchArr);
											}
										}
										if (calldeep) {
											observer.observer.value.call(itm, newArgs);
										}
									}
								} else {
									var calldeep = true;
									if (newArgs.data && newArgs.hasOwnProperty("item")) {
										var watchArr = newArgs.data.$.model._fldGrps.watch[newArgs.item].watch;
										if (Array.isArray(watchArr)) {
											watchArr = obsbind[j].observer.Jpath[watchPath];
											calldeep = Lyte.checkWatchPath(exactPath, watchArr);
										}
									}
									if (calldeep) {
										observer.observer.value.call(scope, newArgs);
									}
								}
							}
						}
					}
					if (!callLengthObserver && type == "array" && binding.length) {
						this.affectChanges(binding.length, undefined, initialArrLength, undefined, array.length, callLengthObserver);
					}
				}
			}
		},
		"callArrayObservers": function callArrayObservers(array, args, callLengthObserver, initialArrLength) {
			if (array._scp && array._scp.size) {
				this.callDeepObservers(array, Object.assign({}, args), undefined, true);
			}
			if (array._bindings) {
				var objbind = array._bindings.toArrayLyte();
				for (var _i70 = 0; _i70 < objbind.length; _i70++) {
					var binding = objbind[_i70];
					var path = objbind[_i70]._path;
					if (binding._observers) {
						var obsbind = binding._observers.toArrayLyte();
						for (var j = 0; j < obsbind.length; j++) {
							var observer = obsbind[j];
							if (observer.isArrayObserver) {
								if (args) {
									args.item = path;
								}
								if (observer.callee && observer.callee.component) {
									observer.observer.value.call(observer.callee.component, args);
								} else {
									var scope = array._setterScope ? array._setterScope : window;
									if (Array.isArray(scope)) {
										var sLen = scope.length;
										for (var k = 0; k < sLen; k++) {
											var itm = scope[k];
											observer.observer.value.call(itm, args);
										}
									} else {
										observer.observer.value.call(scope, args);
									}
								}
							}
						}
					}
					if (binding.length) {
						this.affectChanges(binding.length, undefined, initialArrLength, undefined, array.length, callLengthObserver);
					}
				}
			}
		},
		"bindWatchObj": function bindWatchObj(watch, data, insItems, remItems, pos) {
			if (watch && watch.length) {
				watch.forEach(function (wObj) {
					if (wObj.isRec) {
						store.$.deepValueChange(wObj.rec, wObj.attr, data, wObj);
					}
					if (remItems) {
						remItems.forEach(function (itm) {
							Lyte.removeNestScp(itm, wObj.id, undefined, undefined, undefined, undefined, wObj.reInit ? wObj.data : undefined);
						});
					}
					if (insItems) {
						insItems.forEach(function (itm, idx) {
							if (itm && (Array.isArray(itm) || (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == "object")) {
								var pth = wObj.path.split(',');
								pth.push(pos + idx);
								Lyte.bindObj(itm, undefined, wObj.id, pth && pth.length ? pth : [], undefined, undefined, undefined, true);
							}
						});
					}
					if (pos !== undefined) {
						var nestObj = Lyte.nestScp[wObj.id];
						if (nestObj && nestObj.cyclic) {
							Lyte.removeNestScp(nestObj._data, wObj.id);
							Lyte.bindObj(nestObj._data, undefined, wObj.id, [], undefined, undefined, undefined, true);
						} else {
							var insLen = insItems ? insItems.length : 0,
							    newInd = pos + insLen;
							var arr = data.slice(newInd);
							arr.forEach(function (itm) {
								Lyte.removeNestScp(itm, wObj.id);
							});
							arr.forEach(function (itm, idx) {
								if (itm && (Array.isArray(itm) || (typeof itm === 'undefined' ? 'undefined' : _typeof(itm)) == "object")) {
									var pth = wObj.path.split(',');
									pth.push(newInd + idx);
									Lyte.bindObj(itm, undefined, wObj.id, pth && pth.length ? pth : [], undefined, undefined, undefined, true);
								}
							});
						}
					}
				});
			}
		},
		"establishUpdateBindings": function establishUpdateBindings(bindings, property, actualData) {
			var objbind = bindings.toArrayLyte();
			for (var _i71 = 0; _i71 < objbind.length; _i71++) {
				var item = objbind[_i71];
				if (item[property]) {
					makeSet(actualData, "_bindings");
					addBindings(actualData._bindings, item[property]);
					this.establishBindings(item[property], actualData);
				}
			}
		},
		"establishSelectedBinding": function establishSelectedBinding(property, actualData, node) {
			if (!property) {
				return;
			}
			var propName = property._path;
			var props = propName.split('.');
			var currentProp = node.getProperty(props[0]);
			var currentValue = actualData[props[0]];
			for (var _i72 = 0; _i72 < props.length; _i72++) {
				if (!currentValue || (typeof currentValue === 'undefined' ? 'undefined' : _typeof(currentValue)) !== "object") {
					break;
				}
				makeSet(currentValue, "_bindings");
				addBindings(currentValue._bindings, currentProp);
				currentProp = currentProp[props[_i72 + 1]];
				currentValue = currentValue[props[_i72 + 1]];
			}
		},
		"establishBindings": function establishBindings(properties, actualData) {
			if (properties._helperNodes) {
				var path = properties._path;
				var _arr = properties._helperNodes.toArrayLyte();
				for (var _s2 = 0; _s2 < _arr.length; _s2++) {
					var nodes = _arr[_s2]._dynamicProperty ? _arr[_s2]._dynamicProperty[path] : undefined;
					if (nodes) {
						for (var j = 0; j < nodes.length; j++) {
							var node = nodes[j];
							var helper = node.ownerElement;
							if (helper && helper.tagName === "TEMPLATE" && helper.getAttribute("is") === "for") {
								if (helper._items) {
									var item = helper.getAttribute("item");
									for (var _i73 = 0; _i73 < helper._items.length; _i73++) {
										var data = actualData[_i73];
										var _item12 = helper.getAttribute("item");
										if (data) {
											if (_typeof(helper._items[_i73]) === "object") {
												this.establishBindings(helper._items[_i73].itemProperty, _defineProperty({}, _item12, data));
											}
										}
									}
								}
							}
						}
					}
				}
			}
			for (var _i74 in properties) {
				var actData = actualData[_i74];
				if (!actData || typeof actData === "string" || typeof actData === "number" || typeof actData === "boolean") {
					if (!actualData._bindings) {
						makeSet(actualData, "_bindings");
					}
					addBindings(actualData._bindings, properties);
				} else {
					if (!actData._bindings) {
						makeSet(actData, "_bindings");
					}
					addBindings(actData._bindings, properties[_i74]);
					if (_typeof(properties[_i74]) === "object") {
						this.establishBindings(properties[_i74], actData);
					}
				}
			}
		},
		"removeSelectedBindingDeep": function removeSelectedBindingDeep(binding, actualData, fromDisConnect) {
			var del = "delete";
			if (!actualData && !fromDisConnect) {
				return;
			}
			if (actualData && actualData._bindings) {
				deleteBindingCheckSize(actualData, "_bindings", binding);
			}
			for (var _i75 in binding) {
				var actData = void 0;
				if (actualData) {
					actData = actualData[_i75];
				}
				if (actData && actData._bindings) {
					deleteBindingCheckSize(actData, "_bindings", binding[_i75]);
				}
				if (_typeof(binding[_i75]) === "object") {
					this.removeSelectedBindingDeep(binding[_i75], actData, fromDisConnect);
				}
			}
			if (fromDisConnect) {
				var dynNodes = binding._dynamicNodes;
				var helperNodes = binding._helperNodes;
				if (dynNodes && dynNodes.length) {
					binding._dynamicNodes.splice(0, dynNodes.length);
				}
				if (helperNodes && helperNodes.size) {
					helperNodes.clear();
				}
			}
			if (binding && binding._forHelpers) {
				var objbind = binding._forHelpers.toArrayLyte();
				for (var _i76 = 0; _i76 < objbind.length; _i76++) {
					var fH = objbind[_i76];
					if (fH.getAttribute("is") === "for") {
						var item = fH.getAttribute("item");
						var items = fH._attributes.items;
						var itemCases = fH._items;
						for (var _i77 = 0; _i77 < itemCases.length; _i77++) {
							this.removeSelectedBindingDeep(itemCases[_i77].itemProperty, items[_i77], fromDisConnect);
						}
					} else {
						if (fH._propBindingObject) {
							if (actualData && actualData._bindings) {
								deleteBindingCheckSize(actualData, "_bindings", fH._propBindingObject);
								this.removeSelectedBindingDeep(fH._propBindingObject, actualData, fromDisConnect);
							}
						}
					}
				}
			}
		},
		"removeAllBindings": function removeAllBindings(properties, data) {
			var del = "delete";
			for (var _key36 in properties) {
				if (data[_key36] && data[_key36]._bindings) {
					//                    data[key]._bindings[del](properties[key]);
					//                    if(!data[key]._bindings.size) {
					//                        delete data[key]._bindings;
					//                    }
					deleteBindingCheckSize(data[_key36], "_bindings", properties[_key36]);
				}
				if (data[_key36] && typeof data[_key36] !== "string") {
					_LC.removeAllBindings(properties[_key36], data[_key36]);
				}
			}
		},
		"affectChanges": function affectChanges(item, contextAlreadySwitched, oldValue, setterScope, newValue, callLengthObserver) {
			if (item._dynamicNodes) {
				for (var _i78 = 0; _i78 < item._dynamicNodes.length; _i78++) {
					item._dynamicNodes[_i78]._callee.updateNode(item._dynamicNodes[_i78], item._path);
				}
			}
			var propPath = item._path;
			if (item._helperNodes) {
				var nodes = [],
				    itemHelperNodes = item._helperNodes.toArrayLyte();
				for (var _s3 = 0; _s3 < itemHelperNodes.length; _s3++) {
					if (!item._helperNodes.has(itemHelperNodes[_s3])) {
						continue;
					}
					if (itemHelperNodes[_s3].getAttribute("is") === "for" && itemHelperNodes[_s3]._items) {
						var innerContextSwitchArray = [];
						_LC.adCx(itemHelperNodes[_s3], innerContextSwitchArray);
						var indexValue = itemHelperNodes[_s3].getAttribute("index");
						var itemValue = itemHelperNodes[_s3].getAttribute("item");
						var callee = itemHelperNodes[_s3]._callee;
						var initialItemValue = callee.component.data[itemValue];
						var initialIndexValue = callee.component.data[indexValue];
						var initialItemProp = callee._properties[itemValue];
						var initialIndexProp = callee._properties[indexValue];
						var items = itemHelperNodes[_s3]._attributes.items;
						for (var _i79 = 0; _i79 < itemHelperNodes[_s3]._items.length; _i79++) {
							callee.component.data[itemValue] = items[_i79];
							callee.component.data[indexValue] = _i79;
							callee._properties[itemValue] = itemHelperNodes[_s3]._items[_i79].itemProperty;
							if (itemHelperNodes[_s3]._items[_i79]._dynamicProperty[propPath]) {
								nodes = itemHelperNodes[_s3]._items[_i79]._dynamicProperty[propPath];
								for (var _i80 = 0; _i80 < nodes.length; _i80++) {
									nodes[_i80]._callee.updateNode(nodes[_i80], propPath);
								}
							}
						}
						callee.component.data[itemValue] = initialItemValue;
						callee.component.data[indexValue] = initialIndexValue;
						callee._properties[itemValue] = initialItemProp;
						callee._properties[indexValue] = initialIndexProp;
						_LC.rmCx(itemHelperNodes[_s3], innerContextSwitchArray);
					} else if (itemHelperNodes[_s3].getAttribute("is") === "forIn" && itemHelperNodes[_s3]._items) {
						var _innerContextSwitchArray = [];
						_LC.adCx(itemHelperNodes[_s3], _innerContextSwitchArray);
						var _indexValue = itemHelperNodes[_s3].getAttribute("key");
						var _itemValue4 = itemHelperNodes[_s3].getAttribute("value");
						var _callee5 = itemHelperNodes[_s3]._callee;
						var _initialItemValue = _callee5.component.data[_itemValue4];
						var _initialIndexValue = _callee5.component.data[_indexValue];
						var _initialItemProp = _callee5._properties[_itemValue4];
						var _initialIndexProp = _callee5._properties[_indexValue];
						var object = itemHelperNodes[_s3]._attributes.object;
						for (var _key37 in itemHelperNodes[_s3]._items) {
							_callee5.component.data[_itemValue4] = object[_key37];
							_callee5.component.data[_indexValue] = _key37;
							_callee5._properties[_itemValue4] = itemHelperNodes[_s3]._items[_key37].itemProperty;
							if (itemHelperNodes[_s3]._items[_key37]._dynamicProperty[propPath]) {
								nodes = itemHelperNodes[_s3]._items[_key37]._dynamicProperty[propPath];
								for (var _i81 = 0; _i81 < nodes.length; _i81++) {
									nodes[_i81]._callee.updateNode(nodes[_i81], propPath);
								}
							}
						}
						_callee5.component.data[_itemValue4] = _initialItemValue;
						_callee5.component.data[_indexValue] = _initialIndexValue;
						_callee5._properties[_itemValue4] = _initialItemProp;
						_callee5._properties[_indexValue] = _initialIndexProp;
						_LC.rmCx(itemHelperNodes[_s3], _innerContextSwitchArray);
					} else {
						nodes = itemHelperNodes[_s3]._dynamicProperty[item._path] || [];
						var contextSwitchArray = [];
						if (nodes.length) {
							_LC.adCx(itemHelperNodes[_s3], contextSwitchArray);
							for (var _i82 = 0; _i82 < nodes.length; _i82++) {
								nodes[_i82]._callee.updateNode(nodes[_i82], item._path);
							}
							_LC.rmCx(itemHelperNodes[_s3], contextSwitchArray);
						}
					}
				}
			}
			if (item._observers) {
				var objbind = item._observers.toArrayLyte();
				var cond = callLengthObserver == false ? false : oldValue != undefined || newValue != undefined;
				if (cond) {
					for (var _i83 = 0; _i83 < objbind.length; _i83++) {
						var observer = objbind[_i83];
						var obsObj = { type: "change", oldValue: oldValue, newValue: newValue, item: item._path };
						if (observer.callee && observer.callee.component) {
							observer.observer.value.call(observer.callee.component, obsObj);
						} else {
							var scope = setterScope ? setterScope : window;
							if (Array.isArray(scope)) {
								var sLen = scope.length;
								for (var k = 0; k < sLen; k++) {
									var itm = scope[k];
									observer.observer.value.call(itm, obsObj);
								}
							} else {
								observer.observer.value.call(scope, obsObj);
							}
						}
					}
				}
			}
			if (Array.isArray(item)) {
				for (var i = 0; i < item.length; i++) {
					for (var _key38 in item[i]) {
						this.affectChanges(item[i][_key38], true, oldValue ? oldValue[i] ? oldValue[i][_key38] : oldValue[i] : oldValue, setterScope, newValue ? newValue[i] ? newValue[i][_key38] : newValue[i] : newValue);
					}
				}
			} else {
				for (var _key39 in item) {
					var oldV = oldValue ? oldValue[_key39] : oldValue,
					    newV = newValue ? newValue[_key39] : newValue;
					if (_key39 == "*" && item[_key39].hasOwnProperty("_observers")) {
						oldV = oldValue;
						newV = newValue;
					}
					this.affectChanges(item[_key39], true, oldV, setterScope, newV);
				}
			}
		},
		"skipArgProcessing": function skipArgProcessing(cloneActObj, ev, target) {
			if (cloneActObj.skipArgProcessing) {
				var args = cloneActObj.args = cloneActObj.actArgs;
				args.shift();
				var eventIndex = args.indexOf("__lyteEvent__");
				var nodeIndex = args.indexOf("__lyteNode__");
				if (eventIndex !== -1) {
					args[eventIndex] = ev;
				}
				if (nodeIndex !== -1) {
					args[nodeIndex] = target;
				}
			} else {
				cloneActObj.args.shift();
			}
		},
		// getDV added
		"getDV": function getDV(value) {
			var result = [],
			    ref = result,
			    arr = [],
			    data = "",
			    strStack = [],
			    arrayStack = [],
			    refStack = [],
			    strLast,
			    str;
			for (var i = 0; i < value.length; i++) {
				if (value[i] === ".") {
					if (data.length) {
						ref.push(data);
					}
					data = "";
					continue;
				} else if (value[i] === "[") {
					arrayStack.push(i);
					if (data.length) {
						ref.push(data);
					}
					while (value[i + 1] === "\s") {
						i++;
					}
					if (value[i + 1] === "\"" || value[i + 1] === "'") {
						strStack.push(value[i + 1]);
						strLast = value[i + 1];
						i++;
					} else if (arr.length) {
						ref.push([]);
						refStack.push(ref);
						ref = ref[ref.length - 1];
					} else {
						arr.push([]);
						refStack.push(ref);
						ref = arr[arr.length - 1];
					}
					data = "";
					continue;
				} else if ((value[i] === "\"" || value[i] === "'") && value[i++] === strLast) {
					while (value[i] === "\s" && value[i] != "]") {
						i++;
					}
					strStack.pop();
					str = true;
				}
				if (value[i] === "]") {
					arrayStack.pop();
					if (data.length) {
						if (str === true) {
							ref.push(data);
						} else if (!isNaN(parseInt(data))) {
							if (refStack.length) {
								ref = refStack.pop();
								if (arr.length && Array.isArray(ref[ref.length - 1]) && !ref[ref.length - 1].length) {
									ref.pop();
								}
								ref.push(data);
								if (!arrayStack.length && arr.length) {
									arr.shift();
								}
							}
						} else {
							ref.push(data);
						}
					}
					if (!arrayStack.length && arr.length) {
						result.push(arr.shift());
						ref = result;
					} else if (refStack.length && !arr.length) {
						ref = refStack.pop();
					}
					data = "";
					str = "";
					continue;
				}
				data = data.concat(value[i]);
			}
			if (data.length) {
				result.push(data);
			}
			if (strStack.length || arrayStack.length) {
				console.log("check the syntax", strStack, arrayStack);
			}
			return result;
		},
		"ccDelay": [],
		"callCC": function callCC() {
			this.ccDelay.forEach(function (item) {
				if (item.component) {
					item.actualConnectedCallback();
				}
			});
			this.ccDelay = [];
		},
		"getDD": function getDD(context, dataArr) {
			var self = context;
			dataArr.forEach(function (item, index) {
				if (Array.isArray(item)) {
					if (context == undefined) {
						return undefined;
					}
					var inner = _LC.getDD(self, item);
					if (inner == undefined) {
						return undefined;
					}
					context = context[inner];
				} else {
					if (context == undefined) {
						return undefined;
					}
					context = context[item];
				}
			});
			return context;
		},

		"processStatic": function processStatic(temp) {
			var arr = temp.innerHTML.split("__**");
			var newArr = [];
			for (var i = 0; i < arr.length; i++) {
				if (arr[i].startsWith("--Lyte")) {
					newArr.push(parseInt(arr[i].substring(6)));
				} else {
					newArr.push(undefined);
				}
			}
			arr.cc = newArr;
			return arr;
		},
		"findLastNodeL": function findLastNodeL(lastNode1, count, node) {
			var totalNodeIndex = 0;
			if (count != undefined) {
				totalNodeIndex = count;
			}
			var helperNode;
			switch (node.getAttribute("is")) {
				case "for":
					if (node._helpers[totalNodeIndex]) {
						helperNode = node._helpers[totalNodeIndex][0];
					}
					if (!lastNode1) {
						if (node._forContent[0]) {
							lastNode1 = node._forContent[0][0];
						}
					}
					break;
				case "forIn":
					if (node._helpers[node._keysArray[0]]) {
						helperNode = node._helpers[node._keysArray[0]][0];
					}
					if (!lastNode1) {
						if (node._forContent[node._keysArray[0]]) {
							lastNode1 = node._forContent[node._keysArray[0]][0];
						}
					}
					break;
				case "if":
				case "switch":
					helperNode = node._helpers[totalNodeIndex];
					if (!lastNode1) {
						lastNode1 = node._caseContent[0];
					}
					break;
				case "component":
					lastNode1 = lastNode1._renderedComponent[lastNode1._currentComponent] || lastNode1;
					return lastNode1;
			}
			if (!lastNode1) {
				lastNode1 = node._placeHolder;
			}
			if (helperNode && lastNode1 == helperNode._placeHolder) {
				lastNode1 = this.findLastNodeL(undefined, undefined, helperNode);
			}
			return lastNode1;
		},
		"processAction": function processAction(node) {
			Array.from(node.querySelectorAll('[lyteaction]')).forEach(function (item) {
				var locIndex = item.attributes.lyteaction.value;
				item._boundEvents = _LC.fRP[locIndex];
				delete _LC.fRP[locIndex];
				// _LC.pushFrc(locIndex);
				// item._boundEvents = JSON.parse(item.attributes.lyteaction.value);
				var _cx = item._boundEvents._cx;
				var boundEvents = item._boundEvents;
				delete boundEvents._cx;
				var componentName = boundEvents.componentName;
				delete boundEvents.componentName;
				for (var key in item._boundEvents) {
					if (key.indexOf("-") !== -1) {
						item._actions = item._actions || {};
						item._actions[key] = new CustomEvent(key);
						item._actions[key].processAction = item._boundEvents[key];
						item._boundEvents[key].actArgs.shift();
						var nodeIndex = item._boundEvents[key].actArgs.indexOf("__lyteNode__");
						if (nodeIndex !== -1) {
							item._boundEvents[key].actArgs[nodeIndex] = item;
						}
						item._boundEvents[key].args = item._boundEvents[key].actArgs;
						delete item._boundEvents[key];
					} else {
						var actArgs = _Lyte.deepCopyObject(item._boundEvents[key].args);
						var actName = actArgs.splice(0, 1)[0];
						actName = actName.startsWith("'") ? actName.replace(/'/g, '') : actName;
						var actString = getArgString(actName, actArgs);
						item.setAttribute(key.startsWith("on") ? key.substr(2) : key, componentName + " => " + actString);
						if (!item._boundEvents[key].globalEvent) {
							item.addEventListener(key, globalEventHandler);
						}
					}
				}
				item._boundEvents._cx = _cx;
				item.removeAttribute("lyteaction");
				//item._boundEvents = item.
			});
		},
		"getCtxVal": function getCtxVal(context, val) {
			if (context != undefined) {
				return context[val];
			} else {
				return undefined;
			}
		},
		"get": function get(context, path, ac, cache) {
			if (!ac) {
				ac = [];
			}
			if (cache && cache.hasOwnProperty(path)) {
				// cache.cacheData[path]
				nodeValue = cache[path]._data;
				if (cache[path]._dyn) {
					cache[path]._dyn.forEach(function (item) {
						ac.push(item);
					});
				}
				return nodeValue;
			} else {
				try {
					var _arr2 = path.match(/([^[\]]+|\[\])/g);
					var initialContext = context;
					ac.push(_arr2[0]);
					var locArr = _arr2[0].split('.');
					for (var _k6 = 0; _k6 < locArr.length; _k6++) {
						context = _LC.getCtxVal(context, locArr[_k6]);
					}
					for (var _i84 = 1; _i84 < _arr2.length; _i84++) {
						var locVal = _arr2[_i84];
						//this is context switching
						if (locVal.startsWith(".")) {
							//direct context switching
							var _locArr = locVal.substring(1).split('.');
							for (var _k7 = 0; _k7 < _locArr.length; _k7++) {
								context = _LC.getCtxVal(context, _locArr[_k7]);
							}
							// ac[ac.length -1] = ac[ac.length - 1] + locVal;
							ac[0] = ac[0] + locVal;
						} else if (locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
							if (!isNaN(locVal)) {
								// ac[ac.length-1] = ac[0] + "." + locVal;
								ac[0] = ac[0] + "." + locVal;
								context = _LC.getCtxVal(context, locVal);
							} else {
								// ac[ac.length-1] = ac[0] + "." + locVal.substring(1, locVal.length -1);
								ac[0] = ac[0] + "." + locVal.substring(1, locVal.length - 1);
								context = _LC.getCtxVal(context, locVal.substring(1, locVal.length - 1));
							}
						} else {
							var length = ac.length;
							var val = _LC.get(initialContext, locVal, ac);
							ac[0] = ac[0] + "." + val;
							context = _LC.getCtxVal(context, val);
						}
					}
					if (cache) {
						cache[path] = {};
						cache[path]._data = context;
						cache[path]._dyn = ac;
					}
					return context;
				} catch (e) {
					return undefined;
				}
			}
		},
		"getNew": function getNew(context, path) {
			try {
				var _arr3 = path.match(/([^[\]]+|\[\])/g);
				var initialContext = context;
				var locArr = _arr3[0].split('.');
				if (_arr3.length < 2) {
					if (locArr.length < 2) {
						return { "context": initialContext, "lastKey": locArr[0] };
					} else {
						for (var k = 0; k < locArr.length - 1; k++) {
							context = context[locArr[k]];
						}
						return { "context": context, "lastKey": locArr[k] };
					}
				}
				for (var _k8 = 0; _k8 < locArr.length; _k8++) {
					context = context[locArr[_k8]];
				}
				for (var i = 1; i < _arr3.length - 1; i++) {
					var locVal = _arr3[i];
					//this is context switching
					if (locVal.startsWith(".")) {
						//direct context switching
						var _locArr2 = locVal.substring(1).split('.');
						for (var _k9 = 0; _k9 < _locArr2.length; _k9++) {
							context = context[_locArr2[_k9]];
						}
					} else if (locVal.startsWith("'") || locVal.startsWith('"') || !isNaN(locVal)) {
						context = context[locVal.substring(1, locVal.length - 1)];
					} else {
						var val = this.get(initialContext, locVal);
						context = context[val];
					}
				}
				var lastKey = _arr3[i];
				if (lastKey.startsWith(".")) {
					//direct context switching
					var _locArr3 = lastKey.substring(1).split('.');
					var _k10 = 0;
					for (; _k10 < _locArr3.length - 1; _k10++) {
						context = context[_locArr3[_k10]];
					}
					lastKey = _locArr3[_k10];
				} else if (lastKey.startsWith("'") || lastKey.startsWith('"') || !isNaN(lastKey)) {
					lastKey = lastKey.substring(1, lastKey.length - 1);
				} else {
					lastKey = this.get(initialContext, lastKey);
				}
				return { "context": context, "lastKey": lastKey };
			} catch (e) {
				return undefined;
			}
		},
		"componentGetData": function componentGetData(key) {
			if (key) {
				return this.get(key);
			} else {
				return this.data;
			}
		},
		"componentSetData": function componentSetData(arg0, arg1, options) {
			if (typeof arg0 === "string") {
				this.set(arg0, arg1, options);
			} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
				for (var _key40 in arg0) {
					this.set(_key40, arg0[_key40], arg1);
				}
			}
		},
		"componentGetMethods": function componentGetMethods(key) {
			var node = this.$node;
			if (node) {
				if (key && node._methods) {
					return node._methods[key];
				} else {
					return node._methods;
				}
			}
		},
		"componentHasAction": function componentHasAction(key) {
			var node = this.$node;
			if (node) {
				if (key && node._actions[key]) {
					return true;
				} else {
					return false;
				}
			}
		},
		"componentsetActions": function componentsetActions(arg0, arg1) {
			var actions = this.$node._actions;
			if (typeof arg0 === "string") {
				actions[arg0] = arg1;
			} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
				for (var _key41 in arg0) {
					actions[_key41] = arg0[_key41];
				}
			}
		},
		"componentSetMethods": function componentSetMethods(arg0, arg1) {
			var node = this.$node;
			if (node) {
				if (typeof arg0 === "string") {
					node._methods[arg0] = arg1;
				} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
					for (var _key42 in arg0) {
						node._methods[_key42] = arg0[_key42];
					}
				}
			}
		},
		"render": function render(componentName, data, outlet, options) {
			var component;
			if (componentName) {
				if (typeof componentName == "string") {
					component = createElement(componentName);
				} else if (componentName.compName) {
					component = createElement(componentName.compName);
				} else {
					_Lyte.error("LC007");
					return;
				}
			} else {
				_Lyte.error("LC007");
				return;
			}

			if (data) {
				component.setData(data);
			}
			if (options && options.methods) {
				component.setMethods(options.methods);
			}
			if (outlet) {
				var actOutlet = void 0;
				if (typeof outlet == "string") {
					actOutlet = document.querySelector(outlet);
				} else {
					actOutlet = outlet;
				}
				if (actOutlet) {
					if (options && options.dataType) {
						component.component.__data = options.dataType;
					}
					actOutlet.appendChild(component);
					component._callee = component.getCallee ? component.getCallee(actOutlet) : undefined;
				} else {
					_Lyte.error("LC008", outlet);
				}
			}
			return component;
		},
		"String": {
			"cache_c": {},
			"cache_d": {},
			"upperCaseFirstLetter": function upperCaseFirstLetter(string) {
				return string.charAt(0).toUpperCase() + string.slice(1);
			},
			"lowerCaseFirstLetter": function lowerCaseFirstLetter(string) {
				return string.charAt(0).toLowerCase() + string.slice(1);
			},
			"toCamelCase": function toCamelCase(string) {
				if (!this.cache_c[string]) {
					this.cache_c[string] = string.replace(/(-\w)/g, function (m) {
						return m[1].toUpperCase();
					});
				}
				return this.cache_c[string];
			},
			"dasherize": function dasherize(string) {
				if (!this.cache_d[string]) {
					this.cache_d[string] = string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
				}
				return this.cache_d[string];
			}
		},
		"appendChild": function appendChild(outlet, component) {
			_LC.ignoreDisconnect = true;
			outlet.appendChild(component);
			_LC.ignoreDisconnect = false;
		},
		"replaceWith": function replaceWith() {
			var argumentsArr = Array.from(arguments);
			var oldNode = argumentsArr.shift();
			_LC.ignoreDisconnect = true;
			var parentNode = oldNode.parentNode;
			for (var i = 0, node; node = argumentsArr[i]; i++) {
				parentNode.insertBefore(node, oldNode);
			}
			oldNode.remove();
			_LC.ignoreDisconnect = false;
		},
		"insertBefore": function insertBefore(referenceNode, newNode, parentNode) {
			_LC.ignoreDisconnect = true;
			if (!parentNode) {
				if (!referenceNode) {
					_Lyte.error("LC010");
					_LC.ignoreDisconnect = false;
					return;
				} else {
					parentNode = referenceNode.parentNode;
				}
			}
			_insertBefore(parentNode, newNode, referenceNode ? referenceNode : null);
			_LC.ignoreDisconnect = false;
		},
		"insertAfter": function insertAfter() {
			var argumentsArr = Array.from(arguments);
			var referenceNode = argumentsArr.shift();
			_LC.ignoreDisconnect = true;
			referenceNode.after.apply(referenceNode, argumentsArr);
			_LC.ignoreDisconnect = false;
		},
		"executeMethod": function executeMethod() {
			var node = this.$node;
			if (node) {
				var args = Array.prototype.slice.call(arguments, 1);
				var methodName = _LC.String.toCamelCase(arguments[0]);
				if (!node._methods[methodName]) {
					_Lyte.error("LC009", methodName, this.$node.tagName);
					return;
				}
				return node._methods[methodName].apply(this, args);
			}
		},
		"getProperData": function getProperData(obj) {
			var dataType = obj.dataType;
			var attr = obj.attr;
			var newValue = obj.newValue;
			var tagName = obj.tagName;
			switch (dataType) {
				case "boolean":
					{
						if (!newValue || newValue === "false") {
							newValue = false;
						} else {
							newValue = true;
						}
					}
					break;
				case "object":
					try {
						newValue = JSON.parse(newValue);
						if (!(newValue instanceof Object)) {
							_Lyte.warn("data type of the value provided for attribute " + attr + " of " + tagName + " is not valid");
						}
					} catch (e) {
						_Lyte.warn("attribute " + attr + " is not a valid JSON string.");
						return;
					}
					break;
				case "array":
					try {
						newValue = JSON.parse(newValue);
						if (!(newValue instanceof Array)) {
							_Lyte.warn("data type of the value provided for attribute " + attr + " of " + tagName + " is not valid");
						}
					} catch (e) {
						_Lyte.warn("attribute " + attr + " is not a valid JSON string.");
						return;
					}
					break;
				case "number":
					{
						var numValue = +newValue;
						if (newValue === numValue + "") {
							newValue = numValue;
						} else {
							_Lyte.warn("data type of the value provided for attribute " + attr + " of " + tagName + " is not valid");
							return;
						}
					}
					break;
			}
			obj.newValue = newValue;
			return true;
		},
		"cssEscape": function cssEscape(string) {
			if (string) {
				return string.replace(/['"]/g, "\\$&");
			} else {
				return string;
			}
		}

	};
	_Lyte.typeCast = LyteComponent.typeCast;
	_Lyte.getDataType = LyteComponent.getDataType;
	_Lyte.Component._get = LyteComponent.get;
	_LyteComponent.chromeBugFix = function () {
		var version = userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);;
		version = version ? parseInt(version[2], 10) : 0;
		if (version > 62) {
			this.chI = [];
			document.addEventListener("focus", function (event) {
				var target = event.target;
				if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "DIV") {
					if (Lyte.Component.chI.indexOf(target) == -1) {
						Lyte.Component.chI.push(target);
					}
				}
			}, true);
			this.chromeBugFix = function () {
				var tags = Lyte.Component.chI;
				var tagsL = tags.length;
				var toRemove = ["_callee", "_attributeDetails", "_attributes", "_removedAttributes", "_yields", "_rA", "_cx"]; //no i18n
				var toBeRemoved = [];
				var keepAliveInputs = [];
				document.querySelectorAll("[lyte-keep-alive]").forEach(function (item, index) {
					for (var key in item._renderedComponent) {
						keepAliveInputs.push.apply(keepAliveInputs, Array.from(item._renderedComponent[key].querySelectorAll("input")));
					}
				});
				for (var i = tagsL - 1, item; item = tags[i]; i--) {
					if (document.compareDocumentPosition(item) % 2 && keepAliveInputs.indexOf(item) == -1) {
						tags.splice(i, 1);
						item.remove();
						toBeRemoved.push(item);
						item._rA = item._rA || [];
						item._rA.forEach(function (remAttr) {
							//eslint-disable-line no-loop-func
							remAttr.ownerElement = undefined;
						});
						toRemove.forEach(function (key) {
							//eslint-disable-line no-loop-func
							item[key] = undefined;
						});
						Array.from(item.attributes).forEach(function (itemVal) {
							//eslint-disable-line no-loop-func
							item.removeAttribute(itemVal.nodeName);
						});
					}
				}
			};
			Lyte.addEventListener("afterRouteTransition", function () {
				Lyte.Component.chromeBugFix();
			});
			if (!Lyte.Router) {
				setInterval(function () {
					// Lyte.Component.chromeBugFix();
					LyteComponent.String.cache_c = {};
					LyteComponent.String.cache_d = {};
				}, 300000);
			}
		}
	};

	var _LC = LyteComponent;

	customElements.define("lyte-safari-test-component", Test);
	var divTest = document.createElement("div");
	divTest.innerHTML = "<lyte-safari-test-component t></lyte-safari-test-component>";

	_LyteComponent.render = _LC.render;
	//Change it in v3.0 - Remove from LyteComponent scope. 
	_LyteComponent.insertBefore = _LC.insertBefore;
	_LyteComponent.insertAfter = _LC.insertAfter;
	_LyteComponent.replaceWith = _LC.replaceWith;
	_LyteComponent.appendChild = _LC.appendChild;
	_LC.tDiv = createElement("template");
	// _LC.tDiv = createElement("div");
	_LC.tDiv.setAttribute("id", "dummy-templates-div");
	// _LC.tDiv.setAttribute("style", "display:none");
	_LC.hDiv = createElement("template");

	// _LC.hDiv = createElement("div");
	_LC.hDiv.setAttribute("id", "keep-alive-div");
	// _LC.hDiv.setAttribute("style", "display:none");
	_LC.h1Div = createElement("template");

	// _LC.h1Div = createElement("div");
	_LC.h1Div.setAttribute("id", "lyte-helper-div");
	// _LC.h1Div.setAttribute("style", "display:none");
	Lyte.Compile.componentsDiv = _LC.lyteComponentsDiv = createElement("div");
	_LC.lyteComponentsDiv.setAttribute("id", "lyte-components-div");

	Set.prototype.toArrayLyte = function () {
		if (this.constructor.name === "Set") {
			return Array.from(this);
		} else {
			return Array.from(this._values);
		}
	};
	//_LC.registerListener(function() {
	//  
	//});

	if (document.readyState === "complete" || document.readyState === "interactive") {
		onDomContentForLyte();
	} else {
		document.addEventListener("DOMContentLoaded", function (e) {
			onDomContentForLyte();
		}, true);
	}
	function createSvgDepth(actualTemplate, type) {
		var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		for (var s = 0; s < actualTemplate.childNodes.length; s++) {
			svg.appendChild(actualTemplate.childNodes[s].cloneNode(true));
		}
		var depthTemp = document.createElement("template");
		depthTemp.setAttribute("is", type);
		for (var s = 0; s < svg.childNodes.length; s++) {
			depthTemp.content.appendChild(svg.childNodes[s]);
			s--;
		}
		return depthTemp;
	}
	function createDepth(actualTemplate, type) {
		var depthTemp = document.createElement("template");
		depthTemp.setAttribute("is", type);
		depthTemp.innerHTML = actualTemplate.innerHTML;
		return depthTemp;
	}
	function appendDepth(depthTemp, constr) {
		constr.splitTextNodes(depthTemp);
		constr._depthTemp.content.appendChild(depthTemp);
	}
	function setHT(dynN, info, dynNewCompile, constr) {
		var flag = true;
		if (dynN.tagName == "TEMPLATE") {
			info._ht = dynN.innerHTML;
			flag = false;
		}
		if (info._ht) {
			if (flag) {
				dynN.innerHTML = info._ht;
				constr.splitTextNodes(dynN);
			}
			if (dynNewCompile && dynNewCompile.innerHTML !== info._ht) {
				dynNewCompile.innerHTML = info._ht;
				constr.splitTextNodes(dynNewCompile);
			}
		}
	}
	function doCompile(dynamicN, dynamicNodes, componentName, constr, newCompile) {
		var lastUsedAttrPosition = void 0;

		var _loop = function _loop(j) {
			var info = dynamicNodes[j],
			    type = info.type,
			    pos = info.position,
			    helperInfo = void 0;
			var dynN = getDynamicNode(dynamicN, pos);
			var dynNewCompile = void 0;
			if (newCompile) {
				dynNewCompile = getDynamicNode(newCompile, pos);
			}
			switch (type) {
				case "text":
					{
						var mustache = Lyte.Compile.getMustache(dynN.nodeValue),
						    dynamicValue = void 0,
						    helperFunc = void 0;
						if (mustache) {
							helperFunc = Lyte.Compile.getHelper(mustache);
						}
						var dynamic = mustache;
						if (helperFunc) {
							info.helperInfo = helperFunc;
							if (dynNewCompile) {
								info.newHelperInfo = Lyte.Compile.getHelper(mustache, true);
								_LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte" + j + "__**"));
							}
						} else if (dynamic) {
							//deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: dynamic});
							info.dynamicValue = dynamic;
							info.newDynamicValue = _LC.getDV(dynamic);
							if (dynNewCompile) {
								_LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte" + j + "__**"));
							}
							//              LN to do
							//              deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: getDV(dynamic)});                    
						}
					}
					break;
				case "insertYield":
					{
						if (dynNewCompile) {
							dynNewCompile.appendChild(document.createTextNode("__**--Lyte" + j + "__**"));
							var yieldAttr = dynNewCompile.attributes["yield-name"];
							info.yieldName = yieldAttr ? yieldAttr.nodeValue : undefined;
						}
					}
					break;
				case "componentDynamic":
					{
						if (dynNewCompile) {
							dynNewCompile.appendChild(document.createTextNode("__**--Lyte" + j + "__**"));
							info.componentName = dynNewCompile.localName;
							attrs = Array.from(dynNewCompile.attributes);

							info.staticAttrs = {};
							for (i = 0; i < attrs.length; i++) {
								info.staticAttrs[_LC.String.toCamelCase(attrs[i].nodeName)] = attrs[i].nodeValue;
							}
							delete info.staticAttrs._lyteprop;
						}
					}
					break;
				case "attr":
					{
						var add = false,
						    toBeRemoved = [],
						    toBeAdded = [];
						var node = dynN;
						var attr = info.attr = info.attr || {};
						for (var _i85 = 0; _i85 < node.attributes.length; _i85++) {
							if (node.attributes[_i85].nodeValue.indexOf("{{") !== -1) {
								var val = node.attributes[_i85].nodeValue;
								var actValue = Lyte.Compile.getMustache(val),
								    actObj = void 0;
								if (actValue) {
									actObj = Lyte.Compile.getHelper(actValue);
								} else if (/{{.*}}/.test(val) && !/\\{{.*}}/.test(val)) {
									actObj = Lyte.Compile.splitMixedText(val);
								}
								if (actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|__focus|__focusin|__focusout|__resize|__scroll|__click|__dblclick|__mousedown|__mouseup|__mousemove|__mouseover|__mouseout|__change|__select|__submit|__keydown|__keypress|__keyup|__contextmenu)$/.test(node.attributes[_i85].name)) {
									attr[node.attributes[_i85].name.substr(2)] = { name: node.attributes[_i85].name.substr(2), camelCase: _LC.String.toCamelCase(node.attributes[_i85].name.substr(2)), helperInfo: actObj, newHelperInfo: Lyte.Compile.getHelper(actValue, true), globalEvent: true };

									var actArgs = _Lyte.deepCopyObject(actObj.args);
									var actName = actArgs.splice(0, 1)[0];
									actName = actName.startsWith("'") ? actName.replace(/'/g, '') : actName;
									var actString = getArgString(actName, actArgs);
									node.setAttribute(node.attributes[_i85].name.substr(2), componentName + " => " + actString);
									if (dynNewCompile) {
										dynNewCompile.setAttribute(node.attributes[_i85].name.substr(2), componentName + " => " + actString);
									}
									toBeRemoved.push(node.attributes[_i85].name);
								} else {
									if (actObj || actValue) {
										var attrToPush = {};

										if (node.attributes[_i85].name.startsWith("lbind:")) {
											toBeRemoved.push(node.attributes[_i85].name);
											toBeAdded.push({ "name": node.attributes[_i85].name.substring(6), "value": node.attributes[_i85].nodeValue });
											attrToPush.isLbind = true;
											attrToPush.name = node.attributes[_i85].name.substring(6);
											attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
										} else {
											attrToPush.name = node.attributes[_i85].name;
											attrToPush.camelCase = _LC.String.toCamelCase(attrToPush.name);
										}
										if (actObj) {
											if (actObj.name === "lbind") {
												attrToPush.dynamicValue = actObj.args[0];
												attrToPush.newDynamicValue = _LC.getDV(actObj.args[0]);
												attrToPush.isLbind = true;
											} else {
												attrToPush.helperInfo = actObj;
												attrToPush.newHelperInfo = Lyte.Compile.getHelper(actValue, true);
											}
										} else {
											attrToPush.dynamicValue = actValue;
											//                              LN to do
											attrToPush.newDynamicValue = _LC.getDV(actValue);
										}
										add = true;
										attr[attrToPush.name] = attrToPush;
									}
								}
							}
						}
						if (toBeRemoved.length) {
							for (var _i86 = 0; _i86 < toBeRemoved.length; _i86++) {
								node.removeAttribute(toBeRemoved[_i86]);
								if (dynNewCompile) {
									dynNewCompile.removeAttribute(toBeRemoved[_i86]);
								}
							}
						}
						if (dynNewCompile) {
							for (key in attr) {
								dynNewCompile.removeAttribute(key);
							}
							dynNewCompile.setAttribute("_lyteAttr", "__**--Lyte" + j + "__**", "");
						}
						if (toBeAdded.length) {
							for (var _i87 = 0; _i87 < toBeAdded.length; _i87++) {
								node.setAttribute(toBeAdded[_i87].name, toBeAdded[_i87].value);
							}
						}
					}
					break;
				case "for":
				case "forIn":
				case "registerYield":
					setHT(dynN, info, dynNewCompile, constr);
				case "component":
					{
						actualTemplate = _Lyte._ie ? dynN : dynN.content;

						if (!dynNewCompile && (type == "registerYield" || dynN.hasAttribute("unbound"))) {
							if (_Lyte._ms) {
								dynNewCompile = document.createElement("div");
								dynNewCompile.innerHTML = info.actualTemplate ? info.actualTemplate : dynN.outerHTML;
								dynNewCompile = dynNewCompile.childNodes[0];
								constr.splitTextNodes(dynNewCompile);
							} else {
								dynNewCompile = dynN.cloneNode(true);
							}
						}
						var depthTemp = void 0;
						var dnNode = void 0;
						actualTemplateNewCompile = dynNewCompile ? _Lyte._ie ? dynNewCompile : dynNewCompile.content : undefined;

						var args = {};
						if (info.actualTemplate) {
							actualTemplate = _LC.getContentForIE(info.actualTemplate, constr, undefined, _Lyte._ms ? info : undefined);
							if (dynNewCompile) {
								actualTemplateNewCompile = _LC.getContentForIE(info.actualTemplate, constr);
							}
						}
						doCompile(actualTemplate, info.dynamicNodes, componentName, constr, actualTemplateNewCompile, info);
						if (actualTemplateNewCompile) {
							var staticTemp = info.actualTemplate ? actualTemplateNewCompile : dynNewCompile;
							info._sta = _LC.processStatic(staticTemp);
						}
						if (_Lyte._ms) {
							if (info.actualTemplate) {
								info.templateContent = actualTemplate.outerHTML;
								if (info._content) {
									info.actualTemplate = info._content.innerHTML;
									delete info._content;
								}
							} else {
								info.templateContent = dynN.outerHTML;
							}
							dynN.innerHTML = "";
						}
						if (info.actualTemplate) {
							depthTemp = type;
							if (!_Lyte._ie) {
								if (info.svg) {
									depthTemp = createSvgDepth(actualTemplate, type);
								} else {
									depthTemp = createDepth(actualTemplate, type);
								}
								appendDepth(depthTemp, constr);
							}
							if (dynamicNodes[j - 1] && dynamicNodes[j - 1].position.toString() === dynamicNodes[j].position.toString()) {
								dnNode = dynamicNodes[j - 1];
							} else {
								dnNode = dynamicNodes[j];
							}
							dnNode._depthTemp = depthTemp;
						}

						if (dynNewCompile) {
							info._args = {};
							if (type === "registerYield") {
								//dynNewCompile.parentNode.parentNode.insertBefore(document.createTextNode("__**--Lyte"+j+"__**"), dynNewCompile.parentNode);
								//dynNewCompile.parentNode.setAttribute("_lyteyield", "");
								//_LC.replaceWithPf(dynNewCompile, document.createTextNode(""));
								_LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte" + j + "__**"));
							} else if (type === "component") {
								_LC.replaceWithPf(dynNewCompile, document.createTextNode((dynNewCompile.hasAttribute("_lyteattr") ? dynNewCompile.getAttribute("_lyteattr") : "") + "__**--Lyte" + j + "__**"));
							} else {
								//dynNewCompile.replaceWith(document.createTextNode("__**--Lyte"+j+"__**"))
								_LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte" + j + "__**"));
							}
							Array.from(dynNewCompile.attributes).forEach(function (item) {
								//eslint-disable-line no-loop-func
								info._args[item.nodeName] = item.nodeValue;
							});
						}
						if (info._ht) {
							info._ht = dynN.cloneNode(true);
							constr._helperTemplate.content.append(info._ht);
							dynN.innerHTML = "";
						}
						//  When a registerYield is present inside another registerYield, in fastRender, we will not be able to get the template using the positions and parentComponent alone, since the insertYield is present inside the insertYield of the parent component. 
						// info.actYield = dynN;
					}
					break;
				case "if":
				case "switch":
					{
						setHT(dynN, info, dynNewCompile, constr);
						oldDyn = dynN;

						var _depthTemp = void 0;
						actualTemplateNewCompile = dynNewCompile ? _Lyte._ie ? dynNewCompile : dynNewCompile.content : undefined;

						if (info.actualTemplate) {
							dynN = _LC.getContentForIE(info.actualTemplate, constr, undefined);
							if (dynNewCompile) {
								var dummy = _LC.getContentForIE(info.actualTemplate, constr);
								actualTemplateNewCompile = _Lyte._ie ? dummy : dummy.content;
							}
						}
						def = "default";

						if (_Lyte._ms) {
							cases = {};
							dynNchildNodes = _Lyte._ed ? dynN.content.childNodes : dynN.childNodes;

							for (i = 0; i < dynNchildNodes.length; i++) {
								if (dynNchildNodes[i].tagName === "TEMPLATE") {
									if (dynNchildNodes[i].getAttribute("case")) {
										cases[dynNchildNodes[i].getAttribute("case")] = dynNchildNodes[i];
									} else if (dynNchildNodes[i].hasAttribute("default")) {
										defCase = dynNchildNodes[i];
									}
								}
							}
							for (key in info.cases) {
								var contentNewCompile = void 0;
								content = _LC.getContentForIE(cases[key], undefined, true);
								if (actualTemplateNewCompile) {
									contentNewCompile = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[case='" + LyteComponent.cssEscape(key) + "']"));
								}
								setHT(content, info.cases[key], contentNewCompile, constr);
								doCompile(content, info.cases[key].dynamicNodes, componentName, constr, contentNewCompile ? _LC.getContentForIE(contentNewCompile) : undefined);

								cases[key].remove();
								if (actualTemplateNewCompile) {
									info.cases[key]._sta = _LC.processStatic(contentNewCompile);
								}
								info.cases[key].templateContent = cases[key].outerHTML;
							}
							if (info[def].dynamicNodes) {
								var _contentNewCompile = void 0;
								content = _LC.getContentForIE(defCase, undefined, true);
								if (actualTemplateNewCompile) {
									_contentNewCompile = actualTemplateNewCompile.querySelector("[default]");
								}
								setHT(content, info[def], _contentNewCompile, constr);
								doCompile(content, info[def].dynamicNodes, componentName, constr, _contentNewCompile ? _LC.getContentForIE(_contentNewCompile) : undefined);

								defCase.remove();
								info[def].templateContent = defCase.outerHTML;
								if (actualTemplateNewCompile) {
									info[def]._sta = _LC.processStatic(_contentNewCompile);
								}
							}
						} else {
							dynNContent = dynN.content || dynN;

							for (var _key43 in info.cases) {
								var _contentNewCompile2 = void 0;
								if (actualTemplateNewCompile) {
									_contentNewCompile2 = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[case='" + LyteComponent.cssEscape(_key43) + "']"));
								}
								content = _LC.getContentForIE(dynNContent.querySelector("[case='" + _LC.cssEscape(_key43) + "']"), undefined, true);

								setHT(content, info.cases[_key43], _contentNewCompile2, constr);
								doCompile(content.tagName === "TEMPLATE" ? content.content : content, info.cases[_key43].dynamicNodes, componentName, constr, _contentNewCompile2);
								if (actualTemplateNewCompile) {
									info.cases[_key43]._sta = _LC.processStatic(_contentNewCompile2);
								}
								if (info.cases[_key43]._ht) {
									info.cases[_key43]._ht = content.cloneNode(true);
									constr._helperTemplate.content.append(info.cases[_key43]._ht);
									content.innerHTML = "";
								}
							}
							if (info[def].dynamicNodes) {
								var _contentNewCompile3 = void 0;
								if (actualTemplateNewCompile) {
									_contentNewCompile3 = _LC.getContentForIE(actualTemplateNewCompile.querySelector("[default]"));
								}
								content = _LC.getContentForIE(dynNContent.querySelector("[default]"), undefined, true);

								setHT(content, info[def], _contentNewCompile3, constr);
								doCompile(content.tagName === "TEMPLATE" ? content.content : content, info[def].dynamicNodes, componentName, constr, _contentNewCompile3);
								if (actualTemplateNewCompile) {
									info[def]._sta = _LC.processStatic(_contentNewCompile3);
								}
								if (info[def]._ht) {
									info[def]._ht = content.cloneNode(true);
									constr._helperTemplate.content.append(info[def]._ht);
									content.innerHTML = "";
								}
							}
						}

						if (info.actualTemplate) {
							_depthTemp = type;
							if (!_Lyte._ie) {
								if (info.svg) {
									_depthTemp = createSvgDepth(dynN.content, type);
								} else {
									_depthTemp = createDepth(dynN, type);
								}
								appendDepth(_depthTemp, constr);
							}
							if (dynamicNodes[j - 1] && dynamicNodes[j - 1].position.toString() === dynamicNodes[j].position.toString()) {
								dynamicNodes[j - 1]._depthTemp = _depthTemp;
							} else {
								dynamicNodes[j]._depthTemp = _depthTemp;
							}
						}

						if (dynNewCompile) {
							_LC.replaceWithPf(dynNewCompile, document.createTextNode("__**--Lyte" + j + "__**"));
						}
						if (info._ht) {
							info._ht = dynN.cloneNode(true);
							constr._helperTemplate.content.append(info._ht);
							dynN.innerHTML = "";
						}
					}
					break;
			}
		};

		for (var j = 0; j < dynamicNodes.length; j++) {
			var attrs;
			var i;
			var key;
			var actualTemplate;
			var actualTemplateNewCompile;
			var oldDyn;
			var actualTemplateNewCompile;
			var def;
			var cases;
			var defCase;
			var dynNchildNodes;
			var i;
			var key;
			var dynNContent;
			var content;
			var content;

			_loop(j);
		}
	}

	//This is the function where the actual rendering takes place. 
	//It takes the template, finds the actual dynamic nodes uwing dynamicNodes argument and then binds each node with the associated
	//property by calling bindNode. 

	function getDynamicNode(content, positions) {
		var dynamicN = content;
		for (var i = 0; i < positions.length; i++) {
			dynamicN = dynamicN.tagName != "TEMPLATE" || _Lyte._ie ? dynamicN.childNodes[positions[i]] : dynamicN.content.childNodes[positions[i]];
		}
		return dynamicN;
	}

	function getArgString(name, array) {
		var retString = void 0;
		for (var _i88 = 0; _i88 < array.length; _i88++) {
			if (array[_i88] && _typeof(array[_i88]) === "object") {
				array[_i88] = getArgString(array[_i88].value.name, array[_i88].value.args);
			}
		}
		if (name) {
			retString = name + "(" + array.toString() + ")";
		} else {
			retString = array.toString();
		}
		return retString;
	}

	_LC[registerHelperStr]("unbound", function (value) {
		return value;
	});

	_LC[registerHelperStr]("action", function (parentNode, attrName, isCustom, actObj) {
		if (isCustom) {
			parentNode._actions = parentNode._actions ? parentNode._actions : {};
			if (!parentNode._actions[attrName]) {
				this.createCustomEvent(attrName, parentNode, actObj);
				parentNode.removeAttribute(attrName);
			}
		} else {

			this.createEventListeners(parentNode, attrName, actObj);
		}
	});

	_LC[registerHelperStr]("lbind", function (name) {
		return this.getData(name);
	});

	_LC[registerHelperStr]("method", function (parentComponent, attributeNode, functionName) {
		var parentComponent = arguments[0];
		var attributeNode = arguments[1];
		var functionName = arguments[2];
		var self = arguments[0].component;
		var childComponent = attributeNode ? attributeNode.ownerElement : null;
		var attributeName = arguments[1].nodeName;
		attributeNode = null;
		var args = Array.prototype.slice.call(arguments, 2);
		var newFunc = function newFunc() {
			var node = this.$node;
			var contextSwitchArray = [];
			_LC.adCx(node, contextSwitchArray);
			var processedArgs = this.$node.processArgs(this.$node._callee, { "helperInfo": { "args": args } }, [], undefined, this.$node);
			var functionName1 = processedArgs.splice(0, 1)[0];
			_LC.rmCx(node, contextSwitchArray);
			var customArgs = Array.from(arguments);
			var mainArgs = processedArgs.concat(customArgs);
			if (self.$node._methods[functionName1]) {
				return self.$node._methods[functionName1].apply(self, mainArgs);
			}
			_Lyte.error("LC009", functionName, self.$node.tagName);
		};
		if (childComponent) {
			if (!childComponent.set) {
				childComponent.setMethods(_LC.String.toCamelCase(attributeName), newFunc);
			} else {
				childComponent._methods[_LC.String.toCamelCase(attributeName)] = newFunc;
			}
		} else {
			return newFunc;
		}
	});

	_LC[registerHelperStr]("unescapeAttr", function () {
		debugger;
		return Lyte.Component.registeredHelpers.unescape.apply(this, arguments).innerHTML;
	});
	_LC[registerHelperStr]("unescape", function (value, additionalObject, userInstance) {
		if (_LC.ffr) {
			return value;
		}
		if (Lyte.Security.ignoreSanitizer) {
			var _divEle = document.createElement("div");
			_divEle.innerHTML = value;
			return _divEle;
		} else {
			if (additionalObject && Object.keys(additionalObject) && Object.keys(additionalObject).length > 0) {
				if (Object(additionalObject.GLOBAL_TAGS).length > 0) {
					var index = additionalObject.GLOBAL_TAGS.indexOf("link-to");
					if (index != -1) {
						additionalObject.GLOBAL_TAGS.splice(index, 1);
					}
				}
				if (additionalObject && additionalObject.GLOBAL_ATTRIBUTES && Object.keys(additionalObject.GLOBAL_ATTRIBUTES).length > 0) {
					var arr = ["is", "yield-name", "lt-prop-route", "lt-prop-dp", "lt-prop-fragment", "lt-prop-qp", "lt-prop", "lt-prop-class", "lt-prop-id", "lt-prop-rel", "lt-prop-title", "lt-prop-style", "lt-prop-target", "lt-prop-td", "lt-prop-custom", "lt-prop-target", "lt-prop-id", "lt-prop-class", "lt-prop-style", "lt-prop-rel", "lt-prop-title"];
					for (var i = 0; i < arr.length; i++) {
						var index = additionalObject.GLOBAL_ATTRIBUTES.indexOf(arr[i]);
						if (index != -1) {
							additionalObject.GLOBAL_ATTRIBUTES.splice(index, 1);
						}
					}
				}
			}
			if (additionalObject && additionalObject.GLOBAL_TAGS) {
				//this if check is inorder to getobserved attributes given in globaltags
				if (additionalObject.GLOBAL_ATTRIBUTES == undefined) {
					additionalObject.GLOBAL_ATTRIBUTES = [];
				}
				var globalTagArr = Array.from(additionalObject.GLOBAL_TAGS);
				var attr = [];
				for (var a = 0; a < globalTagArr.length; a++) {
					if (LyteComponent._registeredComponents[globalTagArr[a]]) {
						attr = LyteComponent._registeredComponents[globalTagArr[a]].observedAttributes;
					} else if (Lyte.registeredCustomComponent[globalTagArr[a]]) {
						if (Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes) {
							attr = Lyte.registeredCustomComponent[globalTagArr[a]].observedAttributes;
						} else {
							attr = [];
						}
					}
					for (var i = 0; i < attr.length; i++) {
						if (additionalObject.GLOBAL_ATTRIBUTES.indexOf(attr[i]) == -1) {
							additionalObject.GLOBAL_ATTRIBUTES.push(attr[i]);
						}
					}
				}
			}
			var divEle = document.createElement("div");
			if (userInstance && Object.keys(userInstance).length) {
				if (additionalObject && Object.keys(additionalObject).length) {
					Lyte.Security.addGlobalObject(userInstance, additionalObject);
					var clean = userInstance.sanitize(value);
					Lyte.Security.removeGlobalObject(userInstance, additionalObject);
				} else {
					var clean = userInstance.sanitize(value);
				}
			} else {
				if (additionalObject && Object.keys(additionalObject).length) {
					Lyte.Security.addGlobalObject(Lyte.Security._ourSanitizerInstance_, additionalObject);
					var clean = Lyte.Security._ourSanitizerInstance_.sanitize(value);
					Lyte.Security.removeGlobalObject(Lyte.Security._ourSanitizerInstance_, additionalObject);
				} else {
					var clean = Lyte.Security._ourSanitizerInstance_.sanitize(value);
				}
			}
			divEle.innerHTML = clean;
			return divEle;
		}
	});

	_LC[registerHelperStr]("escape", function (value, type) {
		if (type == 'url') {
			return ZWAF['7_0_0'].Encoder.encodeForHTMLAttribute(value);
		} else if (type == 'js') {
			return ZWAF['7_0_0'].Encoder.encodeForJavaScript(value);
		} else if (type == 'css') {
			return ZWAF['7_0_0'].Encoder.encodeForCSS(value);
		} else {
			return value;
		}
	});

	_LC[registerHelperStr]("debugger", function () {
		debugger;
	});

	_LC[registerHelperStr]("log", function () {
		console.log.apply(window, Array.from(arguments));
	});

	_LC[registerHelperStr]("ifEquals", function (arg1, arg2) {
		if (arg1 === arg2) {
			return true;
		} else {
			return false;
		}
	});

	_LC[registerHelperStr]("if", function (value, trueValue, falseValue) {
		if (value) {
			return trueValue;
		} else {
			return falseValue;
		}
	});

	_LC[registerHelperStr]("negate", function (arg1) {
		return !arg1;
	});

	_LC[registerHelperStr]("ifNotEquals", function (arg1, arg2) {
		if (arg1 === arg2) {
			return false;
		} else {
			return true;
		}
	});

	_LC[registerHelperStr]('concat', function () {
		var resp = '';
		var argLength = arguments.length;
		for (var i = 0; i < argLength; i++) {
			if (arguments[i] != undefined) {
				resp += arguments[i];
			}
		}
		return resp;
	});

	defProp(HTMLElement.prototype, 'setData', {
		enumerable: false,
		value: function value(arg0, arg1) {
			this._initProperties = this._initProperties || {};
			if (typeof arg0 === "string") {
				this._initProperties[arg0] = arg1;
			} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
				for (var _key44 in arg0) {
					this._initProperties[_key44] = arg0[_key44];
				}
			}
		}
	});

	defProp(HTMLElement.prototype, 'setMethods', {
		enumerable: false,
		value: function value(arg0, arg1) {
			this._initMethods = this._initMethods || {};
			if (typeof arg0 === "string") {
				this._initMethods[arg0] = arg1;
			} else if ((typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) === "object") {
				for (var _key45 in arg0) {
					this._initMethods[_key45] = arg0[_key45];
				}
			}
		}
	});

	_LC[registerHelperStr]('encAttr', function (val) {
		return ZWAF['7_0_0'].Encoder.encodeForHTMLAttribute(encodeURIComponent(val));
	});

	_LC[registerHelperStr]('expHandlers', function (leftOperand, operator, rightOperand, nextOperand) {
		var argLen = arguments.length;
		if (operator == '++') {
			if (rightOperand == "postfix") {
				return leftOperand++;
			} else if (rightOperand == "prefix") {
				return ++leftOperand;
			}
		} else if (operator == "--") {
			if (rightOperand == "postfix") {
				return leftOperand--;
			} else if (rightOperand == "prefix") {
				return --leftOperand;
			}
		} else if (operator == "==") {
			return leftOperand == rightOperand;
		} else if (operator == "===") {
			return leftOperand === rightOperand;
		} else if (operator == "!=") {
			return leftOperand != rightOperand;
		} else if (operator == "!==") {
			return leftOperand !== rightOperand;
		} else if (operator == "&&") {
			return leftOperand && rightOperand;
		} else if (operator == "||") {
			return leftOperand || rightOperand;
		} else if (operator == "+") {
			if (argLen > 2) {
				return leftOperand + rightOperand;
			}
			return leftOperand;
		} else if (operator == '-') {
			if (argLen > 2) {
				return leftOperand - rightOperand;
			}
			return -leftOperand;
		} else if (operator == '*') {
			return leftOperand * rightOperand;
		} else if (operator == "/") {
			return leftOperand / rightOperand;
		} else if (operator == "%") {
			return leftOperand % rightOperand;
		} else if (operator == "<") {
			return leftOperand < rightOperand;
		} else if (operator == ">") {
			return leftOperand > rightOperand;
		} else if (operator == "<=") {
			return leftOperand <= rightOperand;
		} else if (operator == ">=") {
			return leftOperand >= rightOperand;
		} else if (operator == '|') {
			return leftOperand | rightOperand;
		} else if (operator == '&') {
			return leftOperand & rightOperand;
		} else if (operator == "!") {
			return !leftOperand;
		} else if (operator == '=') {
			leftOperand = rightOperand;
			return leftOperand;
		} else if (operator == "+=") {
			return leftOperand += rightOperand;
		} else if (operator == '-=') {
			return leftOperand -= rightOperand;
		} else if (operator == "*=") {
			return leftOperand *= rightOperand;
		} else if (operator == '/=') {
			return leftOperand /= rightOperand;
		} else if (operator == '?:') {
			return leftOperand ? rightOperand : nextOperand;
		}
	});

	_LyteComponent.register("lyte-event-listener", {
		_template: "<template tag-name=\"lyte-event-listener\"></template>",
		_dynamicNodes: [],
		_observedAttributes: ['eventName'],
		init: function init() {
			var self = this;
			var regId = _Lyte.addEventListener(this.get('eventName'), function () {
				var args = Array.prototype.slice.call(arguments);
				args.splice(0, 0, 'on-fire');
				self.throwEvent.apply(self, args);
			});
			//this.set('regId', regId);
			this.regId = regId;
		},
		data: function data() {
			return {
				"eventName": _Lyte.attr("string")
			};
		},
		didDestroy: function didDestroy() {
			_Lyte.removeEventListener(this.regId);
		}
	});

	_LyteComponent.registerCustomPropHandler("ltProp");

	_LyteComponent.shouldIgnoreDisconnect = function () {
		return _LC.ignoreDisconnect;
	};

	_LyteComponent.addLyteEventListener = function (element, eventName, func, context) {
		element._lyteEvents = element._lyteEvents || {};
		element._lyteEvents[eventName] = element._lyteEvents[eventName] || [];
		var ind = element._lyteEvents[eventName].push({ "func": func, "fromEventListener": true, "context": context });
		return eventName + "-" + ind;
	};

	_LyteComponent.removeLyteEventListener = function (element, listenerId) {
		if (!listenerId) {
			_Lyte.error("No listenerId provided");
			return;
		}
		var split = listenerId.split('-');
		var eventName = split[0];
		var index = parseInt(split[1]);
		if (!element._lyteEvents || !element._lyteEvents[split[0]] || isNaN(index)) {
			_Lyte.error("Invalid listenerId / listener is not available");
			return;
		}
		element._lyteEvents[split[0]][split[1] - 1] = {};
	};

	_LyteComponent.throwEvent = _LC.throwEvent;

	_LC.hasLyteEvents = function (element, eventName) {
		if (element._lyteEvents && element._lyteEvents[eventName]) {
			return true;
		} else {
			return false;
		}
	};

	_LC.handleLyteEvents = function (element, event) {
		var funcs = element._lyteEvents[event.type];
		var ret;
		var eventStopped;
		for (var i = 0; i < funcs.length; i++) {
			if (funcs[i].func) {
				ret = funcs[i].func.call(funcs[i].context ? funcs[i].context : window, event);
				if (ret === false || event.cancelBubble) {
					eventStopped = true;
					break;
				}
			}
		}
		if (eventStopped) {
			event.stopPropagation();
		}
		return eventStopped;
	};

	Object.defineProperty(window, "LyteComponent", {
		get: function get() {
			_Lyte.warn("Usage of LyteComponent is deprecated. Use Lyte.Component instead");
			return LyteComponent;
		}
	});
	_LyteComponent.chromeBugFix();
	_LC.booleanAttrList = ["async", "autocomplete", "autofocus", "autoplay", "border", "challenge", "checked1", "compact", "contenteditable", "controls", "default", "defer", "disabled", "formNoValidate", "frameborder", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "readonly", "required", "reversed", "scoped", "scrolling", "seamless", "selected", "sortable", "spellcheck", "translate"];
	Lyte.$.requiredMixins.component = function (mix, compDetails) {
		var mixinsToBeUsed = [];
		var actionsFromMixin = {};
		var methodsFromMixin = {};
		var newDefinition = {};
		mixinsToBeUsed.push(mix);
		compDetails.forEach(function (ele) {
			var componentName = ele;
			var customCrmComponent = LyteComponent._registeredComponents[componentName];
			if (mixinsToBeUsed.length) {
				LyteComponent.dataFromMixin(mixinsToBeUsed, actionsFromMixin, methodsFromMixin, newDefinition);
			}
			customCrmComponent._actions = Object.assign(customCrmComponent._actions, actionsFromMixin);
			var methods = Object.assign(customCrmComponent._methods, methodsFromMixin);
			delete newDefinition.methods;
			LyteComponent.updateCustomCrmComponent(newDefinition, customCrmComponent);
			customCrmComponent._methods = methods;
			LyteComponent._registeredComponents[componentName] = customCrmComponent;
		});
	};

	Lyte.$.injectServices.component = function (key, name, type, ins, compClass, data) {
		if (compClass) {
			var obj = {};
			obj[compClass.compName] = compClass;
		}
		var registeredComponents = compClass ? obj : _LC._registeredComponents;
		if (registeredComponents) {
			var arr = Object.keys(registeredComponents);
			arr.forEach(function (comp) {
				var component = registeredComponents[comp];
				// obj = {};
				// obj[key] = name;
				// component._serviceToBeUsed = Object.assign(obj, component._serviceToBeUsed);
				if (ins && Lyte.__gS[key]) {
					component.component.prototype[key] = ins;
				} else {
					Lyte.$.requiredServices(key, name, function (serviceData, serviceKey) {
						component.component.prototype[serviceKey] = serviceData;
					}, undefined, undefined, true, data);
				}
			});
		}
	};
	//security
	Lyte.Security.addGlobalObject = function (instanceObj, additionalObj) {
		for (var property in additionalObj) {
			if (Array.isArray(additionalObj[property])) {
				additionalObj[property].forEach(function (item) {
					if (instanceObj["_" + property].indexOf(item) == -1) {
						instanceObj["_" + property].push(item);
					}
				});
			}
		}
	};
	Lyte.Security.removeGlobalObject = function (instanceObj, additionalObj) {
		for (var property in additionalObj) {
			if (Array.isArray(additionalObj[property])) {
				additionalObj[property].forEach(function (item) {
					var index = instanceObj["_" + property].indexOf(item);
					if (index != -1) {
						instanceObj["_" + property].splice(index, 1);
					}
				});
			}
		};
	};
	Lyte.Compile.getTrimmedContent = function (content, position, node) {
		var dummyContent = content;
		if (node) {
			position = [];
			var parentNode = node.parentNode;
			while (true) {
				position.unshift(this.getArrayIndex(parentNode.childNodes, node));
				parentNode = parentNode.parentNode;
				node = node.parentNode;
				if (!parentNode) {
					break;
				}
			}
		}
		for (var _i89 = 0; _i89 < position.length; _i89++) {
			for (var j = content.childNodes.length - 1; j > position[_i89]; j--) {
				content.childNodes[j].remove();
			}
			content = content.childNodes[position[_i89]];
		}
		return dummyContent;
	};
	Lyte.Compile.getArrayIndex = function (array, value) {
		for (var _i90 = 0; _i90 < array.length; _i90++) {
			if (array[_i90] === value) {
				return _i90;
			};
		}
	};

	Lyte.Compile.splitMixedText = function (str) {
		var stack = [],
		    start = 0,
		    helper = { name: "concat", args: [] },
		    strStack = [],
		    lastAdded,
		    helperStarted;
		for (var i = 0; i < str.length; i++) {
			var j = i;
			if (helperStarted && str[i] === "'") {
				if (lastAdded === "'" && str[i - 1] !== "\\") {
					strStack.pop();
					lastAdded = undefined;
				} else if (!strStack.length) {
					lastAdded = str[i];
					strStack.push(lastAdded);
				}
			} else if (helperStarted && str[i] === "\"") {
				if (lastAdded === "\"" && str[i - 1] !== "\\") {
					strStack.pop();
					lastAdded = undefined;
				} else if (!strStack.length) {
					lastAdded = str[i];
					strStack.push(lastAdded);
				}
			} else if ((helperStarted && !strStack.length || !helperStarted) && str[i - 1] !== "\\" && str[i] === "{" && str[++i] === "{") {
				stack.push('{{');
				helper.args.push("'" + str.substr(start, j - start) + "'");
				start = i + 1;
				helperStarted = true;
			} else if ((helperStarted && !strStack.length || !helperStarted) && str[i] === "}" && str[++i] === "}" && stack.length) {
				stack.pop(start);
				helperStarted = false;
				var toPush = str.substr(start, j - start);
				var actObj = this.getHelper(toPush);
				if (actObj) {
					toPush = actObj;
					helper.args.push({ type: "helper", value: toPush });
				} else {
					helper.args.push(toPush);
				}
				start = i + 1;
			}
		}
		// if(stack.length){
		// return false;
		// }
		if (start < str.length) {
			helper.args.push("'" + str.substr(start, str.length - start) + "'");
		}
		return helper;
	};

	Lyte.Compile.getHelper = function (dynamicValue, newCompile) {
		var helperValue = /\((?:[^)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/.exec(dynamicValue);
		if (helperValue) {
			return this.getHelperInfo(dynamicValue, helperValue, newCompile);
		}
		return undefined;
	};

	Lyte.Compile.getHelperInfo = function (dynamicValue, helperValue, newCompile) {
		var helperFunc = {};
		helperFunc.name = dynamicValue.substr(0, helperValue.index).replace(/\s/g, '');
		helperValue = helperValue ? helperValue[0].trim() : helperValue;
		if (helperFunc.name == "lyteViewPort" && helperValue == "()") {
			helperFunc.args = [];
			return helperFunc;
		}
		var args = this.getHelperArgs(helperValue.substr(1, helperValue.length - 2), newCompile);
		if (args === false) {
			return false;
		}
		helperFunc.args = args;
		return helperFunc;
	};

	Lyte.Compile.getHelperArgs = function (str, newCompile) {
		var stack = [],
		    args = [],
		    from = 0;
		var lastPushed = void 0;
		for (var _i91 = 0; _i91 < str.length; _i91++) {
			if (!stack.length && str.charAt(_i91) === ",") {
				var _toPush2 = str.substr(from, _i91 - from);
				_toPush2 = _toPush2.trim();
				if (_toPush2 && _toPush2.startsWith("\"") && _toPush2.endsWith("\"")) {
					_toPush2 = _toPush2.slice(1, -1);
					_toPush2 = "'" + _toPush2 + "'";
				}
				_toPush2 = this.getHelperArgValue(_toPush2, newCompile);
				args.push(_toPush2);
				from = _i91 + 1;
			} else if (str.charAt(_i91) === "(") {
				if (stack[stack.length - 1] != "'" && stack[stack.length - 1] != "\"") {
					stack.push(str.charAt(_i91));
					lastPushed = str.charAt(_i91);
				}
			} else if (str.charAt(_i91) === ")") {
				if (stack[stack.length - 1] === "(") {
					stack.pop();
				}
			} else if (str.charAt(_i91) === "'" && str.charAt(_i91 - 1) !== "\\") {
				if (stack[stack.length - 1] === "'") {
					stack.pop();
				} else if (stack[stack.length - 1] !== "\"") {
					stack.push(str.charAt(_i91));
					lastPushed = str.charAt(_i91);
				}
			} else if (str.charAt(_i91) === "\"" && str.charAt(_i91 - 1) !== "\\") {
				if (stack[stack.length - 1] === "\"") {
					stack.pop();
					//                  str.replaceAt(i, "'");
				} else if (stack[stack.length - 1] !== "'") {
					stack.push(str.charAt(_i91));
					lastPushed = str.charAt(_i91);
					//                  str.replaceAt(i, "'");
				}
			}
		}
		if (stack.length) {
			return false;
		}
		var toPush = str.substr(from, str.length - from);
		toPush = toPush.trim();
		if (toPush && toPush.startsWith("\"") && toPush.endsWith("\"")) {
			toPush = toPush.slice(1, -1);
			toPush = "'" + toPush + "'";
		}
		try {
			toPush = this.getHelperArgValue(toPush, newCompile);
		} catch (err) {
			//console.log("errr",err);
			return false;
		}

		args.push(toPush);
		if (newCompile) {
			var newArgs = [];
			args.forEach(function (item) {
				if (typeof item === "string" && item[0] !== "'" && item !== "event" && item !== "this") {
					newArgs.push(_LC.getDV(item));
				} else {
					newArgs.push(item);
				}
			});
			args = newArgs;
		}
		return args;
	};

	Lyte.Compile.getHelperArgValue = function (argValue, newCompile) {
		switch (argValue) {
			case "undefined":
				return undefined;
			case "true":
				return true;
			case "false":
				return false;
			case "null":
				return null;
			case "":
				return undefined;
			default:
				if (argValue && argValue.startsWith("'") && argValue.endsWith("'")) {
					//escaping
					argValue = argValue.replace(/\\\'/g, "'");
					argValue = argValue.replace(/\\\"/g, '"');
					return argValue;
				} else if (/\([\w\s,')(]*/.test(argValue)) {
					return { "type": "helper", "value": this.getHelper(argValue, newCompile) };
				} else if (!isNaN(argValue)) {
					return parseInt(argValue);
				} else {
					return argValue;
				}
		}
	};
	Lyte.Compile.getMustache = function (value) {
		value = value && typeof value === "string" ? value.trim() : value;
		if (/^{{(?=[\s]*[\w-_\(\$)]+)/.test(value)) {
			var _arr4 = value.match(/{{[a-zA-Z0-9_.[\]()]*(?![\\])}}/g);
			if (_arr4 && _arr4.length > 1) {
				//console.log("length>1",value)
				return undefined;
			}
			if (!this.syntaxCheck(value) || !/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/.test(value)) {
				//'
				return undefined;
			}
			var dynamic = value.match(/[\w!@#$%^&*)(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g); //'
			if (dynamic && dynamic.length > 1) {
				return undefined;
			} else {
				dynamic = dynamic ? dynamic[0].trim() : dynamic;
			}
			//        let dynamic = /[\w!@#\$%\^\&*\)\(+=.,_-]+(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?(?=}}$)/.exec(value);
			return dynamic;
		}
		return undefined;
	};
	Lyte.Compile.syntaxCheck = function (value) {
		var stack = [],
		    lastAdded;
		for (var i = 0; i < value.length; i++) {
			if (value[i] === "'") {
				if (lastAdded === "'" && value[i - 1] !== "\\") {
					stack.pop();
					lastAdded = undefined;
				} else if (!stack.length) {
					lastAdded = value[i];
					stack.push(lastAdded);
				}
			} else if (value[i] === "\"") {
				if (lastAdded === "\"" && value[i - 1] !== "\\") {
					stack.pop();
					lastAdded = undefined;
				} else if (!stack.length) {
					lastAdded = value[i];
					stack.push(lastAdded);
				}
			}
		}
		if (stack.length) {
			return false;
		}
		return true;
	};
	LyteComponent.replaceWithOrigTemplate = function (node) {
		node._origTemplate._fakeTemp = node;
		return node._origTemplate;
	};
	LyteComponent.pendingViewPortElements = [];
	LyteComponent.isInViewPort = function (el) {
		var rect = el.getBoundingClientRect();
		if (rect.width == 0 && rect.height == 0 && rect.top == 0 && rect.bottom == 0 && el.localName != "dummy-port-element") {
			// hidden Element
			return false;
		}
		return rect.top >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight) || rect.bottom >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);
	};
	_LC._doneRaf = {};
	Lyte.Component.registerHelper("lyteViewPort", function (node, config) {
		var compName = this.localName;
		var self = this;
		var actNode = _LC.getActViewPortTemplate(node);
		if (actNode._viewPortRendered) {
			return false;
		}
		var disableViewPort = config;
		var pve = _LC.pendingViewPortElements;
		var promise = void 0;
		actNode._disable = {};
		if (config && (typeof config === 'undefined' ? 'undefined' : _typeof(config)) == "object") {
			actNode._custom = true;
			disableViewPort = config.disableViewPort;
			if (config.viewIn || config.viewOut) {
				promise = true;
				actNode._viewIn = config.viewIn ? Object.assign(config.viewIn) : undefined;
				actNode._viewOut = config.viewOut ? Object.assign(config.viewOut) : undefined;

				// actNode._inView = config.inView;
				// actNode._didRender = config.didRender;
				// actNode._isLoading = config.isLoading;
				var _res = void 0,
				    _rej = void 0;
				actNode._renderPromise = new Promise(function (res, rej) {
					_res = res;
					_rej = rej;
				});
				actNode._promiseObject = {
					resolvedByLyte: false,
					spouse: actNode._viewIn,
					resolve: function resolve() {
						if (!actNode._viewOut._afterAppendCalled && actNode._viewOut.beforeRemove && actNode._renderPromise && !actNode._viewOut._beforeRemoveCalled) {
							actNode._viewOut.beforeRemove.apply(actNode._viewOut, [node._promiseObject]);
						}
						if (actNode._renderPromise) {
							// let config = actNode._promiseObject.options;
							// if(config && config.disable){
							//     if(config.disable.inView === true){
							//         actNode._disable.inView = true; 
							//     }
							//     if(config.disable.didRender === true){
							//         actNode._disable.didRender = true;
							//     }
							// }
							_res();
						}
					},
					reject: function reject() {
						actNode._renderPromise._reject = true;
						// actNode._disable.inView = true;
						// actNode._disable.didRender = true;
						_rej();
					}
					// options : {
					//     disable : {
					//         inView : false,
					//         didRender : false
					//     }
					// }

					// actNode._renderPromise.resolve = _res;
					// actNode._renderPromise.reject = _rej;

				};actNode._renderPromise.then(function () {
					//fix observers issue ember
					if (!actNode._callee.component) {
						return;
					}
					actNode._renderPromise._resolved = true;
					var ind = pve.indexOf(actNode);
					if (ind != -1) {
						pve.splice(ind, 1);
					}
					var viewInIns = actNode._viewIn;
					if (viewInIns && viewInIns.beforeAppend) {
						viewInIns.beforeAppend.apply(viewInIns);
					}
					_LC._executeIfTemplates(actNode);
					if (viewInIns && viewInIns.afterAppend) {
						viewInIns.afterAppend.apply(viewInIns);
					}
					actNode._renderPromise = null;
				}, function () {
					Lyte.error("Promise rejected - Viewport cannot be toggled.");
				});
			}
		}
		if (!disableViewPort) {
			// if(!LyteComponent._pendingAnimationFrame){
			if (!_LC._doneRaf[compName]) {
				requestAnimationFrame(function () {
					requestAnimationFrame(function () {
						var inViewTemplates = [];
						var arr = Array.from(pve);
						var beforeRemoveHook = [];
						for (var i = arr.length - 1; i >= 0; i--) {
							var temp = arr[i];
							var actTemp = _LC.getActViewPortTemplate(temp);
							var viewOutIns = actTemp._viewOut;
							//var loaderAfterAppend = actTemp._viewOut.afterAppend;
							if (viewOutIns && viewOutIns.afterAppend) {
								viewOutIns.afterAppend.apply(viewOutIns, [actTemp._promiseObject]);
								viewOutIns._afterAppendCalled = true;
							}
						}
						for (var i = arr.length - 1; i >= 0; i--) {
							var _temp = arr[i];
							var actTemp = _LC.getActViewPortTemplate(_temp);
							// let viewOutIns = actTemp._viewOut;
							//var loaderAfterAppend = actTemp._viewOut.afterAppend;
							// if(viewOutIns && viewOutIns.afterAppend){
							//     viewOutIns.afterAppend.apply(viewOutIns,[actTemp._promiseObject]);
							//     viewOutIns._afterAppendCalled = true;
							// }
							if (_LC.isViewPortTemplate(_temp) && !_temp._callee._destroyed) {
								if (_LC._isInViewPort(actTemp, actTemp._callee, beforeRemoveHook)) {
									inViewTemplates.push(pve.splice(i, 1)[0]);
									_temp._inPve = false;
									_temp._viewPortRendered = true;
								}
								actTemp._inPve = _temp._inPve;
								actTemp._viewPortRendered = _temp._viewPortRendered;
							}
						}
						for (var _i92 = 0; _i92 < beforeRemoveHook.length; _i92++) {
							beforeRemoveHook[_i92].viewOutIns.beforeRemove.apply(beforeRemoveHook[_i92].viewOutIns, beforeRemoveHook[_i92].arg);
						}
						for (var _i93 = 0; _i93 < inViewTemplates.length; _i93++) {
							_LC._executeIfTemplates(inViewTemplates[_i93]);
						}
						// LyteComponent._pendingAnimationFrame = false;
						_LC._doneRaf[compName] = false;
						if (inViewTemplates.length) {
							requestAnimationFrame(function () {
								requestAnimationFrame(function () {
									_LC.executePendingViewPort();
								});
							});
						}
					});
				});
				// LyteComponent._pendingAnimationFrame = true;
				_LC._doneRaf[compName] = true;
			}
			if (pve.indexOf(_LC.getFakeTemplate(node)) == -1) {
				node._inPve = true;
				pve.push(node);
			}
			return true;
		} else if (pve.length) {
			var fakeTemp = _LC.getFakeTemplate(node);
			var ind = pve.indexOf(fakeTemp);
			if (ind != -1) {
				pve[ind]._inpve = node._inPve = false;
				pve[ind]._viewPortRendered = node._viewPortRendered = true;
				pve.splice(ind, 1);
			}
		}
	});
	LyteComponent._isInViewPort = function (node, comp, beforeRemoveHook) {
		var fchild = node._caseContent[0];
		if (fchild && _LC.isInViewPort(fchild)) {
			node._isInView = true;
			if (node._custom) {
				var viewOutIns = node._viewOut;
				if (viewOutIns && !node._renderPromise._resolved && viewOutIns.beforeRemove) {
					node._promiseObject.resolvedByLyte = true;
					viewOutIns._beforeRemoveCalled = true;
					beforeRemoveHook.push({
						viewOutIns: viewOutIns,
						arg: [node._promiseObject]
					});
					// viewOutIns.beforeRemove.apply(viewOutIns,[node._promiseObject]);
				} else if (!node._renderPromise._reject) {
					return true;
				}
			}
			// if(node._inView && !node._renderPromise._resolved && !node._disable.inView){
			//     node._inView.apply(this,[node._promiseObject]);
			// }
			else {
					return true;
				}
		}
	};
	LyteComponent._executeIfTemplates = function (node) {
		var actNode = _LC.getActViewPortTemplate(node);
		// actNode._renderPromise = null;
		actNode._attributes.value = false;
		var isYieldContext, contextSwitchInfo;
		if (actNode._cx || actNode.nodeType === 2 && actNode.ownerElement._cx) {
			contextSwitchInfo = actNode._cx || actNode.ownerElement._cx;
			var contextSwitchArray = [];
			_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo);
		} else if (actNode.tagName === "LYTE-YIELD" && actNode._callee._cx) {
			isYieldContext = true;
			contextSwitchInfo = actNode._callee._cx;
			var contextSwitchArray = [];
			_LC.changeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, true);
		}
		if (!actNode._callee.component) {
			debugger;
		}
		actNode._callee.updateSwitchHelper("if", actNode, actNode._cx, true, true);
		if (contextSwitchInfo) {
			_LC.removeContext(contextSwitchInfo.node, contextSwitchArray, contextSwitchInfo, isYieldContext);
		}
		// node._isViewPortPending = false;
	};
	LyteComponent.isViewPortTemplate = function (node) {
		if ((node.tagName == "TEMPLATE" || node._origTemplate) && node.getAttribute("is") == "if") {
			return true;
		}
	};
	LyteComponent.getActViewPortTemplate = function (node) {
		return node._origTemplate ? node._origTemplate : node;
	};
	LyteComponent.getFakeTemplate = function (node) {
		return node._fakeTemp ? node._fakeTemp : node;
	};
	LyteComponent.executePendingViewPort = function (options) {
		var pve = _LC.pendingViewPortElements;
		if (!pve.length) {
			return;
		}
		var arr = Array.from(pve);
		var inViewPortElements = [];
		var beforeRemoveHook = [];
		if (!options || !options.force) {
			for (var i = arr.length - 1; i >= 0; i--) {
				var ele = arr[i];
				if (_LC.isViewPortTemplate(ele)) {
					var actTemp = _LC.getActViewPortTemplate(ele);
					if (_LC._isInViewPort(actTemp, actTemp._callee, beforeRemoveHook)) {
						inViewPortElements.push(pve.splice(i, 1)[0]);
						ele._inPve = false;
						ele._viewPortRendered = true;
					}
					actTemp._inPve = ele._inPve;
					actTemp._viewPortRendered = ele._viewPortRendered;
				} else if (_LC.isInViewPort(ele._dummyViewPortF) || _LC.isInViewPort(ele._dummyViewPortL)) {
					ele._dummyViewPortF = ele._dummyViewPortL = undefined;
					inViewPortElements.push(pve.splice(i, 1)[0]);
				}
			}
			for (var _i94 = 0; _i94 < beforeRemoveHook.length; _i94++) {
				beforeRemoveHook[_i94].viewOutIns.beforeRemove.apply(beforeRemoveHook[_i94].viewOutIns, beforeRemoveHook[_i94].arg);
			}
		} else {
			inViewPortElements = arr;
		}

		_LC.isViewPortPending = false;

		for (var j = 0; j < inViewPortElements.length; j++) {
			var _ele = inViewPortElements[j];
			if (_LC.isViewPortTemplate(_ele)) {
				_LC._executeIfTemplates(_ele);
			} else {
				_ele.setData("lyteViewPort", false);
			}
		}
		if (inViewPortElements.length) {
			requestAnimationFrame(function () {
				requestAnimationFrame(function () {
					_LC.executePendingViewPort();
				});
			});
		}
	};

	window.addEventListener("resize", function () {
		requestAnimationFrame(function () {
			requestAnimationFrame(function () {
				_LC.executePendingViewPort();
			});
		});
	});

	document.addEventListener("scroll", function () {
		var debounceTime = _LyteComponent.viewPortSettings.debounce;
		if (debounceTime) {
			if (_LC.viewPortScrollDebounce) {
				clearTimeout(_LC.viewPortScrollDebounce);
			}
			_LC.viewPortScrollDebounce = setTimeout(function () {
				requestAnimationFrame(function () {
					requestAnimationFrame(function () {
						_LC.executePendingViewPort();
					});
				});
				_LC.viewPortScrollDebound = undefined;
			}, debounceTime);
		} else {
			requestAnimationFrame(function () {
				requestAnimationFrame(function () {
					_LC.executePendingViewPort();
				});
			});
		}
	}, true);

	LyteComponent.core = {};
	LyteComponent.core._constructor = customElementPrototype;
	LyteComponent.core._registerComponent = customElementPrototype._registerComponent;
	LyteComponent.core.registerComponent = _LC.registerComponent;
	LyteComponent.core.executeBlockHelpers = customElementPrototype.prototype.executeBlockHelpers;
	LyteComponent.core.updateForHelper = customElementPrototype.prototype.updateForHelper;
	LyteComponent.core.updateForInHelper = customElementPrototype.prototype.updateForInHelper;
	LyteComponent.core.updateSwitchHelper = customElementPrototype.prototype.updateSwitchHelper;

	_LyteComponent.viewPortSettings = {
		debounce: 0,
		executePendingViewPortElements: function executePendingViewPortElements(options) {
			LyteComponent.executePendingViewPort(options);
		}
	};
})(window);
Lyte.registerErrorCodes({
	LD01: "Primary key value might be missing in the response data that is received, {0}",
	LD02: "{0} - {1} is not registered",
	LD03: "Cannot set the error {0} for {1}",
	LD04: "No such record to merge, {0}",
	LD05: "Model( {0} ) of related property - {1} not found in model - {2}",
	LD06: "Backward relation not present in model( {0} ), for the property {1} of model( {2} )",
	LD07: "{0} type not handled in handleArrayOperations",
	LD08: "{0} {1} will be deprecated from next version {2}",
	LD09: "deserializeKey cannot be processed for payload with more than two keys. Please use payloadKey callback instead or try modifying the same in normalizeResponse callback",
	LD10: "Response data not in a format lyte data store expects",
	LD11: "Deprecation Warning! findRecord response payload will not accept an array. It will be deprecated from the next version",
	LD12: "Response ( {0} ) is not in a format, lyte data store expects",
	LD13: "Response processing failed in {0} for model-{1} {2}, since invalid data is received in {1}(modelName) key of the data",
	LD14: "Cannot register {0} - {1}, as it already exists.",
	LD15: "Primary key value might be missing in the response data that is received, {0}",
	LD16: "Record merge failed for the record in model - {0} with primaryKey value - {1}, since either the persisted(saved) primary key value for a newly created record is not received from server or not in the proper structure to merge",
	LD17: "Record with the primary key value already exists",
	LD18: "No { 0 } present",
	LD19: "Deprecation Warning! findAll will not accept response payload values other than an array or any empty value. Current implementation which allows this will be deprecated from the next version",
	LD20: "Record cannot be saved as a state, when it is not either a new or a modified record or in a error state.",
	LD21: "No such state ( {0} ) saved for the record.",
	LD22: "For create / createRecord, response with a primary key value should be received",
	LD23: "PrimaryKey field {1} in {0} cannot have default value",
	LD24: "Response couldn't be parsed, {0}",
	LD25: "Cannot create record for the data - {0}",
	LD26: "Only one baseKey is allowed for a model",
	LD27: "Record merge failed, since the data passed is invalid - {0}",
	LD28: "Record merge failed for the model - {0}, since a valid primary key value is not found in the data to be merged - {1}",
	LD29: "Unloaded record-{0} of the model-{1} is being saved",
	LD30: "Variable value in query is mandatory for {0}",
	LD31: "Datatype defined for {0} is mismatch with the value's datatype",
	LD32: "Query '{0}' was not registered for the model '{1}"
});
var $Record = function $Record() {
	Object.assign(this, { inIDB: false, isPersisted: true, isUnloaded: false, isModified: false, isNew: false, isDeleted: false, isError: false, events: [], validatedOnCreate: true, error: {} });
};
/* Record Constructor
Steps Done: 
* Assign data
* Assign $Record -> Maintaining Record state
* Assign ref of model,record to act independently
***
*/
var Record = function Record(modelName, data, opts, clone) {
	var model = store.modelFor(modelName),
	    delayPers = opts ? opts.delayPersistence : store.$.getFromCB("adapter", modelName, "delayPersistence");
	Object.assign(this, data);
	Object.defineProperties(this, {
		$: {
			writable: true,
			value: new $Record()
		}
	});
	var pkVal = store.$.getpKVal(this, model);
	if (clone) {
		Object.defineProperties(this.$, {
			isCloned: {
				value: true,
				writable: false
			},
			donor: {
				value: store.peekRecord(modelName, pkVal)
			}
		});
	}
	Object.defineProperties(this.$, {
		pK: {
			value: pkVal,
			writable: true
		},
		model: {
			value: model
		},
		_attributes: {
			value: {},
			writable: true
		},
		_relationships: {
			value: {},
			writable: true
		},
		isDirty: {
			value: function value() {
				var result = [];
				var record = this.record;
				if (record.$.isModified) {
					return true;
				}
				result = store.$.isDirty(record, this.model.relations);
				if (result.length) {
					return result;
				}
				return false;
			}
		},
		undoStack: {
			value: store.$.genUnRedoStack(),
			writable: true
		},
		redoStack: {
			value: store.$.genUnRedoStack(),
			writable: true
		},
		delayPersistence: {
			value: delayPers
		}
	});
	this.$.record = this;
	var parent = store.$.saveParent;
	if (parent && this !== parent) {
		store.$.defProp(this.$, "parent", parent);
	}
	var defF = model._fldGrps.default;
	var watchF = model._fldGrps.watch;
	var hasManyF = model._fldGrps.hasMany;
	var nested = model._fldGrps.nested_prop;
	for (var dKey in defF) {
		var dFld = defF[dKey];
		var fldVal = data[dKey];
		if (fldVal === undefined || fldVal === "") {
			this[dKey] = store.$.getDefaultVal(this, dFld.default);
		}
	}
	for (var wKey in watchF) {
		Lyte.establishObjectBinding(this, wKey, true, undefined, undefined, true);
	}
	for (var k in nested) {
		Lyte.establishObjectBinding(this, k, true, undefined, undefined, k && k.watch ? k.watch : undefined);
	}
	for (var hKey in hasManyF) {
		var hFld = hasManyF[hKey];
		if (this.hasOwnProperty(hKey)) {
			this[hKey] = Array.isArray(this[hKey]) ? Array.from(this[hKey]) : this[hKey];
		} else if (store.modelFor(hFld.relatedTo) && !clone) {
			var toInit = store.$.getFromCB("serializer", hFld.relatedTo, "initHasManyRelation");
			if (toInit) {
				this[hKey] = [];
			}
		}
	}
	var props = model._properties;
	if (Object.keys(props).length) {
		if (!this._bindings) {
			store.$.defProp(this, '_bindings', new Set(), false, true);
		}
		this._bindings.add(props);
		store.$.establishObserverBindings(this, props);
	}
	//	console.log(this.$.model._properties);
};
/* Assigning the following in $record.prototype 
So it will be available to all record.$
*/

Object.defineProperties($Record.prototype, {
	get: {
		value: function value(attr) {
			if (Lyte.Component && Lyte.Component._get) {
				return Lyte.Component._get(this.record, attr);
			}
			return this.record[attr];
		}
	},
	set: {
		value: function value1(attr, value, opts) {
			if (this.isDeleted) {
				store.$.setRecErr(this, this.model._pK, "ERR17");
			} else {
				store.$.setData(this, attr, value, opts);
			}
			return this.record;
		}
	},
	getDirtyAttributes: {
		value: function value() {
			var ret = [];
			var attributes = this._attributes;
			if (Object.keys(attributes).length) {
				for (var key in attributes) {
					ret.push(key);
				}
			}
			return ret;
		}
	},
	rollBackAttributes: {
		value: function value(attr, inherit) {
			if (!Array.isArray(attr)) {
				attr = [attr];
			}
			var record = this.record,
			    changed = [],
			    model = this.model,
			    _attrs = this._attributes;
			for (var i = 0; i < attr.length; i++) {
				var key = attr[i];
				if (_attrs.hasOwnProperty(key)) {
					var field = model.fieldList[key],
					    oldVal = _attrs[key];
					if (field.type == "relation") {
						store.$.rllBckRecArr(oldVal, record, model, field);
						var obj = record.$.dN && record.$.dN.hasOwnProperty(key) ? record.$.dN[key] : new Map();
						obj.forEach(function (item, mKey) {
							store.$.deleteDeepNest(record, key, mKey);
						});
					} else {
						store.$.cmpSet(record, key, oldVal, undefined, true);
					}
					changed.push(key);
					delete _attrs[key];
				}
				store.$.clrRecErr(this, key);
			}
			if (!Object.keys(this._attributes).length) {
				if ((!this.hasOwnProperty("dN") || this.dN && !Object.keys(this.dN).length) && !record.$.isNew) {
					store.$.removeParentNesting(record, "modified");
				}
				store.$.cmpSet(this, "isModified", false);
				store.$.changePersist(record, true);
				if (!this.isNew) {
					store.$.deleteFromArray(model.dirty, this.get(model._pK));
				}
			}
			if (changed.length > 0) {
				var arr = [record, changed];
				this.emit("change", arr);
				model.emit("change", arr);
				this.undoStack = store.$.genUnRedoStack();
				this.redoStack = store.$.genUnRedoStack();
			}
		}
	},
	rollBack: {
		value: function value(state, inherit) {
			var model = this.model,
			    pK = model._pK,
			    recmp = new Map();
			inherit = inherit === false ? false : model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
			if (state) {
				this.rollBackState(state, inherit);
				store.$.removeOnSave(this.model._name, this.record.$.pK);
			} else {
				if (inherit) {
					store.$.rBinherit(this, recmp, "");
				}
				store.$.rollBackRecord(this);
			}
		}
	},
	deleteRecord: {
		value: function value(delayPers) {
			var model = this.model,
			    record = this.record,
			    delayPers = delayPers !== undefined ? delayPers : record.$.delayPersistence ? record.$.delayPersistence.delete : undefined;
			store.$.removeFromStore(model, record.$.pK, undefined, undefined, delayPers);
		}
	},
	destroyRecord: {
		value: function value(customData, qP, delayPers, mutationName) {
			this.deleteRecord(delayPers);
			return this.save(customData, qP, "destroyRecord", undefined, mutationName);
		}
	},
	addEventListener: {
		value: function value(type, func) {
			return store.$.eventListeners.add(this, type, func);
		}
	},
	removeEventListener: {
		value: function value(id) {
			store.$.eventListeners.remove(this, id);
		}
	},
	emit: {
		value: function value(type, args) {
			store.$.eventListeners.emit(this, type, args);
		}
	},
	triggerAction: {
		value: function value(actionName, customData, qP, method, data) {
			var model = this.model,
			    actions = model.actions,
			    action = actions ? actions[actionName] : undefined;
			if (action) {
				return store.adapter.$.handleAction(actionName, model, this.record, customData, qP, method, data);
			}
			return Promise.reject({ code: "ERR18", message: Lyte.errorCodes.ERR18, data: actionName });
		}
	},
	save: {
		value: function value(customData, qP, options, destroy, mutationName) {
			var self = this;
			if (this.isCloned) {
				if (this.isUnloaded) {
					return Promise.resolve();
				} else {
					self = store.$.savingDonorRecord(this);
				}
			}
			var model = self.model,
			    record = self.record,
			    dirty = self.isDirty(),
			    validateOnSave = options && options.validateOnSave,
			    skipValidation = options && options.skipValidation,
			    clear,
			    fields = model.fieldList,
			    ret;
			if (self.isUnloaded !== true) {
				if (self.isDeleted) {
					if (!self.isNew) {
						return store.adapter.$.del(model._name, record, true, destroy, customData, qP, mutationName);
					}
					// store.adapter.$.handleResponse(record, record, undefined, undefined, model);
				} else if (self.isNew) {
					var err = self;
					if (!skipValidation && (!record.$.validatedOnCreate || validateOnSave)) {
						ret = store.$.validateRecord(self.record, fields);
					}
					if (!skipValidation && (ret == false || err && err.error && Object.keys(err.error).length > 0)) {
						return Promise.reject(err.error);
					}
					return store.adapter.$.create(model._name, record, true, customData, qP, mutationName);
				} else if (self.isModified || dirty && dirty.length) {
					var data = {};
					if (!skipValidation && options && validateOnSave) {
						ret = store.$.validateRecord(self.record, fields);
					}
					if (!skipValidation) {
						if (ret == false || record && record.$ && record.$.isError) {
							return Promise.reject(record.$.error);
						}
					}
					var data = store.$.updateJSON(self.record, model, dirty);
					return store.adapter.$.put(model._name, data, record, true, customData, qP, mutationName);
				}
			} else {
				Lyte.warn("LD29", _typeof(record.$.pK) == "object" ? JSON.stringify(record.$.pK) : record.$.pK, model._name);
				var rejectUnloadRecordSave = store.$.getFromCB("adapter", model._name, "rejectUnloadRecordSave");
				if (rejectUnloadRecordSave) {
					return Promise.reject({ code: "ERR28", message: Lyte.errorCodes.ERR28, data: record });
				}
			}
			return Promise.resolve();
		}
	},
	getInitialValues: {
		value: function value(attr) {
			var isAttrPassed = false;
			if (attr) {
				if (!Array.isArray(attr)) {
					attr = [attr];
				}
				isAttrPassed = true;
			} else {
				attr = this.getDirtyAttributes();
			}
			var ret = {},
			    rec = this.record,
			    _attrs = this._attributes;
			for (var i = 0; i < attr.length; i++) {
				if (rec[attr] == undefined || !rec[attr[i]].add) {
					ret[attr[i]] = _attrs[attr[i]];
				} else {
					ret[attr[i]] = rec[attr[i]].slice(0);
					var arr = _attrs[attr[i]],
					    pK = rec[attr[i]].model._pK;
					for (var j = arr.length - 1; j >= 0; j--) {
						if (arr[j]._type == "added") {
							for (var k = 0; k < arr[j].records.length; k++) {
								var index = store.$.getIndex(ret[attr[i]], pK, arr[j].records[k].$.pK);
								if (index == -1) {
									continue;
								}
								ret[attr[i]].splice(index, 1);
							}
						} else if (arr[j]._type == "removed") {
							for (var k = arr[j].records.length - 1; k >= 0; k--) {
								ret[attr[i]].splice(arr[j]._indices[k], 0, arr[j].records[k]);
							}
						} else if (arr[j]._type == "changed") {
							ret[attr[i]] = Array.isArray(arr[j].records) ? Array.from(arr[j].records) : arr[j].records;
						}
					}
				}
			}
			if (isAttrPassed) {
				return ret[attr[0]];
			}
			return ret;
		}
	},
	toJSON: {
		value: function value(type, addNotDefinedFields) {
			var inherit = true;
			addNotDefinedFields = addNotDefinedFields ? true : false;
			if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) == "object" && type.inherit == false) {
				inherit = type.inherit;
			}
			return Object.assign({}, store.$.toJSON(this.model._name, this.record, !type ? true : type, undefined, undefined, inherit, addNotDefinedFields));
		}
	},
	undo: {
		value: function value(attr, state) {
			var currentState = this.undoStack._order_.length;
			state = state || (currentState ? currentState - 1 : currentState);
			// state = state || 0;
			while (currentState-- > state) {
				store.$.unredoOp(1, this, attr);
			}
		}
	},
	getCurrentState: {
		value: function value() {
			return this.undoStack._order_.length;
		}
	},
	redo: {
		value: function value(attr) {
			store.$.unredoOp(2, this, attr);
		}
	},
	validate: {
		value: function value(arr) {
			var fields = {};
			var model = this.model;
			var fieldList = model.fieldList;
			if (Array.isArray(arr)) {
				arr.forEach(function (item, index) {
					if (fieldList[item]) {
						fields[item] = fieldList[item];
					}
				});
			}
			if (Object.keys(fields).length == 0) {
				fields = fieldList;
			}
			var record = this.record;
			store.$.validateRecord(record, fields);
		}
	},
	saveState: {
		value: function value(state) {
			if (!this.isNew && !this.isModified) {
				Lyte.warn("LD20");
				return;
			}
			var savedState = this._savedState = this._savedState || {},
			    currentState = state,
			    randomState;
			while (!currentState) {
				randomState = Math.floor(Math.random() * 100000 + 1);
				currentState = !savedState.hasOwnProperty(randomState) ? randomState : currentState;
			}
			var obj = this.toJSON("state");
			store.$.defProp(obj, "$", {}, false, true);
			var pK = this.model._arrPk;
			pK.forEach(function (val) {
				delete obj[val];
			});
			var undoStack = this.undoStack;
			var redoStack = this.redoStack;
			var _attributes = this._attributes;
			// var dN = this.record.$.dN;
			if (undoStack && Object.keys(undoStack).length) {
				var _order = undoStack._order_;
				undoStack = obj.$.undoStack = store.$.deepCopyStack(undoStack);
				store.$.defProp(undoStack, "_order_", Lyte.deepCopyObject(_order), false, true);
			}
			if (redoStack && Object.keys(redoStack).length) {
				var _order = redoStack._order_;
				redoStack = obj.$.redoStack = store.$.deepCopyStack(redoStack);
				store.$.defProp(redoStack, "_order_", Lyte.deepCopyObject(_order), false, true);
			}
			if (_attributes && Object.keys(_attributes).length) {
				obj.$._attributes = store.$.deepCopyAttrs(this.model, _attributes);
			}
			this._savedState[currentState] = obj;
			return currentState;
		}
	},
	clearState: {
		value: function value(state) {
			if (!state) {
				this._savedState = {};
				return;
			}
			delete this._savedState[state];
		}
	},
	rollBackState: {
		value: function value(state, inherit) {
			var savedSt = this._savedState;
			var obj = savedSt ? savedSt[state] : undefined;
			if (!obj) {
				Lyte.warn("LD21", state);
				return;
			}
			this.dN ? this.dN = {} : undefined;
			store.$.setData(this, obj, undefined, undefined, {}, true, inherit);
			store.$.updateDn(this.record);
			this.undoStack = obj.$.undoStack || store.$.genUnRedoStack();
			this.redoStack = obj.$.redoStack || store.$.genUnRedoStack();
			this._attributes = obj.$._attributes || {};
			store.$.checkAttrs(this.record);
			delete this._savedState[state];
		}
	},
	hasSavedState: {
		value: function value(state) {
			return this._savedState && this._savedState.hasOwnProperty(state) ? true : false;
		}
	},
	persist: {
		value: function value(obj) {
			var mName = this.model._name,
			    rec = this.record,
			    partialObj = { obj: new Map() },
			    type,
			    dirty;
			if (this.isNew) {
				type = "create";
				store.$.toJSON(mName, rec, undefined, type, partialObj);
			} else if (dirty = this.isDirty()) {
				var data = store.$.updateJSON(rec, this.model, dirty);
				store.$.toJSON(mName, data, undefined, undefined, partialObj);
			}
			var pObj = partialObj.obj.get(this.pK);
			store.adapter.$.mergeResponse(rec, this.model, undefined, this.pK, pObj, true);
			store.adapter.$.updateIDB(mName, type ? type : rec.$.isDeleted ? "deleteRecord" : rec.$.isModified || dirty ? "updateRecord" : undefined, rec);
		}
	},
	clone: {
		value: function value() {
			var parent = this.record,
			    data = this.record.$.toJSON({ type: "isClone" });
			var clonedData = store.$.insertIntoStore(parent.$.model._name, data, undefined, undefined, undefined, undefined, undefined, { type: "isClone" });
			return clonedData;
		}
	}
});
/* Model Object Constructor 
*/
var Model = function Model(name, fields) {
	Object.assign(this, { _name: name, fieldList: { id: { type: "string", primaryKey: true, defined: false } }, relations: {}, _properties: {}, _fldGrps: { default: {}, hasMany: {}, watch: {}, inherit: {}, nested_prop: {}, inverse: {}, JsonPathWatch: {} }, data: [], dirty: [], _deleted: new Map(),
		events: {} });
	store.$.defProp(this.data, "_recMap", new Map());
	var obs = [];
	for (var key in fields) {
		store.$.registerField(this, key, fields[key], obs);
	}
	if (!this._pK) {
		this._pK = 'id';
	}
	this.isComp = false;
	var splt = this._pK.split(',');
	if (splt.length > 1) {
		this.isComp = true;
	}
	this._arrPk = splt;
	if (typeof Lyte != "undefined") {
		Lyte.establishObserverBindings(obs, true, this._properties, this);
		Lyte.establishWatchScope(this._fldGrps.JsonPathWatch, this);
	}
	store.$.defArrUtls(this.data);
	store.$.defUtls(this.data, this);
	store.$.defProp(this, "extends", store.$.extendModel);
};
Model.prototype.addEventListener = function (type, func) {
	return store.$.eventListeners.add(this, type, func);
};
Model.prototype.removeEventListener = function (id) {
	store.$.eventListeners.remove(this, id);
};
Model.prototype.emit = function (type, args) {
	store.$.eventListeners.emit(this, type, args);
};
Model.prototype.on = function (type, func) {
	return this.addEventListener(type, func);
};
Model.prototype.setGql = function value(type, key, Query) {
	store.$.setQuery(this, key, type, Query);
};
var store = {
	model: {},
	$: {
		idbOpen: true,
		request: {},
		toRelate: {},
		idbQueue: [],
		idbQ: {},
		idbQ2: {},
		nestScp: {},
		nestScpId: 1,
		getAdapter: function getAdapter(obj) {
			if (obj.name == "application") {
				return store.adapter[obj.name];
			}
			if (obj.model || obj.name) {
				var model = obj.model || store.model[obj.name];
				if (model && model.extend) {
					if (!store.adapter.hasOwnProperty(model._name)) {
						return store.adapter[model.extend];
					}
				}
				var name = model ? model._name : obj.name;
				return store.adapter[name];
			}
		},
		registerModel: function registerModel(name, fields, options) {
			if (store.model.hasOwnProperty(name)) {
				Lyte.warn("LD14", "Model", name);
				Lyte._postRegister();
				return { error: Lyte.getErrorMessage("LD14", "Model", name), extends: function _extends() {} };
			}
			try {
				var extend, actions, idb, gql;
				if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) == "object") {
					extend = options.extends || undefined;
					actions = options.actions || undefined;
					idb = options.idb || undefined;
					gql = options.gql || undefined;
				}
				if (extend) {
					var parentFields = Object.assign({}, store.model[extend].fieldList);
					for (var key in parentFields) {
						if (parentFields[key].type == "relation") {
							delete parentFields[key];
						}
					}
					fields = Object.assign(fields, parentFields);
				}
				var model = store.model[name] = new Model(name, fields);
				if (extend) {
					store.$.extendModel(extend, model);
				}
				if (actions) {
					model.actions = actions;
				}
				if (idb) {
					model.idb = idb;
				}
				if (gql) {
					model.gql = gql;
				}
				Lyte._postRegister();
			} catch (e) {
				Lyte._postRegister();
			}
			return model;
		},
		changePersist: function changePersist(record, value) {
			if (!record.$.isUnloaded || record.$.isPeristed !== value) {
				switch (value) {
					case true:
						{
							if (!record.$.isNew && !record.$.isModified && !record.$.isDeleted) {
								store.$.cmpSet(record.$, "isPersisted", true);
							}
							break;
						}
					case false:
						{
							if (record.$.isNew || record.$.isModified || record.$.isDeleted || record.$.dN && Object.keys(record.$.dN) && Object.keys(record.$.dN).length) {
								store.$.cmpSet(record.$, "isPersisted", false);
							}
							break;
						}
				}
			}
		},
		getFromCB: function getFromCB(type, name, key) {
			var scp = store[type],
			    extend;
			if (/^(adapter|serializer)$/.test(type) && store.model.hasOwnProperty(name) && store.model[name].extend) {
				extend = store.model[name].extend;
			}
			var obj = scp && scp.hasOwnProperty(name) ? scp[name] : extend && scp.hasOwnProperty(extend) ? scp[extend] : undefined,
			    result = obj ? obj[key] : undefined;
			while (result === undefined) {
				if (obj && obj.$super) {
					obj = obj.$super;
					result = obj ? obj[key] : undefined;
				} else {
					if (!obj) {
						obj = scp.application;
					}
					if (obj && obj.hasOwnProperty(key)) {
						result = obj[key];
					} else {
						if (type == "adapter") {
							switch (key) {
								case "host":
									{
										result = window.location.origin ? window.location.origin : window.location.protocol + "//" + window.location.host;
										break;
									}
								case "namespace":
									{
										result = "";
										break;
									}
								case "actionNamespace":
									{
										result = "action";
										break;
									}
								case "batchNamespace":
									{
										result = "batch";
										break;
									}
								default:
									result = undefined;
							}
							break;
						} else {
							break;
						}
					}
					if (!obj && !result) {
						break;
					}
				}
			}
			return result;
		},
		newCB: function newCB(type, self, name, attrs, opts) {
			self.__extendedBy = [];
			for (var key in attrs) {
				self[key] = attrs[key];
			}
			store.$.extendOptions(opts, type, name, self, store);
			store.$.lazyExtend(type, self, name);
			store.$.defProp(self, "is", type);
			store.$.defProp(self, "__name", name);
		},
		extendOptions: function extendOptions(opts, type, name, self, scope) {
			if (opts && opts.mixins && opts.mixins.length) {
				opts.mixins.forEach(function (item) {
					if (Lyte.Mixin.exists(item)) {
						var mixin = Lyte.registeredMixins[item];
						for (var key in mixin) {
							self[key] = mixin[key];
						}
					} else {
						Lyte.$.requiredMixins(item, { "name": name, "scope": scope }, type);
					}
				});
			}
			var services = opts ? opts.services : [];
			store.$.extendService(services, type, name, self, scope);
			if (Lyte.toBeInjectedServices) {
				var tbServ = Lyte.toBeInjectedServices,
				    arr = [];
				for (var key in tbServ) {
					arr.push({ as: key, service: tbServ[key] });
				}
				store.$.extendService(arr, type, name, self, scope, true);
			}
		},
		extendService: function extendService(services, type, name, self, scope, isGlobal, data) {
			Lyte.extendService({ services: services, type: type, name: name, ins: self, isGlobal: isGlobal, data: data, callback: function callback(serv, key, name) {
					Lyte.$.lazyRegisterService(isGlobal ? serv : new serv(), { scope: scope, type: type, name: name, key: key });
				} });
		},
		lazyExtend: function lazyExtend(type, self, name) {
			var scope = store[type];
			if (scope.__toAddSuper && scope.__toAddSuper.hasOwnProperty(name)) {
				var addSuper = scope.__toAddSuper[name];
				for (var i = 0; i < addSuper.length; i++) {
					var child = scope[addSuper[i]];
					if (child && child.is == type) {
						child.$super = self;
						self.__extendedBy.push(addSuper[i]);
						var index;
						if (name != "application") {
							if (scope.__toAddSuper.application) {
								index = scope.__toAddSuper.application.indexOf(child.__name);
								if (index > -1) {
									scope.__toAddSuper.application.splice(index, 1);
								}
							}
							if (scope.application) {
								index = scope.application.__extendedBy.indexOf(child.__name);
								if (index > -1) {
									scope.application.__extendedBy.splice(index, 1);
								}
							}
						}
					}
				}
				delete scope.__toAddSuper[name];
			}
		},
		cbDef: function cbDef(cls, type) {
			Object.defineProperties(cls.prototype, {
				"super": {
					value: function value() {
						return store.$.super.call(this, arguments);
					}
				},
				"extends": {
					value: function value(name) {
						store.$.extendCallback.call(this, store, type, name);
					}
				}
			});
		},
		changeRelPkMaps: function changeRelPkMaps(data, oldPk, newPk, type, changedField) {
			var model = data.$.model;
			var relations = model.relations;
			for (var key in relations) {
				var rels = relations[key],
				    relsLen = rels.length;
				for (var i = 0; i < relsLen; i++) {
					var itm = rels[i];
					var attr = itm.relKey,
					    relType = itm.relType,
					    inv;
					if (data.hasOwnProperty(attr)) {
						var relRec = data[attr],
						    bMod = store.model[itm.relatedTo],
						    inv,
						    isSortDef;
						if (bMod) {
							inv = store.$.getBackwardRel(model, itm, bMod);
							if (inv && inv.relType == "hasMany") {
								isSortDef = inv.opts && inv.opts.sort && inv.opts.sort.sortFn && inv.opts.sort.observes;
								if (relType == "belongsTo" && Lyte.isRecord(relRec)) {
									switch (type) {
										case "sort":
										case "srtObsChk":
											{
												if (relRec && Array.isArray(relRec[inv.relKey])) {
													if (type == "sort") {
														if (isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1) {
															store.$.handleArrOp(relRec[inv.relKey], "sort");
														}
													} else if (changedField !== inv.relKey) {
														return true;
													}
												}
												break;
											}
										default:
											{
												relRec[inv.relKey] && relRec[inv.relKey]._recMap && relRec[inv.relKey]._recMap.delete(oldPk) ? relRec[inv.relKey]._recMap.set(newPk, data) : undefined;
											}
									}
								} else if (relType == "hasMany" && Array.isArray(relRec)) {
									var relRecLen = relRec.length;
									for (var l = 0; l < relRecLen; l++) {
										var rec = relRec[l];
										switch (type) {
											case "sort":
											case "srtObsChk":
												{
													if (rec && Array.isArray(rec[inv.relKey])) {
														if (type == "sort") {
															if (isSortDef && inv.opts.sort.observes.indexOf(changedField) != -1) {
																store.$.handleArrOp(rec[inv.relKey], "sort");
															}
														} else if (changedField !== inv.relKey) {
															return true;
														}
													}
													break;
												}
											default:
												{
													Lyte.isRecord(rec) && rec[inv.relKey] && rec[inv.relKey]._recMap && rec[inv.relKey]._recMap.delete(oldPk) ? rec[inv.relKey]._recMap.set(newPk, data) : undefined;
												}
										}
									}
								}
							}
						}
					}
				}
			}
			var _rels = data.$._relationships;
			for (var md in _rels) {
				var mdObj = _rels[md];
				var mdlIns = store.modelFor(md);
				for (var attr in mdObj) {
					var arr = mdObj[attr];
					var fldObj = mdlIns.fieldList[attr];
					var isSortDef = fldObj.opts && fldObj.opts.sort && fldObj.opts.sort.sortFn && fldObj.opts.sort.observes;
					var arrLen = arr.length;
					for (var j = 0; j < arrLen; j++) {
						var rec = arr[j];
						var relData = rec[attr];
						if (Array.isArray(relData)) {
							switch (type) {
								case "sort":
								case "srtObsChk":
									{
										if (Array.isArray(relData)) {
											if (type == "sort") {
												if (isSortDef && fldObj.opts.sort.observes.indexOf(changedField) != -1) {
													store.$.handleArrOp(relData, "sort");
												}
											} else if (changedField !== fldObj.relKey) {
												return true;
											}
										}
										break;
									}
								default:
									{
										relData._recMap && relData._recMap.delete(oldPk) ? relData._recMap.set(newPk, data) : undefined;
									}
							}
						}
					}
				}
			}
		},
		updateNestScp: function updateNestScp(record, oldPk) {
			if (Lyte.isRecord(record)) {
				var scpObj = record.$.__scpObj || {};
				for (var key in scpObj) {
					var val = scpObj[key];
					val = val.split("_")[0];
					if (Lyte.nestScp && Lyte.nestScp.hasOwnProperty(val) && Lyte.nestScp[val].model) {
						var mp1 = Lyte.nestScp[val].model.get(record.$.model._name);
						if (mp1.has(oldPk)) {
							var val = mp1.get(oldPk);
							mp1.delete(oldPk);
							mp1.set(record.$.pK, val);
						}
						// Lyte.nestScp[val].pK = record.$.pK;
					}
				}
			}
		},
		getDefaultVal: function getDefaultVal(rec, defVal) {
			if (typeof defVal != "function") {
				return defVal;
			} else {
				return defVal.call(rec);
			}
		},
		deepValueChange: function deepValueChange(rec, attr, value, changeObj) {
			var toEmit = { emit: false, attr: [], oldRec: {} };
			store.$.estAttrs(rec, attr, value, toEmit, changeObj);
			store.$.checkAttrs(rec);
			store.$.changeCallbck(rec, toEmit);
		},
		updateDn: function updateDn(record) {
			var model = record.$.model;
			var relations = model.relations;
			for (var key in relations) {
				var rels = relations[key];
				rels.forEach(function (itm) {
					var options = itm.opts,
					    attr = itm.relKey,
					    relType = itm.relType;
					if (options && options.deepNest) {
						if (record.hasOwnProperty(attr)) {
							var relRec = record[attr];
							if (relType == "belongsTo" && (relRec.$.isModified || relRec.$.dN && Object.keys(relRec.$.dN).length)) {
								store.$.setDeepNest(record, attr, relRec.$.pK, "updated");
							} else if (relType == "hasMany" && Array.isArray(relRec)) {
								relRec.forEach(function (rec) {
									if (rec.$.isModified || rec.$.dN && Object.keys(rec.$.dN).length) {
										store.$.setDeepNest(record, attr, rec.$.pK, "updated");
									}
								});
							}
						}
					}
				});
			}
		},
		genUnRedoStack: function genUnRedoStack() {
			var obj = {};
			store.$.defProp(obj, "_order_", [], false);
			return obj;
		},
		deepCopyStack: function deepCopyStack(stack) {
			if (stack && (typeof stack === 'undefined' ? 'undefined' : _typeof(stack)) == "object") {
				stack = Object.assign({}, stack);
				for (var attr in stack) {
					if (Array.isArray(stack[attr])) {
						var arr = stack[attr] = Array.from(stack[attr]);
						arr.forEach(function (itm, idx) {
							arr[idx] = Object.assign(itm);
						});
					}
				}
			}
			return stack;
		},
		deepCopyAttrs: function deepCopyAttrs(model, obj) {
			var fields = model.fieldList;
			var obj = Object.assign({}, obj);
			for (var attr in obj) {
				var _attr = obj[attr];
				if (fields[attr] && fields[attr].type == "relation" && Array.isArray(_attr)) {
					_attr = obj[attr] = Array.from(_attr);
					_attr.forEach(function (itm, idx) {
						_attr[idx] = Object.assign({}, itm);
						itm.hasOwnProperty("records") && itm.records ? itm.records = Array.from(itm.records) : undefined;
						itm.hasOwnProperty("_indices") && itm._indices ? itm._indices = Array.from(itm._indices) : undefined;
					});
				}
			}
			return obj;
		},
		// 1 index -> delete [0,2,a,4,5,6,7,8,9,10] '1' -> 1 index            
		// 2 index -> delete [0,2,4,5,6,7,8,9,10]   'a' -> 2 index
		// a index -> delete [0,2,4,6,7,8,9,10]	  	'5' -> a index
		// 2 index -> delete [0,2,4,7,8,9,10]	   	'6' -> a index 
		// 1 index -> delete [0,4,7,8,9,10]		  	'2' -> 1 index
		// 5 index -> delete [0,4,7,8,9]         	'10' -> 5 index
		// insert -> 5 -> add [0,4,7,8,9,11]

		// algo 
		// 1) to find the current index -> check the later items for lesser index. Minus the current index when the below item's index is less than it
		// 2) after rollbacking, check the later items for the same or higher index and increment it

		// case 1) rollback number 5 -> it should go in position 2
		// a - 1 - 1 = 1 
		// [ 0,4,5,7,8,9,11 ] 
		// 1 -> 1 , a -> 2, 6 -> a + 1, 2 -> 1 , 10 -> 5 + 1

		// case 2) rollback number a -> it should go in position 1
		// 2 - 1 = 1   
		// [ 0,a,4,5,7,8,9,11 ]
		// 1 -> 1 , 6 - > 4 + 1 , 2 -> 1 , 10 -> 6 + 1

		// case a) rollback number 6 -> it should go in position 4
		// 5 - 1
		// [ 0,a,4,5,6,7,8,9,11 ]
		// 1 -> 1 , 2 -> 1, 10 -> 7 + 1

		// case 4) rollback 10 -> it should go in position 8 
		// 8 
		// [ 0,a,4,6,7,8,9,10,11 ]

		addTo_Del: function addTo_Del(model, data, ind) {
			var deleted = model._deleted = model._deleted || new Map();
			var obj = { index: ind, data: data };
			deleted.set(data.$.pK, obj);
		},
		scExtd: function scExtd(type, name, opts, parent) {
			var scope = type == "adapter" ? store.adapter : store.serializer;
			if (!name) {
				return;
			}
			if (scope.hasOwnProperty(name)) {
				Lyte.warn("LD14", type, name);
				return { error: Lyte.getErrorMessage("LD14", type, name), extends: function _extends() {} };
			}
			if (type == "adapter") {
				scope[name] = new Adapter(opts, parent, name);
			} else {
				scope[name] = new Serializer(opts, parent, name);
			}
			if (scope.application && name != "application") {
				scope[name].$super = scope.application;
				scope.application.__extendedBy.push(name);
			}
			if (!scope.application && name != "application") {
				scope.__toAddSuper = scope.__toAddSuper || {};
				if (!scope.__toAddSuper.hasOwnProperty("application")) {
					scope.__toAddSuper.application = [];
				}
				scope.__toAddSuper.application.push(name);
			}
			return scope[name];
		},
		initCB: function initCB(type, modelName, key, obj) {
			var scope = store.$.cbScp(modelName, key, type),
			    args = obj.args,
			    ret = {};
			if (scope) {
				ret.data = store.$.cB(scope, args);
				return ret;
			}
		},
		cB: function cB(callback, args) {
			return callback.func.apply(callback.scope, args.concat(callback.name));
		},
		cbScp: function cbScp(name, key, type) {
			var scope = store[type],
			    callback,
			    application = scope.application,
			    extend;
			if (/^(adapter|serializer)$/.test(type) && store.model.hasOwnProperty(name) && store.model[name].extend) {
				extend = store.model[name].extend;
			}
			var layer = scope && scope.hasOwnProperty(name) ? scope[name] : extend && scope.hasOwnProperty(extend) ? scope[extend] : undefined;
			while (callback == undefined) {
				if (layer && layer[key] && typeof layer[key] == "function") {
					return { scope: layer, func: layer[key], name: key };
				} else if (layer && layer.$super) {
					layer = layer.$super;
				} else if (application && application[key] && typeof application[key] == "function") {
					return { scope: application, func: application[key], name: key };
				} else {
					return undefined;
				}
			}
		},
		comparePk: function comparePk(rec, pkVal) {
			var pK = rec.$.pK;
			var pkType = typeof pK === 'undefined' ? 'undefined' : _typeof(pK);
			if (pkType == "string" || pkType == "number") {
				return pK === pkVal;
			} else if ((typeof pK === 'undefined' ? 'undefined' : _typeof(pK)) == "object") {
				var len = Object.keys(pK).length,
				    i = 0;
				for (var key in pK) {
					if (pK[key] === pkVal[key]) {
						i++;
					}
				}
				return len === i;
			}
		},
		getpKVal: function getpKVal(record, model) {
			var model = model ? model : record.$.model;
			var arr = model._arrPk;
			if (arr.length == 1) {
				return record[arr[0]];
			} else {
				var obj = {};
				arr.forEach(function (item) {
					obj[item] = record[item];
				});
			}
			return obj;
		},
		unredoOp: function unredoOp(type, rec, attr) {
			var stack, revStack;
			if (type == 1) {
				stack = rec.undoStack;
				revStack = rec.redoStack;
			} else {
				stack = rec.redoStack;
				revStack = rec.undoStack;
			}
			var attrs = [],
			    obj,
			    revObj = {};
			if (attr) {
				if (!Array.isArray(attr)) {
					attrs = [attr];
				} else {
					attrs = attr;
				}
				attrs.forEach(function (item) {
					if (stack[item].length) {
						var len = stack._order_.length;
						for (var index = len - 1; index >= 0; index--) {
							var order = stack._order_[index];
							var attrIndex = order.indexOf(item);
							if (attrIndex > -1) {
								order.splice(attrIndex, 1);
								if (!order.length) {
									stack._order_.splice(index, 1);
								}
								break;
							}
						}
					}
				});
			} else {
				attrs = stack._order_ && stack._order_.length ? stack._order_.pop() : attrs;
			}
			if (attrs.length) {
				for (var index = 0; index < attrs.length; index++) {
					var key = attrs[index],
					    obj = stack[key].pop();
					if (obj._type == "update") {
						if (obj.hasOwnProperty("val")) {
							store.$.setData(rec, key, obj.val, undefined, revObj);
							// redoObj[key] = undo;
						} else if (obj.hasOwnProperty("records")) {
							store.$.setData(rec, key, obj.records, undefined, revObj);
						}
					} else if (type == 1 && obj._type == "propAdd") {
						if (typeof Lyte != "undefined") {
							revObj[key] = { _type: "propDelete", val: rec.record[key] };
							if (obj.hasOwnProperty("val")) {
								store.$.setData(rec, key, obj.val, undefined, {});
								// redoObj[key] = undo;
							}
							if (Lyte.objectUtils) {
								Lyte.objectUtils(rec.record, "delete", key);
							} else {
								delete rec.record[key];
							}
						} else {
							delete rec.record[key];
						}
					} else if (type == 2 && obj._type == "propDelete") {
						revObj[key] = { _type: "propAdd" };
						store.$.setData(rec, key, obj.val, undefined, revObj);
					} else if (obj._type == "added") {
						rec.record.$.get(key).remove(obj.records, undefined, revObj);
					} else if (obj._type == "removed") {
						store.$.rllBckRecArr([obj], rec.record, rec.model, rec.model.fieldList[key]);
						obj._type = "added";
						revObj[key] = obj;
					}
				}
				var keys = Object.keys(revObj);
				for (var index = 0; index < keys.length; index++) {
					var key = keys[index];
					revStack[key] = revStack[key] || [];
					revStack[key].push(revObj[key]);
				}
				if (keys.length) {
					// rec.redoStack._order_ = rec.redoStack._order_ || [];
					revStack._order_.push(keys);
				}
			}
		},
		// undo: function(rec){
		// 	var obj = rec.undoStack.pop(),undo, redoObj = {};
		// 	if(obj){
		// 		for(var key in obj){
		// 			var undo = obj[key];
		// 			if(undo._type == "update"){
		// 				if(undo.hasOwnProperty("val")){
		// 					store.$.setData(rec,key,undo.val,redoObj)
		// 				}else if(undo.hasOwnProperty("records")){
		// 					store.$.setData(rec,key,undo.records,redoObj)	
		// 				}
		// 			}
		// 			else if(undo._type == "propAdd"){
		// 				if(typeof Lyte != "undefined"){
		// 					redoObj[key] = {type:"propDelete", val:rec.record[key]};
		// 					Lyte.objectUtils(rec.record, "delete", key);
		// 				}
		// 				else{
		// 					delete rec.record[key];
		// 				}
		// 			}
		// 			else if(undo._type == "added"){
		// 				rec.record.$.get(key).remove(undo.records,undefined,redoObj);
		// 			}
		// 			else if(undo._type == "removed"){
		// 				store.$.rllBckRecArr([undo], rec.record, rec.model, rec.model.fieldList[key])
		// 				undo._type = "added";
		// 				redoObj[key] = undo;
		// 			}
		// 		}
		// 		rec.redoStack.push(redoObj);				
		// 	}
		// },
		unregisterModel: function unregisterModel(name, inherit) {
			var model = store.modelFor(name);
			if (!model) {
				Lyte.warn("LD02", "Model ", name);
				return;
			}
			if (model.data.length) {
				store.unloadAll(name, undefined, inherit);
			}
			var extendedBy = model.extendedBy;
			if (extendedBy && Object.keys(extendedBy).length) {
				for (var ext in extendedBy) {
					store.unregisterModel(ext, inherit);
				}
			}
			var extend = model.extend;
			if (extend) {
				var extMod = store.modelFor(extend);
				delete extMod.extendedBy[name];
			}
			delete store.model[name];
		},

		getDsrzEmpData: function getDsrzEmpData(field, modelName) {
			if (field.hasOwnProperty("deserializeEmptyData")) {
				return field.deserializeEmptyData;
			} else {
				var desrz = store.$.getFromCB("serializer", modelName, "deserializeEmptyData");
				if (desrz !== undefined) {
					return desrz;
				}
			}
			return false;
		},
		updateFieldValidation: function updateFieldValidation(model, key, deserialize, ignoreValidation) {
			var records = model.data;
			var fields = model.fieldList;
			records.forEach(function (item) {
				var field = fields[key];
				if (deserialize) {
					var empD = store.$.getDsrzEmpData(field, model._name);
					var boolChk = !empD && item[key];
					if (item.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(field.type) && Lyte.Transform[field.type].hasOwnProperty("deserialize")) {
						item[key] = Lyte.Transform[field.type].deserialize(item[key], key, model._name, store.$.getpKVal(item, model));
					}
				}
				if (!ignoreValidation) {
					var isOldVal = item.$.error && item.$.error.hasOwnProperty(key) && item.$.error[key].hasOwnProperty("value") ? true : false;
					var oldVal = isOldVal ? item.$.error[key].value : undefined;
					store.$.clrRecErr(item.$, key);
					isOldVal ? store.$.validateField(item, key, field, undefined, { old: true, value: oldVal }) : store.$.validateField(item, key, field, undefined);
				}
				if (isOldVal && item.$.error && Object.keys(item.$.error) === 0) {
					item.$.set(key, oldVal);
				}
			});
		},
		validateRelatedRecord: function validateRelatedRecord(record, key, field) {
			var fields = store.model[field.relatedTo].fieldList;
			if (field && field.opts && record && record.hasOwnProperty(key)) {
				if (field.opts && field.opts.serialize == "record") {
					if (field.relType == "belongsTo" && Lyte.isRecord(record[key])) {
						return this.validateRecord(record[key], fields);
					} else if (field.relType == "hasMany") {
						if (Array.isArray(record[key])) {
							var ret = true,
							    result,
							    self = this;
							record[key].forEach(function (item, index) {
								if (Lyte.isRecord(item)) {
									result = self.validateRecord(item, fields);
									if (result === false) {
										ret = false;
									}
								}
							});
							return ret;
						}
					}
				}
			}
		},
		validateRecord: function validateRecord(record, fields) {
			var result,
			    ret = true,
			    returnVal;
			for (var field in fields) {
				returnVal = this.validateField(record, field, fields[field], result);
				if (ret === true && returnVal === false) {
					ret = false;
				}
			}
			if (ret === false || record.$.isError === true && record.$.error && Object.keys(record.$.error).length) {
				return false;
			}
			return true;
		},
		validateField: function validateField(record, key, field, result, obj) {
			var val = obj && obj.old ? obj.value : record[key],
			    ret,
			    err = record.$,
			    clear;
			if (field.type == "relation") {
				ret = this.validateRelatedRecord(record, key, field);
				if (ret === false) {
					result = false;
					return result;
				}
			} else if (field.mandatory && !record.$.error.hasOwnProperty(key) && (val === undefined || val === "" || Array.isArray(val) && val.length === 0)) {
				store.$.setRecErr(err, key, { code: "ERR02", message: Lyte.errorCodes.ERR02, value: val });
			} else {
				clear = true;
				if (obj || record.hasOwnProperty(key) && !record.$.error.hasOwnProperty(key)) {
					var _field = field;
					if (!(_field.any && Array.isArray(_field))) {
						_field = [_field];
					}
					var fldLen = _field.length,
					    _ret = true;
					for (var i = 0; i < fldLen; i++) {
						var _fld = _field[i];
						for (var property in _fld) {
							var resp = Lyte.checkProperty(property, val, key, _fld[property], _fld, record, undefined, Lyte.isRecord(record) ? record.$.model._name : undefined);
							if (resp !== true) {
								if (_ret === true) {
									if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) == "object") {
										resp.value = val;
									}
									_ret = resp;
									// store.$.setRecErr(err,key,resp);
									// clear = false;
								}
								//err[field] = resp;
								break;
							}
						}
					}
					if (_ret !== true) {
						store.$.setRecErr(err, key, _ret);
						clear = false;
					}
					if (obj && clear) {
						store.$.cmpSet(record, key, val, undefined, true);
					}
					if (clear) {
						store.$.clrRecErr(err, key);
					}
				}
			}
		},
		partialData: function partialData(rec, key, pK, type, polymorphicType, partRemoveOnly) {
			var arr = rec[key];
			if (!arr || !Array.isArray(arr)) {
				return true;
			}
			if (!arr.partial) {
				store.$.defPar(arr);
			}
			var partial = arr.partial = arr.partial || new Map();
			if (!partial.get(pK)) {
				partial.set(pK, {});
			}
			var revert = false;
			var obj = partial.get(pK);
			var objType = obj.type;
			switch (objType) {
				case "added":
					{
						if (type == "removed") {
							partial.delete(pK);
							revert = true;
						}
						break;
					}
				case "removed":
					{
						if (type == "added") {
							if (rec[key]._recMap) {
								var relRec = rec[key]._recMap.get(pK);
							}
							if (!relRec || Lyte.isRecord(relRec) && !relRec.$.isDirty()) {
								partial.delete(pK);
								revert = true;
							} else {
								var obj = partial.get(pK);
								obj.type = "modified";
							}
						}
						break;
					}
				case "modified":
				case "updated":
					{
						if (type == "added") {
							//this case mostly won't come. if at all it comes, break
							break;
						}
					}
				default:
					{
						if (!partRemoveOnly) {
							var pObj = { type: type };
							polymorphicType ? pObj.polymorphicType = polymorphicType : undefined;
							partial.set(pK, pObj);
						} else {
							partial.delete(pK);
							revert = true;
						}
					}
			}
			if (revert && !partial.size) {
				if (!partial.size) {
					store.$.deleteDeepNest(rec, key, pK);
				}
				return true;
			}
		},
		removeParentNesting: function removeParentNesting(rec, type, ignorePartial) {
			var model = rec.$.model;
			var pkVal = rec.$.pK;
			var rels = model.relations;
			for (var key in rels) {
				var relations = rels[key];
				relations.forEach(function (item) {
					var inv, deep, part, invRecs;
					//store.$.getRelations(model, item.relKey, store.model[item.relatedTo], rel);
					var bMod = store.model[item.relatedTo];
					if (bMod) {
						inv = store.$.getBackwardRel(model, item, bMod);
						//inv = rel.backward;
						if (inv && inv.opts) {
							deep = inv.opts.deepNest;
							part = inv.opts.hasOwnProperty("serialize");
							if (!item.relKey || item == inv) {
								invRecs = store.$.getRelatedRecord(rec, item.relatedTo, item.dummy ? item.dummy : item.relKey);
							} else {
								invRecs = rec[item.relKey];
							}
						}
						// if(deep){
						// 	if(Array.isArray(invRecs)){
						// 		invRecs.forEach(function(item){
						// 			if(Lyte.isRecord(item)){
						// 				store.$.deleteDeepNest(item, inv.relKey, pkVal);
						// 			}
						// 		});
						// 	}
						// 	else if(Lyte.isRecord(invRecs)){
						// 		store.$.deleteDeepNest(invRecs, inv.relKey, pkVal);
						// 	}
						// }
						if (part && !ignorePartial) {
							if (invRecs && !Array.isArray(invRecs)) {
								invRecs = [invRecs];
							}
							if (Array.isArray(invRecs)) {
								invRecs.forEach(function (invItm) {
									if (inv.relKey) {
										if (inv.relType == "belongsTo" && invItm && invItm.$) {
											if (invItm.$.partial && invItm.$.partial[inv.relKey] && invItm.$.partial[inv.relKey].has(pkVal)) {
												invItm.$.partial[inv.relKey].delete(pkVal);
												if (!invItm.$.partial[inv.relKey].size) {
													delete invItm.$.partial[inv.relKey];
												}
											}
											deep ? store.$.deleteDeepNest(invItm, inv.relKey, pkVal) : undefined;
										} else if (inv.relType == "hasMany") {
											var invArr = invItm[inv.relKey];
											if (Array.isArray(invArr)) {
												if (invArr.partial && invArr.partial.has(pkVal)) {
													var _ptype = invArr.partial.get(pkVal).type;
													if (type == "modified") {
														if (/^(modified|updated)$/.test(_ptype)) {
															invArr.partial.delete(pkVal);
														}
													} else {
														invArr.partial.delete(pkVal);
													}
												}
												deep ? store.$.deleteDeepNest(invItm, inv.relKey, pkVal) : undefined;
											}
										}
									}
								});
							}

							// if(invRecs && !Array.isArray(invRecs)){
							// 	invRecs=[invRecs];
							// }
							// if(Array.isArray(invRecs)){
							// 	invRecs.forEach(function(item){
							// 		var partData = inv.relKey ? item[inv.relKey] : undefined; 
							// 		if(partData && partData.partial && partData.partial.get(pkVal)){
							// 			var _ptype = partData.partial.get(pkVal).type;
							// 			if(type == "modified"){
							// 				if(/^(modified|updated)$/.test(_ptype)){
							// 					partData.partial.delete(pkVal);
							// 				}
							// 			}
							// 			else{
							// 				partData.partial.delete(pkVal);
							// 			}
							// 		}
							// 	});
							// }	
						}
					}
				});
			}
		},
		deleteDeepNest: function deleteDeepNest(rec, key, pkVal) {
			var deepNest = rec.$.dN;
			if (deepNest) {
				if (deepNest[key] && pkVal === undefined) {
					delete deepNest[key];
				} else if (deepNest[key] && deepNest[key].get(pkVal)) {
					deepNest[key].delete(pkVal);
					if (!deepNest[key].size) {
						delete deepNest[key];
					}
				}
				if (!Object.keys(deepNest).length) {
					delete rec.$.dN;
					if (!rec.$.isModified && !rec.$.isNew) {
						store.$.removeParentNesting(rec);
					}
					store.$.changePersist(rec, true);
				}
			}
		},
		// createJSON:function(record, fields, err, validateOnSave){
		// 	for(var field in fields){
		// 		var val = record[field], fieldKeys = fields[field];
		// 		if(fieldKeys.type == "relation"){
		// 			continue;
		// 		}
		// 		if(!record.$.validatedOnCreate || validateOnSave){
		// 			if(fieldKeys.mandatory && !record.$.error.hasOwnProperty(field) && (val == null || val == undefined || val === "" || (Array.isArray(val) && val.length == 0) )){
		// 					store.$.setRecErr(err,field,{code : "ERR02", message : Lyte.errorCodes.ERR02});
		// 					//err[field] = {code : "ERR02", message : Lyte.errorCodes.ERR02};
		// 			}
		// 			else{
		// 				clear = true;
		// 				if(record.hasOwnProperty(field) && !record.$.error.hasOwnProperty(field)){
		// 					for(var property in fieldKeys){
		// 						var resp = Lyte.checkProperty(property, record[field], field, fieldKeys[property]);
		// 						if(resp != true){
		// 							store.$.setRecErr(err,field,resp);
		// 							clear = false;
		// 							//err[field] = resp;
		// 							break;
		// 						}
		// 					}
		// 					if(clear){
		// 						store.$.clrRecErr(err, field);
		// 					}		
		// 				}
		// 			}							
		// 		}
		// 	}
		// },
		updateJSON: function updateJSON(record, model, dirty) {
			var data = {};
			var arrPk = model._arrPk;
			var dirtyAttr = record.$._attributes;
			for (var field in dirtyAttr) {
				data[field] = record[field];
			}
			var attrs = dirty;
			if (dirty == true) {
				attrs = store.$.isDirty(record, model.relations) || [];
			}
			for (var i = 0; i < attrs.length; i++) {
				data[attrs[i]] = record[attrs[i]];
			}
			arrPk.forEach(function (item) {
				data[item] = record[item];
			});
			return data;
		},
		removeDeepNest: function removeDeepNest(record) {
			if (!Lyte.isRecord(record)) {
				return;
			}
			var bool1 = record.$.dN && Object.keys(record.$.dN).length;
			if (bool1) {
				record.$.dN = {};
				var model = record.$.model;
				var relations = model.relations;
				for (var key in relations) {
					var rels = relations[key];
					rels.forEach(function (item) {
						var opts = item.opts;
						if (opts && (opts.deepNest || opts.serialize == "partial")) {
							var data = record[item.relKey];
							if (Array.isArray(data)) {
								data.forEach(function (itm) {
									if (Lyte.isRecord(itm)) {
										store.$.removeDeepNest(itm);
										if (!itm.$.isNew && !itm.$.isModified && (!itm.$.dN || itm.$.dN && Object.keys(itm.$.dN).length == 0)) {
											store.$.removeParentNesting(itm);
										}
									}
								});
							} else if (Lyte.isRecord(data)) {
								store.$.removeDeepNest(data);
								if (!data.$.isNew && !data.$.isModified && (!data.$.dN || data.$.dN && Object.keys(data.$.dN).length == 0)) {
									store.$.removeParentNesting(data);
								}
							}
						}
					});
				}
			}
		},
		addDeepNest: function addDeepNest(record, extended, type, ignoreRel, mp, processOnlySrzPart) {
			var relatedRecord,
			    mp = mp || new Map(),
			    model = extended ? store.model[record.$.model.extend] : record.$.model,
			    pK = record.$.pK,
			    type = type || "updated",
			    relations = model.relations;
			for (var key in relations) {
				var rels = relations[key];
				rels.forEach(function (item) {
					var inv,
					    deep,
					    part,
					    serz,
					    bMod = store.model[item.relatedTo];
					if (bMod) {
						inv = store.$.getBackwardRel(model, item, bMod);
						if (!item.relKey || inv === item) {
							relatedRecord = store.$.getRelatedRecord(record, item.relatedTo, item.dummy ? item.dummy : item.relKey);
						} else {
							relatedRecord = record[item.relKey];
						}
						if (relatedRecord) {
							var mppass = false,
							    nmp,
							    ignoreDn;
							if (!mp.get(inv)) {
								var nmp = mp.set(inv, new Map());
								mppass = true;
							}
							nmp = mp.get(inv);
							if (mppass || !nmp.get(relatedRecord)) {
								nmp.set(relatedRecord, true);
								if (inv && inv.opts) {
									deep = inv.opts.deepNest;
									part = inv.opts.serialize == "partial" ? true : false;
									serz = inv.opts.serialize ? inv.opts.serialize : false;
								}
								if (type == "updated" && serz == "id") {
									ignoreDn = true;
								}
								if ((!processOnlySrzPart || processOnlySrzPart && part) && !ignoreDn) {
									if (deep) {
										//					if(deep || part){
										store.$.makeDirty("dirty", relatedRecord, type, inv, pK, mp);
									}
									if (serz && record && relatedRecord && (!ignoreRel || !(ignoreRel && ignoreRel.model === item.relatedTo && inv.relKey === ignoreRel.relKey))) {
										var data = relatedRecord;
										if (inv.relType == "hasMany") {
											if (Array.isArray(data)) {
												data.forEach(function (item) {
													store.$.partialData(item, inv.relKey, pK, /^(added|removed)$/.test(type) ? type : "modified");
												});
											} else if (Lyte.isRecord(data)) {
												store.$.partialData(data, inv.relKey, pK, /^(added|removed)$/.test(type) ? type : "modified");
											}
										} else {
											if (Array.isArray(data)) {
												data.forEach(function (item) {
													if (type == "added" && item && item.$ && item.$.partial && item.$.partial[inv.relKey] && item.$.partial[inv.relKey].has(pK)) {
														delete item.$.partial;
													}
												});
											} else if (Lyte.isRecord(data)) {
												if (type == "added" && data && data.$ && data.$.partial && data.$.partial[inv.relKey] && data.$.partial[inv.relKey].has(pK)) {
													delete data.$.partial;
												}
											}
										}
										//store.$.partialData(record[item.relKey], inv.relKey, pK , "modified");
									}
								}
							}
						}
					}
				});
			}
			if (model.extend) {
				this.addDeepNest(record, true);
			}
		},
		getRelatedRecord: function getRelatedRecord(record, modelName, key) {
			if (record) {
				var relationship = record.$._relationships;
				if (relationship[modelName] && relationship[modelName][key]) {
					return relationship[modelName][key];
				}
			}
		},
		makeDirty: function makeDirty(name, records, type, rel, pK, mp) {
			if (!(rel.opts.serialize == 'id' && type == "updated")) {
				var relKey = rel.relKey;
				if (Array.isArray(records)) {
					records.forEach(function (item) {
						store.$.setDeepNest(item, relKey, pK, type, mp);
					});
				} else if (Lyte.isRecord(records)) {
					store.$.setDeepNest(records, relKey, pK, type, mp);
				}
			}
		},
		setDeepNest: function setDeepNest(item, relKey, pK, type, mp) {
			var deepN = item.$.dN = item.$.dN || {};
			var deepRel = deepN[relKey] = deepN[relKey] || new Map();
			if (!deepRel.has(pK)) {
				deepRel.set(pK, {});
			}
			var obj = deepRel.get(pK);
			switch (obj.type) {
				case "added":
					{
						if (type == "removed") {
							store.$.deleteDeepNest(item, relKey, pK);
						}
						break;
					}
				case "removed":
					{
						if (type == "added") {
							store.$.deleteDeepNest(item, relKey, pK);
						}
						if (type == "modified") {
							obj.type = "updated";
						}
						break;
					}
				default:
					{
						obj.type = type;
						store.$.changePersist(item, false);
						store.$.addDeepNest(item, undefined, undefined, undefined, mp);
					}
			}
		},
		isDirty: function isDirty(record, relations, parent, fMod) {
			var result = [];
			for (var rel in relations) {
				var rel_model = relations[rel];
				for (var j = 0; j < rel_model.length; j++) {
					var rel = rel_model[j];
					if (rel.opts && rel.opts.serialize) {
						var key = rel.relKey,
						    type = rel.relType,
						    records = record[key],
						    bMod = store.model[rel.relatedTo];
						if (parent && bMod) {
							var child = store.$.getBackwardRel(fMod, rel, store.model[rel.relatedTo]);
							if (parent == child && fMod._name != rel.relatedTo) {
								continue;
							}
						}
						if (rel.opts.serialize == "record") {
							var res = store.$.isRelDirty(rel, records, rel);
							if (res) {
								result.push(key);
								continue;
							}
						} else if (rel.opts.serialize == "partial") {
							if (type == "hasMany") {
								if (records && records.partial && records.partial.size) {
									result.push(key);
									continue;
								}
							} else {
								if (Lyte.isRecord(records) && records.$.isModified || record && record.$ && record.$.partial && record.$.partial.hasOwnProperty(key)) {
									result.push(key);
									continue;
								}
							}
						}
						if (rel.opts.deepNest) {
							if (record.$.dN && record.$.dN[key]) {
								result.push(key);
							}
						}
					}
				}
			}
			return result;
		},
		isRelDirty: function isRelDirty(rel, records, parent) {
			var type = rel.relType;
			var fMod = store.model[rel.relatedTo];
			var relations = fMod.relations;
			if (!store.$.isEmpty(records)) {
				if (type == "hasMany" && Array.isArray(records) && records.length) {
					var len = records.length;
					for (var i = 0; i < len; i++) {
						if (records[i].$.isModified == true) {
							return true;
						}
					}
					for (var j = 0; j < len; j++) {
						var rec = records[j];
						var arr = this.isDirty(rec, relations, parent, fMod);
						if (arr.length) {
							return true;
						}
					}
				} else if (type == "belongsTo" && Lyte.isRecord(records)) {
					if (records.$.isModified == true) {
						return true;
					}
					var arr = this.isDirty(records, relations, parent, fMod);
					if (arr.length) {
						return true;
					}
				}
			}
			return false;
		},
		handleCachedResponse: function handleCachedResponse(batch, resp) {
			var cached = store.$.cachedBatch = store.$.cachedBatch || {};
			var arr = cached[batch] || [],
			    count = 0;
			arr.forEach(function (item, index) {
				resp.splice(item.ind + count++, 0, item.data);
			});
			delete cached[batch];
			return resp;
		},
		addToCachedBatch: function addToCachedBatch(data) {
			var curr = store.$.currentBatch;
			var cached = store.$.cachedBatch = store.$.cachedBatch || {};
			var cachedB = cached[curr] = cached[curr] || [];
			var arr = store.$.batch[curr] || [];
			var ind = arr.length;
			cachedB.push({ ind: ind, data: data });
		},
		establishToRelated: function establishToRelated(record, relArr) {
			var bModel = record.$.model,
			    rel = {};
			relArr.forEach(function (item) {
				var rec = store.peekRecord(item.model, item.pkVal);
				if (rec) {
					var fModel = rec.$.model;
					store.$.getRelations(fModel, item.key, bModel, rel);
					store.$.establishLink(rel.forward, rel.backward, rec, record, undefined, true);
				}
			});
		},
		checkObjAndAddToArr: function checkObjAndAddToArr(arr, obj, keys) {
			var len = Object.keys(keys).length,
			    res = -1,
			    arrLen = arr.length;
			for (var k = 0; k < arrLen; k++) {
				var item = arr[k];
				var i = 0;
				for (var key in keys) {
					if (item[key] == obj[key]) {
						i++;
					}
				}
				if (i == len) {
					res = k;
					arr.splice(k, 1, obj);
					return;
				}
			}
			if (res == -1) {
				arr.push(obj);
			}
			return res;
		},
		addToRelate: function addToRelate(modelName, data, rel, key) {
			var relMod = rel.forward.relatedTo;
			var toRelMod = store.$.toRelate[relMod] = store.$.toRelate[relMod] || new Map();
			if (!toRelMod.has(key)) {
				toRelMod.set(key, []);
			}
			var toRel = toRelMod.get(key);
			var pkVal = data.$.pK;
			var obj = { model: modelName, pkVal: pkVal, key: rel.forward.relKey };
			toRel.push(obj);
			// this.checkObjAndAddToArr(toRel, obj, ["record","key"]);
		},
		addOnSave: function addOnSave(modelName, record, attr, field, pK, relPk) {
			store.$.onSave = store.$.onSave || {};
			var saveMod = store.$.onSave[modelName] = store.$.onSave[modelName] || {};
			var saveQ = saveMod[record[pK]] = saveMod[record[pK]] || {};
			var recs = record[attr] || [];
			if (field.relType == "belongsTo") {
				recs = !Array.isArray(record[attr]) ? [record[attr]] : record[attr];
			}
			recs.forEach(function (item) {
				var q = saveQ[field.relKey] = saveQ[field.relKey] || [];
				store.$.checkAndAddToArray(q, item[relPk]);
			});
		},
		addToIDBonSave: function addToIDBonSave(modelName, rec) {
			var model = store.model[modelName];
			var fields = model.fieldList;
			var saveMod = store.$.onSave ? store.$.onSave[modelName] : undefined;
			if (saveMod) {
				var pK = store.model[modelName]._pK;
				var saveQ = rec && pK ? saveMod[rec[pK]] : undefined;
				if (saveQ) {
					for (var key in saveQ) {
						var ids = saveQ[key];
						var relMod = fields[key].relatedTo;
						ids.forEach(function (item) {
							var rec = store.peekRecord(relMod, item);
							if (rec) {
								var parent = rec.$.parent;
								if (Lyte.isRecord(parent)) {
									var mod = parent.$.model;
									var modName = mod._name;
									var modPk = mod._pK;
									store.$.checkAndAddToIDBQ(modName, "updateRecord", store.peekRecord(modName, parent[modPk]).$.toJSON(true));
								} else {
									store.$.checkAndAddToIDBQ(relMod, "updateRecord", store.peekRecord(relMod, item).$.toJSON(true));
								}
							}
						});
					}
					store.$.removeOnSave(modelName, rec[pK]);
				}
			}
		},
		removeOnSave: function removeOnSave(modelName, pkVal) {
			var saveMod = store.$.onSave ? store.$.onSave[modelName] : undefined;
			if (saveMod && saveMod[pkVal]) {
				delete saveMod[pkVal];
			}
		},
		checkAndAddToIDBQ: function checkAndAddToIDBQ(modelName, type, data) {
			var obj = { model: modelName, type: type, data: data };
			var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
			q.push(obj);
		},
		checkAndRemoveKey: function checkAndRemoveKey(rawData, fields, deserializeKeys) {
			for (var key in rawData) {
				var field = fields[key];
				if (field && field.type == "relation") {
					if (deserializeKeys && !this.checkPresenceInArray(deserializeKeys, key)) {
						delete rawData[key];
					} else {
						this.removeNotNeededKeys(field.relatedTo, rawData[key]);
					}
				}
			}
		},
		removeNotNeededKeys: function removeNotNeededKeys(modelName, rawData, idbObj) {
			var model = store.model[modelName];
			var fields = model.fieldList;
			var deserializeKeys = idbObj ? idbObj.deserializeKeys : undefined;
			if (model) {
				var self = this;
				if (Array.isArray(rawData)) {
					rawData.forEach(function (item) {
						self.checkAndRemoveKey(item, fields, deserializeKeys);
					});
				} else {
					this.checkAndRemoveKey(rawData, fields, deserializeKeys);
				}
			}
			return rawData;
		},
		getIDBObj: function getIDBObj(model, queryParams, type, key, customData, modelName) {
			if (model && model.hasOwnProperty('idb')) {
				if (typeof model.idb == "function") {
					return model.idb.apply(model, [{ model: modelName ? modelName : model._name, type: type, queryParams: queryParams, key: key, customData: customData }]);
				}
				return model.idb;
			}
		},
		idbQ2Push: function idbQ2Push(modelName, rawData, queryParams, type, key, meta, customData) {
			try {
				var model = store.model[modelName],
				    idb = store.$.getIDBObj(model, queryParams, type, key, customData);
				if (idb) {
					// if(type !== "pushPayload"){
					// 	rawData = Lyte.deepCopyObject(rawData);
					// }
					var qObj = { model: modelName, type: type, customData: customData };
					qObj.queryCache = idb.queryCache;
					var pK = model._pK;
					var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
					switch (type) {
						case "action":
							{
								delete q[type];
								return;
							}
						case "update":
						case "create":
							{
								qObj.data = [];
								rawData.forEach(function (item) {
									qObj.data.push(Lyte.isRecord(item) ? item.$.toJSON(undefined, true) : item);
								});
								break;
							}
						case "updateRecord":
						case "createRecord":
							{
								qObj.data = rawData;
								break;
							}
						case "delete":
							{
								qObj.data = rawData;
								break;
							}
						case "destroyRecord":
						case "deleteRecord":
							{
								qObj.id = rawData;
								break;
							}
						case "findRecord":
							qObj.key = key;
							var newRawData = rawData[0].$.toJSON("idb");
							var nObj = {};
							nObj[modelName] = newRawData;
							if (meta) {
								nObj.meta = meta;
							}
							if (idb.queryCache === true) {
								qObj.queryParams = queryParams;
							}
							qObj.data = nObj;
							break;
						case "findAll":
							{
								var newRawData = [];
								rawData.forEach(function (itm) {
									newRawData.push(itm.$.toJSON("idb"));
								});
								var nObj = {};
								nObj[modelName] = newRawData;
								if (meta) {
									nObj.meta = meta;
								}
								// rawData[modelName] = this.removeNotNeededKeys(modelName, rawData[modelName], idb);
								if (idb.queryCache === true) {
									qObj.queryParams = queryParams;
								}
								qObj.data = nObj;
								break;
							}
						case "pushPayload":
							{
								if (Lyte.isRecord(rawData)) {
									rawData = rawData.$.toJSON("idb");
								}
								// rawData = this.removeNotNeededKeys(modelName, rawData, idb);
								qObj.data = rawData;
								break;
							}
					}
					q.push(qObj);
				}
			} catch (err) {
				Lyte.error("Error while adding to IDBQueue ", err);
			}
		},
		isEmpty: function isEmpty(val) {
			if (val != undefined && val !== "" && val != null) {
				return false;
			}
			return true;
		},
		isEmptyObj: function isEmptyObj(obj) {
			if (obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object" && Object.keys(obj).length == 0) {
				return true;
			}
			return false;
		},
		isEmptyArray: function isEmptyArray(arr) {
			if (Array.isArray(arr) && arr.length == 0) {
				return true;
			}
			return false;
		},
		registerField: function registerField(model, key, field, obs) {
			var oldField = model.fieldList[key] ? Object.assign({}, model.fieldList[key]) : undefined;
			if (field.type == "observer") {
				obs.push(field);
			} else if (field.type == "callBack") {
				if (field.observes) {
					obs.push(field.observes);
				}
				var props = field.properties;
				for (var i = 0; i < props.length; i++) {
					if (props[i] === "didLoad" || props[i] === "init") {
						if (!model.didLoad) {
							model.didLoad = [];
						}
						model.didLoad.push(field.value);
					} else if (props[i] === "add" || props[i] === "change") {
						model.on(props[i], field.value);
					}
				}
				if (key == "didLoad") {
					if (!model.didLoad) {
						model.didLoad = [];
					}
					model.didLoad.push(field.value);
				}
			} else if (key == "didLoad") {
				if (!model.didLoad) {
					model.didLoad = [];
				}
				model.didLoad.push(field);
			} else if (Object.keys(field).length) {
				if (field.primaryKey) {
					if (model.fieldList.id && model.fieldList.id.defined == false) {
						delete model.fieldList.id;
					}
					if (field.hasOwnProperty("default")) {
						Lyte.warn("LD23", model._name, key);
						delete field.default;
					}
					if (model._pK != undefined) {
						model._pK = model._pK + "," + key;
						model.isComposite = true;
					} else {
						model._pK = key;
					}
					if (field.baseKey) {
						if (model.bK) {
							Lyte.warn("LD26");
							return;
						}
						model.bK = key;
					}
				}
				if (model.fieldList.hasOwnProperty(key)) {
					var alrPresent = true;
				}
				model.fieldList[key] = field;
				if (oldField && model._fldGrps) {
					if (oldField.hasOwnProperty("default")) {
						delete model._fldGrps.default[key];
					}
					if (oldField.hasOwnProperty("watch")) {
						delete model._fldGrps.watch[key];
					}
					if (oldField.opts && oldField.opts.hasOwnProperty("inherit")) {
						delete model._fldGrps.inherit[key];
					}
				}
				if (field.hasOwnProperty("default")) {
					model._fldGrps.default[key] = field;
				}
				if (field && field.opts && field.opts.hasOwnProperty("inherit")) {
					model._fldGrps.inherit[key] = field;
				}
				if (field.hasOwnProperty("watch") && (field.watch == true || Array.isArray(field.watch)) && /^(array|object)$/.test(field.type)) {
					model._fldGrps.watch[key] = field;
				}
				if (Lyte.Transform[field.type]) {
					var customDatatype = Lyte.Transform[field.type];
					if (/^(array|object)$/.test(customDatatype.extends) && customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items")) {
						model._fldGrps.nested_prop[key] = field;
					}
				}
			}
			if (field.type === "relation") {
				field.relKey = key;
				var relTo = field.relatedTo;
				var relObj = model.fieldList[key];
				if (!model.relations[relTo]) {
					model.relations[relTo] = [];
				}
				var chkObj = {};
				chkObj.relKey = relObj.relKey;
				store.$.checkObjAndAddToArr(model.relations[field.relatedTo], relObj, chkObj);
				if (field.relType == "hasMany") {
					model._fldGrps.hasMany[key] = field;
				}
				if (field.hasOwnProperty("opts") && field.opts.hasOwnProperty("inverse")) {
					model._fldGrps.inverse[relTo] = field;
				}
			}
		},
		setError: function setError(err, attr, codeObj) {
			if (err.$.hasOwnProperty("error")) {
				if (Array.isArray(attr)) {
					attr.forEach(function (itm) {
						store.$.cmpSet(err.$.error, itm, codeObj);
					});
				} else {
					store.$.cmpSet(err.$.error, attr, codeObj);
				}
			} else {
				Lyte.error("LD03", err, attr);
			}
		},
		unRegCb: function unRegCb(type, name) {
			var callback = store[type][name];
			if (!callback) {
				Lyte.error("LD02", type, name);
				return;
			}
			var extendedBy = callback.__extendedBy;
			if (extendedBy.length) {
				store[type].__toAddSuper = store[type].__toAddSuper || {};
				if (!store[type].__toAddSuper[name]) {
					store[type].__toAddSuper[name] = extendedBy.slice();
				} else {
					extendedBy.forEach(function (item) {
						store[type].__toAddSuper[name].push(item);
					});
				}
				extendedBy.forEach(function (item) {
					store[type][item].$super = undefined;
				});
				if (store[type].application && name != "application") {
					var application = store[type].application;
					extendedBy.forEach(function (item) {
						store[type][item].$super = application;
						store[type].application.__extendedBy.push(item);
					});
				}
				if (!store[type].application) {
					if (!store[type].__toAddSuper.application) {
						store[type].__toAddSuper.application = extendedBy.slice();
					} else {
						extendedBy.forEach(function (item) {
							store[type].__toAddSuper.application.push(item);
						});
					}
				}
			}
			if (callback.$super) {
				callback.$super.__extendedBy.splice(callback.$super.__extendedBy.indexOf(name), 1);
			}
			delete store[type][name];
		},
		eventListeners: {
			add: function add(scope, type, func) {
				scope.events = scope.events || {};
				scope.events[type] = scope.events[type] || [];
				scope.events[type].push({ f: func });
				return type + "-" + (scope.events[type].length - 1);
			},
			remove: function remove(scope, id) {
				var type;
				if (id) {
					if (/^(add|remove|change)$/.test(id)) {
						type = id;
						scope.events && scope.events[type] ? delete scope.events[type] : undefined;
					} else {
						var arr = id ? id.split("-") : undefined;
						if (arr) {
							var listeners = scope.events[arr[0]];
							if (listeners && arr[1]) {
								listeners[arr[1]] = null;
							}
						}
					}
				} else {
					var ev = scope.events;
					for (var evType in ev) {
						ev && ev[evType] ? delete ev[evType] : undefined;
					}
				}
			},
			emit: function emit(scope, type, args) {
				var listeners = scope.events && scope.events[type] ? scope.events[type] : [];
				for (var i = 0; i < listeners.length; i++) {
					listeners[i] ? listeners[i].f.apply(null, args) : undefined;
				}
			}
		},
		extendCallback: function extendCallback(scope, type, parent) {
			var callback = scope[type],
			    addsuper;
			var res;
			if (parent && typeof parent === "string") {
				res = callback[parent];
				if (!res) {
					callback.__toAddSuper = callback.__toAddSuper || {};
					if (!callback.__toAddSuper.hasOwnProperty(parent)) {
						callback.__toAddSuper[parent] = [];
					}
					callback.__toAddSuper[parent].push(this.__name);
				}
			}
			if (res && res.is == type && (!this.$super || this.$super.__name == "application")) {
				this.$super = res;
				res.__extendedBy.push(this.__name);
				if (callback.application) {
					var application_extarr = callback.application.__extendedBy;
					var index = application_extarr.indexOf(this.__name);
					if (index > -1) {
						callback.application.__extendedBy.splice(index, 1);
					}
				}
				addsuper = callback.__toAddSuper;
				if (addsuper) {
					if (addsuper.application) {
						var addsuper_arr = addsuper.application;
						var index1 = addsuper_arr.indexOf(this.__name);
						if (index1 > -1) {
							callback.__toAddSuper.application.splice(index1, 1);
						}
					}
				}
			}
			return this;
		},
		super: function _super() {
			// console.log(arguments);
			var scope = this,
			    parent = this.$super,
			    name = arguments[0][0][arguments[0][0].length - 1],
			    arr = [],
			    arg = arguments[0][0];
			var parent_type = parent[name];
			if (typeof parent_type == "function") {
				delete arg[arg.length - 1];
				for (var key in arg) {
					if (arg.hasOwnProperty(key)) {
						arr.push(arg[key]);
					}
				}
				return parent_type.apply(parent, arr);
			}
			if (parent_type) {
				return parent_type;
			}
		},
		extendModel: function extendModel(extend, mdl) {
			var scp = mdl || this;
			if (!extend || !store.model[extend]) {
				return;
			}
			var parentFields = Object.assign({}, store.model[extend].fieldList);
			for (var key in parentFields) {
				if (parentFields[key].type == "relation") {
					delete parentFields[key];
				}
			}
			var pkObj = {};
			var extendParentPks = scp._pK == "id" && scp.fieldList.id.defined == false ? true : false;
			for (var key in parentFields) {
				var fld = parentFields[key];
				var custPk = extendParentPks && fld.primaryKey && fld.defined != false;
				if (scp.fieldList.hasOwnProperty(key) && scp._fldGrps) {
					var oldField = scp.fieldList[key];
					if (oldField.hasOwnProperty("default")) {
						delete scp._fldGrps.default[key];
					}
					if (oldField.hasOwnProperty("watch")) {
						delete scp._fldGrps.watch[key];
					}
				}
				if (fld.hasOwnProperty("default")) {
					scp._fldGrps.default[key] = fld;
				}
				if (fld.hasOwnProperty("watch") && fld.watch == true && /^(array|object)$/.test(fld.type)) {
					scp._fldGrps.watch[key] = fld;
				}
				if (!fld.primaryKey) {
					scp.fieldList[key] = fld;
				} else {
					pkObj[key] = fld;
				}
			}
			var pkObjKeys = Object.keys(pkObj),
			    pkObjLen = pkObjKeys.length;
			if (extendParentPks && pkObjLen) {
				delete scp.fieldList.id;
				for (var key in pkObj) {
					scp.fieldList[key] = pkObj[key];
				}
				if (pkObjLen == 1) {
					scp._pK = pkObjKeys[0];
					scp._arrPk = Array.from(pkObjKeys);
				} else {
					scp.isComp = true;
					scp._arrPk = Array.from(pkObjKeys);
					scp._pK = scp._arrPk.toString();
				}
			}
			var name = scp._name;
			store.model[name].extend = extend;
			store.model[extend].extendedBy = store.model[extend].extendedBy || {};
			store.model[extend].extendedBy[name] = true;
			// if(!store.adapter[name] && store.adapter[extend]){
			// 	store.adapter[name] = store.adapter[extend];
			// }
			// if(!store.serializer[name] && store.serializer[extend]){
			// 	store.serializer[name] = store.serializer[extend];
			// }
			if (store.model[extend].actions) {
				var actions = scp.actions = scp.actions || {};
				for (var key in store.model[extend].actions) {
					if (!actions.hasOwnProperty(key)) {
						actions[key] = store.model[extend].actions[key];
					}
				}
			}
		},
		demoLishObserverBindings: function demoLishObserverBindings(obj, prop, record) {
			if (!record) {
				record = obj;
			}
			for (key in prop) {
				if (obj[key] instanceof Object) {
					if (record && obj[key]._setterScope) {
						var ind = obj[key]._setterScope.indexOf(record);
						ind != -1 ? obj[key]._setterScope.splice(ind, 1) : undefined;
					}
					if (Object.keys(prop[key]).length) {
						this.demoLishObserverBindings(obj[key], prop[key], obj);
					}
				}
				if (obj._setterScope && obj != record) {
					var inx = obj._setterScope.indexOf(record);
					inx != -1 ? obj._setterScope.splice(inx, 1) : undefined;
				}
			}
		},
		establishObserverBindings: function establishObserverBindings(obj, prop, record) {
			if (!record) {
				record = obj;
			}
			for (key in prop) {
				if (obj[key] instanceof Object) {
					if (!obj[key]._bindings) {
						store.$.defProp(obj[key], '_bindings', new Set(), false, true);
					}
					if (record && !obj[key]._setterScope) {
						store.$.defProp(obj[key], '_setterScope', []);
					}
					var ind = obj[key]._setterScope.indexOf(record);
					ind == -1 ? obj[key]._setterScope.push(record) : undefined;
					obj[key]._bindings.add(prop[key]);
					if (Object.keys(prop[key]).length) {
						this.establishObserverBindings(obj[key], prop[key], obj);
					}
				}
				if (!obj._setterScope) {
					store.$.defProp(obj, '_setterScope', []);
					obj._setterScope.push(obj);
				}
			}
		},
		setData: function setData(self, attr, value, opts, redoObj, ignoreChange, inherit) {
			var toEmit = { emit: false, attr: [], oldRec: {} };
			var model = self.model,
			    _estObsBind = false,
			    record = self.record,
			    attrData;
			if (inherit && attr) {
				var mfl = self.model._fldGrps.inherit;
				for (var v in mfl) {
					if (self.record[mfl[v].relKey] && attr[mfl[v].relKey]) {
						if (mfl[v].relType == "belongsTo") {
							self.model._arrPk.forEach(function (_key) {
								delete attr[mfl[v].relKey][_key];
							});
							this.setData(self.record[mfl[v].relKey].$, attr[mfl[v].relKey], undefined, undefined, undefined, ignoreChange, true);
						} else {
							var len = attr[mfl[v].relKey].length;
							for (var j = len - 1; j >= 0; j--) {
								self.model._arrPk.forEach(function (_key) {
									delete attr[mfl[v].relKey][j][_key];
								});
								this.setData(self.record[mfl[v].relKey][j].$, attr[mfl[v].relKey][j], undefined, undefined, undefined, ignoreChange, true);
							}
						}
						delete attr[mfl[v].relKey];
					}
				}
			}
			if (attr && (typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === "object") {
				attrData = [];
				opts = value;
				for (var key in attr) {
					attrData.push(key);
					this.setValue(self, key, attr[key], opts, toEmit, ignoreChange);
					model && model._properties && model._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
				}
			} else {
				attrData = attr;
				this.setValue(self, attr, value, opts, toEmit, ignoreChange);
				model && model._properties && model._properties.hasOwnProperty(attr) ? _estObsBind = true : undefined;
			}
			self.emit("set", [self.record, attrData]);
			self.model.emit("set", [model._name, self.record, attrData]);
			store.emit("set", [model._name, self.record, attrData]);
			if (_estObsBind) {
				store.$.establishObserverBindings(record, model._properties);
			}
			if (!ignoreChange && toEmit.emit) {
				store.$.changeCallbck(record, toEmit, redoObj);
			}
			return record;
		},
		changeCallbck: function changeCallbck(record, toEmit, redoObj) {
			var arr = [record, toEmit.attr];
			var self = record.$;
			self.emit("change", arr);
			self.model.emit("change", arr);
			store.emit("change", [self.model._name, self.record, toEmit.attr]);
			if (redoObj) {
				for (var key in toEmit.oldRec) {
					redoObj[key] = toEmit.oldRec[key];
				}
			} else {
				for (var index = 0; index < toEmit.attr.length; index++) {
					var key = toEmit.attr[index];
					self.undoStack[key] = self.undoStack[key] || [];
					self.undoStack[key].push(toEmit.oldRec[key]);
				}
				// self.undoStack._order_ = self.undoStack._order_ || store.$.defProp(self.undoStack, "_order_", [], false, true);
				self.undoStack._order_.push(toEmit.attr);
			}
		},
		setValue: function setValue(self, attr, value, opts, toEmit, ignoreChange, deepChange) {
			var model = self.model,
			    oldAttrVal,
			    hasAttr,
			    pK = model._pK,
			    record = self.record;
			if (attr != model._pK) {
				var field = model.fieldList[attr],
				    watch = field && field.opts ? field.opts.watch == true : undefined;
				var hasAttr = record.hasOwnProperty(attr),
				    oldAttrVal = record[attr];
				if (!field) {
					store.$.cmpSet(record, attr, value, undefined, true);
					return;
				} else if (field.mandatory && (value == undefined || value == null || value === "")) {
					store.$.setRecErr(self, attr, { code: "ERR02", message: Lyte.errorCodes.ERR02, value: value });
				} else if (field.relType) {
					var relType = field.relType;
					var rel = {},
					    relRec,
					    oldVal,
					    relMod = store.modelFor(field.relatedTo),
					    bModel = relMod,
					    bPk = bModel._pK,
					    relPk = relMod._pK,
					    isComp = relMod.isComp,
					    bPkType = isComp ? "object" : relMod.fieldList[bPk].type,
					    relRec;
					var isComp = relMod.isComp,
					    bPk = relMod._pK,
					    bPkType = isComp ? "object" : relMod.fieldList[bPk].type,
					    isPoly = field && field.opts ? field.opts.polymorphic : undefined;
					this.getRelations(model, field.relKey, relMod, rel);
					if (record[attr] && relType == "hasMany") {
						oldVal = [];
						record[attr].forEach(function (item) {
							oldVal.push(item.$.pK);
						});
						if (record[attr] === value) {
							return;
						}
						if (Array.isArray(value) && value.length === record[attr].length) {
							var valLen = value.length,
							    j = 0,
							    val;
							for (var i = 0; i < valLen; i++) {
								val = value[i];
								if (Lyte.isRecord(val)) {
									relRec = val;
								} else {
									if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == bPkType) {
										relRec = store.peekRecord(val._type ? val._type : field.relatedTo, val);
									}
								}
								if (Lyte.isRecord(relRec) && relRec === record[attr][i]) {
									j++;
								} else {
									break;
								}
							}
							if (j && j == valLen) {
								return;
							}
						}
						// oldVal = record[attr].slice(0);
						// oldVal1 = record[attr].mapBy(relMod._pK);
						store.$.addOnSave(model._name, record, attr, field, pK, relPk);
						var relData = Array.from(record[attr]);
						relData.forEach(function (rec) {
							store.$.demolishLink(rec, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
							if (rel.backward !== null) {
								store.$.demolishLink(record, model._pK, rec, rel.backward.relKey, rel.forward);
							}
						});
						// // record[attr].splice(0, record[attr].length);
						// if(Array.isArray(record[attr]) && record[attr].length){
						// 	this.handleArrOp(record[attr], "removeAt", undefined, 0, record[attr].length);
						// }
					} else if (record[attr] && Lyte.isRecord(record[attr]) && relType == "belongsTo") {
						oldVal = record[attr].$.pK;
						if (Lyte.isRecord(value)) {
							relRec = value;
						} else {
							if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == bPkType) {
								relRec = store.peekRecord(value._type ? value._type : field.relatedTo, value);
							}
						}
						if (Lyte.isRecord(relRec) && relRec === record[attr]) {
							return;
						}
						// oldVal = this.createCopy(record[attr]);
						store.$.addOnSave(model._name, record, attr, field, pK, relPk);
						// oldVal1 = record[attr][relMod._pK];
						var relRef = record[attr];
						store.$.demolishLink(relRef, relPk, record, rel.forward.relKey, undefined, undefined, undefined, true);
						if (rel.backward !== null) {
							store.$.demolishLink(record, model._pK, relRef, rel.backward.relKey, rel.forward);
						}
						// record[attr] = undefined;
						store.$.cmpSet(record, attr, {}, opts, true);
					}
					if (relType == "hasMany" && store.$.isEmpty(value)) {
						var partial = record[attr] && record[attr].partial ? record[attr].partial : undefined;
						store.$.cmpSet(record, attr, [], opts, true);
						partial ? store.$.defProp(record[attr], "partial", partial) : undefined;
						store.$.establishObserverBindings(record, record.$.model._properties);
						store.$.defArrUtls(record[attr]);
						store.$.defPolyUtls(record[attr]);
						store.$.defUtls(record[attr], relMod, record, attr);
					}
					if (!Array.isArray(value)) {
						value = [value];
					} else if (relType == "belongsTo") {
						this.revertToOldVal(record, attr, oldVal, rel);
						store.$.setRecErr(self, attr, "ERR21", value);
						return;
					}
					var err = [];
					for (var i = 0; i < value.length; i++) {
						if (this.isEmpty(value[i]) || relType == "belongsTo" && this.isEmptyObj(value[i]) || relType == "hasMany" && this.isEmptyArray(value[i])) {
							continue;
						}
						var relRecord = value[i],
						    relMod1 = value[i] && value[i]._type ? value[i]._type : field.relatedTo;
						if (!isComp && value[i] && _typeof(value[i]) === bPkType) {
							relRecord = store.peekRecord(value[i]._type ? value[i]._type : field.relatedTo, value[i]);
							if (relRecord == undefined) {
								this.addToRelate(model._name, record, rel, value[i]);
							} else if (relRecord.$ && relRecord.$.isError) {
								err.push({ code: "ERR15", message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
								continue;
							}
						} else if (value[i] && _typeof(value[i]) == "object") {
							if (relRecord.$ && relRecord.$.isError) {
								err.push({ code: "ERR15", message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
								continue;
							} else if (!Lyte.isRecord(relRecord)) {
								if (isPoly && value[i] && value[i]._type) {
									relRecord = store.peekRecord(value[i]._type, store.$.getpKVal(value[i], store.modelFor(value[i]._type)));
								} else if (isComp) {
									relRecord = store.peekRecord(value[i]._type ? value[i]._type : field.relatedTo, value[i]);
									if (!relRecord) {
										relRecord = this.newRecord(relMod1, value[i], opts ? opts.skipValidation : undefined);
									}
								} else {
									relRecord = this.newRecord(relMod1, value[i], opts ? opts.skipValidation : undefined);
								}
								if (relRecord.$.isError) {
									err.push({ code: "ERR15", data: value[i], message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
									continue;
								}
							}
						}
						var changed = this.establishLink(rel.forward, rel.backward, record, relRecord, undefined, ignoreChange ? true : undefined);
						if (changed != true) {
							err.push({ code: changed, data: value[i], message: Lyte.errorCodes[changed] });
						} else {
							store.$.addOnSave(model._name, record, attr, field, pK, relPk);
						}
					}
					if (err.length && err.length == value.length) {
						this.revertToOldVal(record, attr, oldVal, rel);
						if (field.relType == "belongsTo") {
							store.$.setRecErr(self, attr, err[0]);
						} else {
							store.$.setRecErr(self, attr, err);
						}
						return;
					} else {
						if (err.length > 1) {
							store.$.setRecErr(self, attr, err);
						} else {
							store.$.clrRecErr(self, attr);
						}
						if (!ignoreChange) {
							var _attrs = record.$._attributes;
							if (!_attrs.hasOwnProperty(attr)) {
								_attrs[attr] = [];
							}
							_attrs[attr].push({ _type: "changed", records: oldVal });
							toEmit.emit = true;
							toEmit.attr.push(attr);
							var obj = {};obj.records = oldVal;obj._type = "update";
							toEmit.oldRec[attr] = obj;
							var arr = record.$.getInitialValues(attr),
							    changed = true;
							if (arr && Array.isArray(record[attr]) && arr.length == record[attr].length) {
								changed = false;
								for (var i = 0; i < arr.length; i++) {
									if (!store.$.comparePk(record[attr][i], arr[i])) {
										changed = true;
										break;
									}
								}
							}
							if (!changed) {
								delete _attrs[attr];
							}
						}
					}
				} else {
					if (value !== record[attr]) {
						// if(field && field.type !== Lyte.getDataType(value) && (value !== undefined  || field.type === "boolean")) {
						// 	value = Lyte.typeCast(value, field.type);
						// }
						if (!opts || opts && opts.skipValidation !== true) {
							var _field = field;
							if (!(_field.any && Array.isArray(_field))) {
								_field = [_field];
							}
							var fldLen = _field.length,
							    _ret = true;
							for (var i = 0; i < fldLen; i++) {
								var _fld = _field[i];
								for (var property in _fld) {
									var resp = Lyte.checkProperty(property, value, attr, _fld[property], _fld, record, undefined, model._name);
									if (resp !== true) {
										if (_ret === true) {
											if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) == "object") {
												resp.value = value;
											}
											_ret = resp;
										}
									}
								}
							}
							if (_ret !== true) {
								store.$.setRecErr(self, attr, _ret);
								return;
							}
						}
						if (!ignoreChange) {
							store.$.estAttrs(record, attr, value, toEmit, deepChange, opts);
						} else {
							var customDtype = false;
							if (Lyte.Transform[field.type]) {
								var customDatatype = Lyte.Transform[field.type];
								if (customDatatype.hasOwnProperty("properties") || customDatatype.hasOwnProperty("items")) {
									customDtype = true;
								}
							}
							if (watch && /^(array|object)$/.test(field.type) || customDtype) {
								Lyte.establishObjectBinding(record, attr, true);
							}
							store.$.cmpSet(record, attr, value, opts, true);
						}
					} else if (value === record[attr] && record.$.isError && record.$.error[attr]) {
						var valid = true,
						    _field = field;
						if (!(_field.any && Array.isArray(_field))) {
							_field = [_field];
						}
						var fldLen = _field.length,
						    _ret = true;
						for (var i = 0; i < fldLen; i++) {
							var _fld = _field[i];
							for (var property in _fld) {
								var resp = Lyte.checkProperty(property, value, attr, _fld[property], _fld, record, undefined, model._name);
								if (resp !== true) {
									_ret = false;
								}
							}
						}
						if (_ret !== true) {
							valid = false;
						}
						if (valid) {
							store.$.clrRecErr(self, attr);
						}
					}
				}
				store.$.checkAttrs(record);
			} else {
				if (record[attr] !== value) {
					store.$.setRecErr(self, attr, "ERR01", value);
				}
			}
		},
		estAttrs: function estAttrs(record, attr, value, toEmit, deepChange, opts) {
			var _attrs = record.$._attributes;
			var model = record.$.model;
			var attribute = _attrs[attr];
			var isAttrPres = _attrs.hasOwnProperty(attr);
			if (!isAttrPres) {
				_attrs[attr] = deepChange ? deepChange.data : this.createCopy(record[attr]);
			} else if (deepChange && Lyte.cmpData(isAttrPres ? attribute : deepChange.data, record[attr]) || value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == "object" && !deepChange && store.adapter.$.compareObjects(attribute, value) || attribute == value) {
				delete _attrs[attr];
			}
			var hasAttr = record.hasOwnProperty(attr);
			var oldAttrVal = deepChange ? deepChange.data : record[attr];
			if (!deepChange) {
				var isPropPresent = model._properties && model._properties.hasOwnProperty(attr),
				    propObj = {};
				if (isPropPresent) {
					propObj[attr] = model._properties[attr];
					store.$.demoLishObserverBindings(record, propObj);
				}
				store.$.cmpSet(record, attr, value, opts, true);
			}
			store.$.clrRecErr(record.$, attr);
			if (record.$.srtObs) {
				store.$.changeRelPkMaps(record, undefined, undefined, "sort", attr);
			}
			var obj = {};
			obj._type = "update";
			obj.val = oldAttrVal;
			if (!hasAttr) {
				obj._type = "propAdd";
			}
			toEmit.emit = true;
			toEmit.attr.push(attr);
			toEmit.oldRec[attr] = obj;
		},
		checkAttrs: function checkAttrs(record) {
			var model = record.$.model;
			if (Object.keys(record.$._attributes).length) {
				store.$.cmpSet(record.$, "isModified", true);
				store.$.changePersist(record, false);
				store.$.addDeepNest(record);
				this.checkAndAddToArray(model.dirty, record.$.pK);
			} else {
				store.$.cmpSet(record.$, "isModified", false);
				store.$.changePersist(record, true);
				if (!record.$.isNew && (!record.$.hasOwnProperty("dN") || record.$.dN && !Object.keys(record.$.dN).length)) {
					store.$.removeParentNesting(record);
				}
				if (!record.$.isNew) {
					this.deleteFromArray(model.dirty, record.$.pK);
				}
			}
		},
		checkForCorrectRelation: function checkForCorrectRelation(rel, record) {
			var relatedTo = rel.relatedTo;
			if (!Lyte.isRecord(record)) {
				return false;
			}
			if (rel.opts && rel.opts.polymorphic) {
				return record.$.model.extend ? rel.relatedTo === record.$.model.extend : false;
			}
			return rel && record ? relatedTo === record.$.model._name : false;
		},
		removeKeys: function removeKeys(fieldList, record) {
			for (var key in record) {
				if (!fieldList.hasOwnProperty(key)) {
					delete record[key];
				} else {
					var field = fieldList[key];
					if (field.type === "belongsTo" || field.type === "hasMany" && record[key]) {
						this.removeNotDefinedKeys(field.relatedTo, record[key], field.opts && field.opts.polymorphic ? true : undefined);
					}
				}
			}
		},
		removeNotDefinedKeys: function removeNotDefinedKeys(model, records, polymorphic) {
			var fieldList = model.fieldList;
			if (Array.isArray(records)) {
				for (var i = 0; i < records.length; i++) {
					var record = records[i];
					this.removeKeys(polymorphic ? Lyte.isRecord(record) ? record.$.model.fieldList : fieldList : fieldList, record);
				}
			} else {
				this.removeKeys(polymorphic ? Lyte.isRecord(records) ? records.$.model.fieldList : fieldList : fieldList, records);
			}
		},
		add: function add(value, type, opts, redoObj) {
			var record = this.record,
			    model = record.$.model,
			    attr = this.key,
			    field = model.fieldList[attr],
			    rel = {};
			var oldArr;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			if (!Array.isArray(value)) {
				value = [value];
			}
			var relMod = store.modelFor(rel.forward.relatedTo);
			var pK = relMod._pK,
			    err = [],
			    arr = [],
			    isComp = relMod.isComp;
			if (record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length) {
				oldArr = record.$.getInitialValues(attr);
			}
			for (var i = 0; i < value.length; i++) {
				var rec = value[i];
				if (isComp) {
					if ((typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && Object.keys(rec).length === relMod._arrPk.length) {
						if (this.polymorphic && !type) {
							err.push({ code: "ERR22", data: value[i], message: Lyte.errorCodes.ERR22 });
							continue;
						}
						rec = store.peekRecord(type ? type : rel.forward.relatedTo, rec);
					}
				}
				if (!isComp && relMod.fieldList[pK].type.toLowerCase() == (typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) || isComp && (typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && Object.keys(rec).length === relMod._arrPk.length) {
					if (this.polymorphic && !type) {
						err.push({ code: "ERR22", data: value[i], message: Lyte.errorCodes.ERR22 });
						continue;
					}
					rec = store.peekRecord(type ? type : rel.forward.relatedTo, rec);
				} else if ((typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && !Lyte.isRecord(rec)) {
					rec = store.$.newRecord(rec._type ? rec._type : type ? type : field.relatedTo, rec, opts ? opts.skipValidation : undefined);
				}
				var polyType = this.polymorphic && type ? type : rec && rec._type ? rec._type : undefined;
				if (rec == undefined) {
					err.push({ code: "ERR13", data: value[i], message: Lyte.errorCodes.ERR13 });
				} else if (rec.$ && rec.$.isError) {
					err.push({ code: "ERR15", data: value[i], message: Lyte.errorCodes.ERR15, error: rec });
				} else if (Lyte.isRecord(rec) && !store.$.hasDuplicateRelation(rec, record[attr], pK, polyType, relMod)) {
					var resp = store.$.establishLink(rel.forward, rel.backward, record, rec);
					if (resp != true) {
						err.push({ code: resp, data: value[i], message: Lyte.errorCodes[resp] });
					} else {
						arr.push(rec);
					}
				}
			}
			if (arr.length) {
				var _attrs = record.$._attributes;
				if (!_attrs[attr]) {
					_attrs[attr] = [{ _type: "added", records: arr }];
					store.$.cmpSet(record.$, "isModified", true);
					store.$.changePersist(record, false);
					// record.$.isModified = true;
					store.$.checkAndAddToArray(model.dirty, record[model._pK]);
				} else if (store.$.hasRecordsArrayChanged(record, attr, oldArr)) {
					_attrs[attr].push({ _type: "added", records: arr });
				} else {
					delete record.$._attributes[attr];
					if (!Object.keys(record.$._attributes).length) {
						store.$.cmpSet(record.$, "isModified", false);
						store.$.changePersist(record, true);

						// record.$.isModified = false;
						delete _attrs[attr];
						if (!record.$.isNew) {
							store.$.deleteFromArray(model.dirty, record.$.pK);
							if (!record.$.dN || record.$.dN && !Object.keys(record.$.dN).length) {
								store.$.removeParentNesting(record);
							}
						}
					}
				}
				store.$.emit("change", record, [attr]);
				var obj = { _type: "added", records: arr };
				if (redoObj) {
					redoObj[attr] = obj;
				} else {
					var stackObj = {};
					stackObj[attr] = obj;
					record.$.undoStack[attr] = record.$.undoStack[attr] || [];
					record.$.undoStack[attr].push(obj);
					// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
					record.$.undoStack._order_.push([attr]);
				}
			}
			if (err.length > 0) {
				store.$.setRecErr(record.$, attr, err);
			} else {
				store.$.clrRecErr(record.$, attr);
			}
			return record;
		},
		remove: function remove(key, type, redoObj) {
			var record = this.record,
			    model = record.$.model,
			    attr = this.key,
			    field = model.fieldList[attr],
			    rel = {};
			var oldArr;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			if (!Array.isArray(key)) {
				key = [key];
			}
			var relMod = store.modelFor(rel.forward.relatedTo);
			var pK = relMod._pK,
			    isComp = relMod.isComp,
			    err = [],
			    relatedRecord,
			    arr = [],
			    indices = [];
			if (record.$._attributes.hasOwnProperty(attr) && record.$._attributes[attr].length) {
				oldArr = record.$.getInitialValues(attr);
			}
			for (var i = 0; i < key.length; i++) {
				var rec = key[i],
				    polyType;
				if (!isComp && relMod.fieldList[pK].type.toLowerCase() == _typeof(key[i]) || isComp && (typeof rec === 'undefined' ? 'undefined' : _typeof(rec)) == "object" && Object.keys(rec).length === relMod._arrPk.length) {
					if (this.polymorphic == true && !type) {
						err.push({ code: "ERR22", data: key[i], message: Lyte.errorCodes.ERR22 });
						continue;
					}
					relatedRecord = store.peekRecord(type ? type : rel.forward.relatedTo, key[i]);
					polyType = type;
				} else if (Lyte.isRecord(key[i])) {
					relatedRecord = key[i];
					polyType = type ? type : relatedRecord && relatedRecord._type ? relatedRecord._type : undefined;
				}
				if (relatedRecord) {
					var index = store.$.getIndex(record[attr], pK, relatedRecord.$.get(pK), polyType);
					store.$.demolishLink(relatedRecord, pK, store.peekRecord(model._name, record.$.pK), rel.forward.relKey, undefined, undefined, undefined, true);
					if (rel.backward != null) {
						store.$.demolishLink(record, model._pK, store.peekRecord(polyType ? polyType : rel.forward.relatedTo, relatedRecord.$.pK), rel.backward.relKey, rel.forward);
					}
					arr.push(relatedRecord);
					indices.push(index);
				}
			}
			if (arr.length) {
				var _attrs = record.$._attributes;
				if (!_attrs[attr]) {
					_attrs[attr] = [{ _type: "removed", records: arr, _indices: indices }];
					store.$.cmpSet(record.$, "isModified", true);
					store.$.changePersist(record, false);

					// record.$.isModified = true;
					store.$.checkAndAddToArray(model.dirty, record[model._pK]);
				} else if (store.$.hasRecordsArrayChanged(record, attr, oldArr)) {
					_attrs[attr].push({ _type: "removed", records: arr, _indices: indices });
				} else {
					delete record.$._attributes[attr];
					if (!Object.keys(record.$._attributes).length) {
						store.$.cmpSet(record.$, "isModified", false);
						store.$.changePersist(record, true);

						// record.$.isModified = false;
						delete _attrs[attr];
						if (!record.$.isNew) {
							store.$.deleteFromArray(model.dirty, record.$.pK);
							if (!record.$.dN || record.$.dN && !Object.keys(record.$.dN).length) {
								store.$.removeParentNesting(record);
							}
						}
					}
				}
				store.$.emit("change", record, [attr]);
				var obj = { _type: "removed", records: arr, _indices: indices };
				if (redoObj) {
					redoObj[attr] = obj;
				} else {
					var stackObj = {};
					stackObj[attr] = obj;
					// record.$.undoStack.push(stackObj);
					record.$.undoStack[attr] = record.$.undoStack[attr] || [];
					record.$.undoStack[attr].push(obj);
					// record.$.undoStack._order_ = record.$.undoStack._order_ || [];
					record.$.undoStack._order_.push([attr]);
				}
			}
			if (err.length > 0) {
				store.$.setRecErr(record.$, attr, err);
			} else {
				store.$.clrRecErr(record.$, attr);
			}
		},
		filter: function filter(record, filObj, len) {
			var j = 0;
			for (var key in filObj) {
				if (record[key] === filObj[key]) {
					j++;
				}
			}
			if (j === len) {
				return true;
			}
		},
		filterBy: function filterBy(obj) {
			var len = Object.keys(obj).length,
			    j = 0,
			    arr = [];
			for (var i = 0; i < this.length; i++) {
				if (store.$.filter(this[i], obj, len)) {
					arr.push(this[i]);
				}
			}
			if (!arr.filterBy) {
				store.$.defArrUtls(arr);
				store.$.defUtls(arr, this.model);
			}
			return arr;
		},
		idbSerialize: function idbSerialize(data, rel, model, bModel, pkVal, expose) {
			var relTo = rel.forward.relatedTo,
			    pK = model._pK,
			    bPk = bModel._pK;
			if (Array.isArray(data)) {
				data.forEach(function (item, index) {
					if (Lyte.isRecord(item) && item.$.inIDB) {
						data[index] = item[bPk];
					} else if (!store.$.checkPresenceInArray(store.$.recStack[relTo], item[bPk])) {
						store.$.removeBackwardRel(item, rel, pK, pkVal, true);
						store.$.removeSelfCircularReference(bModel._name, item, expose);
					} else {
						data[index] = item[bPk];
					}
				});
			} else if (data && Lyte.isRecord(data)) {
				if (Lyte.isRecord(data) && data.$.inIDB) {
					data[rel.relKey] = data[bPk];
				} else if (!this.checkPresenceInArray(store.$.recStack[relTo], data[bPk])) {
					this.removeBackwardRel(data, rel, pK, pkVal, true);
					this.removeSelfCircularReference(bModel._name, data, expose);
				} else {
					data[rel.relKey] = data[bPk];
				}
			}
		},
		idSerialize: function idSerialize(obj, rel, expose, partialObj, partialRef) {
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined,
			    relKey = rel.forward.relKey,
			    relKey = rel.forward.relKey;
			var data = obj[relKey],
			    model = store.model[rel.backward.relatedTo],
			    bModel = store.model[rel.forward.relatedTo],
			    pkVal = store.$.getpKVal(obj, model),
			    modName;
			if (Array.isArray(data)) {
				if (polymorphic) {
					obj[relKey] = this.polymorphicToJSON(rel.forward, data);
				} else {
					var arr = [];
					if (partialObj) {
						var partial = partialObj[relKey] = partialObj[relKey] || [],
						    anyNew = false;
					}
					data.forEach(function (item) {
						if (item.$ && item.$.isNew && expose != true && expose != "state") {
							anyNew = true;
							store.$.rSerialize(item, rel, bModel, model._pK, pkVal, expose, partial, partialRef);
							arr.push(item);
						} else {
							if (partial) {
								var pObj = {},
								    pType = "related";
								if (item.$.isDeleted) {
									pType = "removed";
								}
								store.$.defProp(pObj, "$", {});
								var nPartial = pObj.$,
								    nModel = rel.forward.relatedTo;
								Object.defineProperties(nPartial, {
									pkVal: {
										value: item.$.pK
									},
									type: {
										value: pType
									},
									model: {
										value: nModel
									},
									record: {
										value: store.peekRecord(nModel, item.$.pK)
									}
								});
								if (item.$.isDeleted) {
									pObj.$.onlyDetach = true;
								}
								partial.push(pObj);
							}
							if (item.$ && !item.$.isDeleted) {
								arr.push(item.$.pK && _typeof(item.$.pK) == "object" ? Object.assign({}, item.$.pK) : item.$.pK);
							}
						}
					});
					obj[relKey] = arr;
				}
			} else if (data && Lyte.isRecord(data)) {
				if (data.$.isNew && expose != true && expose != "state") {
					if (partialObj) {
						var partial = partialObj[relKey] = partialObj[relKey] || {};
					}
					partial = store.$.rSerialize(data, rel, bModel, model._pK, pkVal, expose, partial, partialRef);
					partialObj[relKey] = partial;
				} else {
					if (polymorphic) {
						obj[relKey] = this.polymorphicToJSON(rel.forward, data);
					} else if (!data.$.isDeleted) {
						obj[relKey] = data.$.pK && _typeof(data.$.pK) == "object" ? Object.assign({}, data.$.pK) : data.$.pK;
					}
				}
			}
		},
		recordSerialize: function recordSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef) {
			var pK = model._pK;
			if (Array.isArray(val)) {
				if (val.length == 0) {
					delete obj[key];
					return 0;
				}
				val = Array.from(val);
				var partial = partialObj[key] = partialObj[key] || [];
				if (val.length) {
					var toRem = [];
					for (var j = 0; j < val.length; j++) {
						if (val[j] && Lyte.isRecord(val[j])) {
							// if(val[j].$.isDeleted){
							// 	toRem.push(j);
							// }
							// else{
							this.rSerialize(val[j], rel, bModel, pK, pkVal, expose, partial, partialRef);
							// }
							if (val[j].$.isDeleted) {
								partial[j] && partial[j].$ ? partial[j].$.onlyDetach = true : undefined;
								val.splice(j, 1);
								j--;
							}
						}
					}
					if (toRem.length) {
						for (var k = 0; k < toRem.length; k++) {
							val.splice(k, 1);
						}
					}
				}
			} else if (val && Lyte.isRecord(val)) {
				var partial = partialObj[key] = partialObj[key] || {};
				partial = this.rSerialize(val, rel, bModel, pK, pkVal, expose, partial, partialRef);
				// if(val.$.isDeleted){
				// 	debugger
				// }
				partialObj[key] = partial;
			}
		},
		rSerialize: function rSerialize(data, rel, bModel, pK, pkVal, expose, partialObj, partialRef) {
			var relTo = rel.forward.relatedTo,
			    partial,
			    model = store.model[rel.backward.relatedTo];
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			this.removeBackwardRel(data, rel, pK, pkVal);
			if (partialObj) {
				var partial = {};
				var pType = data.$.isNew ? "added" : data.$.isModified ? "modified" : data.$.isDeleted ? "removed" : "related",
				    modName;
				if (polymorphic) {
					modName = data.$.model._name;
					data.$.polymorphicType = modName;
					bModel = store.model[modName];
				}
				store.$.defProp(partial, "$", {});
				var nPartial = partial.$;
				var nModel = polymorphic ? modName : relTo;
				Object.defineProperties(nPartial, {
					pkVal: {
						value: data.$.pK
					},
					type: {
						value: pType
					},
					model: {
						value: nModel
					},
					record: {
						value: store.peekRecord(nModel, data.$.pK)
					}
				});
				if (Array.isArray(partialObj)) {
					partialObj.push(partial);
				}
			}
			this.removeSelfCircularReference(bModel._name, data, expose, undefined, partial, partialRef);
			return partial;
		},
		partialSerialize: function partialSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef) {
			var field = rel.forward,
			    pK = model._pK,
			    relTo = rel.forward.relatedTo;
			var polymorphic = rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			if (field.relType == "hasMany") {
				if (val && val.partial) {
					var part = val.partial;
					var bpK = bModel._pK;
					if (partialObj) {
						partial = partialObj[key] = partialObj[key] || [];
						store.$.defProp(partial, "partial", true);
					}
					if (part) {
						var pObj,
						    pKey,
						    newPartial,
						    result = [],
						    self = this;
						part.forEach(function (value, partKey) {
							pObj = value, pKey = partKey, newPartial;
							if (/^(added|modified)$/.test(pObj.type)) {
								var pType = "related";
								var ind = store.$.getIndex(val, bpK, pKey, undefined, store.model[relTo]);
								if (ind != -1) {
									var rec = val[ind],
									    updVal,
									    rec$;
									if (rec && rec.$) {
										rec$ = Object.assign({}, rec.$);
										rec = Object.assign({}, rec);
										store.$.defProp(rec, '$', rec$);
									}
									updVal = rec;
									var polyType;
									if (polymorphic && rec) {
										polyType = rec._type ? rec._type : rec.$.model._name;
										bModel = store.model[polyType];
									}
									var record = store.peekRecord(bModel._name, pKey);
									self.removeBackwardRel(rec, rel, pK, pkVal);
									if (rec.$.isNew) {
										pType = "added";
									} else if (rec.$.isModified) {
										pType = "modified";
										var valDir = store.$.isDirty(record, bModel.relations);
										updVal = store.$.updateJSON(rec, bModel, valDir);
									} else {
										var valDir = store.$.isDirty(record, bModel.relations);
										updVal = store.$.updateJSON(rec, bModel, valDir);
									}
									if (partial) {
										var newPart = {};
										store.$.defProp(newPart, "$", {});
										var newPart$ = newPart.$;
										var newPartModel = polymorphic ? polyType : relTo;
										Object.defineProperties(newPart$, {
											pkVal: {
												value: pKey
											},
											type: {
												value: pType
											},
											model: {
												value: polymorphic ? polyType : relTo
											},
											record: {
												value: store.peekRecord(newPartModel, pKey)
											}
										});
										// if(partialRef){
										// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
										// 	updVal[refKey] = refId;
										// 	partialRef.set(refId, newPart);
										// }
										partial.push(newPart);
									}
									self.removeSelfCircularReference(bModel._name, updVal, expose, undefined, newPart, partialRef);
									// var resObj = {type: pObj.type, data: updVal};
									if (Lyte.isRecord(updVal)) {
										updVal.$.partialType = pObj.type;
									} else {
										store.$.defProp(updVal, "$", {});
										store.$.defProp(updVal.$, "partialType", pObj.type);
										if (!updVal.$.hasOwnProperty("pK")) {
											store.$.defProp(updVal.$, "pK", pKey);
										}
									}
									if (polymorphic) {
										updVal.$.polymorphicType = polyType;
									}
									result.push(updVal);
								}
							} else if (pObj.type == "removed") {
								var dObj = {};
								if (pKey && (typeof pKey === 'undefined' ? 'undefined' : _typeof(pKey)) == "object") {
									Object.assign(dObj, Object.assign({}, pKey));
								} else {
									dObj[bpK] = pKey;
								}
								var record = store.peekRecord(bModel._name, pKey) || store.peekRecord(bModel._name, pKey, true);
								if (partial) {
									var newPart = {};
									store.$.defProp(newPart, "$", {});
									var newPart$ = newPart.$;
									Object.defineProperties(newPart$, {
										pkVal: {
											value: pKey
										},
										type: {
											value: "removed"
										},
										model: {
											value: polymorphic && pObj.polymorphicType ? pObj.polymorphicType : relTo
										},
										record: {
											value: record
										}
									});
									if (partialRef) {
										var refId = "rec" + ++partialRef.size,
										    refKey = partialRef.refKey;
										dObj[refKey] = refId;
										partialRef.set(refId, newPart);
									}
									partial.push(newPart);
								}
								store.$.defProp(dObj, "$", {});
								dObj.$.partialType = "removed";
								if (polymorphic && pObj.polymorphicType) {
									dObj.$.polymorphicType = pObj.polymorphicType;
								}
								if (!dObj.$.hasOwnProperty('pK')) {
									dObj.$.pK = pKey;
								}
								// result.push({type:"removed", data: dObj})

								result.push(dObj);
							}
						});
						if (result.length) {
							val = obj[key] = result;
						} else {
							delete obj[key];
						}
					}
				} else {
					delete obj[key];
				}
			} else if (field.relType == "belongsTo" && val && Lyte.isRecord(val)) {
				var polyType;
				if (polymorphic && val) {
					polyType = val._type ? val._type : val.$.model._name;
					bModel = store.model[polyType];
				}
				this.removeBackwardRel(val, rel, pK, pkVal);
				var updVal = val,
				    valDir;
				if (val.$.isNew) {
					this.removeBackwardRel(val, rel, pK, pkVal);
				} else {
					valDir = store.$.isDirty(val, bModel.relations);
					updVal = store.$.updateJSON(val, bModel, valDir);
				}
				if (partialObj) {
					var partial = partialObj[key] = partialObj[key] || {};
					var pType = val.$.isNew ? "added" : val.$.isModified ? "modified" : "related";
					store.$.defProp(partial, "$", {});
					var partial$ = partial.$;
					var partMod = polymorphic ? polyType : relTo;
					Object.defineProperties(partial$, {
						pkVal: {
							value: val.$.pK
						},
						type: {
							value: pType
						},
						model: {
							value: partMod
						},
						record: {
							value: store.peekRecord(partMod, val.$.pK)
						}
					});
					// if(partialRef){
					// 	var refId = "rec"+(++partialRef.size), refKey = partialRef.refKey;
					// 	updVal[refKey] = refId;
					// 	partialRef.set(refId, partial);
					// }
				}
				if (polymorphic) {
					updVal.$ || store.$.defProp(updVal, "$", {});
					updVal.$.polymorphicType = polyType;
				}
				this.removeSelfCircularReference(bModel._name, updVal, expose, undefined, partial, partialRef);
				val = obj[key] = updVal;
			}
		},
		removeSelfCircularReference: function removeSelfCircularReference(modelName, obj, expose, type, partialObj, partialRef, inherit, addNotDefinedFields) {
			var model = store.model[modelName],
			    fieldList = model.fieldList,
			    extended = model.extend ? true : false,
			    pkVal = store.$.getpKVal(obj, model);
			store.$.recStack[modelName] = store.$.recStack[modelName] || [];
			var ret = store.$.checkAndAddToArray(store.$.recStack[modelName], pkVal),
			    record = store.peekRecord(modelName, pkVal),
			    partObj = Lyte.isRecord(record) ? record.$.partial : undefined,
			    polymorphicType = obj && obj.$ ? obj.$.polymorphicType : undefined,
			    recmp = new Map(),
			    refId;
			recmp.set(obj, pkVal);
			if (partialRef) {
				refId = "rec" + ++partialRef.size;
				var refObj = {};
				store.$.defProp(refObj, "$", { pkVal: record.$.pK, model: record.$.model._name });
				partialRef.set(refId, refObj);
			}
			var unlinkedKeys = store.$.getFromCB("serializer", modelName, "serializeEmptyRelation");
			for (var key in obj) {
				var field = fieldList[key],
				    extMod,
				    swap = false,
				    relTo,
				    bModel,
				    relType,
				    relSlave;
				var removePk = (type == "create" || Lyte.isRecord(obj) && obj.$.isNew) && model._pK == key ? true : false;
				if (removePk && expose != true) {
					delete obj[key];
					continue;
				}
				if (!field) {
					if (polymorphicType) {
						extMod = store.modelFor(polymorphicType);
						field = extMod.fieldList[key];
						swap = true;
					}
					if (!addNotDefinedFields) {
						delete obj[key];
					}
					continue;
				}
				if (field && field.type != "relation" && !expose && Lyte.Transform[field.type] && Lyte.Transform[field.type].serialize && obj.hasOwnProperty(key)) {
					obj[key] = Lyte.Transform[field.type].serialize(obj[key], key, record);
					continue;
				}
				if (partObj && partObj.hasOwnProperty(key)) {
					var partPload = {},
					    bPk = store.model[field.relatedTo]._pK,
					    doCont = false;
					partObj[key].forEach(function (item, partPk) {
						if ((unlinkedKeys === true || Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey)) && field.opts && /^(id|record)$/.test(field.opts.serialize)) {
							obj[key] = null;
							doCont = true;
						} else if (field.opts.serialize == "partial") {
							partPload[bPk] = partPk;
							store.$.defProp(partPload, "$", {});
							store.$.defProp(partPload.$, "partialType", "removed");
							store.$.defProp(partPload.$, "pK", partPk);
							obj[key] = partPload;
							doCont = true;
						}
						if (partialObj) {
							var partial = partialObj[key] = partialObj[key] || {};
							store.$.defProp(partial, "$", {});
							var partial$ = partial.$;
							Object.defineProperties(partial$, {
								pkVal: {
									value: partPk
								},
								type: {
									value: "removed"
								},
								model: {
									value: field.relatedTo
								},
								parent: {
									value: record
								},
								record: {
									value: store.peekRecord(field.relatedTo, partPk)
								}
							});
							if (field && field.opts && /^(id|record)$/.test(field.opts.serialize)) {
								Object.defineProperties(partial$, {
									onlyDetach: {
										value: true
									},
									relKey: {
										value: key
									}
								});
							}
						}
					});
					if (doCont) {
						continue;
					}
				}
				if ((expose == true || expose == "state") && obj[key] && _typeof(obj[key]) == "object" && field && field.type != "relation") {
					obj[key] = Lyte.deepCopyObject(obj[key]);
					continue;
				}
				if (expose && expose.type == "isClone") {
					if (obj[key] && field && field.type == "relation") {
						relSlave = field.opts && field.opts.inherit ? true : false;
						if (!relSlave) {
							delete obj[key];
						}
					}
				}
				if (obj[key] && field && field.type == "relation") {
					relTo = field.relatedTo;
					relType = field.relType;
					relSlave = field.opts && field.opts.inherit ? true : false;
					bModel = store.modelFor(relTo);
					if (bModel == undefined) {
						continue;
					}
					var relKey = field.relKey,
					    rel = {};
					if (swap) {
						this.getRelations(extMod, field.relKey, bModel, rel);
					} else {
						this.getRelations(model, relKey, bModel, rel);
					}
					var opts = field.opts;
					var serialize = opts ? opts.serialize : undefined,
					    val = obj[relKey];
					if (expose == "idb") {
						store.$.idbSerialize(val, rel, model, bModel, pkVal, expose);
					} else if (inherit && relSlave) {
						store.$.toChildJSON(relTo, relType, obj[key], key, modelName, recmp, addNotDefinedFields);
						if (relType == "belongsTo") {
							if (obj[key][store.modelFor(relTo)._pK] == pkVal && relTo == modelName) {
								delete obj[key];
							}
							obj[key] = Object.assign({}, obj[key]);
						}
						//store.$.toChildJSON(relTo,relType,obj[key],key,modelName,recmp,modelName+"_"+pkVal);
					} else if (expose && !inherit || inherit && !relSlave || serialize == "id") {
						store.$.idSerialize(obj, rel, expose, partialObj, partialRef);
					} else if (serialize === "record") {
						var ret = store.$.recordSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef);
						if (ret == 0) {
							if (relType === "hasMany" && (unlinkedKeys === true || Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey)) && Array.isArray(record[key]) && record[key].partial && record[key].partial.size) {
								var emptyArr = true;
								record[key].partial.forEach(function (pobj) {
									if (pobj.type !== "removed") {
										emptyArr = false;
									}
								});
								if (emptyArr) {
									obj[key] = [];
									continue;
								}
							}
						}
					} else if (serialize === "partial") {
						store.$.partialSerialize(obj, key, val, rel, model, bModel, pkVal, expose, partialObj, partialRef);
					} else {
						delete obj[relKey];
						continue;
					}
					val = obj ? obj[relKey] : undefined;
					if (val && relType == "hasMany" && Array.isArray(val) && val.length == 0 || relType == "belongsTo" && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && Object.keys(val).length == 0) {
						if ((unlinkedKeys === true || Array.isArray(unlinkedKeys) && unlinkedKeys.indexOf(field.relKey)) && relType == "hasMany" && field.opts && /^(id|record)$/.test(field.opts.serialize)) {
							obj[relKey] = [];
						} else {
							delete obj[relKey];
						}
					}
				}
			}
			if (partialRef) {
				var refKey = partialRef.refKey;
				obj[refKey] = refId;
			}
		},
		removeBackwardRel: function removeBackwardRel(val, rel, pK, pkVal, wholeRelKey) {
			if (wholeRelKey) {
				delete val[rel.backward.relKey];
				return;
			}
			if (rel.backward != null) {
				var rec = val[rel.backward.relKey];
				if (Array.isArray(rec)) {
					for (var i = 0; i < rec.length; i++) {
						if (this.comparePk(rec[i], pkVal)) {
							rec.splice(i, 1);
							if (rec.length == 0) {
								delete val[rel.backward.relKey];
							}
							return;
						}
					}
				} else if (rec && Lyte.isRecord(rec) && this.comparePk(rec, pkVal)) {
					delete val[rel.backward.relKey];
				}
			}
		},
		polymorphicToJSON: function polymorphicToJSON(rel, data) {
			var opts = rel.opts;
			if (opts && opts.polymorphic) {
				if (Array.isArray(data)) {
					var res = [];
					data.forEach(function (item) {
						res.push(store.$.polyToJSON(item));
					});
					return res;
				} else {
					return store.$.polyToJSON(data);
				}
			}
		},
		polyToJSON: function polyToJSON(data) {
			var polyMod = data.$.model;
			if (!polyMod.hasOwnProperty("fieldList") && polyMod._name) {
				polyMod = store.model[polyMod._name];
			}
			var pK = polyMod ? polyMod._pK : undefined,
			    poly = {},
			    pkVal = data.$.pK;
			if ((typeof pkVal === 'undefined' ? 'undefined' : _typeof(pkVal)) == "object") {
				poly = Object.assign({}, pkVal);
			} else {
				poly[pK] = pkVal;
			}
			poly._type = data._type ? data._type : data.$.model._name;
			return poly;
		},
		toChildJSON: function toChildJSON(model, reltype, record, relKey, parent, recmp, addNotDefinedFields) {
			var mdl = store.modelFor(model),
			    mdlf = mdl.fieldList,
			    rel = {},
			    pk;
			if (!Array.isArray(record)) {
				record = [record];
			}
			for (var i = 0; i < record.length; i++) {
				if (!recmp.get(record[i])) {
					var pval = store.$.getpKVal(record[i], mdl);
					recmp.set(record[i], pval);
				}
				if (!addNotDefinedFields) {
					for (var fldKeys in record[i]) {
						if (!mdlf.hasOwnProperty(fldKeys)) {
							delete record[i][fldKeys];
						}
					}
				}
				for (var s in mdl.relations) {
					for (var j = 0; j < mdl.relations[s].length; j++) {
						var v = mdl.relations[s][j].relKey ? mdl.relations[s][j].relKey : undefined;
						if (v && mdlf[v] && mdlf[v].type == "relation" && record[i][mdlf[v].relKey]) {
							if (record[i][mdlf[v].relKey] && mdlf[v].opts && mdlf[v].opts.inherit) {
								if (mdlf[v].relType == "hasMany" && record[i][mdlf[v].relKey]) {
									for (var v1 = 0; v1 < record[i][mdlf[v].relKey].length; v1++) {
										pval = store.$.getpKVal(record[i][mdlf[v].relKey][v1], store.modelFor(mdlf[v].relatedTo));
										if (!recmp.get(record[i][mdlf[v].relKey][v1])) {
											recmp.set(record[i][mdlf[v].relKey][v1], pval);
											store.$.toChildJSON(mdlf[v].relatedTo, mdlf[v].relType, record[i][mdlf[v].relKey][v1], mdlf[v].relKey, mdlf[v].relatedTo, recmp, addNotDefinedFields);
											if (_typeof(record[i][mdlf[v].relKey][v1]) == "object") {
												record[i][mdlf[v].relKey][v1] = Object.assign({}, record[i][mdlf[v].relKey][v1]);
											}
											//store.$.toChildJSON(mdlf[v].relatedTo,mdlf[v].relType,record[i][mdlf[v].relKey][v1],mdlf[v].relKey,mdlf[v].relatedTo,recmp,str);
										} else if (Lyte.isRecord(record[i][mdlf[v].relKey][v1]) && recmp.get(record[i][mdlf[v].relKey][v1])) {
											if ((typeof pval === 'undefined' ? 'undefined' : _typeof(pval)) == "object") {
												record[i][mdlf[v].relKey][v1] = pval;
											} else {
												var robj = {};
												robj[store.modelFor(mdlf[v].relatedTo)._pK] = pval;
												record[i][mdlf[v].relKey][v1] = robj;
											}
											record[i][mdlf[v].relKey][v1] = (typeof pval === 'undefined' ? 'undefined' : _typeof(pval)) == "object" ? pval : _defineProperty({}, store.modelFor(mdlf[v].relatedTo)._pK, pval);
										}
									}
								} else if (mdlf[v].relType == "belongsTo" && record[i][mdlf[v].relKey]) {
									pval = store.$.getpKVal(record[i][mdlf[v].relKey], store.modelFor(mdlf[v].relatedTo));
									if (!recmp.get(record[i][mdlf[v].relKey])) {
										recmp.set(record[i][mdlf[v].relKey], pval);
										store.$.toChildJSON(mdlf[v].relatedTo, mdlf[v].relType, record[i][mdlf[v].relKey], mdlf[v].relKey, mdlf[v].relatedTo, recmp, addNotDefinedFields);
										record[i][mdlf[v].relKey] = Object.assign({}, record[i][mdlf[v].relKey]);
									} else {
										record[i][mdlf[v].relKey] = (typeof pval === 'undefined' ? 'undefined' : _typeof(pval)) == "object" ? pval : _defineProperty({}, store.modelFor(mdlf[v].relatedTo)._pK, pval);
									}
								}
								if (Object.keys(record[i][mdlf[v].relKey]).length == 0) {
									delete record[i][mdlf[v].relKey];
								}
							} else if (Lyte.isRecord(record[i][mdlf[v].relKey]) || mdlf[v].relType == "hasMany" && Lyte.isRecord(record[i][mdlf[v].relKey][0])) {
								this.getRelations(mdl, mdlf[v].relKey, store.modelFor(mdlf[v].relatedTo), rel);
								store.$.idSerialize(record[i], rel, true);
							}
						}
					}
				}
				if (Lyte.isRecord(record[i])) {
					record[i] = Object.assign({}, record[i]);
				}
			}
		},
		toJSONObj: function toJSONObj(model, data, expose, type, partial, inherit, addNotDefinedFields) {
			var copyObj,
			    pkVal,
			    modelName = model._name,
			    pK = model._pK;
			var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
			if ((expose == true || expose == "state") && (!inherit || inherit && !inhFldLen)) {
				copyObj = Object.assign({}, data);
			} else {
				copyObj = Lyte.deepCopyObject(data);
			}
			if (Lyte.isRecord(copyObj)) {
				pkVal = copyObj.$.pK;
			} else {
				if (store.$.getpKVal(copyObj, model)) {
					if (store.peekRecord(modelName, store.$.getpKVal(copyObj, model))) {
						pkVal = store.peekRecord(modelName, store.$.getpKVal(copyObj, model)).$.pK;
					} else {
						return;
					}
				} else {
					return;
				}
			}
			var partialObj = partial ? partial.obj : undefined,
			    partialMp;
			if (partialObj && !partialObj.has(pkVal)) {
				partialObj.set(pkVal, {});
				partialMp = partialObj.get(pkVal);
			}
			this.removeSelfCircularReference(modelName, copyObj, expose, type, partialMp, partial && partial.ref ? partial.ref : undefined, inherit, addNotDefinedFields);
			if (expose == "idb") {
				this.removeNotNeededKeys(modelName, copyObj, model.idb);
			}
			return copyObj;
		},
		toJSON: function toJSON(modelName, obj, expose, type, partialObj, inherit, addNotDefinedFields) {
			var copyObj,
			    model = store.model[modelName];
			store.$.recStack = {};
			if (Array.isArray(obj)) {
				var arr = [];
				for (var i = 0; i < obj.length; i++) {
					copyObj = this.toJSONObj(model, obj[i], expose, type, partialObj, inherit, addNotDefinedFields);
					arr.push(copyObj);
				}
				return arr;
			} else if (obj && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === "object" || Lyte.isRecord(obj))) {
				copyObj = this.toJSONObj(model, obj, expose, type, partialObj, inherit, addNotDefinedFields);
			}
			store.$.recStack = {};
			return copyObj;
		},
		createCopy: function createCopy(data) {
			if (Array.isArray(data)) {
				if (data.save) {
					var arr = [];
					for (var i = 0; i < data.length; i++) {
						var rec = Lyte.deepCopyObject(data[i]);
						arr.push(rec);
					}
					return arr;
				}
			} else if (data && (Lyte.isRecord(data) || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object")) {
				return Lyte.deepCopyObject(data);
			}
			return data;
		},
		compareRecords: function compareRecords(a, b, pK, type, model) {
			var pK = model._arrPk;
			if (Lyte.isRecord(a) && Lyte.isRecord(b) && pK.length) {
				if (type && a._type && type !== a._type) {
					return false;
				}
				var pkLen = pK.length;
				for (var i = 0; i < pkLen; i++) {
					var itm = pK[i];
					if (a[itm] && b[itm] && a[itm] !== b[itm]) {
						return false;
					}
				}
				return true;
			}
			return false;
		},
		hasRecordInArray: function hasRecordInArray(array, record, pK, type, isComp) {
			if (Lyte.isRecord(record) && pK) {
				var len = array.length;
				for (var i = 0; i < len; i++) {
					var itm = array[i];
					if (type && itm._type !== type) {
						continue;
					}
					if (isComp) {
						if (this.compareRecords(itm, record, pK, undefined, record.$.model)) {
							return true;
						}
					} else {
						if (type && itm._type && type === record._type && itm[pK] === record[pK] || itm[pK] === record[pK]) {
							return true;
						}
					}
				}
			}
			return false;
		},
		hasDuplicateRelation: function hasDuplicateRelation(toRelate, relation, pK, type, model) {
			var isComp = model.isComp;
			if (Array.isArray(relation)) {
				if (!isComp && !relation.isPolymorphic && relation._recMap) {
					return relation._recMap.get(toRelate[pK]);
				} else {
					return this.hasRecordInArray(relation, toRelate, pK, type, isComp);
				}
			} else if (relation && Lyte.isRecord(relation)) {
				return this.compareRecords(toRelate, relation, pK, type, model);
			}
			return false;
		},
		checkPresenceInArray: function checkPresenceInArray(arr, value) {
			return arr && arr.some(function (val) {
				return val === value;
			});
		},
		checkAndAddToArray: function checkAndAddToArray(arr, value) {
			if (!this.checkPresenceInArray(arr, value)) {
				arr.push(value);
			} else {
				return -1;
			}
		},
		deleteFromArray: function deleteFromArray(arr, value) {
			var ind = arr.indexOf(value);
			if (ind != -1) {
				arr.splice(ind, 1);
			}
		},
		genPk: function genPk(pK, opts, fields) {
			var pkType;
			pK.forEach(function (item) {
				pkType = fields[item].type;
				var random = opts[item] = Math.floor(Math.random() * 100000 + 1);
				if (pkType == "string") {
					opts[item] = random.toString();
				}
			});
		},
		generateRandomPk: function generateRandomPk(model, opts, pK, fields) {
			this.genPk(pK, opts, fields);
			while (this.isDuplicateRecord(model, opts, pK.toString())) {
				this.genPk(pK, opts, fields);
			}
		},
		pkPresence: function pkPresence(opts, pK) {
			var result = true;
			pK.forEach(function (item) {
				if (!opts.hasOwnProperty(item) || !opts[item]) {
					result = false;
					return;
				}
			});
			return result;
		},
		newRecord: function newRecord(name, opts, withoutValidation) {
			var model = store.modelFor(name);
			if (model === undefined) {
				Lyte.warn("LD02", "Model", name);
				var err = new error1(undefined, undefined, Lyte.getErrorMessage("LD02", "Model", name));
				return err;
			}
			if (opts === undefined) {
				opts = {};
			}
			if (opts && (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== "object") {
				Lyte.warn("LD25", opts);
				var err = new error1(undefined, undefined, Lyte.getErrorMessage("LD25", opts));
				return err;
			}
			var fields = model.fieldList,
			    record = {},
			    errorObj = new error1();
			var pK = model._arrPk;
			if (!this.pkPresence(opts, pK)) {
				this.generateRandomPk(model, opts, pK, fields);
			} else if (this.isDuplicateRecord(model, opts, pK)) {
				store.$.setError(errorObj, pK, { code: "ERR16", message: Lyte.errorCodes.ERR16 });
			}
			for (var field in fields) {
				var fieldKeys = fields[field];
				if (fieldKeys.relType == "hasMany") {
					record[field] = [];
				}
				var val = opts[field];
				var fldType = fieldKeys.type;
				if (fldType != "relation") {
					if (val === undefined || val === "") {
						if (fieldKeys.hasOwnProperty("default")) {
							val = record[field] = store.$.getDefaultVal(record, fieldKeys.default);
						}
					}
					// if(fldType !== Lyte.getDataType(val) && (val !== undefined  || fldType === "boolean")) {
					// 	val = Lyte.typeCast(val, fldType);
					// }		
					if (!withoutValidation) {
						var _field = fieldKeys;
						if (!(_field.any && Array.isArray(_field))) {
							_field = [_field];
						}
						var fldLen = _field.length,
						    _ret = true;
						for (var i = 0; i < fldLen; i++) {
							var _fld = _field[i];
							for (var property in _fld) {
								var resp = Lyte.checkProperty(property, val, field, _fld[property], _fld, opts, record, name);
								if (resp != true) {
									if (_ret === true) {
										if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) == "object") {
											resp.value = val;
										}
										_ret = resp;
									}
									// store.$.setError(errorObj,field,resp);
									// break;
								}
							}
						}
						if (_ret !== true) {
							store.$.setError(errorObj, field, _ret);
						}
					}
				}
			}
			for (var opt_key in opts) {
				record[opt_key] = opts[opt_key];
			}
			record = new Record(name, record);
			store.$.cmpSet(record.$, "isNew", true);
			store.$.changePersist(record, false);
			// record.$.isNew = true;
			var relations = model.relations;
			for (var key in relations) {
				var relation = relations[key];
				for (var i = 0; i < relation.length; i++) {
					var relObj = relation[i];
					var relKey = relObj.relKey;
					var polymorphic = relObj.opts ? relObj.opts.polymorphic : undefined;
					if (record && record[relKey]) {
						var optsRelVal = opts[relKey];
						record[relKey] = undefined;
						var fieldKeys = relation[i],
						    rel = {},
						    resp = this.getRelations(model, fieldKeys.relKey, store.modelFor(fieldKeys.relatedTo), rel),
						    ingore = false;
						if (resp != true) {
							store.$.setError(errorObj, fieldKeys.relKey, { code: resp, data: relation, message: Lyte.errorCodes[resp] });
							continue;
						}
						var bModel = store.modelFor(fieldKeys.relatedTo),
						    bPk = bModel._pK,
						    isComp = bModel.isComp,
						    bPkType = !isComp ? bModel.fieldList[bModel._pK].type : undefined;
						if (!Array.isArray(optsRelVal)) {
							optsRelVal = [optsRelVal];
						} else if (relation[i].relType == "belongsTo") {
							store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR21", data: optsRelVal, message: Lyte.errorCodes.ERR21 });
							continue;
						}
						errorObj[fieldKeys.relKey] = [];
						for (var j = 0; j < optsRelVal.length; j++) {
							var relRecord = undefined,
							    relMod = fieldKeys.relatedTo,
							    ind;
							if (optsRelVal[j] && Lyte.isRecord(optsRelVal[j])) {
								relRecord = optsRelVal[j];
							} else if (isComp && _typeof(optsRelVal[j]) == "object") {
								var ind = store.$.getIndex(bModel.data, bPk, store.$.getpKVal(optsRelVal[j], bModel));
								if (ind != -1) {
									relRecord = bModel.data[ind];
								} else {
									if (polymorphic) {
										if (optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")) {
											relMod = optsRelVal[j]._type;
										} else {
											store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR22", data: optsRelVal[j], message: Lyte.errorCodes.ERR22 });
											continue;
										}
									}
									relRecord = this.newRecord(relMod, optsRelVal[j]);
								}
							} else if (optsRelVal[j] && _typeof(optsRelVal[j]) == bPkType.toLowerCase()) {
								relRecord = store.peekRecord(relMod, optsRelVal[j]);
							} else if (optsRelVal[j] && _typeof(optsRelVal[j]) == "object") {
								if (polymorphic) {
									if (optsRelVal[j] && optsRelVal[j].hasOwnProperty("_type")) {
										relMod = optsRelVal[j]._type;
									} else {
										store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR22", data: optsRelVal[j], message: Lyte.errorCodes.ERR22 });
										continue;
									}
								}
								relRecord = this.newRecord(relMod, optsRelVal[j]);
								// ingore = true;
							}
							if (relRecord && relRecord.$ && relRecord.$.isError) {
								store.$.setError(errorObj, fieldKeys.relKey, { code: "ERR15", data: optsRelVal[j], message: Lyte.errorCodes.ERR15, error: Object.assign({}, relRecord) });
								continue;
							}
							if (relRecord && relRecord.$ && !relRecord.$.isError) {
								resp = this.establishLink(rel.forward, rel.backward, record, relRecord, undefined, ingore);
								if (resp != true) {
									store.$.setError(errorObj, fieldKeys.relKey, { code: resp, data: optsRelVal[j], message: Lyte.errorCodes[resp] });
								}
							}
						}
						if (errorObj[fieldKeys.relKey].length == 0) {
							delete errorObj[fieldKeys.relKey];
						}
						if (relation[i].relType == "hasMany") {
							var fieldkey = relKey;
							if (record[fieldkey] == undefined) {
								record[fieldkey] = [];
							}
							if (!record[fieldkey].add) {
								if (polymorphic) {
									store.$.defProp(record[fieldkey], "polymorphic", true);
								}
								store.$.defArrUtls(record[fieldkey]);
								store.$.defUtls(record[fieldkey], store.modelFor(relation[i].relatedTo), record, fieldkey);
								store.$.defPolyUtls(record[fieldkey]);
							}
						}
					}
				}
			}
			if (errorObj && errorObj.$ && Object.keys(errorObj.$.error).length > 0) {
				return errorObj;
			}
			var toRel = store.$.toRelate[model._name],
			    pkVal = record.$.pK;
			if (toRel && toRel.has(pkVal)) {
				store.$.establishToRelated(record, toRel.get(pkVal));
				toRel.delete(pkVal);
			}
			if (model.didLoad) {
				var callBack = model.didLoad;
				for (var i = 0; i < callBack.length; i++) {
					callBack[i].apply(record);
				}
			}
			this.handleArrOp(model.data, "push", record);
			this.checkAndAddToArray(model.dirty, record.$.pK);
			model.emit("add", [record]);
			store.emit("add", [model._name, record]);
			if (withoutValidation) {
				record.$.validatedOnCreate = false;
			}
			return record;
		},
		toInsertData: function toInsertData(modelName, payLoad, saveParent, ind) {
			var model = store.model[modelName];
			var data = this.insertIntoStore(modelName, payLoad[modelName], saveParent, true, undefined, undefined, undefined, undefined, ind);
			model ? delete model.rel : undefined;
			return data;
		},
		insertIntoStore: function insertIntoStore(modelName, data, saveParent, stack, partialObj, temp, checkRelData, clone, index) {
			var ret;
			if (Array.isArray(data)) {
				ret = [];
				for (var i = 0; i < data.length; i++) {
					ret[i] = this.insertIntoStore(modelName, data[i], saveParent, stack, partialObj);
					if (ret[i] && ret[i].$ && ret[i].$.isError) {
						ret.$ = ret.$ || store.$.defProp(ret, "$", {});
						// ret.$.isError = true;y
						store.$.cmpSet(ret.$, "isError", true);
					}
				}
			} else if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" && Object.keys(data).length) {
				var currentModel = store.modelFor(modelName);
				if (data._type && currentModel.extendedBy) {
					currentModel = currentModel.extendedBy[data._type] ? store.modelFor(data._type) : undefined;
				}
				if (currentModel) {
					if (Lyte.isRecord(data) && !clone) {
						return undefined;
					}
					if (checkRelData && data && currentModel) {
						var rels = currentModel.relations;
						for (var key in rels) {
							var relArr = rels[key];
							relArr.forEach(function (rel) {
								var key = rel.relKey;
								var type = rel.relType;
								if (type == "hasMany" && data.hasOwnProperty(key) && Array.isArray(data[key]) && data[key].length) {
									var arr = data[key],
									    newArr = [];
									arr.forEach(function (itm) {
										if (Lyte.isRecord(itm)) {
											newArr.push(itm.$.pK);
										} else {
											newArr.push(itm);
										}
									});
									data[key] = newArr;
								} else if (type == "belongsTo" && data.hasOwnProperty(key) && Lyte.isRecord(data[key])) {
									data[key] = data[key].$.pK;
								}
							});
						}
					}
					if (!clone) {
						if (!this.isDuplicateRecord(currentModel, data, currentModel._pK)) {
							var rec = new Record(currentModel._name, data);
							currentModel.data.push(rec);
							var toRel = store.$.toRelate[currentModel._name],
							    pkVal = rec.$.pK;
							if (saveParent) {
								store.$.saveParent = rec;
							}
							ret = this.validateAndPush(currentModel, rec, partialObj);
							if (toRel && toRel.has(pkVal)) {
								store.$.establishToRelated(rec, toRel.get(pkVal));
								toRel.delete(pkVal);
							}
						} else {
							ret = this.validateAndMerge(currentModel, data, partialObj);
							if (ret && ret.data) {
								ret = ret.data;
							} else if (ret && ret.type) {
								Lyte[ret.type].apply(Lyte, ret.args || []);
							}
						}
					} else {
						var rec = new Record(currentModel._name, data, currentModel._pK, clone);
						var ret = this.validateAndPush(currentModel, rec, undefined, clone);
					}
					if (saveParent) {
						store.$.saveParent = undefined;
					}
					if (stack) {
						store.$.recStack = {};
					}
				} else {
					var defobj = store.modelless,
					    def = defobj[modelName] = defobj[modelName] || {};
					if (index) {
						if (!(typeof index === 'undefined' ? 'undefined' : _typeof(index)) == "string") {
							Lyte.error("Index should be a string");
						}
						if (def._pK) {
							if (def._pK !== index) {
								Lyte.error("");
								return;
							}
						}
						def._pK = index;
						def._arrPk = [index];
					} else {
						def._pK = index = "id";
						def._arrPk = [index];
					}
					def.data = def.data || [];
					if (!def.data.modelless) {
						store.$.defProp(def.data, "modelless", true);
						store.$.defProp(def.data, "pK", def._pK);
					}
					var ind = store.$.getInd(def.data, index, data[index]);
					if (ind == -1) {
						store.$.handleArrOp(def.data, "push", data);
					} else {
						store.$.handleArrOp(def.data, "replaceAt", data, ind);
					}
					return data;
				}
			}
			return ret;
		},
		removeFromStore: function removeFromStore(model, keys, fromStore, ignorePartial, delayPer, onlyRem, partOnlyRem) {
			var data = model.data,
			    modelName = model._name;
			if (data.length == 0) {
				return;
			}
			if (!Array.isArray(keys)) {
				keys = [keys];
			}
			var pKey = model._pK;
			for (var i = 0; i < keys.length; i++) {
				var index = this.getIndex(data, pKey, keys[i]);
				if (index == -1) {
					continue;
				}
				var rec = data[index];
				var pK = rec.$.pK;
				var relations = model.relations;
				if (rec.$.isNew) {
					onlyRem = delayPer = undefined;
					fromStore = true;
				}
				if (Object.keys(relations).length) {
					this.toDemolishRelation(model, index, ignorePartial, onlyRem, delayPer, partOnlyRem);
				}
				var deleted;
				if (delayPer !== true && onlyRem !== false) {
					deleted = this.handleArrOp(data, "removeAt", undefined, index, 1);
					model.emit("remove", [deleted[0]]);
					store.emit("remove", [model._name, deleted[0]]);
					if (model._properties) {
						store.$.demoLishObserverBindings(rec, model._properties);
					}
				}
				if (fromStore === true) {
					store.$.cmpSet(rec.$, "isUnloaded", true);
					var scpObj = rec.$.__scpObj;
					for (var key in scpObj) {
						var sid = scpObj[key];
						var sidArr = sid.split("_");
						var nestObj = Lyte.nestScp[sidArr[0]];
						nestObj ? Lyte.removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, { model: modelName, pK: rec.$.pK, attr: key }) : undefined;
					}
					var cqueries = store.model.cachedQueries;
					if (cqueries) {
						var Nm = cqueries[modelName],
						    n = modelName;
						if (Nm && Nm.length) {
							for (var j = Nm.length - 1; j >= 0; j--) {
								var obj = Nm[j];
								if (obj.hasDeletedRecords) {
									if (obj.data) {
										var ind = obj.data[modelName].indexOf(rec);
										if (ind !== -1) {
											Nm.splice(j, 1);
										}
									}
								}
							}
						}
					}
				}
				if (onlyRem == true) {
					continue;
				}
				var remRec = deleted ? deleted[0] : rec;
				if (!fromStore) {
					store.$.cmpSet(remRec.$, "isDeleted", true);
					store.$.changePersist(remRec, true);
					// deleted[0].$.isDeleted = true;
					if (delayPer !== true && onlyRem !== false && (remRec.$.isNew || remRec.$.isModified)) {
						store.$.deleteFromArray(model.dirty, remRec.$.pK);
					}
					if (!remRec.$.isNew) {
						store.$.addTo_Del(model, remRec, index);
						// model._deleted.push(deleted[0]);
					}
					var cqueries = store.model.cachedQueries;
					if (cqueries) {
						var Nm = cqueries[modelName],
						    n = modelName;
						if (Nm && Nm.length) {
							for (var j = Nm.length - 1; j >= 0; j--) {
								var obj = Nm[j];
								if (obj && obj.data) {
									var ind = obj.data[modelName].indexOf(rec);
									if (ind != -1) {
										obj.hasDeletedRecords = true;
									}
								}
							}
						}
					}
				}
				var ind;
				if (Array.isArray(model.dirty) && (ind = model.dirty.indexOf(pK)) != -1) {
					model.dirty.splice(ind, 1);
				}
			}
		},
		getIndex: function getIndex(data, pKey, pkVal, type, model) {
			var isComp = model ? model.isComp : pKey.split(',').length > 1 ? true : false;
			if (!isComp) {
				return this.getInd(data, pKey, pkVal, type);
			} else {
				return this.getCompInd(data, pkVal, type, model);
			}
		},
		getCompInd: function getCompInd(data, pkVal, type, model) {
			for (var i = 0; data && i < data.length; i++) {
				var rec = data[i];
				if (type && data[i]._type !== type) {
					continue;
				}
				if (store.adapter.$.compareObjects(store.$.getpKVal(rec, model), pkVal)) {
					return i;
				}
			}
			return -1;
		},
		getInd: function getInd(data, pKey, pkVal, type) {
			for (var i = 0; data && i < data.length; i++) {
				var rec = data[i];
				if (type && rec._type !== type) {
					continue;
				}
				if (rec[pKey] == pkVal || Lyte.isRecord(rec) && rec.$.get && rec.$.get(pKey) == pkVal) {
					return i;
				}
			}
			return -1;
		},
		isDuplicateRecord: function isDuplicateRecord(model, obj) {
			var data = model.data,
			    pK = model._pK,
			    isComp = model.isComposite;
			if (data.length) {
				if (!isComp && model.data._recMap) {
					var pkVal = obj[pK];
					if (pkVal !== undefined) {
						return model.data._recMap.get(pkVal.toString()) !== undefined;
					} else {
						return false;
					}
				} else {
					return data.some(function (record) {
						if (store.adapter.$.compareObjects(store.$.getpKVal(obj, model), store.$.getpKVal(record))) {
							return true;
						}
					});
				}
			}
			return false;
		},
		validateAndPush: function validateAndPush(model, data, partialObj, clone) {
			if (!model.rel) {
				model.rel = {};
			}
			var pkVals = model._arrPk,
			    pkValsLen = pkVals.length,
			    index;
			for (var i = 0; i < pkValsLen; i++) {
				var item = pkVals[i];
				if (!data.hasOwnProperty(item)) {
					index = model.data.indexOf(data);
					model.data.splice(index, 1);
					return new error1(item, { code: "ERR23", data: data, message: Lyte.errorCodes.ERR23 });
				} else if (data[item] == undefined || data[item] == null) {
					index = model.data.indexOf(data);
					model.data.splice(index, 1);
					return new error1(item, { code: "ERR26", data: data, message: Lyte.errorCodes.ERR26 });
				}
			}
			if (clone) {
				data = this.validateJSON(model, data, undefined, undefined, undefined, clone);
				return data;
			}
			var mapPk = data.$.pK == undefined || _typeof(data.$.pK) == "object" ? data.$.pK : data.$.pK.toString();
			model.data._recMap.set(mapPk, data);
			data = this.validateJSON(model, data, undefined, undefined, partialObj);
			var index = model.data.indexOf(data); //have to check if the removal of these lines, doesn't affect any
			model.data.splice(index, 1);
			this.handleArrOp(model.data, "push", data);
			if (model.didLoad) {
				var callBack = model.didLoad;
				for (var i = 0; i < callBack.length; i++) {
					callBack[i].apply(data);
				}
			}
			model.emit("add", [data]);
			store.emit("add", [model._name, data]);

			return data;
		},
		validateAndMerge: function validateAndMerge(model, data, partialObj, mergeError) {
			if (!model.rel) {
				model.rel = {};
			}
			// if((data && typeof data !== "object") || Lyte.isRecord(data)){
			//     return { type:"warn", args:["LD27",Lyte.isRecord(data) ? data : JSON.stringify(data)]};
			// }
			var pkVal = store.$.getpKVal(data, model);
			if (pkVal === undefined) {
				return { type: "error", args: ["LD28", model._name, Lyte.isRecord(data) ? data : JSON.stringify(data)] };
			}
			var record = store.peekRecord(model._name, store.$.getpKVal(data, model));
			if (!record || !Lyte.isRecord(record)) {
				return { type: "error", args: ["LD04", Lyte.isRecord(data) ? data : JSON.stringify(data)] };
			}
			this.mergeData(record, data, partialObj, mergeError);
			// record = this.validateJSON(model, record, Object.keys(data), toValidate, partialObj);
			if (model.didLoad) {
				var callBack = model.didLoad;
				for (var i = 0; i < callBack.length; i++) {
					callBack[i].apply(record);
				}
				//model.didLoad.apply(record);
			}
			return { data: record };
		},
		mergeData: function mergeData(record, data, partialObj, mergeError) {
			if (!record || !data) {
				return;
			}
			var model = record.$.model,
			    field,
			    _estObsBind = false;
			if (mergeError) {
				store.adapter.$.mergeError(model, record, data);
			}
			for (var key in data) {
				field = model.fieldList[key];
				if (field) {
					if (field.type != "relation") {
						var empD = store.$.getDsrzEmpData(field, model._name);
						var boolChk = !empD && data[key];
						if (data.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(field.type) && Lyte.Transform[field.type].hasOwnProperty("deserialize")) {
							data[key] = Lyte.Transform[field.type].deserialize(data[key], key, model._name, store.$.getpKVal(data, model));
						}
						var isPropPresent = model._properties && model._properties.hasOwnProperty(key),
						    propObj = {};
						if (isPropPresent) {
							propObj[key] = model._properties[key];
							store.$.demoLishObserverBindings(record, propObj);
						}
						store.$.cmpSet(record, key, data[key], undefined, true);
						model._properties && model._properties.hasOwnProperty(key) ? _estObsBind = true : undefined;
					} else if (field && field.type == "relation") {
						var todo = {};
						var rel = {};
						store.$.getRelations(record.$.model, key, store.modelFor(field.relatedTo), rel);
						var bMod = store.model[rel.forward.relatedTo];
						// if new record created and replace (true) , then newly created record will be completely removed form store
						// response recived from the server replaced
						if (field.relType == "hasMany" && partialObj && partialObj[key] && partialObj[key].replace) {
							var rec_ar = record[key]._recMap,
							    arr_rec = [];
							rec_ar.forEach(function (rec, key_i) {
								arr_rec.push(key_i);
							});
							arr_rec.forEach(function (i) {
								if (store.peekRecord(field.relatedTo, i).$.isNew) {
									store.$.removeFromStore(store.modelFor(field.relatedTo), i, true);
								} else {
									store.$.demolishLink(store.peekRecord(field.relatedTo, i), store.peekRecord(field.relatedTo, i).$.model._pK, record, rel.forward.relKey, undefined, undefined, true, true);
									if (rel.backward != null) {
										store.$.demolishLink(record, model._pK, store.peekRecord(field.relatedTo, i), rel.backward.relKey, rel.forward, undefined, true, true);
									}
								}
							});
							delete partialObj[key];
						}
						var result = this.compareRelations(record, data, key, field, partialObj ? partialObj[key] : undefined, todo, mergeError);
						this.mergeRecords(todo, result, model, bMod, record, key, data, rel, partialObj, mergeError);
					}
				} else if (key != "$") {
					store.$.cmpSet(record, key, data[key], undefined, true);
				}
			}
			if (_estObsBind) {
				store.$.establishObserverBindings(record, model._properties);
			}
		},
		mergeRecords: function mergeRecords(todo, result, model, bMod, record, key, data, rel, partialObj, mergeError) {
			if (!rel) {
				var rel = {};
				store.$.getRelations(model, key, bMod, rel);
			}
			var pK = model._pK;
			if (rel.forward.relType == "hasMany" && store.$.isEmptyArray(data[key]) && Array.isArray(todo.remove) && record && record[key] && todo.remove.length != record[key].length || record && !record[key] && Array.isArray(data[key])) {
				store.$.cmpSet(record, key, [], undefined, true);
				store.$.establishObserverBindings(record, record.$.model._properties);
				store.$.defArrUtls(record[key]);
				store.$.defPolyUtls(record[key]);
				store.$.defUtls(record[key], bMod, record, key);
			}
			if (Array.isArray(todo.add)) {
				todo.add.forEach(function (item) {
					store.$.createAndRelate(model, bMod, record, key, item, rel, partialObj);
				});
			}
			if (Array.isArray(todo.remove)) {
				todo.remove.forEach(function (obj) {
					var pkVal = obj.pK,
					    model = obj.model;
					store.$.demolishLink(record, pK, store.peekRecord(model, pkVal), rel.backward.relKey, rel.forward, rel.backward, true);
					store.$.demolishLink(store.peekRecord(model, pkVal), store.modelFor(model)._pK, record, rel.forward.relKey, rel.backward, rel.forward, true);
				});
			}

			if (record && record.hasOwnProperty(key)) {
				store.$.deleteDeepNest(record, key);
				if (Array.isArray(record[key]) && record[key].hasOwnProperty("partial")) {
					var partObj = record[key].partial,
					    partKeys = [];
					partObj.forEach(function (value, partKey) {
						partKeys.push(partKey);
						record[key].partial.delete(partKey);
					});
				}
			}
			switch (result) {
				case 0:
					{
						if (Lyte.isRecord(record[key])) {
							store.$.demolishLink(record, pK, record[key], rel.backward.relKey, rel.forward, rel.backward, true);
							store.$.demolishLink(record[key], bMod._pK, record, rel.forward.relKey, rel.backward, rel.forward, true);
						}
						store.$.createAndRelate(model, bMod, record, key, data[key], rel, partialObj);
						break;
					}
				case 1:
					{
						break;
					}
				case 2:
					{
						this.mergeData(record[key], data[key], undefined, mergeError);
						break;
					}
				default:
					break;
			}
		},
		compareRelations: function compareRelations(record, data, key, field, partialObj, todo, mergeError) {
			//return 0 - not same, 1 -same, 2 - merge, 3 - partial add, 4 - delete and partial add
			var model = store.modelFor(field.relatedTo);
			var pK = model._pK,
			    result = [];
			if (field.relType == "belongsTo") {
				if (partialObj && partialObj.$.type === "removed" && (!data || data && store.$.comparePk(record, store.$.getpKVal(data, model)))) {
					return 1;
				}
				return this.compareRecordWithObj(record[key], data[key], pK, partialObj, mergeError);
			} else {
				var isPartial = false;
				if (partialObj && partialObj.partial) {
					isPartial = true;
				}
				if (!isPartial && (!record.hasOwnProperty(key) || record && record.hasOwnProperty(key) && (store.$.isEmpty(record[key]) || store.$.isEmptyArray(record[key])))) {
					if (todo) {
						var arr = data[key] || [];
						arr.forEach(function (item) {
							var add = todo.add = todo.add || [];
							add.push(item);
						});
						return;
					}
					return 0;
				}
				var len = data[key] ? data[key].length : 0,
				    old = 0,
				    status = 1,
				    oldPks = [];
				for (var i = 0; i < len; i++) {
					var obj = data[key][i];
					if (partialObj && partialObj[i] && partialObj[i].$.type == "removed") {
						continue;
					}
					var ind = this.getIndex(record[key], pK, (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object" ? store.$.getpKVal(obj, model) : obj);
					if (ind == -1) {
						if (todo) {
							var add = todo.add = todo.add || [];
							add.push(obj);
						}
						status = 0;
						continue;
					}
					oldPks.push(record[key][ind].$.pK);
					var res = this.compareRecordWithObj(record[key][ind], obj, pK, partialObj ? partialObj[i] : undefined, mergeError);
					if (res == 1) {
						old++;
					}
					if (res == 2) {
						this.mergeData(record[key][ind], obj, partialObj ? partialObj[i] : undefined, mergeError);
					} else if (res == 0) {
						status = 0;
					}
				}
				if (todo && !isPartial) {
					var arr = record[key] || [];
					arr.forEach(function (item) {
						var pkVal = item.$.pK;
						if (oldPks.indexOf(pkVal) == -1) {
							var remove = todo.remove = todo.remove || [];
							remove.push({ pK: pkVal, model: item.$.model._name });
						}
					});
				}
			}
		},
		compareRecordWithObj: function compareRecordWithObj(rec, obj, pK, partialObj, mergeError) {
			if (!rec || !Lyte.isRecord(rec)) {
				return 0;
			}
			var recModel = rec.$.model;
			var recPk = recModel._pK;
			var isComp = recModel.isComp;
			var recFields = recModel.fieldList;
			if (!isComp) {
				var field = recModel.fieldList[pK];
				if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == field.type) {
					if (rec[pK] == obj) {
						return 1;
					} else {
						return 0;
					}
				}
			}
			if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == "object") {
				if (!store.$.comparePk(rec, store.$.getpKVal(obj, recModel))) {
					return 0;
				}
				if (Lyte.isRecord(obj) && obj === rec) {
					return 1;
				}
				for (var data_key in obj) {
					var field = recFields[data_key];
					if (field) {
						if (field.type == "relation") {
							var todo = {};
							var res = this.compareRelations(rec, obj, data_key, field, partialObj ? partialObj[data_key] : undefined, todo, mergeError);
							this.mergeRecords(todo, res, recModel, store.modelFor(field.relatedTo), rec, data_key, obj, undefined, partialObj);
						} else if (rec[data_key] != obj[data_key]) {
							return 2;
						}
					} else {
						if (rec[data_key] != obj[data_key]) {
							return 2;
						}
					}
				}
				return 1;
			}
			return 0;
		},
		validateJSON: function validateJSON(model, data, keys, toValidate, partialObj, clone) {
			var validate = toValidate ? toValidate.toValidate : undefined;
			var fields = validate && Object.keys(validate).length ? validate : model.fieldList;
			var extended = model.extend ? true : false;
			for (var key in data) {
				if (keys && keys.indexOf(key) == -1) {
					continue;
				}
				var fld = fields[key];
				if (fld) {
					if (fld.type == "relation" && data[key]) {
						var partialAdd = toValidate && toValidate.toPartialAdd ? toValidate.toPartialAdd[key] : undefined;
						var resp = this.handleRelation(key, model, fld, data, partialAdd, partialObj, clone);
						if (resp != true) {
							return new error1(key, { code: resp, data: data, message: Lyte.errorCodes[resp] });
						}
						if (fld.relType == "hasMany" && !data[key].add) {
							store.$.defArrUtls(data[key]);
							store.$.defPolyUtls(data[key]);
							store.$.defUtls(data[key], store.model[fld.relatedTo], data, key);
						}
					} else if (fld.type) {
						var fieldKeys = fld;
						if (data[key] === undefined && fieldKeys.default) {
							data[key] = store.$.getDefaultVal(data, fieldKeys.default);
						}
						var empD = store.$.getDsrzEmpData(fld, model._name);
						var boolChk = !empD && data[key];
						if (data.hasOwnProperty(key) && (boolChk || empD) && Lyte.Transform.hasOwnProperty(fieldKeys.type) && Lyte.Transform[fieldKeys.type].hasOwnProperty("deserialize")) {
							data[key] = Lyte.Transform[fieldKeys.type].deserialize(data[key], key, model._name, store.$.getpKVal(data, model));
						}
					}
				} else {
					if (extended) {
						var extMod = store.modelFor(model.extend);
						var extKey = extMod.fieldList[key];
						if (extKey && extKey.type == "relation") {
							var partialAdd = toValidate && toValidate.toPartialAdd ? toValidate.toPartialAdd[key] : undefined;
							var resp = this.handleRelation(key, extMod, extKey, data, partialAdd);
							if (resp != true) {
								return new error1(key, { code: resp, data: data, message: Lyte.errorCodes[resp] });
							}
							if (extKey.relType == "hasMany" && !data[key].add) {
								store.$.defArrUtls(data[key]);
								store.$.defPolyUtls(data[key]);
								store.$.defUtls(data[key], extMod, data, key);
							}
						}
					}
				}
			}
			return data;
		},
		handleRelation: function handleRelation(key, model, field, data, partialAdd, partialObj, clone) {
			var rel = {};
			if (!model.rel.hasOwnProperty(key)) {
				var relResp = this.getRelations(model, key, store.modelFor(field.relatedTo), rel);
				if (relResp !== true) {
					return relResp;
				}
				model.rel[key] = rel;
			} else {
				rel = model.rel[key];
			}
			return this.solveRelation(rel, model, store.modelFor(field.relatedTo), key, data, partialAdd, partialObj, clone);
		},
		getRelations: function getRelations(fModel, key, bModel, rel) {
			if (bModel == undefined) {
				Lyte.error("LD05", fModel.fieldList[key].relatedTo, key, fModel._name);
				return "ERR11";
			}
			rel.forward = fModel.fieldList[key];
			rel.backward = this.getBackwardRel(fModel, rel.forward, bModel);
			if (rel.backward === undefined) {
				// Lyte.warn("LD06",fModel._name,key,bModel._name);
				// return "ERR25";
				var temp_backward = { type: "relation", relatedTo: fModel._name, dummy: rel.forward.relKey, relKey: undefined };
				bModel.relations[fModel._name] = bModel.relations[fModel._name] || [];
				bModel.relations[fModel._name].push(temp_backward);
				rel.backward = temp_backward;
			}
			return true;
		},
		getBackwardRel: function getBackwardRel(fModel, rel, bModel) {
			var inverse, polymorphic;
			if (rel.opts) {
				inverse = rel.opts.inverse;
				polymorphic = rel.opts.polymorphic;
				if (inverse === null) {
					return undefined;
				}
				if (polymorphic) {
					var extendedModels = bModel.extendedBy;
					if (extendedModels) {
						for (var key in extendedModels) {
							var extModel = store.modelFor(key);
							if (extModel.relations[fModel._name]) {
								bModel = extModel;
								break;
							}
						}
					}
				}
			}
			var relatedTo;
			if (inverse && inverse != "") {
				relatedTo = inverse;
			} else {
				var bRel = bModel.relations[fModel._name];
				var extFmodel = store.modelFor(fModel.extend),
				    checkPoly;
				if (!bRel && extFmodel && bModel.relations[extFmodel._name]) {
					bRel = bModel.relations[extFmodel._name];
					checkPoly = true;
				}
				relatedTo = bRel && bRel.length == 1 && (bRel[0].opts && bRel[0].opts.inverse && bRel[0].opts.inverse !== rel.relKey ? false : true) && (!checkPoly || checkPoly && bRel[0].opts && bRel[0].opts.polymorphic) ? bRel[0].relKey : undefined;
			}
			if (!relatedTo) {
				var bRels = bModel.relations[fModel._name];
				var extFmodel_1 = store.modelFor(fModel.extend);
				if (!bRels && extFmodel_1 && bModel.relations[extFmodel_1._name] && bModel.relations[extFmodel_1._name].opts && bModel.relations[extFmodel_1._name].opts.polymorphic) {
					bRels = bModel.relations[extFmodel_1._name];
				}
				if (rel.dummy && bRels) {
					for (var i = 0; i < bRels.length; i++) {
						if (bRels[i] && bRels[i].relKey && bRels[i].relKey == rel.dummy) {
							relatedTo = bRels[i].relKey;
							break;
						}
					}
				} else if (bRels) {
					for (var i = 0; i < bRels.length; i++) {
						if (bRels[i] && bRels[i].opts && bRels[i].opts.inverse && bRels[i].opts.inverse === rel.relKey) {
							relatedTo = bRels[i].relKey;
							break;
						} else if (bRels[i] && bRels[i].dummy && bRels[i].dummy == rel.relKey) {
							relatedTo = bRels[i];
							break;
						}
					}
				}
			}
			if (relatedTo && relatedTo.dummy) {
				return relatedTo;
			}
			if (relatedTo && fModel._fldGrps.inverse.hasOwnProperty(rel.relatedTo) && !rel.dummy) {
				if (relatedTo && fModel.relations[rel.relatedTo] && fModel.relations[rel.relatedTo].length > 1 && !inverse) {
					if (!bModel.fieldList[relatedTo].opts || bModel.fieldList[relatedTo].opts && !bModel.fieldList[relatedTo].opts.inverse) {
						return undefined;
					}
				}
			}
			return relatedTo && bModel ? bModel.fieldList[relatedTo] : undefined;
		},
		solveRelation: function solveRelation(rel, fModel, bModel, key, data, partialAdd, partialObj, clone) {
			var backward = rel.backward,
			    forward = rel.forward,
			    partial = partialObj ? partialObj[key] : undefined,
			    partialRel = partial && partial.partial;
			var fPk = fModel._pK,
			    val = [];
			if (partialAdd) {
				val = partialAdd;
			} else if (!partialRel) {
				if (data[key] && (data[key].add || Lyte.isRecord(data[key]))) {
					return true;
				}
				if (!Array.isArray(data[key])) {
					data[key] = [data[key]];
				} else if (forward.relType == "belongsTo") {
					return "ERR21";
				}
				val = data[key].splice(0, data[key].length);
				if (forward.relType == "belongsTo") {
					data[key] = undefined;
				}
			} else if (Array.isArray(data[key])) {
				var val = data[key].splice(0, data[key].length);
			}
			for (var i = 0; i < val.length; i++) {
				var ret;
				ret = this.createAndRelate(fModel, bModel, data, key, val[i], rel, partial, clone);
				if (ret != true) {
					return ret;
				}
			}
			return true;
		},
		createAndRelate: function createAndRelate(fModel, bModel, data, key, val, rel, partial, clone) {
			if (!rel.backward) {
				if (rel.forward.relatedTo === fModel._name) {
					rel.backward = rel.forward;
				}
				if (rel.backward === undefined) {
					return "ERR12";
				}
			}
			var pK = fModel._pK,
			    isComp = bModel.isComp,
			    isPoly = rel.forward && rel.forward.opts ? rel.forward.opts.polymorphic : undefined;
			var relatedRecord,
			    newPartial = partial && partial.hasOwnProperty(val[pK]) ? partial[val[pK]] : partial;
			if (!isComp && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == bModel.fieldList[bModel._pK].type) {
				relatedRecord = store.peekRecord(bModel._name, val);
			} else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && !Lyte.isRecord(val)) {
				relatedRecord = this.insertIntoStore(bModel._name, val, undefined, undefined, newPartial, undefined, undefined, clone);
			}
			if (relatedRecord && relatedRecord.$ && relatedRecord.$.isError) {
				store.$.cmpSet(data.$, "isError", true);
				// data.$.isError = true;
				var errObj = { code: "ERR24", message: Lyte.errorCodes.ERR24, data: data, error: relatedRecord.$.error };
				store.$.cmpSet(data.$.error, key, errObj);
			} else if (relatedRecord) {
				if (!this.hasDuplicateRelation(relatedRecord, data[key], bModel._pK, isPoly ? val._type : undefined, bModel)) {
					this.establishLink(rel.forward, rel.backward, data, relatedRecord, undefined, true, false);
				}
			} else {
				this.addToRelate(fModel._name, data, rel, val);
			}
			return true;
		},
		singleEstablishLink: function singleEstablishLink(forward, data, relatedRecord) {
			var relation = relatedRecord.$._relationships,
			    fModelName = data.$.model._name,
			    fRelKey = forward.relKey;
			relation[fModelName] = relation[fModelName] || {};
			relation[fModelName][fRelKey] = relation[fModelName][fRelKey] || [];
			if (!this.hasDuplicateRelation(data, relation[fModelName][fRelKey], data.$.model._pK, undefined, data.$.model)) {
				relation[fModelName][fRelKey].push(data);
			}
		},
		establishLink: function establishLink(forward, backward, data, relatedRecord, index, ignorePartial, isDuplicate, partRemoveOnly) {
			if (!relatedRecord) {
				return "ERR13";
			}
			if (!this.checkForCorrectRelation(forward, relatedRecord)) {
				return "ERR14";
			}
			var fRelKey = forward.relKey,
			    isPoly = forward.opts && forward.opts.polymorphic,
			    type = isPoly ? relatedRecord._type : undefined,
			    ignoreRel = {};
			if (forward.relType == "belongsTo") {
				if (data[fRelKey] !== relatedRecord) {
					store.$.cmpSet(data, fRelKey, relatedRecord, undefined, true);
				}
				if (data.$.partial && Object.keys(data.$.partial).length && data.$.partial[fRelKey]) {
					delete data.$.partial[fRelKey];
				}
			} else if (forward.relType === "hasMany") {
				if (!data[fRelKey]) {
					store.$.cmpSet(data, fRelKey, [], undefined, true);
				}
				if (!data[fRelKey].model) {
					var relModel = relatedRecord.$.model;
					if (isPoly && type) {
						store.$.defProp(data[fRelKey], "polymorphic", true);
						relModel = store.modelFor(relModel.extend);
					}
					store.$.establishObserverBindings(data, data.$.model._properties);
					store.$.defArrUtls(data[fRelKey]);
					store.$.defPolyUtls(data[fRelKey]);
					store.$.defUtls(data[fRelKey], relModel, data, fRelKey);
				}
				var mdl = forward ? store.modelFor(forward.relatedTo) : undefined;
				if (isDuplicate == false || !this.hasDuplicateRelation(relatedRecord, data[fRelKey], forward ? mdl._pK : undefined, type, mdl)) {
					if (index != undefined) {
						this.handleArrOp(data[fRelKey], "insertAt", relatedRecord, index);
						// if(typeof Lyte.arrayUtils != "undefined"){
						// 	Lyte.arrayUtils(data[fRelKey],"insertAt",index,relatedRecord);						
						// }
						// else{
						// 	data[fRelKey].splice(index, 0, relatedRecord);
						// }	
					} else {
						this.handleArrOp(data[fRelKey], "push", relatedRecord);
					}
				}
				var ret;
				if ((!ignorePartial || partRemoveOnly) && forward.opts && forward.opts.serialize) {
					ret = store.$.partialData(data, fRelKey, relatedRecord.$.pK, "added", undefined, partRemoveOnly);
					ignoreRel.relKey = fRelKey;
					ignoreRel.model = data.$.model._name;
				}
			}
			var fnest = false;
			if (!ignorePartial) {
				fnest = ret ? false : true;
			}
			// if(forward == backward){
			// 	this.singleEstablishLink(forward,data,relatedRecord);
			// 	return true;
			// }
			if (backward === null) {
				if (relatedRecord.hasOwnProperty(bRelKey)) {
					delete relatedRecord[bRelKey];
				}
				return true;
			}
			if (backward.dummy || forward == backward) {
				this.singleEstablishLink(forward, data, relatedRecord);
			} else {
				var bRelKey = backward.relKey,
				    relRecMod = relatedRecord.$.model;
				if (!this.checkForCorrectRelation(backward, data)) {
					return "ERR14";
				}
				if (backward.relType == "belongsTo") {
					if (relatedRecord[bRelKey] != undefined && relatedRecord[backward.relKey] !== data) {
						this.toDemolishLink(relRecMod, relatedRecord, backward, ignorePartial);
					}
					if (relatedRecord[bRelKey] !== data) {
						store.$.cmpSet(relatedRecord, bRelKey, data, undefined, true);
					}
					if (relatedRecord.$.partial && Object.keys(relatedRecord.$.partial).length && relatedRecord.$.partial[bRelKey]) {
						delete relatedRecord.$.partial[bRelKey];
					}
				} else if (backward.relType === "hasMany") {
					if (!relatedRecord[bRelKey]) {
						store.$.cmpSet(relatedRecord, bRelKey, [], undefined, true);
					}
					if (!relatedRecord[bRelKey].model) {
						store.$.defArrUtls(relatedRecord[bRelKey]);
						store.$.defPolyUtls(relatedRecord[bRelKey]);
						store.$.defUtls(relatedRecord[bRelKey], data.$.model, relatedRecord, bRelKey);
					}
					var bMdl = backward ? store.modelFor(backward.relatedTo) : undefined;
					if (!this.hasDuplicateRelation(data, relatedRecord[bRelKey], backward ? bMdl._pK : undefined, type, bMdl)) {
						this.handleArrOp(relatedRecord[bRelKey], "push", data);
					}
					var bret;
					if ((!ignorePartial || partRemoveOnly) && backward.opts && backward.opts.serialize) {
						bret = store.$.partialData(relatedRecord, bRelKey, data.$.pK, "added", undefined, partRemoveOnly);
					}
					var bnest;
					if (!ignorePartial) {
						bnest = bret ? false : true;
					}
				}
			}
			if (fnest) {
				if (forward.opts && forward.opts && forward.opts.deepNest) {
					var type = "added";
					if (data[forward.relKey].partial && data[forward.relKey].partial.get(relatedRecord.$.pK)) {
						type = data[forward.relKey].partial.get(relatedRecord.$.pK).type;
					}
					store.$.setDeepNest(data, forward.relKey, relatedRecord.$.pK, type);
					bnest = false;
				}
				// store.$.addDeepNest(relatedRecord, undefined, !ignorePartial ? "added" : undefined, ignoreRel);
				if (bnest) {
					if (backward && backward.opts && backward.opts.deepNest) {
						store.$.setDeepNest(relatedRecord, backward.relKey, data.$.pK, "added");
					}
				}
			}
			return true;
		},
		toDemolishRelation: function toDemolishRelation(model, index, ignorePartial, onlyRem, delayPers, partOnlyRem) {
			var record = model.data[index],
			    relations = model.relations,
			    storeUtils = this;
			for (var key in relations) {
				var rel = relations[key];
				for (var i = 0; i < rel.length; i++) {
					var relation = rel[i],
					    relatedModel = store.modelFor(relation.relatedTo);
					if (relatedModel) {
						var bRel = store.$.getBackwardRel(model, relation, relatedModel);
						// if(model._name == relatedModel._name){
						// 	var data = relatedModel.data,index1,index2;
						// 	for(index1=0 ; index1<data.length; index1++){
						// 		var item=data[index1];
						// 		if(Array.isArray(item[relkey])){
						// 			for(var index2=0;index2<item[relkey].length;index2++){
						// 				var value = item[relkey][index2];
						// 				if(value[relPriKey] == record[relPriKey] && onlyRem !== false && delayPers !== true)
						// 				{
						// 					storeUtils.handleArrOp(item[relkey],"removeAt",undefined,index2,1);
						// 				}
						// 			}
						// 		}
						// 		else if (Lyte.isRecord(item[relkey])){
						// 			if(item[relkey][relPriKey] == record[relPriKey] && onlyRem !== false && delayPers !== true)
						// 				{
						// 					item[relkey] = undefined ;
						// 				}
						// 		}
						// 	}
						// }
						if (!record[relation.relKey] && !relation.dummy && relation !== bRel) {
							continue;
						}
						this.toDemolishLink(model, record, relation, ignorePartial, onlyRem, delayPers, partOnlyRem);
					}
				}
			}
		},
		toDemolishLink: function toDemolishLink(model, record, relation, ignorePartial, onlyRem, delayPers, partOnlyRem) {
			var records = record[relation.relKey],
			    priKey = model._pK,
			    relatedModel = store.modelFor(relation.relatedTo);
			if (!relatedModel) {
				return;
			}
			var relPriKey = relatedModel._pK,
			    relatedModelName = relation.relatedTo,
			    bRelation = this.getBackwardRel(model, relation, relatedModel),
			    serialize = relation.opts ? relation.opts.serialize : undefined;
			if (relation.dummy || relation === bRelation) {
				records = this.getRelatedRecord(record, relation.relatedTo, relation.dummy ? relation.dummy : relation.relKey);
			}
			// if(bRelation.dummy){
			// 	bRelation.relKey = undefined;
			// }
			var pKs = [],
			    rec;
			if (bRelation) {
				if (Array.isArray(records)) {
					for (var i = 0; i < records.length; i++) {
						this.demolishLink(record, priKey, records[i], bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers, partOnlyRem);
					}
				} else if (Lyte.isRecord(records)) {
					this.demolishLink(record, priKey, records, bRelation.relKey, relation, bRelation, ignorePartial, undefined, onlyRem, delayPers, partOnlyRem);
				}
			}
		},
		demolishSingleRelation: function demolishSingleRelation(record, fModelName, key, relatedRecord, priKey, onlyRem, delayPers) {
			var arr, index;
			if (Lyte.isRecord(record)) {
				arr = record.$._relationships;
				if (arr && arr[fModelName] && arr[fModelName][key] && onlyRem !== false && delayPers !== true) {
					arr = arr[fModelName][key];
					index = this.getIndex(arr, priKey, relatedRecord[priKey]);
					if (index > -1) {
						arr.splice(index, 1);
					}
				}
			}
		},
		demolishLink: function demolishLink(record, priKey, relatedRecord, bRelKey, relation, bRelation, ignorePartial, ignoreAttrCheck, onlyRem, delayPers, partOnlyRem) {
			var links = relatedRecord[bRelKey],
			    relMod = relatedRecord.$.model,
			    pKs = [];
			var pK = record.$.pK;
			var poly = links ? links.polymorphic : undefined,
			    polymorphicType;
			if (Array.isArray(links)) {
				var ind = this.getIndex(links, priKey, pK, poly ? record._type : undefined);
				var _attrs = relatedRecord.$._attributes;
				var initialVal = _attrs.hasOwnProperty(bRelKey) && _attrs[bRelKey] && _attrs[bRelKey].length ? relatedRecord.$.getInitialValues(bRelKey) : undefined;
				var toRem = links.partial && links.partial.has(pK) && links.partial.get(pK).type == "added" ? true : false;
				if (ind != -1 && (toRem || onlyRem !== false && delayPers !== true)) {
					poly ? polymorphicType = links[ind].$.model._name : undefined;
					this.handleArrOp(relatedRecord[bRelKey], "removeAt", undefined, ind, 1);
				}
				if (!ignoreAttrCheck && initialVal) {
					if (!store.$.hasRecordsArrayChanged(relatedRecord, bRelKey, initialVal)) {
						delete relatedRecord.$._attributes[bRelKey];
						if (!Object.keys(relatedRecord.$._attributes).length) {
							store.$.cmpSet(relatedRecord.$, "isModified", false);
							store.$.changePersist(relatedRecord, true);
							if (!relatedRecord.$.isNew) {
								store.$.deleteFromArray(relMod.dirty, relatedRecord[relMod._pK]);
								if (!relatedRecord.$.dN || relatedRecord.$.dN && !Object.keys(relatedRecord.$.dN).length) {
									store.$.removeParentNesting(relatedRecord);
								}
							}
						}
					}
				}
			} else if (links && ((typeof links === 'undefined' ? 'undefined' : _typeof(links)) == "object" || Lyte.isRecord(links)) && onlyRem !== false && delayPers !== true) {
				if (Lyte != undefined && Lyte.objectUtils != undefined) {
					Lyte.objectUtils(relatedRecord, "delete", bRelKey, undefined, undefined, true);
				} else {
					delete relatedRecord[bRelKey];
				}
			} else {
				this.demolishSingleRelation(relatedRecord, record.$.model._name, relation.relKey, record, priKey, onlyRem, delayPers);
			}
			if (!bRelation) {
				bRelation = relMod.fieldList[bRelKey];
			}
			if ((!ignorePartial || partOnlyRem) && onlyRem !== true) {
				var relType, isPartial, ret, nest, serz;
				if (bRelation) {
					if (bRelation.opts) {
						isPartial = bRelation.opts.serialize == "partial";
						serz = bRelation.opts.serialize ? true : false;
						nest = bRelation.opts.deepNest;
					}
					var relType = bRelation ? bRelation.relType : undefined;
				}
				// if(delayPers && bRelation && bRelation.opts && /^(id|record)$/.test(bRelation.opts.serialize)){
				// 	return;
				// }
				if (relType == "belongsTo" && serz && !record.$.isNew) {
					var partObj = relatedRecord.$.partial = relatedRecord.$.partial || {};
					if (partOnlyRem) {
						if (partObj && partObj.hasOwnProperty(bRelKey) && partObj[bRelKey].has(pK)) {
							partObj[bRelKey].delete(pK);
						}
						if (nest) {
							store.$.deleteDeepNest(relatedRecord, bRelKey, pK);
						}
						nest = false;
					} else {
						partObj = partObj[bRelKey] = partObj[bRelKey] || new Map();
						if (!partObj.has(pK)) {
							partObj.set(pK, {});
						}
						partObj = partObj.get(pK);
						partObj.type = "removed";
					}
				}
				if (bRelation && bRelation.opts && bRelation.opts.serialize) {
					ret = store.$.partialData(relatedRecord, bRelKey, pK, "removed", polymorphicType, partOnlyRem);
					nest = ret && relType == "hasMany" ? false : nest;
				}
				if (nest) {
					store.$.makeDirty("dirty", relatedRecord, "removed", bRelation, pK);
					store.$.addDeepNest(relatedRecord);
				}
			}
		},
		rllBckRecArr: function rllBckRecArr(oldVal, record, model, field) {
			var rel = {},
			    pK = model._pK,
			    relPK = store.modelFor(field.relatedTo)._pK;
			store.$.getRelations(model, field.relKey, store.modelFor(field.relatedTo), rel);
			for (var i = oldVal.length - 1; i >= 0; i--) {
				var records = oldVal[i].records;
				if (oldVal[i]._type == "added") {
					for (var j = 0; j < records.length; j++) {
						var relatedRecord = records[j];
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							// temp check to know if record exist in store
							this.demolishLink(relatedRecord, relPK, record, rel.forward.relKey);
							if (rel.backward != null) {
								this.demolishLink(record, pK, relatedRecord, rel.backward.relKey, rel.forward);
							}
						}
					}
				} else if (oldVal[i]._type == "removed") {
					for (var j = records.length - 1; j >= 0; j--) {
						var relatedRecord = records[j];
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							// temp check to know if record exist in store
							this.establishLink(rel.forward, rel.backward, record, relatedRecord, oldVal[i]._indices[j]);
						}
					}
				} else if (oldVal[i]._type == "changed") {
					var currentRecords = record[field.relKey];
					if (!Array.isArray(currentRecords)) {
						currentRecords = [currentRecords];
					}
					var self = this;
					var kLen = currentRecords.length;
					for (var k = 0; k < kLen; k++) {
						var relatedRecord = currentRecords[0];
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							self.demolishLink(relatedRecord, relPK, record, rel.forward.relKey);
							if (rel.backward != null) {
								self.demolishLink(record, pK, relatedRecord, rel.backward.relKey, rel.forward);
							}
						}
					}
					if (!Array.isArray(records)) {
						records = [records];
					}
					for (var j = 0; j < records.length; j++) {
						var relatedRecord = records[j];
						if (typeof relatedRecord == "string") {
							relatedRecord = store.peekRecord(rel.forward.relatedTo, relatedRecord);
						}
						if (relatedRecord && relatedRecord.$ && relatedRecord.$.hasOwnProperty("pK")) {
							// temp check to know if record exist in store
							this.establishLink(rel.forward, rel.backward, record, relatedRecord, undefined);
						}
					}
				}
			}
		},
		sortBy: function sortBy(field, order) {
			var fieldArr = store.$.mapBy.call(this, field);
			var model = this.model;
			var fie = model.fieldList[field];
			if (fie && fie.type == "string") {
				fieldArr.sort();
				if (order == "desc") {
					fieldArr.reverse();
				}
			} else {
				fieldArr.sort(function (a, b) {
					return a - b;
				});
				if (order == "desc") {
					fieldArr.sort(function (a, b) {
						return b - a;
					});
				}
			}
			var oldArr = this.slice(0),
			    newArr = [];
			for (var i = 0; i < fieldArr.length; i++) {
				if (fieldArr[i] == undefined) {
					continue;
				}
				var index = store.$.getIndex(oldArr, field, fieldArr[i]);
				newArr.push(oldArr[index]);
				oldArr.splice(index, 1);
			}
			if (oldArr.length > 0) {
				if (order == "desc") {
					newArr = newArr.concat(oldArr);
				} else {
					newArr = oldArr.concat(newArr);
				}
			}
			store.$.defArrUtls(newArr);
			store.$.defUtls(newArr, this.model);
			return newArr;
		},
		mapBy: function mapBy(field) {
			return this.map(function (value) {
				return value.$.get(field);
			});
		},
		revertToOldVal: function revertToOldVal(record, attr, oldVal, rel) {
			if (oldVal == undefined || oldVal.length == 0) {
				return;
			} else {
				if (!Array.isArray(oldVal)) {
					oldVal = [oldVal];
				}
				for (var i = 0; i < oldVal.length; i++) {
					var fModel = rel.forward.relatedTo;
					var fRec = store.peekRecord(fModel, oldVal[i]);
					this.establishLink(rel.forward, rel.backward, record, fRec, undefined);
				}
			}
		},
		removePartial: function removePartial(record, key) {
			var parObj = record.$.partial;
			if (parObj && parObj[key]) {
				delete parObj[key];
			}
		},
		findCurrentInd: function findCurrentInd(model, pkVal) {
			var deleted = model._deleted;
			var handle = false,
			    currentInd,
			    finalInd;
			deleted.forEach(function (itm, idx) {
				if (handle) {
					if (itm.index < currentInd) {
						finalInd--;
					}
				}
				if (idx == pkVal) {
					handle = true;
					finalInd = currentInd = itm.index;
				}
			});
			return finalInd;
		},
		modifyDelInd: function modifyDelInd(model, pkVal) {
			var deleted = model._deleted;
			var handle = false,
			    currentInd;
			deleted.forEach(function (itm, idx) {
				if (handle) {
					if (itm.index >= currentInd) {
						itm.index = itm.index + 1;
					}
				}
				if (idx == pkVal) {
					handle = true;
					currentInd = itm.index;
				}
			});
		},
		rollBackDelete: function rollBackDelete(model, pkVal, index, inherit) {
			var arr = [],
			    modelName = model._name;
			if (!pkVal) {
				model._deleted.forEach(function (itm) {
					arr.push(itm);
				});
			} else {
				var deleted = model._deleted,
				    obj = deleted.get(pkVal),
				    pK = model._pK;
				arr = [obj];
			}
			var self = this,
			    len = arr.length;
			for (var i = len - 1; i >= 0; i--) {
				var obj = arr[i];
				var rec = obj.data;
				//var currentInd = store.$.findCurrentInd(model, pkVal);
				var isRecInModel = model.data._recMap ? model.data._recMap.get(rec.$.pK) : model.data.indexOf(rec) !== -1;
				if (Lyte.isRecord(rec)) {
					store.$.cmpSet(rec.$, "isDeleted", false);
					store.$.changePersist(rec, true);
					var isDuplicate = store.$.isDuplicateRecord(model, rec);
					if (!isRecInModel) {
						if (index) {
							self.handleArrOp(model.data, "insertAt", rec, obj.index);
							// store.$.modifyDelInd(model, pkVal);
						} else {
							self.handleArrOp(model.data, "push", rec);
						}
						model.emit("add", [rec]);
						store.emit("add", [model._name, rec]);
						var relArr = model.relations;
						if (relArr) {
							for (var key in relArr) {
								var rel = relArr[key] || [];
								rel.forEach(function (item) {
									var key = item.relKey,
									    bRel,
									    bMod,
									    data;
									// if(rec.hasOwnProperty(key)){
									bMod = store.modelFor(item.relatedTo);
									bRel = self.getBackwardRel(model, item, bMod);
									if (!item.relKey || item == bRel) {
										data = store.$.getRelatedRecord(rec, item.relatedTo, item.dummy ? item.dummy : item.relKey);
									} else {
										data = rec[item.relKey];
									}
									if (Array.isArray(data)) {
										data.forEach(function (itm, ind) {
											if (item == bRel) {
												self.establishLink(bRel, item, itm, rec, undefined, false);
											} else {
												self.establishLink(item, bRel, rec, itm, undefined, false);
											}
										});
									} else {
										if (item == bRel) {
											self.establishLink(bRel, item, data, rec, undefined, false);
										} else {
											self.establishLink(item, bRel, rec, data, undefined, false);
										}
									}
									// }
								});
							}
						}
					} else {
						store.$.addDeepNest(rec, undefined, "added");
					}
					// else if (isRecInModel){
					// 	var relArr = model.relations;
					// 	var _rel = isRecInModel.$._relationships;
					// 	for(var r in _rel){
					// 		var mdl_rec = _rel[r]
					// 		for(var _k in mdl_rec){
					// 			var records = mdl_rec[_k]
					// 			var mdl = store.modelFor(r);
					// 			var rel = mdl.fieldList[_k]
					// 			if(rel.opts && rel.opts.serialize && rel.opts.serialize == "partial"){
					// 				if(Array.isArray(records)){
					// 					records.forEach(function(rec){
					// 						var partData = rec[_k].partial;
					// 						partData.delete(pkVal);
					// 					})
					// 				}
					// 			}
					// 		}
					// 	}
					// }
					// else{
					// 	Lyte.error("Cannot rollback record of model, since another instance of same record exists in store");
					// }
					var cqueries = store.model.cachedQueries;
					if (cqueries) {
						var Nm = cqueries[modelName],
						    n = modelName;
						if (Nm && Nm.length) {
							for (var j = Nm.length - 1; j >= 0; j--) {
								var obj = Nm[j];
								if (obj && obj.hasDeletedRecords) {
									var ind = obj.data[modelName].indexOf(rec);
									if (ind != -1) {
										delete obj.hasDeletedRecords;
									}
								}
							}
						}
					}
					if (rec.$.isNew || rec.$.isModified) {
						this.checkAndAddToArray(model.dirty, rec[model._pK]);
					}
					store.$.clrRecErr(rec.$, pK, "ERR17");
					!isDuplicate ? model.data._recMap.set(_typeof(rec.$.pK) == "object" ? rec.$.pK : rec.$.pK.toString(), rec) : undefined; //old handling
					model._deleted.delete(rec.$.pK);
				}
			}
		},
		rollBackNew: function rollBackNew(model, record, pK, inherit) {
			store.$.removeFromStore(model, record.$.pK, true, inherit);
			// var pkVal = record.$.pK;
			// var index = this.getIndex(model.data, pK, pkVal);
			// store.$.toDemolishRelation(model, index);
			// this.handleArrOp(model.data,"removeAt",undefined,index,1);
			// // record.$.isNew = false;
			// store.$.cmpSet(record.$, "isNew", false);
			// store.$.cmpSet(record, "$",  {});
			// model.emit("remove", [record]);
			// store.emit("remove", [model._name,record]);
			// this.deleteFromArray(model.dirty, pkVal);
		},
		emit: function emit(type, record, attr, err) {
			record.$.emit(type, [record, attr, err]);
			record.$.model.emit(type, [record, attr, err]);
			store.emit(type, [record.$.model._name, record, attr, err]);
		},
		hasRecordsArrayChanged: function hasRecordsArrayChanged(record, attr, old) {
			var arr = old || record.$.getInitialValues(attr),
			    changed = true,
			    pK = record.$.model._pK;
			if (arr && arr.length == record[attr].length) {
				changed = false;
				for (var i = 0; i < arr.length; i++) {
					if (record[attr].indexOf(arr[i]) == -1) {
						return true;
					}
				}
			}
			return changed;
		},
		setRecErr: function setRecErr($record, field, code, value) {
			store.$.cmpSet($record, "isError", true);
			var errObj = code;
			if ((typeof errObj === 'undefined' ? 'undefined' : _typeof(errObj)) == "object") {
				store.$.cmpSet($record.error, field, errObj);
			} else {
				if (typeof code == "string") {
					var errMes = Lyte.errorCodes[code];
					if (errMes) {
						errObj = { code: code, message: Lyte.errorCodes[code] };
					} else {
						errObj = code;
					}
				}
				store.$.cmpSet($record.error, field, errObj);
				if (value) {
					store.$.cmpSet($record.error[field], "value", value);
				}
			}
			store.$.emit("error", $record.record, field, errObj);
		},
		clrRecErr: function clrRecErr($record, field, code) {
			var objUtl = Lyte.objectUtils;
			var $err = $record.error;
			if (code) {
				if ($record.error.code == code) {
					if (typeof objUtl != "undefined") {
						objUtl($err, "delete", field);
					} else {
						delete $err[field];
					}
				}
			} else if (field) {
				if (typeof objUtl != "undefined") {
					objUtl($err, "delete", field);
				} else {
					delete $err[field];
				}
			} else {
				if (typeof objUtl != "undefined") {
					for (var err in $err) {
						objUtl($err, "delete", err);
					}
				} else {
					$record.error = {};
				}
			}
			if (Object.keys($record.error).length == 0) {
				store.$.cmpSet($record, "isError", false);
			}
		},
		cacheQuery: function cacheQuery(modelName, _cacheQuery, data, status) {
			var cq = store.model.cachedQueries;
			cq = store.model.cachedQueries = cq || {};
			cq = cq[modelName] = cq[modelName] || [];
			cq.push({ cacheQuery: _cacheQuery, data: data, status: status });
		},
		cacheRecordQuery: function cacheRecordQuery(modelName, key, cacheQuery, data, status) {
			var crq = store.model.cachedRecordQueries;
			crq = store.model.cachedRecordQueries = crq || {};
			crq = crq[modelName] = crq[modelName] || {};
			crq = crq[key] = crq[key] || [];
			crq.push({ cacheQuery: cacheQuery, data: data, status: status });
		},
		isModelDataArray: function isModelDataArray(data) {
			if (Array.isArray(data) && (data.modelless || data.model && data.model instanceof Model && !data.polymorphic)) {
				return true;
			}
		},
		handleArrOp: function handleArrOp(data, type, obj, pos, len) {
			len = len != undefined ? len : 0;
			var toBind = typeof Lyte.arrayUtils != "undefined" ? true : false,
			    ret,
			    sort;
			if (data.key && data.record) {
				var fld = data.record.$.model.fieldList[data.key],
				    srtObs = false;
				if (fld && fld.opts && fld.opts.sort) {
					if (fld.opts.sort.sortFn) {
						sort = fld.opts.sort.sortFn;
						if (fld.opts.sort.observes) {
							srtObs = true;
						}
					} else {
						sort = { sortBy: fld.opts.sort.sortBy, sortOrder: fld.opts.sort.sortOrder };
					}
				}
			}
			switch (type) {
				case "push":
					{
						if (this.isModelDataArray(data)) {
							// !data.record ? data.model._pkMap.set(obj.$.pK, {pkVal : obj.$.pK}) : undefined; //for push in model data
							data._recMap == undefined ? store.$.defProp(data, "_recMap", new Map()) : undefined;
							if (!data.modelless) {
								data._recMap.set(_typeof(obj.$.pK) == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
							} else {
								data._recMap.set(obj[data.pK], obj);
							}
						}
						if (!sort) {
							ret = toBind ? Lyte.arrayUtils(data, type, obj) : data.push(obj);
						} else {
							ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.push(obj);
						}
						if (srtObs && obj && obj.$) {
							!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
						}
						break;
					}
				case "removeAt":
					{
						if (this.isModelDataArray(data)) {
							var cpyLen = len;
							for (var i = 0; i < cpyLen; i++) {
								var mpKey = undefined;
								if (!data.modelless) {
									var pkVal = data[pos + i] ? data[pos + i].$.pK : undefined;
									pkVal = (typeof pkVal === 'undefined' ? 'undefined' : _typeof(pkVal)) == "object" ? pkVal : pkVal.toString();
									mpKey = pkVal;
								} else {
									mpKey = data[pos + i][data.pK];
								}
								mpKey !== undefined && data._recMap ? data._recMap.delete(mpKey) : undefined;
							}
						}
						var _rec = data[pos];
						if (srtObs && _rec && _rec.$ && !store.$.changeRelPkMaps(_rec, undefined, undefined, "srtObsChk", data.key)) {
							_rec.$.hasOwnProperty("srtObs") ? _rec.$.srtObs = false : undefined;
						}
						ret = toBind ? Lyte.arrayUtils(data, type, pos, len) : data.splice(pos, len);
						break;
					}
				case "insertAt":
					{
						if (this.isModelDataArray(data)) {
							data._recMap == undefined ? store.$.defProp(data, "_recMap", new Map()) : undefined;
							if (!data.modelless) {
								data._recMap.set(_typeof(obj.$.pK) == "object" ? obj.$.pK : obj.$.pK.toString(), obj);
							} else {
								data._recMap.set(obj[data.pK], obj);
							}
						}
						if (!sort) {
							ret = toBind ? Lyte.arrayUtils(data, type, pos, obj) : data.splice(pos, len, obj);
						} else {
							ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.splice(pos, len, obj);
						}
						if (srtObs && obj && obj.$) {
							!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
						}
						break;
					}
				case "replaceAt":
					{
						if (!sort) {
							ret = toBind ? Lyte.arrayUtils(data, type, pos, obj) : data.splice(pos, len, obj);
						} else {
							ret = toBind ? Lyte.arrayUtils(data, "sort", sort, [obj]) : data.splice(pos, len, obj);
						}
						if (srtObs && obj && obj.$) {
							!obj.$.hasOwnProperty("srtObs") ? store.$.defProp(obj.$, "srtObs", true, false, true) : undefined;
						}
						break;
					}
				case "sort":
					{
						ret = Lyte.arrayUtils(data, "sort", sort);
						break;
					}
				default:
					{
						Lyte.error("LD07", type);
						break;
					}
			}
			return ret;
		},
		defpayObjUtls: function defpayObjUtls(obj) {
			Object.defineProperties(obj, {
				set: {
					value: store.$.payloadSet
				},
				remove: {
					value: store.$.payloadRemove
				}
			});
		},
		defPayArrUtls: function defPayArrUtls(obj) {
			Object.defineProperties(obj, {
				add: {
					value: store.$.payloadAdd
				},
				remove: {
					value: store.$.payloadRemove
				}
			});
		},
		defArrUtls: function defArrUtls(obj) {
			Object.defineProperties(obj, {
				filterBy: {
					value: store.$.filterBy
				},
				sortBy: {
					value: store.$.sortBy
				},
				mapBy: {
					value: store.$.mapBy
				}
			});
		},
		defPolyUtls: function defPolyUtls(obj) {
			Object.defineProperties(obj, {
				add: {
					value: store.$.add
				},
				remove: {
					value: store.$.remove
				}
			});
		},
		defUtls: function defUtls(obj, model, record, key) {
			if (model) {
				store.$.defProp(obj, "model", model);
				// if(model._fldGrps && model._fldGrps.hasOwnProperty("srtObs")){
				// 	store.$.defProp(obj, "srtObs", true, false, true);
				// }
			}
			if (record) {
				store.$.defProp(obj, "record", record, false, true);
			}
			if (key) {
				store.$.defProp(obj, "key", key);
			}
		},
		defPar: function defPar(arr) {
			store.$.defProp(arr, "partial", new Map());
		},
		cmpSet: function cmpSet(obj, key, value, opts, fromStore) {
			if (typeof Lyte.Component != "undefined") {
				// obj = Lyte.isRecord(obj) && obj.$.delayPersistence ? obj.$._data : obj;
				Lyte.Component.set(obj, key, value, opts, fromStore);
			} else {
				obj[key] = value;
			}
		},
		defProp: function defProp(scp, key, val, enume, write) {
			enume = !enume ? false : true;
			write = !write ? false : true;
			Object.defineProperty(scp, key, {
				value: val,
				enumerable: enume,
				writable: write
			});
		},
		removeChildRecords: function removeChildRecords(scope, record, recMap, partOnlyRem) {
			if (!recMap.get(record) && scope) {
				recMap.set(record, true);
				var pkval = record ? record.$.pK : undefined,
				    arrPK = [];
				var r = scope._fldGrps.inherit;
				for (var v in r) {
					var fkey = r[v].relKey ? r[v].relKey : undefined;
					if (record && fkey) {
						if (scope.fieldList[fkey].relType == "belongsTo" && record[scope.fieldList[fkey].relKey]) {
							this.removeChildRecords(store.modelFor(scope.fieldList[fkey].relatedTo), record[scope.fieldList[fkey].relKey], recMap);
						} else if (scope.fieldList[fkey].relType == "hasMany" && record[scope.fieldList[fkey].relKey]) {
							var len = record[scope.fieldList[fkey].relKey].length;
							for (var v1 = len - 1; v1 >= 0; v1--) {
								this.removeChildRecords(store.modelFor(scope.fieldList[fkey].relatedTo), record[scope.fieldList[fkey].relKey][v1], recMap);
							}
						}
					}
				}
				arrPK.push(pkval);
				this.removeFromStore(scope, arrPK, true, true, undefined, undefined, partOnlyRem);
			}
		},
		rBinherit: function rBinherit(scope, recmp) {
			var record = scope.record,
			    rel = scope.model._fldGrps.inherit;
			for (var v in rel) {
				if (rel[v].opts && rel[v].opts.inherit && record[rel[v].relKey]) {
					if (rel[v].relType === "belongsTo") {
						var _record = record[rel[v].relKey];
						if (_record && !recmp.get(_record)) {
							recmp.set(_record, true);
							this.rollBackRecord(_record.$, { inherit: true });
							store.$.rBinherit(_record.$, recmp);
						}
					} else if (rel[v].relType === "hasMany") {
						var rel_len = record[rel[v].relKey].length;
						if (rel_len != 0) {
							for (var j = rel_len - 1; j >= 0; j--) {
								var _record = record[rel[v].relKey][j];
								if (_record && !recmp.get(_record)) {
									recmp.set(_record, true);
									this.rollBackRecord(_record.$, { inherit: true });
									store.$.rBinherit(_record.$, recmp);
								}
							}
						}
					}
				}
			}
		},
		rollBackRecord: function rollBackRecord(scope, inherit) {
			var model = scope.model,
			    pK = model._pK;
			if (scope.isModified) {
				scope.rollBackAttributes(scope.getDirtyAttributes(), inherit);
				delete scope._savedState;
			}
			if (scope.isDeleted) {
				store.$.rollBackDelete(model, scope.get(pK), undefined, inherit);
			} else if (scope.isNew) {
				store.$.rollBackNew(model, scope.record, pK, inherit);
			} else if (scope.isError) {
				store.$.clrRecErr(scope);
			}
			store.$.removeOnSave(scope.model._name, scope.record.$.pK);
		},
		buildVariables: function buildVariables(gqlvar, variables, key, type) {
			gqlvar = gqlvar ? gqlvar : {};
			for (var v in variables) {
				if (variables[v].search(/!/g) != -1) {
					if (!gqlvar[v] && !key) {
						return { LdEr: "LD30", LyteError: "ERR30", "key": v };
					}
				}
				if (variables[v].search(/!/g) != -1) {
					variables[v] = variables[v].replace(/!/g, "");
				}
				if (key && variables[v].search(/\./g) == -1) {
					if (variables[v] == "ID" || variables[v] == "ID!") {
						gqlvar[v] = key;
					}
				}
				var ErrObj = { LdEr: "LD31", LyteError: "ERR30", "key": v };
				if (gqlvar && gqlvar[v]) {
					switch (variables[v]) {
						case "Int":
							if (typeof gqlvar[v] != "number") {
								return ErrObj;
							}
							break;
						case "String":
							if (typeof gqlvar[v] != "string") {
								return ErrObj;
							}
							break;
						case "Float":
							if (typeof gqlvar[v] != "number") {
								return ErrObj;
							}
							break;
						case "Boolean":
							if (typeof gqlvar[v] != "boolean") {
								return ErrObj;
							}
							break;
						case "Object":
							if (_typeof(gqlvar[v]) != "object") {
								return ErrObj;
							}
							break;
					}
				}
			}
			for (var t in gqlvar) {
				if (typeof gqlvar[t] == "string" || _typeof(gqlvar[t]) == "object") {
					gqlvar[t] = store.$.LyteStringfy(gqlvar[t], "");
				}
			}
			return gqlvar;
		},
		buildQuery: function buildQuery(modelName, type, fieldArr, variables, parent, qname, sendvar, key, LocalAttrs, Pmodel) {
			var str = "",
			    ignore = false;
			for (var v in fieldArr) {
				if (_typeof(fieldArr[v]) == "object") {
					str += Object.keys(fieldArr)[0] + " ";
					if (sendvar) {
						str += "( ";
						//str+=(key?"id: "+key:'')+" ";
						for (var s in sendvar) {
							if (s.search(/[.]/g) == -1 && parent == '') {
								str += s + ":" + sendvar[s] + " ";
							} else if (parent != '' && s.search(/[.]/g) != -1) {
								//var pcheck=s.replace(".","_");
								if (parent == s.match(/.*(?=\..*$)/g)[0]) {
									var split = s.split('.');
									str += split[split.length - 1] + ":" + sendvar[s] + " ";
								}
							}
						}
						str += ") ";
						str = str.replace(/\([ ]*\)/g, "");
					}
					str += "{ ";
					for (var i = 0; i < fieldArr[v].length; i++) {
						var v1 = fieldArr[v][i];
						ignore = false;
						if (LocalAttrs) {
							ignore = typeof v1 == "string" && LocalAttrs.includes(v1) && parent == "" ? true : (typeof v1 === 'undefined' ? 'undefined' : _typeof(v1)) == "object" && LocalAttrs.includes(Object.keys(v1)[0]) && parent == "" ? true : false;
						}
						if (!ignore) {
							if (typeof v1 == "string") {
								str = str + v1 + " ";
							} else {
								parent = (parent ? parent + "." : "") + Object.keys(v1)[0];
								str += store.$.buildQuery(modelName, type, v1, variables, parent, qname, sendvar, key, LocalAttrs, Pmodel);
								parent = v == qname ? "" : v;
							}
						}
					}
					str += " } ";
				}
			}
			return str;
		},
		QueryCallback: function QueryCallback(modelName, type, parent, fieldArr, variables, qstuct, qv, queryParams, urlObj) {
			var mdl;
			if ((typeof fieldArr === 'undefined' ? 'undefined' : _typeof(fieldArr)) == "object") {
				var key = Object.keys(fieldArr)[0];
				for (var i = 0; i < fieldArr[key].length; i++) {
					var v = fieldArr[key][i];
					if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) == "object" && store.modelFor(modelName).fieldList[Object.keys(v)[0]] && store.modelFor(modelName).fieldList[Object.keys(v)[0]].relatedTo) {
						mdl = store.modelFor(modelName).fieldList[Object.keys(v)[0]].relatedTo;
						store.$.QueryCallback(mdl, type, parent, v, variables, qstuct, qv, queryParams, urlObj);
					}
				}
				//console.log("selfquery",modelName,fieldArr,variables);
				var res = store.$.initCB("serializer", modelName, "serializeSelfQuery", { args: [modelName, type, urlObj, fieldArr, variables, qstuct] });
				if (res) {
					var qst = res.data[Object.keys(fieldArr)[0]];
					fieldArr[Object.keys(fieldArr)[0]] = qst;
				}
			}
			// modelName=parent;
		},
		buildFields: function buildFields(modelName, parent, key, pModel, marr, properties) {
			var mdl = store.modelFor(modelName),
			    mdlfl = mdl.fieldList;
			var LocalAttrs = mdl.gql && mdl.gql.localAttrs ? mdl.gql.localAttrs : [];
			if (!properties) {
				marr.set(modelName, true);
			} else {
				mdlfl = properties;
			}
			var obj = {},
			    arr = [];
			for (var v in mdlfl) {
				if (!LocalAttrs.includes(v)) {
					if (mdlfl[v].type == "relation") {
						if (store.modelFor(mdlfl[v].relatedTo) && mdlfl[v].relatedTo != pModel && mdlfl[v].relatedTo != modelName) {
							var check = store.$.getBackwardRel(store.modelFor(modelName), mdlfl[v], store.modelFor(mdlfl[v].relatedTo));
							if (check && check.relatedTo == parent && check.dummy == undefined) {
								continue;
							} else {
								var flag = 0;
								// for(var item =0; item<marr.length;item++){
								// 	var check_=store.$.getBackwardRel(store.model[modelName],mdlfl[v],store.model[marr[item]]);
								// 	if(check_ && check_.relatedTo==modelName && check_.dummy == undefined){
								// 		flag=1;
								// 	}
								// }
								if (!marr.has(mdlfl[v].relatedTo)) {
									arr.push(store.$.buildFields(mdlfl[v].relatedTo, mdlfl[v].relatedTo, v, pModel, marr));
								}
							}
						}
						continue;
					} else if (mdlfl[v].type == "object" && mdlfl[v].properties) {
						arr.push(store.$.buildFields(modelName, parent, v, pModel, marr, mdlfl[v].properties));
					} else {
						arr.push(v);
					}
				}
			}
			obj[key] = arr;
			marr.delete(modelName);
			return obj;
		},
		parseQuery: function parseQuery(modelName, key, type, queryParams, gqlObj, mdlq, gqlvar, urlObj, LocalAttrs, payLoad, customData) {
			var qstr,
			    qv,
			    qlvar = {},
			    ret = {},
			    sendvar,
			    qkey = {};
			if ((typeof mdlq === 'undefined' ? 'undefined' : _typeof(mdlq)) == "object") {
				var qstuct, sq, mparent, k;
				var k = Object.keys(mdlq.query);
				var queryName = k[0] != "variables" ? k[0] : k[1];
				qv = Object.assign({}, mdlq.query.variables);
				qkey[k[0] != "variables" ? k[0] : k[1]] = Object.assign(mdlq.query[k[0] != "variables" ? k[0] : k[1]]);
				if ((typeof qkey === 'undefined' ? 'undefined' : _typeof(qkey)) == "object") {
					qstuct = qkey;
				}
			}
			if (typeof mdlq == "string" && mdlq.search(/[ ]/g) != -1) {
				var cquery = mdlq,
				    cvar = {},
				    qst = '';
				cquery = cquery.replace(new RegExp('\n', 'g'), " ");
				cquery = cquery.replace(/ *[ ]*\(/g, ":{variables:[");
				cquery = cquery.replace(/ *\) *{/g, "],attrs:[");
				cquery = cquery.replace(/\w+/g, '"$&"');
				cquery = cquery.replace(/"!/g, '!"');
				cquery = cquery.replace(/" +"/g, '", "');
				cquery = cquery.replace(/\S+{"variables"/g, "{$&");
				cquery = cquery.replace(/} *"/g, '}, "');
				cquery = cquery.replace(/" *{/g, '" :{"attrs" :[');
				cquery = cquery.replace(/\} *\}/g, "]}}");
				cquery = cquery.replace(/" *}/g, '"]} }');
				cquery = cquery.replace(/]}}/g, "]}}]}}");
				cquery = cquery.replace(/]}}]}} *}/g, "]}}]}}]}}");
				cquery = cquery.replace(/} *{/g, "},{");
				cquery = cquery.replace(/\S+ *:{"attrs"/g, "{$&");
				cquery = JSON.parse(cquery);
				qstuct = store.$.buildQueryFields(cquery, cvar, qst, Object.keys(cquery)[0]);
				qv = cvar;
			}
			if ((typeof qstuct === 'undefined' ? 'undefined' : _typeof(qstuct)) == "object") {
				store.$.QueryCallback(modelName, type, modelName, qstuct, gqlvar, qstuct, qv, queryParams, urlObj);
				gqlObj.query = qstuct;
				if (gqlvar) {
					gqlObj.variables = gqlvar;
				}
				var qvkey = Object.keys(qv)[0];
				gqlObj.type == "Mutation" && Object.keys(qv).length == 1 && (qv[qvkey] == "Object" || qv[qvkey] == "Object!") ? gqlObj.variables[qvkey] = payLoad : gqlObj.variables;
				var res = store.$.initCB("serializer", modelName, "serializeGqlQuery", { args: [modelName, type, key, gqlObj, urlObj, payLoad, customData] });
				if (res) {
					qstuct = res.data.query;
					if (res.data.variables) {
						gqlvar = res.data.variables;
					}
				}
				sendvar = store.$.buildVariables(gqlvar, qv, key, urlObj.type);
				if (sendvar && sendvar.LdEr) {
					return sendvar;
				}
				urlObj.gqlObj = gqlObj;
				qstr = store.$.buildQuery(modelName, type, qstuct, qv, '', Object.keys(qstuct)[0], Object.keys(sendvar).length != 0 ? sendvar : undefined, key, LocalAttrs, modelName);
				qstr = '{ ' + qstr + ' }';
			}
			gqlObj.type == "Query" ? ret.query = qstr : ret.query = 'mutation ' + qstr;
			return ret;
		},
		graphQlconfig: function graphQlconfig(modelName, key, type, queryParams, oprName, gqlvar, urlObj, payLoad, customData) {
			var gQobj = {},
			    model = store.modelFor(modelName),
			    mdlq,
			    mdq,
			    gqlObj = {},
			    mp = new Map();
			var LocalAttrs = model.gql && model.gql.localAttrs ? model.gql.localAttrs : [];
			if (type == "findAll" || type == "findRecord") {
				gqlObj.type = "Query";
				mdq = model.gql && model.gql.query && model.gql.query[oprName] ? model.gql.query[oprName] : oprName;
				if (mdq === undefined) {
					var stq = store.$.buildFields(modelName, null, modelName, modelName, mp);
					mdlq = {};
					mdlq.query = stq;
					gqlObj.queryType = "default";
				} else {
					if (typeof oprName == "string" && oprName.search(/[ ]/g) != -1) {
						mdlq = oprName;
						gqlObj.queryType = "query";
					} else if ((typeof oprName === 'undefined' ? 'undefined' : _typeof(oprName)) == "object") {
						mdlq = oprName;
					} else if ((typeof mdq === 'undefined' ? 'undefined' : _typeof(mdq)) == "object") {
						mdlq = mdq;
					} else {
						if (typeof mdq == "string" && mdq.search(/[ ]/g) != -1) {
							mdlq = mdq;
							gqlObj.queryType = "namedQuery";
							gqlObj.queryName = oprName;
						} else {
							return { LdEr: "LD32", LyteError: "ERR31", key: oprName };
						}
					}
				}
				gqlvar = gqlvar ? Object.assign({}, gqlvar) : undefined;
			} else {
				gqlObj.type = "Mutation";
				mdq = model.gql && model.gql.mutation && model.gql.mutation[oprName] ? model.gql.mutation[oprName] : oprName;
				if (typeof oprName == "string" && oprName.search(/[ ]/g) != -1) {
					mdlq = oprName;
					gqlObj.mutationType = "customMutation";
				} else {
					if (typeof mdq == "string" && mdq.search(/[ ]/g) != -1) {
						mdlq = mdq;
						gqlObj.mutationType = "namedMutation";
						gqlObj.MutationName = oprName;
					} else {
						return { LdEr: "LD32", LyteError: "ERR31", key: oprName };
					}
				}
			}
			var sendQuery = store.$.parseQuery(modelName, key, type, queryParams, gqlObj, mdlq, gqlvar, urlObj, LocalAttrs, payLoad, customData);
			if (!sendQuery.LdEr) {
				gQobj.data = JSON.stringify(sendQuery);
				return gQobj.data;
			}
			return sendQuery;
		},
		setQuery: function value(scope, key, type, Query) {
			var model = scope;
			if (model.gql) {
				model.gql[type] = model.gql[type] ? model.gql[type] : {};
				model.gql[type][key] = model.gql[type][key] ? model.gql[type][key] : {};
			} else {
				model.gql = {};
				model.gql[type] = {};
				model.gql[type][key] = {};
			}
			model.gql[type][key] = Query;
		},
		buildQueryFields: function buildQueryFields(fields, variable, parent, objkey) {
			var key = Object.keys(fields)[0],
			    arr = [],
			    query = {};
			if (fields[key].variables) {
				for (var i = 0; i < fields[key].variables.length; i = i + 2) {
					variable[(parent ? parent + "." : "") + fields[key].variables[i]] = fields[key].variables[i + 1];
				}
			}
			for (var q = 0; q < fields[key].attrs.length; q++) {
				if (_typeof(fields[key].attrs[q]) == "object") {
					parent = (parent ? parent + "." : "") + Object.keys(fields[key].attrs[q])[0];
					arr.push(this.buildQueryFields(fields[key].attrs[q], variable, parent, objkey));
					parent = key != objkey ? key : "";
				} else {
					arr.push(fields[key].attrs[q]);
				}
			}
			query[key] = arr;
			return query;
		},
		LyteStringfy: function LyteStringfy(object, string, fs) {
			if (typeof object == "string") {
				return '\"' + object + '"\ ';
			} else if (Array.isArray(object)) {
				string += '[';
				var i = 0,
				    len = object.length;
				object.forEach(function (val) {
					i++;
					if (typeof val == "string") {
						string = string + '\"' + val + '"\ ';
					} else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object") {
						string = store.$.LyteStringfy(val, string);
					} else if (typeof val == "number") {
						string = string + object.toString();
					}
					string = i != len ? string + ',' : string;
				});
				string += ']';
			} else if (object && !Array.isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == "object") {
				string = string + '{';
				var j = 0;
				for (var i in object) {
					j++;
					if (typeof object[i] == "string") {
						string = string + i + ' : \"' + object[i] + '"\ ';
					} else if (_typeof(object[i]) == "object") {
						string = string + i + " : ";
						string = store.$.LyteStringfy(object[i], string);
					} else {
						string = string + i + ' : ' + object[i].toString();
					}

					if (Object.keys(object).length != j) {
						string = string + ', ';
					}
				}
				string = string + '}';
			} else {
				return object.toString();
			}
			return string;
		},
		cpdGql: function cpdGql(modelName, type, qp, urlObj, changedData, customData) {
			var createdVariables = [];
			if (urlObj.gql) {
				if (_typeof(urlObj.gql) == "object") {
					mutName = urlObj.gql.mutation;
				} else if (urlObj.gql == true) {
					mutName = undefined;
				}
				urlObj.data = store.$.graphQlconfig(modelName, undefined, type, qp, mutName, createdVariables, urlObj, changedData, customData);
			}
		},
		payloadAdd: function payloadAdd(key, index) {
			if (!Array.isArray(key)) {
				key = [key];
			}
			var modelName = this._model,
			    partObj = this._partialObj,
			    payload = this._payloadObj;
			var field = { opts: { serialize: this._serialize } };
			var _pk = {},
			    partial = {};
			for (var i = 0; i < key.length; i++) {
				if (partObj._removedRecords && partObj._removedRecords.hasOwnProperty(key[i])) {
					_pk = partObj._removedRecords[key[i]]._payload;
					partial = partObj._removedRecords[key[i]]._partial;
					delete partObj._removedRecords[key[i]];
				} else {
					var record = store.peekRecord(modelName, key[i]);
					var data = store.$.PayloadSerialize(field, _pk, record, undefined, store.modelFor(modelName), partial);
					_pk = data.payload;
					partial = data.partial;
				}
				if (!this.partRecMap.get(key[i])) {
					if (index != undefined && typeof index == "number") {
						Lyte.arrayUtils(partObj, "insertAt", index, partial);
						Lyte.arrayUtils(payload, "insertAt", index, _pK);
						index = index++;
					} else {
						Lyte.arrayUtils(partObj, "push", partial);
						Lyte.arrayUtils(payload, "push", _pk);
					}
					this.partRecMap.set(key[i], true);
				}
			}
		},
		payloadRemove: function payloadRemove(key) {
			var modelName = this._model,
			    partObj = this._partialObj,
			    payload = this._payloadObj;
			if (!Array.isArray(key)) {
				key = [key];
			}
			for (var j = 0; j < key.length; j++) {
				if (Array.isArray(payload)) {
					var len = payload.length;
					if (this._serialize && this._serialize == "id") {
						if (payload.includes(key[j])) {
							var _index = payload.indexOf(key[j]);
							payload.splice(_index, 1);
						}
					} else {
						for (var i = 0; i < len; i++) {
							if (partObj[i] && partObj[i].$.pkVal == key[j]) {
								!partObj.hasOwnProperty("_removedRecords") ? Object.defineProperties(partObj, { _removedRecords: { value: _defineProperty({}, partObj[i].$.pkVal, { _partial: partObj[i], _payload: payload[i] }) } }) : partObj._removedRecords[partObj[i].$.pkVal] = { _partial: partObj[i], _payload: payload[i] };
								Lyte.arrayUtils(partObj, "removeAt", i, 1);
								Lyte.arrayUtils(payload, "removeAt", i, 1);
								this.partRecMap.delete(key[j]);
							}
						}
					}
				} else {
					if (payload[key[j]]) {
						partObj.hasOwnProperty("_removedAttr") && !partObj._removedAttr.hasOwnProperty(key[j]) ? partObj._removedAttr[key[j]] = { _partial: partObj[key[j]], _payload: payload[key[j]] } : !partObj.hasOwnProperty("_removedAttr") ? Object.defineProperties(partObj, { _removedAttr: { value: { _partial: partObj[key[j]], _payload: payload[key[j]] } } }) : undefined;
						if (partObj[key[j]]) {
							partObj._removedAttr[key[j]]._partial = partObj[key[j]];
							Lyte.objectUtils(partObj, "delete", key[j]);
						}
						Lyte.objectUtils(payload, "delete", key[j]);
					}
				}
			}
		},
		payloadSet: function payloadSet(fkey) {
			if (!Array.isArray(fkey)) {
				fkey = [fkey];
			}
			var modelName = this._model,
			    pk = this._pkVal,
			    model = store.modelFor(modelName),
			    payload = this._payloadObj;
			var record = store.peekRecord(modelName, pk),
			    partial = this._partialObj;
			for (var i_key = 0; i_key < fkey.length; i_key++) {
				var key = fkey[i_key];
				if (!this._payloadObj[key]) {
					if (partial.hasOwnProperty("_removedAttr")) {
						if (partial._removedAttr.hasOwnProperty(key) && partial._removedAttr[key] != true) {
							payload[key] = partial._removedAttr[key]._payload;
							if (partial._removedAttr[key]._partial) {
								partial[key] = partial._removedAttr[key]._partial;
							}
							Lyte.objectUtils(partial._removedAttr, "delete", key);
							return;
						}
					}
					var field = model.fieldList[key];
					if (record[key] && field.type == "relation") {
						if (field.relType == "hasMany") {
							partial[key] = [];
							payload[key] = [];
							if (field.opts && field.opts.serialize == "id") {
								store.$.payLoadIdSerialize(payload, key, record, model, field, partial);
							}
							store.$.defProp(payload[key], "$", {});
							store.$.defPayArrUtls(payload[key].$);
							Object.defineProperties(payload[key].$, {
								_key: {
									value: field.relKey
								},
								_partialObj: {
									value: partial[key]
								},
								_model: {
									value: field.relatedTo
								},
								_payloadObj: {
									value: payload[key]
								},
								replace: {
									value: store.$.replaceCheck,
									writable: true
								},
								partRecMap: {
									value: new Map()
								}
							});
							if (field.opts && field.opts.serialize && !payload[key].$.serialize) {
								Object.defineProperty(payload[key].$, "_serialize", {
									value: field.opts.serialize
								});
							}
							if (field.opts && field.opts.serialize != "id" || !field.opts) {
								if (field.opts.serialize == "record") {
									for (i = 0; i < record[key].length; i++) {
										payload[key].$.add(record[key][i].$.pK);
									}
								}
								if (field.opts.serialize == "partial") {
									var dirtyRecords = record[key].partial;
									dirtyRecords.forEach(function (value, pk) {
										payload[key].$.add(pk);
									});
								}
							}
						} else {
							partial[key] = {};
							payload[key] = {};
							var data = store.$.PayloadSerialize(field, payload[key], record[key], key, store.modelFor(field.relatedTo), partial[key]);
							payload[key] = data.payload;
							partial[key] = data.partial;
						}
					} else {
						payload[key] = record[key];
						partial[key] = record[key];
					}
				}
			}
		},
		payLoadIdSerialize: function payLoadIdSerialize(payload, key, record, model, field, partial) {
			var rel = {};
			payload[key] = Lyte.deepCopyObject(record[key]);
			store.$.getRelations(model, key, store.modelFor(field.relatedTo), rel);
			store.$.idSerialize(payload, rel, undefined, partial);
		},
		PayloadSerialize: function PayloadSerialize(field, payload, record, key, model, partial) {
			var getPayloadData = _typeof(record.$.pK) == "object" ? record.$.pK : _defineProperty({}, record.$.model._pK, record.$.pK);
			var mdl = model;
			var data,
			    part,
			    isModifiedFlag = false;
			if (field.opts && field.opts.serialize) {
				part = store.adapter.$.initPartialObj(model._name);
				if (field.opts.serialize == "record") {
					getPayloadData = store.$.toJSON(model._name, record, undefined, undefined, part);
				}
				if (field.opts.serialize == "partial") {
					var dirty = store.$.isDirty(record, mdl.relations);
					var rec = record;
					if (rec.$.isModified || dirty && dirty.length) {
						data = store.$.updateJSON(rec, mdl, dirty);
						getPayloadData = store.$.toJSON(model._name, data, undefined, undefined, part);
						isModifiedFlag = true;
					} else {
						part.obj.set(record.$.pK, partial);
					}
				}
				partial = part.obj.get(record.$.pK) || partial;
				var partobj = {
					pkVal: {
						value: record.$.pK
					},
					type: {
						value: "related"
					},
					model: {
						value: mdl._name
					},
					record: {
						value: record[key] || record
					}
				};
				if (isModifiedFlag == true) {
					partobj.type.value = "modified";
				}
				if (getPayloadData) {
					payload = store.adapter.$.serializeRecords(model._name, getPayloadData, record, undefined, "serializeRecord", undefined, part.obj);
				}
				if (field.opts && field.opts.serialize == "id") {
					getPayloadData = record.$.pK;
				}
				if ((typeof payload === 'undefined' ? 'undefined' : _typeof(payload)) == "object") {
					if (partial && !partial.$) {
						store.$.defProp(partial, "$", {});
					}
					var nPartial = partial.$;
					Object.defineProperties(nPartial, partobj);
					if (field.opts && field.opts.serialize && payload.$ && !payload.$._serialize && field.relType == "belongsTo") {
						Object.defineProperty(payload.$, "_serialize", {
							value: field.opts.serialize
						});
					}
				}
				var data = {
					"payload": payload,
					"partial": partial
				};
				return data;
			}
		},
		replaceCheck: function replaceCheck(bool) {
			store.$.defProp(this._partialObj, "replace", bool);
		},
		savingDonorRecord: function savingDonorRecord(scope) {
			var donor = scope.donor,
			    dirtAttr = scope.getDirtyAttributes(),
			    relDirty = store.$.isDirty(scope.record, scope.model.relations);
			if (relDirty.length || dirtAttr.length) {
				var state = scope.toJSON("state");
				store.$.setData(donor.$, state, undefined, undefined, undefined, undefined, true);
				scope.persist();
			}
			return donor.$;
		}
	}
};

function Adapter(attrs, opts, name) {
	var self = this;
	Object.defineProperty(self, '$lg', {
		value: Lyte.__gl
	});
	store.$.newCB("adapter", this, name, attrs, opts);
}
store.$.cbDef(Adapter, "adapter");
store.adapter = {
	$: {
		buildURL: function buildURL(type, method, modelName, key, snapshot, queryParams, actionName, customData, url, gqlEnables) {
			var adapter = store.$.getAdapter({ name: modelName }),
			    host = store.$.getFromCB("adapter", modelName, "host"),
			    url = url || "",
			    makeBatch = store.$.makeBatch;
			// var modelless = store.$.getFromCB("adapter",modelName,"modelless"), name;	
			// if(typeof modelName == "string" && modelless){
			// 	name = modelName;
			// }
			url = url || "";
			var ret = { method: method };
			if (!url) {
				if (!makeBatch) {
					if (host !== undefined) {
						url += host;
						if (host[host.length - 1] != "/") {
							url += "/";
						}
					}
				}
				// enable = store.$.getFromCB("adapter",modelName,"enableGraphQl");
				// var check = store.$.enableGraphql(enable,type,enableGQl); 
				// var check = store.$.initCB("adapter", modelName, "GraphQl", {args:[modelName,type,queryParams,key,{query:oprName,variables:gqlVariables},customData]});
				if (!gqlEnables) {
					var namespace = store.$.getFromCB("adapter", modelName, "namespace");
					if (namespace !== "" && namespace[namespace.length - 1] != "/") {
						url += namespace + "/";
					} else {
						url += namespace;
					}
					if (type != "batch") {
						url += modelName;
						if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != "object") {
							url += "/" + key;
						}
					}
					if (type == "action") {
						url += "/" + store.$.getFromCB("adapter", modelName, "actionNamespace");
						var actions = store.modelFor(modelName).actions,
						    action = actions[actionName].endPoint ? actions[actionName].endPoint : actionName;
						url += "/" + action;
					} else if (type == "batch") {
						url += store.$.getFromCB("adapter", "application", "batchNamespace");
					}
					ret.method = method ? method : "";
				} else {
					ret.method = "POST";
					ret.gql = gqlEnables;
					method = ret.method;
					var gqlNamespace = store.$.getFromCB("adapter", modelName, "gqlNamespace");
					url += gqlNamespace ? gqlNamespace : "";
				}
			}
			if (!queryParams) {
				queryParams = {};
			}
			var res = store.$.initCB("adapter", modelName, "headersForRequest", { args: [type, queryParams, customData, actionName, key] });
			if (res) {
				ret.headers = res.data;
			}

			res = store.$.initCB("adapter", modelName, "buildURL", { args: [modelName, type, queryParams, snapshot, url, actionName, customData, key] });
			if (res) {
				url = res.data;
			}

			res = store.$.initCB("adapter", modelName, "methodForRequest", { args: [method, type, queryParams, customData, actionName, key] });
			if (res) {
				ret.method = res.data;
			}
			if (!makeBatch && queryParams && Object.keys(queryParams).length) {
				url += "?";
				var index = 0;
				for (var qKey in queryParams) {
					if (index !== 0) {
						url += "&";
					}
					var res = queryParams[qKey];
					if (res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) == "object") {
						res = JSON.stringify(res);
					}
					url += qKey + "=" + encodeURIComponent(res);
					index++;
				}
			}
			if (adapter && adapter.withCredentials == true) {
				ret.withCredentials = true;
			}
			ret.url = url;
			ret.qP = queryParams;
			return ret;
		},
		get: function get(type, modelName, key, queryParams, cacheQuery, customData, cacheData, oprName, gqlVariables) {
			var mdl = store.modelFor(modelName),
			    makeBatch = store.$.makeBatch,
			    gqlEnables,
			    gqlobj = gqlVariables || oprName ? {} : undefined,
			    modelless = store.$.getFromCB("adapter", modelName, "modelless");
			if (modelless && typeof modelName == "string") {
				var defobj = store.modelless,
				    _name = modelName;
				def = defobj[_name] = defobj[_name] || {};
				def._name = _name;
			}
			if (mdl || modelName && modelless) {
				customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
				oprName ? gqlobj.query = oprName : undefined;
				gqlVariables ? gqlobj.variables = gqlVariables : undefined;
				gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, queryParams, key, gqlobj, customData] });
				var urlObj = this.buildURL(type, "GET", modelName, key, undefined, queryParams, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined),
				    self = this;
				queryParams = urlObj.qP, toCheckParams = cacheQuery && typeof cacheQuery !== "boolean" ? cacheQuery : queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" ? queryParams : undefined;
				if (urlObj.gql) {
					if (_typeof(urlObj.gql) == "object") {
						oprName = urlObj.gql.query, gqlVariables = urlObj.gql.variables;
					} else if (urlObj.gql === true) {
						oprName = gqlVariables = undefined;
					}
					urlObj.data = store.$.graphQlconfig(modelName, key, type, queryParams, oprName, gqlVariables, urlObj);
					if (urlObj.data.LdEr) {
						Lyte.warn(urlObj.data.LdEr, urlObj.data.key, modelName);
						return Promise.reject({ code: urlObj.data.LyteError, message: Lyte.errorCodes[urlObj.data.LyteError], data: urlObj.data.key });
					}
				}
				if (type == "findAll" && toCheckParams && store.model.cachedQueries && store.model.cachedQueries[modelName]) {
					var cachedQueries = store.model.cachedQueries[modelName],
					    sendData;
					for (var i = 0; i < cachedQueries.length; i++) {
						var qry = cachedQueries[i];
						if (!qry.hasDeletedRecords) {
							var params = qry.cacheQuery;
							if (this.compareData(params, toCheckParams, true)) {
								sendData = [qry.data, "cache", undefined, qry.status];
								break;
							}
						}
					}
					if (sendData) {
						return new Promise(function (resolve) {
							if (makeBatch) {
								store.$.addToCachedBatch(Array.isArray(sendData) ? sendData[0][modelName] : sendData);
							}
							resolve(sendData);
						});
					}
				} else if (type == "findRecord" && toCheckParams && store.model.cachedRecordQueries && store.model.cachedRecordQueries[modelName] && store.model.cachedRecordQueries[modelName][key]) {
					var cachedQueries = store.model.cachedRecordQueries[modelName][key],
					    sendData;
					for (var i = 0; i < cachedQueries.length; i++) {
						var params = cachedQueries[i].cacheQuery;
						if (this.compareData(params, toCheckParams, true)) {
							sendData = [cachedQueries[i].data, "cache", undefined, cachedQueries[i].status];
							break;
						}
					}
					if (sendData) {
						return new Promise(function (resolve) {
							if (makeBatch) {
								store.$.addToCachedBatch(Array.isArray(sendData) ? sendData[0][modelName] : sendData);
							}
							resolve(sendData);
						});
					}
				} else {
					var scope = store.$.cbScp(modelName, type == "findRecord" ? "reloadRecord" : "reloadAll", "adapter");
					if (scope) {
						var records,
						    callReload = false;
						if (type == "findRecord") {
							records = store.peekRecord(modelName, key);
							callReload = Lyte.isRecord(records) ? true : false;
						} else if (type == "findAll") {
							records = store.peekAll(modelName);
							callReload = records && records.length ? true : false;
						}
						if (callReload && !store.$.cB(scope, [records, queryParams, customData, modelName])) {
							var toRet = {};
							toRet[modelName] = records;
							return new Promise(function (resolve) {
								if (makeBatch) {
									store.$.addToCachedBatch(toRet[modelName]);
								}
								resolve([toRet, "cache"], "success", undefined, true);
							});
						}
					}
				}
				if (urlObj.method == "POST") {
					var res = store.$.initCB("serializer", modelName, "serialize", { args: [type, urlObj ? urlObj.data : undefined, undefined, customData, modelName, queryParams, undefined, urlObj ? urlObj.gqlObj : undefined] });
					if (res) {
						urlObj.data = res.data;
						if (urlObj.data && (_typeof(urlObj.data) == "object" || Lyte.isRecord(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)) {
							// urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
							urlObj.data = JSON.stringify(urlObj.data);
						}
					}
				}
				return new Promise(function (resolve, reject) {
					var model = store.modelFor(modelName);
					var idbObj = store.$.getIDBObj(model, queryParams, type, key, customData);
					var processRequest = store.$.getFromCB("adapter", modelName, "processRequest"),
					    payLoad,
					    sendXHR = true;
					var batchPro = false;
					var argsXHR = [modelName, type, key, urlObj, resolve, reject, "get", undefined, customData];
					var opts = { cacheQuery: cacheQuery, cacheData: cacheData, customD: customData };
					if (processRequest) {
						sendXHR = false;
						var returnPromise = self.callGeneric(type, modelName, undefined, undefined, customData, queryParams, key, urlObj.url, undefined, urlObj.method, urlObj.headers);
						if (returnPromise instanceof Promise) {
							batchPro = true;
							returnPromise.then(function (resp) {
								resp = resp == "" ? JSON.parse("{}") : JSON.parse(resp);
								payLoad = self.getResponse(resp, modelName, type, key, urlObj, undefined, customData, opts);
								resolve([payLoad]);
							}, function (message) {
								reject(message);
							});
						} else {
							sendXHR = true;
						}
					}
					if (makeBatch && !batchPro) {
						store.adapter.$.constructBatch.apply(store.adapter.$, argsXHR).then(function (resObj) {
							var payLoad = resObj.content;
							store.adapter.$.getSuccess(modelName, type, key, urlObj, undefined, resolve, reject, payLoad, resObj, undefined, opts);
							//resolve(payLoad);							
						}, function (resObj) {
							store.adapter.$.getFailure(modelName, type, key, urlObj, undefined, resolve, reject, opts, resObj.content, resObj.code, resObj);
						});
					} else if (idbObj) {
						store.adapter.$.getFromIDB(idbObj, modelName, type, queryParams, key, urlObj, customData).then(function (payLoad) {
							var res = store.$.initCB("serializer", modelName, "idbResponse", { args: [modelName, type, queryParams, key, payLoad] });
							if (res) {
								payLoad = res.data;
							}
							if (payLoad == false) {
								store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
									store.adapter.$.getSuccess(modelName, type, key, urlObj, xhrReq, resolve, reject, undefined, undefined, undefined, opts);
								}, function (xhrReq) {
									store.adapter.$.getFailure(modelName, type, key, urlObj, xhrReq, resolve, reject, opts);
								});
							} else {
								store.adapter.$.getSuccess(modelName, type, key, urlObj, undefined, resolve, reject, payLoad, undefined, "idb", opts);
							}
						}, function (message) {
							store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
								store.adapter.$.getSuccess(modelName, type, key, urlObj, xhrReq, resolve, reject, undefined, undefined, undefined, opts);
							}, function (xhrReq) {
								store.adapter.$.getFailure(modelName, type, key, urlObj, xhrReq, resolve, reject, opts);
							});
						});
					} else if (sendXHR) {
						store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
							store.adapter.$.getSuccess(modelName, type, key, urlObj, xhrReq, resolve, reject, undefined, undefined, undefined, opts);
						}, function (xhrReq) {
							store.adapter.$.getFailure(modelName, type, key, urlObj, xhrReq, resolve, reject, opts);
						});
					}
				});
			} else {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
		},
		constructBatch: function constructBatch(modelName, type, key, urlObj) {
			return new Promise(function (resolve, reject) {
				var batch = store.$.currentBatch;
				var q = store.$.batch[batch] = store.$.batch[batch] || [];
				var pro = store.$.batchPromise[batch] = store.$.batchPromise[batch] || [];
				var batchObj = {};
				batchObj.method = urlObj.method;
				batchObj.uri = "/" + urlObj.url;
				batchObj.parameters = urlObj.qP;
				batchObj.content = typeof urlObj.data == "string" ? JSON.parse(urlObj.data) : undefined;
				q.push(batchObj);
				pro.push({ resolve: resolve, reject: reject });
			});
		},
		getFromIDB: function getFromIDB(idbObj, modelName, type, queryParams, key, urlObj, customData) {
			return new Promise(function (resolve, reject) {
				var reqType = idbObj.queryCache ? "getCachedData" : type == "findAll" ? "getAll" : "get";
				var obj = { resolve: resolve, reject: reject, type: reqType, model: modelName, req: type, key: key };
				if (reqType == "getCachedData") {
					obj.queryParams = queryParams;
				}
				obj.queryCache = idbObj.queryCache;
				obj.customData = customData;
				LyteIDB.postMessage(obj);
			});
		},
		sendXHR: function sendXHR(modelName, type, key, urlObj, resolve, reject, xhrType, data, customData) {
			var xhr = new XMLHttpRequest();
			var prm = new Promise(function (res, rej) {
				xhr.open(urlObj.method, urlObj.url, true);
				for (var header in urlObj.headers) {
					xhr.setRequestHeader(header, urlObj.headers[header]);
				}
				xhr.withCredentials = urlObj.withCredentials ? true : false;
				store.$.initCB("adapter", modelName, "parseRequest", { args: [type, modelName, xhr, urlObj ? urlObj.qP : undefined, key, customData] });
				store.emit("beforeRequest", [xhr, modelName, type, key, urlObj.qP]);
				xhr.send(urlObj.data);
				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						store.emit("afterRequest", [xhr, modelName, type, key, urlObj.qP]);
						if (xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3") {
							return res(xhr);
						} else {
							return rej(xhr);
						}
					}
				};
			});
			prm.xhr = xhr;
			return prm;
		},
		getSuccess: function getSuccess(modelName, type, key, urlObj, xhr, resolve, reject, response, resObj, from, opts) {
			var resp = response,
			    req = xhr,
			    batchIndex,
			    batch,
			    customD = opts.customD,
			    status = xhr ? xhr.status : undefined;;
			if (from != "idb") {
				if (req) {
					resp = req.responseText;
					if (resp && resp.length != 0) {
						resp = JSON.parse(resp);
					} else {
						resp = JSON.parse("{}");
					}
				}
				if (resObj) {
					batchIndex = resObj.index;
					batch = resObj.batch;
					req = resObj.resp;
				}
				if (req) {
					var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, req, resp, urlObj ? urlObj.qP : undefined, key, customD, opts] });
					if (res) {
						resp = res.data;
					}
					if (resp instanceof Promise) {
						return this.handleParseResponsePromise(resp, modelName, type, key, urlObj, xhr, undefined, batchIndex, batch, resolve, reject, opts);
					}
				}
				return this.findParseRequestPromise(resp, modelName, type, key, urlObj, xhr, batchIndex, batch, resolve, opts);
				//resp = this.getResponse(resp,modelName,type,key,urlObj,xhr);
			}
			var resArr = xhr ? [resp, xhr.statusText, xhr] : batchIndex != undefined ? [resp, "batch", { index: batchIndex, batch: batch }] : from ? [resp, "idb"] : [resp];
			resolve(resArr);
		},
		getFailure: function getFailure(modelName, type, key, urlObj, xhr, resolve, reject, opts, content, code, bObj) {
			var customD = opts.customD;
			if (xhr) {
				var resp,
				    response = xhr.responseText;
				if (response) {
					try {
						response = response == "" ? JSON.parse("{}") : JSON.parse(response);
					} catch (exp) {
						Lyte.warn("LD24", exp);
					}
				}
				resp = response;
				var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, xhr, response, urlObj ? urlObj.qP : undefined, key, customD, opts] });
				if (res) {
					resp = res.data;
				}
				if (resp instanceof Promise) {
					return this.handleParseResponsePromise(resp, modelName, type, key, urlObj, xhr, undefined, undefined, undefined, resolve, reject, opts);
				}
			} else if (content) {
				var batch, batchIndex;
				if (bObj) {
					batchIndex = bObj.index;
					batch = bObj.batch;
				}
				store.$.batchResponse[batch][batchIndex] = { code: code, status: "requestFailure", data: content };
				reject({ code: code, status: "requestFailure", data: content });
			}
			reject(xhr);
		},
		getResponse: function getResponse(resp, modelName, type, key, urlObj, xhr, customData, opts) {
			var doNormalize = opts.cacheData !== undefined && opts.cacheData !== null && _typeof(opts.cacheData) == "object" && opts.cacheData.hasOwnProperty("normalize") ? opts.cacheData.normalize : true;
			if (doNormalize === true) {
				resp = store.serializer.$.normalizeResponse(modelName, type, resp, key, xhr ? xhr.status : xhr, urlObj, customData, opts);
				var scope,
				    payLoad = resp,
				    args,
				    qP = urlObj ? urlObj.qP : undefined;
				if ((typeof payLoad === 'undefined' ? 'undefined' : _typeof(payLoad)) != "object") {
					payLoad = JSON.parse(payLoad);
				}
				var res = store.$.initCB("serializer", modelName, "extractMeta", { args: [payLoad, modelName, type, qP, customData, opts] }),
				    metaRes;
				if (res) {
					metaRes = res.data;
					if (!store.$.isEmpty(metaRes)) {
						payLoad.meta = metaRes;
					}
				}
				var keys = Object.keys(payLoad);
				var len = keys.length;
				if (len) {
					res = store.$.initCB("serializer", modelName, "payloadKey", { args: [modelName, type, key, qP, customData, opts] });
					var plKey;
					if (res) {
						plKey = res.data;
						if (plKey && plKey != modelName) {
							var temp = payLoad[plKey];
							payLoad[modelName] = temp;
							delete payLoad[plKey];
						}
					}
					scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
					if (scope) {
						Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
						if (len > 2) {
							Lyte.error("LD09");
						}
						var index = 0;
						if (len == 2 && keys[0] == "meta") {
							index = 1;
						}
						args = [modelName, type];
						var deserializeKey = store.$.cB(scope, args),
						    rec = payLoad[keys[index]];
						delete payLoad[keys[index]];
						payLoad[deserializeKey] = rec;
					}
					store.serializer.$.normalize(modelName, type, payLoad, key, xhr ? xhr.status : xhr, urlObj.headers, customData, opts, urlObj);
				}
				return payLoad;
			} else {
				if ((typeof resp === 'undefined' ? 'undefined' : _typeof(resp)) != "object") {
					resp = JSON.parse(resp);
				}
				var res = store.$.initCB("serializer", modelName, "extractMeta", { args: [resp, modelName, type, qP, customData, opts] }),
				    metaRes;
				if (res) {
					metaRes = res.data;
					if (!store.$.isEmpty(metaRes)) {
						resp.meta = metaRes;
					}
				}
				return resp;
			}
		},
		initPartialObj: function initPartialObj(modelName, type, qP, key, url, customData) {
			var partial = { obj: new Map() };
			// partial.ref = new Map();
			// var rKey = "recId", refKey;
			// var res = store.$.initCB("serializer", modelName, "referenceKey", {args:[modelName,type,qP,key,url,customData]});
			// refKey = res ? res.data : undefined;
			// if(!store.$.isEmpty(refKey)){
			// 	rKey = refKey;
			// }
			// partial.ref.refKey = rKey;
			return partial;
		},
		create: function create(modelName, data, isSingleRecord, customData, qP, mutationName) {
			var type = isSingleRecord ? "createRecord" : "create",
			    gqlObj = mutationName ? { "mutation": mutationName } : undefined;
			var gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, qP, undefined, gqlObj, customData] }),
			    mutName,
			    createdVariables = {};
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var urlObj = this.buildURL(type, "POST", modelName, undefined, data, qP, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, undefined, urlObj.url, customData);
			var changedData = store.$.toJSON(modelName, data, undefined, "create", partial);
			this.sendingData(modelName, changedData, urlObj, type, customData, data, partial.obj);
			if (urlObj.gql) {
				store.$.cpdGql(modelName, type, qP, urlObj, changedData, customData);
			}
			return this.handleRequest(urlObj, modelName, data, type, changedData, customData, partial.obj, undefined, undefined, partial.ref);
		},
		put: function put(modelName, data, record, isSingleRecord, customData, qP, mutationName) {
			var model = store.model[modelName],
			    bK = model.bK,
			    isComp = model.isComp,
			    gqlObj = mutationName ? { "mutation": mutationName } : undefined;
			var type = isSingleRecord ? "updateRecord" : "update",
			    partialObj = new Map(),
			    key = isSingleRecord ? isComp && bK ? record[bK] : record.$.pK : undefined;
			var gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, qP, undefined, gqlObj, customData] }),
			    mutName,
			    createdVariables = {};
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var urlObj = this.buildURL(type, "PATCH", modelName, key, data, qP, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, key, urlObj.url, customData);
			var updatedData = store.$.toJSON(modelName, data, undefined, undefined, partial);
			this.sendingData(modelName, updatedData, urlObj, type, customData, record, partial.obj);
			if (urlObj.gql) {
				store.$.cpdGql(modelName, type, qP, urlObj, updatedData, customData);
			}
			return this.handleRequest(urlObj, modelName, record, type, updatedData, customData, partial.obj, undefined, undefined, partial.ref);
		},
		del: function del(modelName, data, isSingleRecord, destroy, customData, qP, mutationName) {
			var model = store.model[modelName],
			    bK = model.bK,
			    isComp = model.isComp,
			    gqlObj = mutationName ? { "mutation": mutationName } : undefined;
			var type = destroy || "deleteRecord";
			var key = isSingleRecord ? isComp && bK ? data[bK] : data.$.pK : undefined;
			customData = customData == undefined ? store.$.getFromCB("adapter", modelName, "customData") : customData;
			var gqlEnables = store.$.initCB("adapter", modelName, "gql", { args: [modelName, type, qP, undefined, gqlObj, customData] }),
			    mutName,
			    createdVariables = {};
			var urlObj = this.buildURL(type, "DELETE", modelName, key, data, qP, undefined, customData, undefined, gqlEnables ? gqlEnables.data : undefined);
			qP = urlObj.qP;
			var partial = this.initPartialObj(modelName, type, qP, key, urlObj.url, customData);
			var ids = [];
			if (!isSingleRecord) {
				ids = data.map(function (val) {
					return val.$.pK;
				});
			}
			var pkVal = isSingleRecord ? data ? data.$.pK : undefined : ids;
			this.sendingData(modelName, pkVal, urlObj, type, customData, data);
			if (urlObj.gql) {
				store.$.cpdGql(modelName, type, qP, urlObj, pkVal, customData);
			}
			return this.handleRequest(urlObj, modelName, data, type, pkVal, customData, undefined, key);
		},
		sendingData: function sendingData(modelName, data, urlObj, type, customData, snapshot, partial) {
			var serializeKey = modelName,
			    payload = {},
			    qP = urlObj ? urlObj.qP : undefined,
			    tempObj = {};
			for (var key in urlObj) {
				tempObj[key] = urlObj[key];
			}
			tempObj.type = type;
			tempObj.model = modelName;
			var res = store.$.initCB("serializer", modelName, "serializeKey", { args: [modelName, type, customData, qP] });
			if (res) {
				serializeKey = res.data;
			}
			data = this.serializeRecords(modelName, data, snapshot, tempObj, "serializeRecord", customData, partial);
			if (!serializeKey) {
				payload = data;
			} else if (Array.isArray(data) || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" || Lyte.isRecord(data)) {
				payload[serializeKey] = data;
			}
			var res = store.$.initCB("serializer", modelName, "serialize", { args: [type, payload, snapshot, customData, modelName, qP, urlObj ? urlObj.gqlObj : undefined] });
			if (res) {
				payload = res.data;
			}
			urlObj.data = payload;
		},
		serializeRecords: function serializeRecords(modelName, data, records, urlObj, type, customData, partial) {
			var modelless = store.$.getFromCB("adapter", modelName, "modelless");
			var model = store.modelFor(modelName);
			if (!model) {
				return data;
			}
			var rels = model.relations;
			if (!records && type != "normalizeRecord") {
				records = store.peekRecord(model._name, data.$.pK);
			}
			var result, partObj;
			if (Array.isArray(data)) {
				result = [];
				for (var index1 = 0; index1 < data.length; index1++) {
					var record = data[index1];
					if (record && (typeof record === 'undefined' ? 'undefined' : _typeof(record)) === "object") {
						result.push(this.serializeSingleRecord(model._name, record, records ? records[index1] : undefined, urlObj, rels, type, customData, partial));
					} else {
						result.push(record);
					}
				}
			} else if (data) {
				result = data;
				if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === "object") {
					result = this.serializeSingleRecord(model._name, data, records, urlObj, rels, type, customData, partial);
				}
			}
			return result;
		},
		serializeSingleRecord: function serializeSingleRecord(model_name, data, record, urlObj, rels, type, customData, partial) {
			var partObj;
			type == "serializeRecord" && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object" && data.$ == undefined ? store.$.defProp(data, "$", {}) : data;
			if (type == "normalizeRecord" && Lyte.isRecord(data)) {
				return data;
			}
			if ((typeof partial === 'undefined' ? 'undefined' : _typeof(partial)) == "object" && record && record.$ && record.$.pK) {
				partObj = partial.get ? partial.get(record.$.pK) : partial;
				if (data.$ && data.$._partialObj) {
					var data$;
					data$ = Object.assign({}, data.$);
					data = Object.assign({}, data);
					store.$.defProp(data, "$", data$);
				}
				var relDirty = store.$.isDirty(record, record.$.model.relations);
				if (record.$.isModified || Array.isArray(relDirty) && relDirty.length != 0) {
					var dirtAttr = record.$.getDirtyAttributes();
					Array.isArray(relDirty) && dirtAttr.concat(relDirty);
					var keys = Object.keys(data);
					!partObj.hasOwnProperty("_removedAttr") ? Object.defineProperties(partObj, { _removedAttr: { value: {} } }) : undefined;
					dirtAttr.forEach(function (val) {
						if (!keys.includes(val) && !record.$.model._arrPk.includes(val)) {
							partObj._removedAttr[val] = true;
						}
					});
				}
				Object.defineProperties(data.$, {
					_partialObj: {
						value: partObj
					},
					_pkVal: {
						value: record.$.pK
					},
					_model: {
						value: model_name
					},
					_payloadObj: {
						value: data
					}
				});
			}
			type == "serializeRecord" ? store.$.defpayObjUtls(data.$) : undefined;
			var scope = store.$.cbScp(model_name, type, "serializer");
			if (scope) {
				var args;
				if (type == "serializeRecord") {
					args = [urlObj, data, record, model_name, customData];
				} else {
					args = [urlObj, data, model_name, customData];
				}
				data = store.$.cB(scope, args);
			}
			for (var key in rels) {
				var rel = rels[key],
				    relLen = rel.length;
				for (var i = 0; i < relLen; i++) {
					var field = rel[i];
					var val = data[field.relKey],
					    recs,
					    res,
					    relTo,
					    srz,
					    isPoly;
					if (field.type == "relation" && val && (type == "normalizeRecord" || type == "serializeRecord" && field.opts && field.opts.serialize && field.opts.serialize != "id")) {
						recs = record ? record[field.relKey] : undefined, relTo = field.relatedTo, srz = field.opts ? field.opts.serialize : undefined;
						isPoly = field.opts ? field.opts.polymorphic : undefined;
						if (field.relType === "hasMany") {
							if (!Array.isArray(val)) {
								val = [val];
							}
							var valLen = val.length,
							    res = [];
							if (type == "serializeRecord") {
								store.$.defProp(res, "$", {});
								store.$.defPayArrUtls(res.$);
								if (partObj && partObj[field.relKey]) {
									Object.defineProperties(res.$, {
										_key: {
											value: field.relKey
										},
										_partialObj: {
											value: partObj[field.relKey]
										},
										_model: {
											value: relTo
										},
										_payloadObj: {
											value: res
										},
										replace: {
											value: store.$.replaceCheck,
											writable: true
										},
										partRecMap: {
											value: new Map()
										}
									});
									if (field.opts && field.opts.serialize) {
										Object.defineProperty(res.$, "_serialize", {
											value: field.opts.serialize
										});
									}
								}
							}
							for (var index1 = 0; index1 < valLen; index1++) {
								var _relTo = relTo;
								if (isPoly) {
									if (type == "normalizeRecord") {
										_relTo = val[index1] && val[index1]._type ? val[index1]._type : relTo;
									} else if (type == "serializeRecord") {
										if (srz == "record") {
											_relTo = recs && Lyte.isRecord(recs[index1]) ? recs[index1].$.model._name : relTo;
										} else if (srz == "partial") {
											_relTo = val[index1] && val[index1].$ ? val[index1].$.polymorphicType : relTo;
										}
									}
								}
								if (type == "serializeRecord") {
									var relPk = store.modelFor(relTo)._pK;
									res.$.partRecMap.set(val[index1][relPk], true);
								}
								res.push(this.serializeRecords(_relTo, val[index1], undefined, urlObj, type, customData, partObj ? partObj[field.relKey][index1] : undefined));
							}
							data[field.relKey] = res;
						} else {
							var _relTo = relTo;
							if (isPoly) {
								if (type == "normalizeRecord") {
									_relTo = data[field.relKey] && data[field.relKey]._type ? data[field.relKey]._type : relTo;
								} else if (type == "serializeRecord") {
									_relTo = Lyte.isRecord(record[field.relKey]) ? record[field.relKey].$.model._name : relTo;
								}
							}
							if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == "object" && !val.$ && field.opts && field.opts.serialize) {
								store.$.defProp(val, "$", {});
								Object.defineProperty(val.$, "_serialize", {
									value: field.opts.serialize
								});
							}
							data[field.relKey] = this.serializeRecords(_relTo, data[field.relKey], record ? record[field.relKey] : undefined, urlObj, type, customData, partObj ? partObj[field.relKey] : undefined);
						}
					} else if (type == "serializeRecord" && field.opts && field.opts.serialize && field.opts.serialize == "id" && field.type == "relation") {
						if (field.relType == "hsaMany") {
							store.$.defProp(data[field.relKey], "$", {});
							store.$.defPayArrUtls(data[field.relKey].$);
							if (partObj && partObj[field.relKey]) {
								Object.defineProperties(data[field.relKey].$, {
									_key: {
										value: field.relKey
									},
									_partialObj: {
										value: partObj[field.relKey]
									},
									_model: {
										value: relTo
									},
									_payloadObj: {
										value: data[field.relKey]
									},
									replace: {
										value: store.$.replaceCheck,
										writable: true
									}
								});
								if (field.opts && field.opts.serialize) {
									Object.defineProperty(res.$, "_serialize", {
										value: field.opts.serialize
									});
								}
							}
						}
					}
				}
			}
			return data;
		},
		handleAjax: function handleAjax(obj) {
			if (obj.url) {
				if (!obj.model) {
					Lyte.error("Please pass model param to ajax call");
					return Promise.reject("Please pass model param to ajax call");
				}
			}
			// var argsObj = { type: "ajax", schemaName : obj.schema, queryParams: obj.queryParams, customData: obj.customData}
			var urlObj = store.adapter.$.buildURL("ajax", obj.type, obj.model, obj.index, undefined, obj.queryParams, undefined, obj.customData, obj.url);
			urlObj.data = obj.data;
			var qP = urlObj.qP,
			    res = store.$.initCB("serializer", obj.model, "serialize", { args: ["ajax", urlObj.data, undefined, obj.customData, obj.model, qP, undefined] });
			// if(res){
			// 	argsObj.data = urlObj.data = res.data;
			// }
			return store.adapter.$.handleRequest(urlObj, obj.model, undefined, "ajax", undefined, obj.customData, undefined, undefined, undefined, undefined);
		},
		handleAction: function handleAction(actionName, model, record, customData, qP, method, data) {
			var pkVal;
			if (record && Lyte.isRecord(record)) {
				pkVal = record.$.get(model._pK);
			}
			var modelName = model._name,
			    type = "action";
			customData = customData == undefined ? store.$.getFromCB("adapter", model._name, "customData") : customData;
			var urlObj = this.buildURL(type, method ? method : "POST", model._name, pkVal, record, qP, actionName, customData);
			urlObj.data = data, qP = urlObj.qP;
			var res = store.$.initCB("serializer", model._name, "serialize", { args: ["action", data, record, customData, modelName, qP, actionName] });
			if (res) {
				urlObj.data = res.data;
			}
			return this.handleRequest(urlObj, model._name, undefined, type, undefined, customData, undefined, undefined, actionName);
		},
		handleRequest: function handleRequest(urlObj, modelName, data, type, changedData, customData, partialObj, key, actionName, partialRef) {
			if (urlObj.data && urlObj.data.LdEr) {
				Lyte.warn(urlObj.data.LdEr, urlObj.data.key, modelName);
				return Promise.reject({ code: urlObj.data.LyteError, message: Lyte.errorCodes[urlObj.data.LyteError], data: urlObj.data.key });
			}
			if (urlObj.data && (_typeof(urlObj.data) == "object" || Lyte.isRecord(urlObj.data) || Array.isArray(urlObj.data)) && !(urlObj.data instanceof FormData)) {
				// urlObj.reqData = Lyte.deepCopyObject(urlObj.data);
				urlObj.data = JSON.stringify(urlObj.data);
			}
			var self = this,
			    xhr,
			    key;
			return new Promise(function (resolve, reject) {
				var processRequest = store.$.getFromCB("adapter", modelName, "processRequest"),
				    sendXHR = true;
				var makeBatch = store.$.makeBatch;
				var batchPro = false;
				if (processRequest) {
					sendXHR = false;
					var returnPromise = self.callGeneric(type, modelName, urlObj.data, data, customData, urlObj ? urlObj.qP : undefined, key, urlObj.url, actionName, urlObj.method, urlObj.headers),
					    response;
					if (returnPromise instanceof Promise) {
						batchPro = true;
						returnPromise.then(function (resp) {
							if (type == "action" || type == "ajax") {
								try {
									resp = JSON.parse(resp);
								} catch (exp) {
									resp = resp;
								}
							} else {
								resp = JSON.parse(resp);
							}
							response = self.genericResponse(resp, modelName, type, data, urlObj, undefined, partialObj, customData);
							resolve(response);
						}, function (message) {
							reject(message);
						});
					} else {
						sendXHR = true;
					}
				}
				if (makeBatch && !batchPro) {
					store.adapter.$.constructBatch(modelName, type, key, urlObj).then(function (respObj) {
						var resp = respObj.content;
						store.adapter.$.handleSuccess(modelName, type, xhr, data, urlObj, resolve, resp, respObj, undefined, reject, key, customData, actionName, partialRef);
						// resolve(resp);
					}, function (resObj) {
						store.adapter.$.handleFailure(modelName, type, xhr, data, urlObj, resolve, resObj.content, undefined, reject, key, customData, resObj.code, actionName, resObj);
					});
				} else if (sendXHR) {
					var argsXHR = [modelName, type, key, urlObj, resolve, reject, "other", data, customData];
					store.adapter.$.sendXHR.apply(store.adapter.$, argsXHR).then(function (xhrReq) {
						store.adapter.$.handleSuccess(modelName, type, xhrReq, data, urlObj, resolve, undefined, undefined, partialObj, reject, key, customData, actionName, partialRef);
					}, function (xhrReq) {
						store.adapter.$.handleFailure(modelName, type, xhrReq, data, urlObj, resolve, undefined, partialObj, reject, key, customData, undefined, actionName);
					});
				}
			});
		},
		handleSuccess: function handleSuccess(modelName, type, xhr, data, urlObj, resolve, resp, respObj, partialObj, reject, key, customData, actionName, partialRef) {
			var response = xhr ? xhr.responseText : undefined,
			    response,
			    req,
			    batchIndex,
			    batch,
			    status = xhr ? xhr.status : undefined;
			if (resp) {
				response = resp;
			} else {
				if (response && response.length != 0) {
					if (type == "action") {
						try {
							resp = JSON.parse(response);
						} catch (exp) {
							resp = response;
						}
					} else {
						resp = JSON.parse(response);
					}
				} else {
					resp = JSON.parse("{}");
				}
			}
			if (xhr) {
				req = xhr;
			}
			if (respObj) {
				batchIndex = respObj.index;
				batch = respObj.batch;
				req = respObj.resp;
			}
			var opts = { customD: customData };
			if (req) {
				var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, req, resp, urlObj ? urlObj.qP : undefined, key, customData, undefined, actionName] });
				if (res) {
					resp = res.data;
					if (resp instanceof Promise) {
						return this.handleParseResponsePromise(resp, modelName, type, data, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, opts);
					}
				}
			}
			return this.otherParseRequestPromise(resp, modelName, type, data, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, customData, partialRef, key);
		},
		handleFailure: function handleFailure(modelName, type, xhr, data, urlObj, resolve, respObj, partialObj, reject, key, customData, code, actionName, bObj) {
			if (xhr) {
				var resp;
				var scope = store.$.cbScp(modelName, "parseResponse", "adapter"),
				    args,
				    response = xhr.responseText;
				if (response) {
					try {
						response = response == "" ? JSON.parse("{}") : JSON.parse(response);
					} catch (exp) {
						Lyte.warn("LD24", exp);
					}
				}
				var res = store.$.initCB("adapter", modelName, "parseResponse", { args: [type, modelName, xhr, response, urlObj ? urlObj.qP : undefined, key, customData, undefined, actionName] });
				if (res) {
					resp = res.data;
					if (resp instanceof Promise) {
						return this.handleParseResponsePromise(resp, modelName, type, data, urlObj, xhr, partialObj, undefined, undefined, resolve, reject, customData);
					}
				}
			} else if (respObj) {
				var batch, batchIndex;
				if (bObj) {
					batchIndex = bObj.index;
					batch = bObj.batch;
				}
				store.$.batchResponse[batch][batchIndex] = { code: code, status: "requestFailure", data: respObj };
				reject({ code: code, status: "requestFailure", data: respObj });
			}
			reject(xhr);
		},
		updateIDB: function updateIDB(modelName, type, data, customData, urlObj, key) {
			if (data && !Array.isArray(data)) {
				data = [data];
			}
			var model = store.model[modelName];
			var idb = store.$.getIDBObj(model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData);
			if (!model || !idb || idb && !idb.hasOwnProperty("queryCache")) {
				data.forEach(function (item, index) {
					if (item && Lyte.isRecord(item)) {
						store.adapter.$.updateRelationsIDB(item, store.model[modelName].relations, customData, type);
					}
				});
				return;
			}
			var q = store.$.idbQ2[modelName] = store.$.idbQ2[modelName] || [];
			var queryCache = idb.queryCache;
			if (data) {
				switch (type) {
					case "update":
					case "updateRecord":
						{
							data.forEach(function (item, index) {
								if (item && Lyte.isRecord(item)) {
									var model = store.model[modelName];
									var relations = model.relations;
									// var parent = item.$.parent;
									// if(parent){
									// 	var pModel = parent.$.model._name;
									// 	var piObj = store.$.getIDBObj(parent.$.model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData, modelName)
									// 	var pModCacheQuery = piObj.queryCache;
									// 	var parentQ = store.$.idbQ2[pModel] = store.$.idbQ2[pModel] || [];
									// 	parentQ.push({type:"updateRecord",model:pModel,data:parent.$.toJSON(true),queryCache:pModCacheQuery, customData:customData});
									// }
									// else{
									// }
									if (item.$.inIDB && item.$.inIDB.self) {
										q.push({ type: "updateRecord", model: modelName, data: item.$.toJSON("idb"), queryCache: queryCache, customData: customData });
									}
									store.adapter.$.updateRelationsIDB(item, relations, customData);
									store.$.addToIDBonSave(modelName, item);
								}
							});
							break;
						}
					case "delete":
					case "deleteRecord":
					case "destroyRecord":
						{
							var parent,
							    pModel,
							    parentQ,
							    arrPk = store.modelFor(modelName)._arrPk;
							data.forEach(function (item, index) {
								if (item && Lyte.isRecord(item)) {
									var model = store.model[modelName];
									var relations = model.relations;
									parent = item.$.parent;
									var pkObj = {};
									for (var i = 0; i < arrPk.length; i++) {
										pkObj[arrPk[i]] = item[arrPk[i]];
									}
									// if(parent){
									// 	var pMod = parent.$.model;
									// 	pModel = pMod._name;
									// 	var piObj = store.$.getIDBObj(parent.$.model, urlObj && urlObj.qP ? urlObj.qP : undefined, type, key, customData, modelName)
									// 	var pModCacheQuery = piObj.queryCache;
									// 	parentQ = store.$.idbQ2[pModel] = store.$.idbQ2[pModel] || [];
									// 	parentQ.push({type:"updateRecord",model:parent.$.model._name,data:parent.$.toJSON(true), queryCache:pModCacheQuery, customData:customData});
									// }
									// else{
									// }
									if (item.$.inIDB && item.$.inIDB.self) {
										q.push({ type: "deleteRecord", model: modelName, key: pkObj, queryCache: queryCache, customData: customData });
									}
									store.adapter.$.updateRelationsIDB(item, relations, customData);
									store.$.removeOnSave(modelName, item.$.pK);
								}
							});
							break;
						}
					case "create":
					case "createRecord":
						{
							data.forEach(function (item, index) {
								if (item && Lyte.isRecord(item)) {
									var model = store.model[modelName];
									var relations = model.relations;
									q.push({ type: "createRecord", model: modelName, data: item.$.toJSON("idb"), queryCache: queryCache, customData: customData });
									store.adapter.$.updateRelationsIDB(item, relations, customData, "create");
									store.$.addToIDBonSave(modelName, item);
								}
							});
							break;
						}
				}
			}
		},
		updateRelationsIDB: function updateRelationsIDB(item, relations, customData, type) {
			switch (type) {
				case "create":
				case "createRecord":
					{
						for (var key in relations) {
							var rel = relations[key];
							rel.forEach(function (obj) {
								var relKey = obj.relKey,
								    relModel = obj.relatedTo,
								    relQ = store.$.idbQ2[relModel] = store.$.idbQ2[relModel] || [],
								    data,
								    idbObj = item.$.inIDB;
								if (obj.dummy) {
									data = store.$.getRelatedRecord(item, obj.relatedTo, obj.dummy);
								} else {
									data = item[relKey];
								}
								if (data && !Array.isArray(data)) {
									data = [data];
								}
								if (data) {
									data.forEach(function (_data) {
										var pModel = _data.$.model,
										    pRelQ = store.$.idbQ2[pModel._name] = store.$.idbQ2[pModel._name] || [];
										if (_data.$.inIDB.self) {
											pRelQ.push({ type: "updateRecord", model: pModel._name, data: _data.$.toJSON("idb"), customData: customData });
										}
										for (var iKey in _data.$.inIDB) {
											var mp = _data.$.inIDB[iKey],
											    _relQ = store.$.idbQ2[iKey] = store.$.idbQ2[iKey] || [];
											mp.forEach(function (value, pkVal) {
												_relQ.push({ type: "updateRecord", model: iKey, data: store.peekRecord(iKey, pkVal).$.toJSON("idb"), customData: customData });
											});
										}
									});
								}
							});
						}
					}
					break;
				default:
					{
						var idbObj = item.$.inIDB;
						if (idbObj) {
							for (mKey in idbObj) {
								var mp = idbObj[mKey];
								mp.forEach(function (value, key) {
									var pRec = store.peekRecord(mKey, key);
									var relQ = store.$.idbQ2[mKey] = store.$.idbQ2[mKey] || [];
									relQ.push({ type: "updateRecord", model: mKey, data: pRec.$.toJSON("idb"), customData: customData });
								});
							}
						}
					}
			}
		},
		callGeneric: function callGeneric(type, modelName, data, record, customData, queryParams, key, url, actionName, method, headers) {
			var res = store.$.initCB("adapter", modelName, "processRequest", { args: [type, modelName, data, record, customData, queryParams, key, url, actionName, method, headers] });
			return res ? res.data : undefined;
		},
		genericResponse: function genericResponse(resp, modelName, type, data, urlObj, xhr, partialObj, customData, partialRef) {
			var response = resp,
			    status = xhr ? xhr.status : undefined;
			var scope,
			    args,
			    qP = urlObj ? urlObj.qP : undefined,
			    extractMetaCall;
			scope = store.$.cbScp(modelName, "extractMeta", "serializer");
			if (scope) {
				if (response) {
					var metaRes = store.$.cB(scope, [response, modelName, type, qP, customData]);
					if (!store.$.isEmpty(metaRes)) {
						response.meta = metaRes;
					}
					extractMetaCall = true;
				} else {
					extractMetaCall = false;
				}
			}
			if (response && type != "action" && type != "ajax") {
				response = store.serializer.$.buildJSON(modelName, type, response, Lyte.isRecord(data) ? data[store.modelFor(modelName)._pK] : undefined, xhr ? xhr.status : undefined, urlObj, customData, qP);
				if (extractMetaCall == false && scope && response) {
					var metaRes = store.$.cB(scope, [response, modelName, type, qP, customData]);
					if (!store.$.isEmpty(metaRes)) {
						response.meta = metaRes;
					}
				}
				var keys = Object.keys(response);
				var len = keys.length;
				scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
				if (scope) {
					Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
					if (len > 2) {
						Lyte.error("LD09");
					}
					var index = 0;
					if (keys[0] == "meta") {
						index = 1;
					}
					var deserializeKey = store.$.cB(scope, [modelName, type]),
					    rec = response[keys[index]];
					delete response[keys[index]];
					response[deserializeKey] = rec;
				}
				this.handleResponse(data, response, store.modelFor(modelName), type, partialObj, undefined, partialRef);
			}
			return response;
		},
		removePartialKeys: function removePartialKeys(data, model, pK) {
			var rels = model.relations;
			var pkVal = data.$.pK;
			for (var key in rels) {
				var relArr = rels[key];
				relArr.forEach(function (rel) {
					var relObj = {},
					    inv;
					//self.$scope.$.getRelations(model, rel.relKey, self.$scope.model[rel.relatedTo], relObj);
					inv, bMod = store.model[rel.relatedTo];
					// if(relObj){
					// 	inv = relObj;
					// }
					if (bMod) {
						inv = store.$.getBackwardRel(model, rel, bMod);
						if (inv && inv.relType == "hasMany" && inv.opts && inv.opts.serialize) {
							var relKey = rel.relKey;
							var invRelKey = inv.relKey;
							var invObj = data[relKey];
							if (invObj) {
								if (Array.isArray(invObj)) {
									invObj.forEach(function (invRelRec) {
										var invRelObj = invRelRec[invRelKey];
										if (invRelObj && invRelObj.partial && invRelObj.partial.get(pkVal)) {
											invRelObj.partial.delete(pkVal);
										}
									});
								} else if (invObj[invRelKey]) {
									var invRelObj = invObj[invRelKey];
									if (invRelObj && invRelObj.partial && invRelObj.partial.get(pkVal)) {
										invRelObj.partial.delete(pkVal);
									}
								}
							}
						}
					}
				});
			}
		},
		mergeError: function mergeError(model, data, response) {
			if (response && response.$ && response.$.isError) {
				if (response.$.error) {
					var obj = response.$.error;
					for (var key in obj) {
						if (model.fieldList.hasOwnProperty(key)) {
							store.$.setRecErr(data.$, key, obj[key]);
						}
					}
				}
				delete response.$.error;
				delete response.$.isError;
				return true;
			}
		},
		mergeResponse: function mergeResponse(data, model, response, pK, partialObj, cPersist) {
			this.removePartialKeys(data, model, pK);
			if (partialObj && Object.keys(partialObj).length) {
				this.mergeNewDataKeys(partialObj, data, response, cPersist);
			}
			if (this.mergeError(model, data, response)) {
				return;
			}
			var isRec = store.peekRecord(data.$.model._name, data.$.pK);
			var dirtyId,
			    mergeDone = false;
			if (data.$.isDeleted) {
				this.mergeDeletedRec(partialObj, data, cPersist);
			}
			if (data.$.isNew && isRec) {
				mergeDone = this.mergeNewRecord(partialObj, data, response, true, cPersist);
			}
			if (data.$.isModified && isRec) {
				this.mergeModifiedRec(partialObj, data, response, true, mergeDone, cPersist);
			}
			if (model.dirty.length) {
				store.$.deleteFromArray(model.dirty, dirtyId);
			}
			if (partialObj && Object.keys(partialObj).length && response && !mergeDone) {
				if (response) {
					if (isRec) {
						result = store.$.validateAndMerge(model, response, partialObj, true);
						if (result && result.data) {
							result = result.data;
						} else if (result && result.type) {
							Lyte[result.type].apply(Lyte, result.args || []);
						}
					} else {
						result = store.$.insertIntoStore(model._name, response, undefined, undefined, partialObj);
					}
				}
			}
			store.adapter.$.removeDirtyStack(data, partialObj);
			// store.$.removeDeepNest(data);
		},
		removeDirtyStack: function removeDirtyStack(data, partial) {
			if (partial && partial._removedAttr && Object.keys(partial._removedAttr).length != 0) {
				for (var key in data.$._attributes) {
					if (!partial._removedAttr.hasOwnProperty(key)) {
						delete data.$._attributes[key];
					}
				}
			} else {
				data.$._attributes = {};
			}
			// data.$._attributes={};
			data.$.undoStack = store.$.genUnRedoStack();
			data.$.redoStack = store.$.genUnRedoStack();
			delete data.$._savedState;
			store.$.clrRecErr(data.$);
		},
		// handleResults: function(results, partialRef){
		// 	if(Array.isArray(results)){
		// 		var self = this;
		// 		results.forEach(function(itm, idx){
		// 			var refKey = partialRef.refKey;
		// 			var refId = itm[refKey], refObj = partialRef.get(refId);
		// 			if(refObj){
		// 				self.mergePartialObj(refObj, undefined, itm, true);
		// 			} 
		// 		});
		// 	}
		// 	else{
		// 		Lyte.warn("results expected be a flat structure of type array, instead it was "+typeof(results));
		// 	}
		// },
		removeBackwardRelDirty: function removeBackwardRelDirty(rec, pkVal) {
			var model = rec.$.model,
			    relations = model.relations;
			for (var rModl in relations) {
				var rArr = relations[rModl];
				rArr.forEach(function (itm) {
					if (rec.hasOwnProperty(itm.relKey)) {
						var bRel;
						if (store.modelFor(itm.relatedTo)) {
							bRel = store.$.getBackwardRel(model, itm, store.modelFor(itm.relatedTo));
						}
						if (bRel && bRel.opts && bRel.opts.serialize) {
							if (bRel.relType == "hasMany") {
								store.adapter.$.removeRelPartial(rec[itm.relKey], bRel, pkVal);
							} else if (bRel.relType == "belongsTo") {
								store.adapter.$.removeRelPartial(rec[itm.relKey], bRel, pkVal);
							}
						}
					}
				});
			}
		},
		removeRelPartial: function removeRelPartial(data, bRel, pK) {
			if (Array.isArray(data)) {
				data.forEach(function (rec) {
					var relData = rec[bRel.relKey];
					if (relData) {
						if (bRel.relType == "hasMany") {
							if (relData.partial) {
								relData.partial.delete(pK);
								if (!relData.partial.size) {
									store.$.deleteDeepNest(rec, bRel.relKey, pK);
								}
							}
						} else {
							store.$.deleteDeepNest(rec, bRel.relKey, pK);
						}
					}
				});
			} else if (Lyte.isRecord(data)) {
				var relData = data[bRel.relKey];
				if (relData) {
					if (bRel.relType == "hasMany") {
						if (relData.partial) {
							relData.partial.delete(pK);
							if (!relData.partial.size) {
								store.$.deleteDeepNest(data, bRel.relKey, pK);
							}
						}
					} else {
						store.$.deleteDeepNest(data, bRel.relKey, pK);
					}
				}
			}
		},
		mergeNewRecord: function mergeNewRecord(partialObj, data, response, doMerge, cPersist) {
			var mName = partialObj.$ ? partialObj.$.model : data.$.model._name,
			    mdl = store.model[mName],
			    pKeys = mdl._arrPk,
			    oldPk = data.$.pK;
			var rec = store.peekRecord(mName, oldPk),
			    result;
			var partRec = partialObj.$ ? partialObj.$.record : undefined;
			if (Lyte.isRecord(partRec) && partRec !== rec) {
				return;
			}
			if (rec) {
				var oldRelPk = (typeof oldPk === 'undefined' ? 'undefined' : _typeof(oldPk)) == "object" ? oldPk : oldPk.toString();
				var crProcessed = false;
				if (cPersist !== true) {
					pKeys.forEach(function (item) {
						if (!response || !response.hasOwnProperty(item)) {
							Lyte.error("LD16", mName, Lyte.isRecord(data) ? _typeof(data.$.pK) == "object" ? JSON.stringify(data.$.pK) : data.$.pK : undefined);
							return;
						}
						store.$.cmpSet(data, item, response[item], undefined, true);
						crProcessed = true;
					});
					var newPk = store.$.getpKVal(data);
					store.$.cmpSet(data.$, "pK", store.$.getpKVal(data));
					var newRelPk = (typeof newPk === 'undefined' ? 'undefined' : _typeof(newPk)) == "object" ? newPk : newPk.toString();
					if (mdl.data._recMap) {
						mdl.data._recMap.delete(oldRelPk);
						mdl.data._recMap.set(newRelPk, data);
					}
					store.$.changeRelPkMaps(data, oldRelPk, newRelPk);
					store.$.updateNestScp(data, oldPk);
				}
				if (crProcessed && partialObj && partialObj.$) {
					partialObj.$.processed = true;
				}
				if (doMerge && cPersist !== true) {
					result = store.$.validateAndMerge(mdl, response, partialObj, true);
					if (result && result.data) {
						result = result.data;
					} else if (result && result.type) {
						Lyte[result.type].apply(Lyte, result.args || []);
					}
				}
				store.$.cmpSet(data.$, "isNew", false);
				if (partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length != 0) {
					return result;
				}
				store.$.cmpSet(data.$, "isModified", false);
				store.$.changePersist(data, true);
				store.$.deleteFromArray(mdl.dirty, oldPk);
				store.adapter.$.removeBackwardRelDirty(data, oldPk);
				if (!data.$.dN || data.$.dN && Object.keys(data.$.dN).length == 0) {
					store.$.removeParentNesting(data);
				}
			}
			return result;
		},
		mergeModifiedRec: function mergeModifiedRec(partialObj, data, response, doMerge, mergeDone, cPersist) {
			var dirtyId = !dirtyId ? data.$.pK : dirtyId,
			    result;
			if (!data.$.isDeleted && response && !mergeDone && cPersist !== true) {
				if (response && doMerge) {
					result = store.$.validateAndMerge(data.$.model, response, partialObj, true);
					if (result && result.data) {
						result = result.data;
					} else if (result && result.type) {
						Lyte[result.type].apply(Lyte, result.args || []);
					}
				}
				mergeDone = true;
			}
			if (partialObj && partialObj.hasOwnProperty("_removedAttr") && Object.keys(partialObj._removedAttr).length) {
				return result;
			}
			store.$.cmpSet(data.$, "isModified", false);
			store.$.changePersist(data, true);
			store.$.deleteFromArray(data.$.model.dirty, data.$.pK);
			store.adapter.$.removeBackwardRelDirty(data, data.$.pK);
			if (!data.$.dN || data.$.dN && Object.keys(data.$.dN).length == 0) {
				store.$.removeParentNesting(data);
			}
			return result;
		},
		mergeDeletedRec: function mergeDeletedRec(partialObj, data) {
			var mName, pkVal, model, obj;
			if (partialObj) {
				mName = partialObj.$.model;
				pkVal = partialObj.$.pkVal;
			} else if (data) {
				mName = data.$.model._name;
				pkVal = data.$.pK;
			}
			model = store.model[mName];
			obj = model._deleted.get(pkVal);
			var rec = obj ? obj.data : undefined;
			var isRec = store.peekRecord(mName, pkVal);
			if (rec) {
				store.$.cmpSet(rec.$, "isDeleted", false);
				store.$.cmpSet(rec.$, "isUnloaded", true);
				store.$.cmpSet(rec.$, "isPersisted", true);
				var scpObj = rec.$.__scpObj;
				for (var key in scpObj) {
					var sid = scpObj[key];
					var sidArr = sid.split("_");
					var nestObj = Lyte.nestScp[sidArr[0]];
					nestObj ? Lyte.removeNestScp(nestObj._data, sidArr[0], sidArr[1], undefined, rec, undefined, undefined, { model: mName, pK: pkVal, attr: key }) : undefined;
				}
				model._deleted.delete(pkVal);
				store.$.removeParentNesting(rec);
			}
			if (isRec) {
				store.$.removeFromStore(model, pkVal, true, undefined, undefined, true);
				store.$.removeParentNesting(isRec);
			} else {
				var cqueries = store.model.cachedQueries;
				if (cqueries) {
					var Nm = cqueries[mName],
					    n = mName;
					if (Nm && Nm.length) {
						for (var i = Nm.length - 1; i >= 0; i--) {
							var obj = Nm[i];
							if (obj.hasDeletedRecords) {
								if (obj.data) {
									var ind = obj.data[mName].indexOf(rec);
									if (ind !== -1) {
										Nm.splice(i, 1);
									}
								}
							}
						}
					}
				}
			}
			if (partialObj && partialObj.$ && partialObj.$.parent) {
				partialObj.$.parent.$.partial = {};
			}
			partialObj && partialObj.$ ? partialObj.$.processed = true : undefined;
		},
		mergePartialObj: function mergePartialObj(partialObj, data, response, doMerge, cPersist) {
			var prec = store.peekRecord(partialObj.$.model, partialObj.$.pkVal),
			    data = data || prec,
			    isRec = prec ? true : false,
			    mergeDone;
			if (partialObj && partialObj.$ && partialObj.$.processed) {
				return;
			}
			if (this.mergeError(store.model[partialObj.$.model], data, response)) {
				return;
			}
			if (partialObj.$.type == "removed") {
				this.mergeDeletedRec(partialObj, data, cPersist);
				return;
			} else if ((partialObj.$.type == "added" || data && data.$ && data.$.isNew == true) && isRec) {
				mergeDone = this.mergeNewRecord(partialObj, data, response, doMerge, cPersist);
			} else if ((partialObj.$.type == "modified" || partialObj.$.type == "related" || data && data.$ && data.$.isModified == true) && isRec) {
				this.mergeModifiedRec(partialObj, data, response, doMerge, mergeDone, cPersist);
			}
			if (isRec) {
				if (partialObj.$.type != "removed") {
					for (var key in partialObj) {
						var part = partialObj[key];
						this.mergeNewDataKeys(part, data[key], response ? response[key] : undefined, cPersist);
					}
				}
				if (data.$.partial && Object.keys(data.$.partial)) {
					data.$.partial = new Map();
				}
				store.adapter.$.removeDirtyStack(data, partialObj);
			}
		},
		mergeNewDataKeys: function mergeNewDataKeys(partialObj, data, response, cPersist) {
			if (partialObj && (data && data.partial && data.partial.size || partialObj.partial == true)) {
				//true checked since partial key can come in this 
				var self = this;
				if (Array.isArray(partialObj)) {
					var rep = partialObj.replace ? partialObj.replace : false;
					partialObj.forEach(function (item, index) {
						if (item.$) {
							var pK = store.model[item.$.model]._pK;
							var ind = store.$.getIndex(data, pK, item.$.pkVal);
							if (item.$.onlyDetach === true) {
								if (data.record && data.key) {
									store.$.deleteDeepNest(data.record, data.key, item.$.pkVal);
								}
								store.$.handleArrOp(data, "removeAt", undefined, ind, 1);
							} else {
								if (rep && item.$.record && item.$.record.$.isNew) {
									rep = true;
								} else {
									self.mergeNewDataKeys(item, ind != -1 ? data[ind] : undefined, response ? response[index] : undefined, cPersist);
								}
								data.partial ? data.partial.delete(item.$.pkVal) : undefined;
							}
							if (!item._removedAttr || item._removedAttr && Object.keys(item._removedAttr).length) {
								data.partial ? data.partial.delete(item.$.pkVal) : undefined;
							}
						}
					});
					if (Array.isArray(data) && data.partial && data.partial.size && data.record && data.key && data.record.$.model) {
						var relFld = data.record.$.model.fieldList[data.key],
						    toRemPart = [];
						if (relFld.opts && /^(id|record)$/.test(relFld.opts.serialize)) {
							data.partial.forEach(function (pObj, pKey) {
								if (pObj.type == "removed") {
									toRemPart.push(pKey);
								}
							});
							toRemPart.forEach(function (rItm) {
								var rec = store.peekRecord(data.model._name, rItm) || store.peekRecord(data.model._name, rItm, true);
								data.partial.delete(rItm);
								rec ? store.$.removeParentNesting(rec) : undefined;
							});
						}
					}
				}
			} else if (partialObj && partialObj.$ && partialObj.$.type) {
				if (partialObj.$.onlyDetach) {
					//only for belongsTo
					var parent = partialObj.$.parent;
					if (parent && parent.$.partial && parent.$.partial[partialObj.$.relKey] && parent.$.partial[partialObj.$.relKey].has(partialObj.$.pkVal) && parent.$.partial[partialObj.$.relKey].get(partialObj.$.pkVal).type == "removed") {
						var rec = store.peekRecord(partialObj.$.model, partialObj.$.pkVal) || store.peekRecord(partialObj.$.model, partialObj.$.pkVal, true);
						parent.$.partial[partialObj.$.relKey].delete(partialObj.$.pkVal);
						if (!parent.$.partial[partialObj.$.relKey].size) {
							delete parent.$.partial[partialObj.$.relKey];
							if (!Object.keys(parent.$.partial).length) {
								delete parent.$.partial;
							}
						}
						rec ? store.$.removeParentNesting(rec) : undefined;
					}
				} else {
					this.mergePartialObj(partialObj, data, response, undefined, cPersist);
				}
			} else {
				if (Array.isArray(partialObj)) {
					var self = this;
					partialObj.forEach(function (item, index) {
						self.mergeNewDataKeys(item, data[index], response ? response[index] : undefined, cPersist);
					});
				} else if ((typeof partialObj === 'undefined' ? 'undefined' : _typeof(partialObj)) == "object") {
					for (var key in partialObj) {
						var part = partialObj[key];
						this.mergeNewDataKeys(partialObj[key], data[key], response ? response[key] : undefined, cPersist);
					}
				}
			}
		},
		handleResponse: function handleResponse(data, response, model, type, partialObj, status, partialRef) {
			var pK = model._pK,
			    partial,
			    obj,
			    pkVal;
			// if(response.results && model._name != "results"){
			// 	this.handleResults(response.results, partialRef);
			// }
			response = response[model._name];
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					obj = data[i], pkVal = obj.$.pK;
					partial = partialObj && obj && pkVal ? partialObj.get(pkVal) : undefined;
					this.mergeResponse(data[i], model, Array.isArray(response) ? response[i] : response, pK, partial);
				}
			} else {
				pkVal = data.$.pK;
				partial = partialObj && data && pkVal ? partialObj.get(pkVal) : undefined;
				this.mergeResponse(data, model, response, pK, partial);
			}
		},
		/*Compares two objects
  params - obj1, obj2
  return true/false
  */
		compareData: function compareData(data1, data2, isQp) {
			if (!store.$.isEmpty(data1) && !store.$.isEmpty(data2)) {
				var data1Type = typeof data1 === 'undefined' ? 'undefined' : _typeof(data1),
				    data2Type = typeof data2 === 'undefined' ? 'undefined' : _typeof(data2);
				if (data1Type !== data2Type) {
					return false;
				}
				switch (data1Type) {
					case "string":
					case "number":
					case "boolean":
						if (data1 === data2) {
							return true;
						}
						break;
					case "object":
						return this.compareObjects(data1, data2, isQp);
				}
			}
			return false;
		},
		compareObjects: function compareObjects(obj1, obj2, qP) {
			if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
				return false;
			}
			if (Object.keys(obj1).length != Object.keys(obj2).length) {
				return false;
			}
			for (var key in obj1) {
				var val1 = obj1[key],
				    val2 = obj2[key];
				if (qP && Array.isArray(val1) && Array.isArray(val2)) {
					if (val1.length != val2.length) {
						return false;
					}
					var len = val1.length;
					for (var i = 0; i < len; i++) {
						var ret = store.adapter.$.compareData(val1[i], val2[i], qP);
						if (!ret) {
							return false;
						}
					}
				} else if (val2 === undefined || !store.adapter.$.compareData(val1, val2, qP)) {
					return false;
				}
			}
			return true;
		},
		handleBatchPromise: function handleBatchPromise(obj) {
			var response = obj.response,
			    batch = obj.batch,
			    fail = obj.fail;
			if (!fail) {
				var res = store.$.initCB("serializer", "application", "normalizeResponse", { args: [undefined, "batch", obj.response] });
				if (res) {
					response = res.data;
				}

				var resp = response.batch_requests;
				resp.forEach(function (item, index) {
					var pro = store.$.batchPromise[batch][index];
					var status = item.status.toString();
					var code = status[0];
					if (code == "2") {
						pro.resolve({ content: item.content, index: index, batch: batch, resp: item });
					} else if (code == "4" || code == "5") {
						store.$.batchResponse[batch][index] = undefined;
						pro.reject({ content: item.content, index: index, batch: batch, resp: item, code: status });
					}
				});
			} else {
				var prmArr = store.$.batchPromise[batch];
				prmArr.forEach(function (itm, idx) {
					itm.reject({ content: {}, index: idx, batch: batch, code: "400", resp: {} });
				});
			}
			// obj.resolve(response);
			delete store.$.batch[batch];
			delete store.$.batchPromise[batch];
		},
		handleParseResponsePromise: function handleParseResponsePromise(response, modelName, type, key, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, opts) {
			response.then(function (payload) {
				if (type == "findRecord" || type == "findAll") {
					store.adapter.$.findParseRequestPromise(payload, modelName, type, key, urlObj, xhr, batchIndex, batch, resolve, opts);
				} else {
					store.adapter.$.otherParseRequestPromise(payload, modelName, type, key, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, opts ? opts.customD : undefined, undefined, key);
				}
			}, function (payload) {
				reject(xhr);
			});
		},
		findParseRequestPromise: function findParseRequestPromise(payload, modelName, type, key, urlObj, xhr, batchIndex, batch, resolve, opts) {
			var options = Object.assign({}, opts);
			delete options.customD;
			var resp = this.getResponse(payload, modelName, type, key, urlObj, xhr, opts ? opts.customD : undefined, options);
			var resArr = xhr ? [resp, xhr.statusText, xhr] : batchIndex != undefined ? [resp, "batch", { index: batchIndex, batch: batch }] : [resp];
			resolve(resArr);
		},
		otherParseRequestPromise: function otherParseRequestPromise(resp, modelName, type, data, urlObj, xhr, partialObj, batchIndex, batch, resolve, reject, customData, partialRef, key) {
			var response = this.genericResponse(resp, modelName, type, data, urlObj, xhr, partialObj, customData, partialRef);
			if (batchIndex != undefined) {
				store.$.batchResponse[batch][batchIndex] = response;
			}
			if (type != "action" && type != "ajax") {
				this.updateIDB(modelName, type, data, customData, urlObj, key);
			}
			resolve(response);
		}
	}
};

store.$.defProp(store.adapter, "extends", function value(adapterName, opts, parent) {
	return store.$.scExtd("adapter", adapterName, opts, parent);
}, false);

Lyte.$.requiredMixins.serializer = Lyte.$.requiredMixins.adapter = function (mixin, parent, callback_name) {
	if (Object.keys(mixin).length) {
		parent.forEach(function (item, index) {
			var scope = item.scope,
			    name = item.name,
			    callback = scope[callback_name][name];
			if (callback) {
				for (var key in mixin) {
					callback[key] = mixin[key];
				}
			}
		});
	}
};

if (Lyte.$.injectServices) {
	Lyte.$.injectServices.adapter = Lyte.$.injectServices.serializer = function (key, name, type, ins, cmpIns, data) {
		var cls = store[type];
		var obj = {};
		obj.as = key;
		obj.service = name;
		for (var cName in cls) {
			var def = cls[cName];
			store.$.extendService([obj], type, cName, def, store, true, data);
		}
	};
}

function Serializer(attrs, opts, name) {
	var self = this;
	Object.defineProperty(self, '$lg', {
		value: Lyte.__gl
	});
	store.$.newCB("serializer", this, name, attrs, opts);
}
store.$.cbDef(Serializer, "serializer");
store.serializer = {
	$: {
		buildJSON: function buildJSON(modelName, type, payLoad, id, status, urlObj, customData, qP) {
			var headers = urlObj ? urlObj.headers : undefined,
			    realData = payLoad;
			var res = store.$.initCB("serializer", modelName, "normalizeResponse", { args: [modelName, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, undefined, urlObj ? urlObj.gqlObj : undefined] });
			if (res) {
				realData = res.data;
			}
			var changed = false,
			    recs,
			    isGet = /^(findRecord|findAll)$/.test(type);
			if (!isGet && realData && (typeof realData === 'undefined' ? 'undefined' : _typeof(realData)) == "object") {
				res = store.$.initCB("serializer", modelName, "payloadKey", { args: [modelName, type, undefined, qP, customData] });
				if (res) {
					var plKey = res.data;
					if (plKey && plKey != modelName) {
						var temp = realData[plKey];
						realData[modelName] = temp;
						delete realData[plKey];
					}
				}
			}
			if (isGet || realData && realData[modelName]) {
				recs = realData[modelName], changed = true;
				scope = store.$.cbScp(modelName, "normalize", "serializer");
				if (scope) {
					if (Array.isArray(recs)) {
						for (var i = 0; i < recs.length; i++) {
							recs[i] = store.$.cB(scope, [modelName, type, recs[i], customData]);
						}
					} else {
						recs = store.$.cB(scope, [modelName, type, recs, customData]);
					}
				}
				var flUrlObj = type != "pushPayload" ? { url: urlObj.url, method: urlObj.method, headers: urlObj.headers, type: type, qP: urlObj.qP, withCredentials: urlObj.withCredentials, model: modelName } : undefined;
				recs = store.adapter.$.serializeRecords(modelName, recs, undefined, flUrlObj, "normalizeRecord", customData);
				realData[modelName] = recs;
			}
			return realData;
		},
		normalizeResponse: function normalizeResponse(modelName, type, payLoad, id, status, urlObj, customData, opts) {
			var headers = urlObj ? urlObj.headers : undefined,
			    realData = payLoad;
			var res = store.$.initCB("serializer", modelName, "normalizeResponse", { args: [modelName, type, realData, id, status, headers, urlObj ? urlObj.qP : undefined, customData, opts, urlObj ? urlObj.gqlObj : undefined] });
			if (res) {
				realData = res.data;
			}
			return realData;
		},
		normalize: function normalize(modelName, type, payLoad, id, status, headers, customData, opts, urlObj) {
			var realData = payLoad,
			    changed = false;
			if (/^(findRecord|findAll)$/.test(type) || realData[modelName]) {
				realData = realData[modelName];
				changed = true;
			}
			var scope = store.$.cbScp(modelName, "normalize", "serializer");
			if (scope) {
				if (Array.isArray(realData)) {
					for (var i = 0; i < realData.length; i++) {
						realData[i] = store.$.cB(scope, [modelName, type, realData[i], customData, opts]);
					}
				} else {
					realData = store.$.cB(scope, [modelName, type, realData, customData, opts]);
				}
			}
			if (changed) {
				payLoad = {};
				realData = store.adapter.$.serializeRecords(modelName, realData, undefined, { url: urlObj.url, method: urlObj.method, headers: urlObj.headers, type: type, qP: urlObj.qP, withCredentials: urlObj.withCredentials, model: modelName }, "normalizeRecord", customData);
				payLoad[modelName] = realData;
			}
		}
	}
};
store.$.defProp(store.serializer, "extends", function value(serializerName, opts, parent) {
	return store.$.scExtd("serializer", serializerName, opts, parent);
});

Object.defineProperties(store, {
	modelless: {
		value: {}
	},
	registerModel: {
		get: function get() {
			Lyte._preRegister();
			return store.$.registerModel;
		}
	},
	ajax: {
		value: function ajax(obj) {
			if (!obj.model) {
				return Promise.reject("Model name is mandatory for ajax method");
			}
			var defless = store.$.getFromCB("adapter", obj.model, "modelless");
			if (defless != true) {
				return Promise.reject("Modelless behaviour is not enabled. Please enable it to make ajax call for models that are not defined");
			}
			if (!obj.type) {
				return Promise.reject(obj.type + " is not a valid HTTP method");
			}
			var def = typeof obj.model === "string" ? this.model[obj.model] : undefined;
			if (def && def.fieldList) {
				return Promise.reject(obj.model + " is a defined model. ajax is supported only for a model which is not defined");
			}
			return store.adapter.$.handleAjax(obj);
		}
	},
	triggerUpdate: {
		value: function value(modelName, pkVal, keys, qP, customData, mutationName) {
			var model = store.modelFor(modelName),
			    ArrayOfKeys,
			    sendData = [],
			    recordsArray = [];
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			ArrayOfKeys = Array.isArray(pkVal) ? pkVal : [pkVal];
			for (var update_Rec = 0; update_Rec < ArrayOfKeys.length; update_Rec++) {
				var record = store.peekRecord(modelName, ArrayOfKeys[update_Rec]);
				if (record) {
					var obj = {};
					var model = record.$.model;
					var pK = model._arrPk;
					var fields = keys || Object.keys(model.fieldList);
					fields.forEach(function (item) {
						obj[item] = record[item];
					});
					pK.forEach(function (item) {
						obj[item] = record[item];
					});
					sendData.push(obj);
					recordsArray.push(record);
				} else {
					return Promise.reject("No such record found");
				}
			}
			var isSingleRecord = false;
			if (!Array.isArray(pkVal)) {
				sendData = sendData[0];
				recordsArray = recordsArray[0];
				isSingleRecord = true;
			}
			return store.adapter.$.put(modelName, sendData, recordsArray, isSingleRecord, customData, qP, mutationName);
		}
	},
	batch: {
		value: function value(arg) {
			return new Promise(function (resolve, reject) {
				store.$.makeBatch = true;
				store.$.batch = store.$.batch || {};
				store.$.batchPromise = store.$.batchPromise || {};
				var method,
				    customData,
				    bLen = store.$.currentBatch === undefined ? Object.keys(store.$.batch).length : store.$.currentBatch + 1,
				    batch = store.$.currentBatch = bLen;
				if (arg && typeof arg == "function") {
					method = arg;
				} else if (arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) == "object") {
					method = arg.method;
					customData = arg.customData;
				}
				try {
					method();
				} catch (e) {
					store.$.makeBatch = false;
					throw e;
				}
				store.$.makeBatch = false;
				var payLoad = { batch: store.$.batch[batch] };
				var urlObj = store.adapter.$.buildURL("batch", "POST", "application", undefined, payLoad, undefined, undefined, customData);
				var batchPl = payLoad.batch;
				if (store.$.isEmpty(batchPl)) {
					if (store.$.cachedBatch && store.$.cachedBatch[batch] && store.$.cachedBatch[batch].length) {
						var finalRes = store.$.handleCachedResponse(batch, []);
						return resolve(finalRes);
					}
					return resolve();
				}
				var res = store.$.initCB("serializer", "application", "serialize", { args: ["batch", payLoad, undefined, customData] });
				if (res) {
					payLoad = res.data;
				}
				var xhr = new XMLHttpRequest();
				xhr.open("POST", urlObj.url, true);
				for (var header in urlObj.headers) {
					xhr.setRequestHeader(header, urlObj.headers[header]);
				}
				xhr.withCredentials = urlObj.withCredentials ? true : false;
				xhr.send(JSON.stringify(payLoad));
				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {
						if (xhr.status.toString()[0] == "2" || xhr.status.toString()[0] == "3") {
							var resp = JSON.parse(xhr.responseText);
							store.$.batchResponse = store.$.batchResponse || {};
							store.$.batchResponse[batch] = [];
							store.adapter.$.handleBatchPromise({ response: resp, batch: batch, resolve: resolve });
							setTimeout(function () {
								var finalRes = store.$.handleCachedResponse(batch, store.$.batchResponse[batch]);
								resolve(finalRes);
								store.$.batchResponse[batch] = [];
							}, 0);
						} else {
							store.$.batchResponse[batch] = [];
							store.adapter.$.handleBatchPromise({ batch: batch, resolve: resolve, fail: true });
							setTimeout(function () {
								var finalRes = store.$.handleCachedResponse(batch, store.$.batchResponse[batch]);
								reject(finalRes);
							}, 0);
						}
					}
				};
			});
		}
	},
	pushPayload: {
		value: function value(modelName, data, deserialize, ind) {
			var model = store.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model", modelName);
				return;
			}
			var result = data,
			    len;
			if (deserialize) {
				data = store.serializer.$.buildJSON(modelName, "pushPayload", data);
				var scope = store.$.cbScp(modelName, "deserializeKey", "serializer");
				len = data ? Object.keys(data).length : undefined;
				if (scope) {
					Lyte.warn("LD08", "deserializeKey", "callback", "Please use payloadKey callback instead");
					if (len > 2) {
						Lyte.error("LD09");
					}
					var keys = Object.keys(data),
					    index = 0;
					if (keys.length == 2 && keys[0] == "meta") {
						index = 1;
					}
					var deserializeKey = store.$.cB(scope, [modelName, "pushPayload"]),
					    rec = data[keys[index]];
					delete data[keys[index]];
					data[deserializeKey] = rec;
				}
				result = data[modelName];
			}
			data = store.$.insertIntoStore(modelName, result, true, undefined, undefined, index, true, undefined, ind);
			var nData = data || [];
			if (!Array.isArray(nData)) {
				nData = [nData];
			}
			var idb = model && model.hasOwnProperty("idb");
			if (window.LyteIDB) {
				nData.forEach(function (itm) {
					if (Lyte.isRecord(itm)) {
						if (idb) {
							store.$.idbQ2Push(modelName, itm, undefined, "pushPayload");
						}
						if (!itm.$.isError) {
							if (itm.$.inIDB && Object.keys(itm.$.inIDB).length) {
								store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
							}
						}
					}
				});
			}
			model ? delete model.rel : undefined;
			return data;
		}
	},
	unregisterModel: {
		value: function value(data, inherit) {
			inherit = inherit === false ? false : true;
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					store.$.unregisterModel(item, inherit);
				});
			} else {
				store.$.unregisterModel(data, inherit);
			}
		}
	},

	unregisterAdapter: {
		value: function value(data) {
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					store.$.unRegCb("adapter", item);
				});
			} else {
				store.$.unRegCb("adapter", data);
			}
		}
	},
	unregisterSerializer: {
		value: function value(data) {
			if (Array.isArray(data)) {
				data.forEach(function (item) {
					store.$.unRegCb("serializer", item);
				});
			} else {
				store.$.unRegCb("serializer", data);
			}
		}
	},
	addField: {
		value: function value(modelName, key, type, options, ignoreValidation, deserialize) {
			var model = store.modelFor(modelName),
			    fieldType;
			var obs = [];
			if (model.fieldList.hasOwnProperty(key)) {
				if (model.fieldList[key].type == "relation") {
					var relfld = model.fieldList[key];
					var rel = model.relations[relfld.relatedTo];
					if (Array.isArray(rel)) {
						var index = rel.indexOf(relfld);
						rel.splice(index, 1);
					}
					if (relfld.relType == "hasMany") {
						delete model._fldGrps.hasMany[key];
					}
				}
			}
			if (type && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) == "object") {
				// if(type && type.type !== "relation" && model.fieldList.hasOwnProperty(key) && type.type === model.fieldList[key].type && store.adapter.$.compareData(type, model.fieldList[key])){
				// 	ignoreValidation = true;
				// }
				store.$.registerField(model, key, type, obs);
				if (type.type == "relation") {
					fieldType = "relation";
				} else {
					fieldType = "attr";
				}
				var deserialize = arguments[4],
				    ignoreValidation = ignoreValidation === undefined ? arguments[3] : ignoreValidation;
			} else {
				var field = Lyte.attr(type, options);
				// if(field.type !== "relation" && model.fieldList.hasOwnProperty(key) && model.fieldList[key].type === field.type && store.adapter.$.compareData(field, model.fieldList[key])){
				// 	ignoreValidation = true;
				// }
				store.$.registerField(model, key, field, obs);
			}
			if (fieldType != "relation") {
				if (!ignoreValidation || deserialize) {
					store.$.updateFieldValidation(model, key, deserialize, ignoreValidation);
				}
			}
		}
	},
	modelFor: {
		value: function value(name) {
			return store.model[name];
		}
	},
	createRecord: {
		value: function value(modelName, opts, withoutValidation) {
			return this.$.newRecord(modelName, opts, withoutValidation);
		}
	},
	deleteRecord: {
		value: function value(modelName, key) {
			this.$.removeFromStore(store.modelFor(modelName), key, undefined);
		}
	},
	/*
 args - modelName, queryParams, cacheQuery, cacheData, customData
 cacheQuery - true/false (default false) -> whether to cache the request with queryparams or not
 cacheData - true/false (default true) -> whether to store the data in the store or not
 customData - some custom data that can be sent, which will be received as the last param in all adapter functions
 */
	findAll: {
		value: function value(modelName, queryParams, cacheQuery, cacheData, customData, oprName, variables, index) {
			return store.adapter.$.get("findAll", modelName, undefined, queryParams, cacheQuery, customData, cacheData, oprName, variables).then(function () {
				var args = arguments,
				    data = args[0][0],
				    xhr = args[0][2],
				    status = xhr ? xhr.status : args[0][3],
				    fromCache = args[0][1] == "cache" ? true : false,
				    batchObj = args[0][1] == "batch" ? args[0][2] : undefined,
				    fromIDB = args[0][1] == "idb" ? true : false,
				    model,
				    toCacheParams;
				var modelless = store.$.getFromCB("adapter", modelName, "modelless"),
				    _defless;
				// if(!modelless){
				model = store.model[modelName];
				// }
				toCacheParams = cacheQuery && cacheQuery !== true ? cacheQuery : cacheQuery === true && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" && Object.keys(queryParams).length ? queryParams : undefined;
				if (!model && cacheData == undefined) {
					cacheData = false;
				} else if (modelless && !model && cacheData == true) {
					_defless = true;
				}
				if (cacheData !== undefined && (typeof cacheData === 'undefined' ? 'undefined' : _typeof(cacheData)) == "object" && cacheData !== null) {
					cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
				}
				if (cacheData === false) {
					if (!fromCache && toCacheParams) {
						store.$.cacheQuery(modelName, toCacheParams, data, status);
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data;
					}
					return data;
				}
				if (data && !data.save) {
					if (!fromCache) {
						if (!data || !data.hasOwnProperty(modelName)) {
							Lyte.error("LD13", "findAll", modelName, queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" ? ",queryParams-" + JSON.stringify(queryParams) : "" /*, Lyte.isRecord(data) ? data: JSON.stringify(data)*/);
							return;
						}
						// if(!fromIDB){
						// 	store.$.idbQ2Push(modelName,data,queryParams,"findAll",undefined,undefined,customData);
						// }
						var payLoad = data[modelName];
						if (payLoad === undefined || payLoad === null || store.$.isEmptyArray(payLoad)) {
							data[modelName] = [];
						} else {
							if (!Array.isArray(payLoad)) {
								Lyte.warn("LD19");
							}
							var defnd = _defless ? "id" : undefined,
							    ind = _defless && index != undefined ? index : defnd;
							var records = store.$.toInsertData(modelName, data, true, ind),
							    nRec = records;
							if (records && !Array.isArray(records)) {
								nRec = [records];
							}
							if (window.LyteIDB && !fromIDB && (nRec && !nRec.$ || records && records.$ && !records.$.isError)) {
								if (model && model.hasOwnProperty('idb')) {
									store.$.idbQ2Push(modelName, nRec, queryParams, "findAll", undefined, undefined, customData);
								}
								nRec.forEach(function (itm) {
									if (itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length) {
										store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
									}
								});
							}
							if (window.LyteIDB && fromIDB && nRec && Array.isArray(nRec)) {
								nRec.forEach(function (itm) {
									LyteIDB.changeIDBState(itm);
								});
							}
							data[modelName] = records;
						}
						if (data.hasOwnProperty("meta")) {
							data[modelName].$ || store.$.defProp(data[modelName], "$", {});
							data[modelName].$.meta = data.meta;
						}
						if (toCacheParams) {
							store.$.cacheQuery(modelName, toCacheParams, data);
						}
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data[modelName];
					}
					return data[modelName];
				}
				return arguments;
			}, function (e) {
				return Promise.reject(e);
			});
		}
	},
	/*
 args - modelName , key, queryParams, cacheQuery, cacheData, customData
 cacheQuery - true/false (default - false) -> to cache the query with queryParams and key
 cacheData - true/false (default - true) -> to store the data in store / not
 customData - custom data that will be available as last param in all adapter callbacks 
 */
	findRecord: {
		value: function value(modelName, key, queryParams, cacheQuery, cacheData, customData, oprName, variables, index) {
			if (key == undefined) {
				return Promise.reject({ code: "ERR20", message: Lyte.errorCodes.ERR20 });
			}
			return store.adapter.$.get("findRecord", modelName, key, queryParams, cacheQuery, customData, cacheData, oprName, variables).then(function () {
				var data = arguments[0][0],
				    fromCache = arguments[0][1] == "cache" ? true : false;
				var xhr = arguments[0][2];
				var status = xhr ? xhr.status : arguments[0][3];
				var batchObj = arguments[0][1] == "batch" ? arguments[0][2] : undefined;
				var fromIDB = arguments[0][1] == "idb" ? true : false;
				var model = store.model[modelName];
				var toCacheParams = cacheQuery && cacheQuery !== true ? cacheQuery : cacheQuery === true && queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" && Object.keys(queryParams).length ? queryParams : undefined;
				var modelless = store.$.getFromCB("adapter", modelName, "modelless"),
				    _defless;
				if (!model && cacheData == undefined) {
					cacheData = false;
				} else if (modelless && !model && cacheData == true) {
					_defless = true;
				}
				if (cacheData !== undefined && (typeof cacheData === 'undefined' ? 'undefined' : _typeof(cacheData)) == "object" && cacheData !== null) {
					cacheData = cacheData.hasOwnProperty("cache") ? cacheData.cache : true;
				}
				if (cacheData === false) {
					if (!fromCache && toCacheParams) {
						store.$.cacheRecordQuery(modelName, key, toCacheParams, data, status);
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data;
					}
					return data;
				}
				if (data) {
					if (!fromCache) {
						var isEmpty;
						if (!data || !data.hasOwnProperty(modelName)) {
							Lyte.error("LD13", "findRecord", modelName, ",key-" + ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) == "object" ? JSON.stringify(key) : key) + (queryParams && (typeof queryParams === 'undefined' ? 'undefined' : _typeof(queryParams)) == "object" ? ", queryParams-" + JSON.stringify(queryParams) + "" : "") /*, Lyte.isRecord(data) ? data: JSON.stringify(data)*/);
							return;
						}
						// if(!fromIDB){
						// 	store.$.idbQ2Push(modelName,data,queryParams,"findRecord",key,data && data.meta ? data.meta : undefined,customData);
						// }
						if (!Lyte.isRecord(data)) {
							var payLoad = data[modelName];
							if (store.$.isEmpty(payLoad) || store.$.isEmptyObj(payLoad)) {
								data[modelName] = {};
								isEmpty = true;
							}
							if ((typeof payLoad === 'undefined' ? 'undefined' : _typeof(payLoad)) != "object" || Array.isArray(payLoad)) {
								Lyte.warn("LD11");
							}
							if (!isEmpty) {
								var defnd = _defless ? "id" : undefined,
								    ind = _defless && index != undefined ? index : defnd;
								var record = store.$.insertIntoStore(modelName, payLoad, true, true, undefined, undefined, undefined, undefined, ind),
								    nRec;
								if (window.LyteIDB && !fromIDB && Lyte.isRecord(record) && !record.$.isError) {
									if (!Array.isArray(record)) {
										nRec = [record];
									}
									if (model && model.hasOwnProperty('idb')) {
										store.$.idbQ2Push(modelName, nRec, queryParams, "findRecord", key, data && data.meta ? data.meta : undefined, customData);
									}
									nRec.forEach(function (itm) {
										if (itm && itm.$ && itm.$.inIDB && Object.keys(itm.$.inIDB).length) {
											store.adapter.$.updateRelationsIDB(itm, itm.$.model.relations);
										}
									});
								}
								if (window.LyteIDB && fromIDB && nRec && Array.isArray(nRec)) {
									nRec.forEach(function (itm) {
										LyteIDB.changeIDBState(itm);
									});
								}
								data[modelName] = record;
							}
							if (data.hasOwnProperty("meta")) {
								if (Lyte.isRecord(record)) {
									record.$.meta = data.meta;
								} else {
									payLoad = data[modelName];
									payLoad.$ || store.$.defProp(payLoad, "$", {});
									payLoad.$.meta = data.meta;
								}
							}
						}
						if (!fromCache && toCacheParams) {
							store.$.cacheRecordQuery(modelName, key, toCacheParams, data);
						}
					}
					if (batchObj != undefined) {
						store.$.batchResponse[batchObj.batch][batchObj.index] = data[modelName];
					}
					return data[modelName];
				}
				return arguments;
			}, function (e) {
				return Promise.reject(e);
			});
		}
	},
	peekRecord: {
		value: function value(modelName, pKey, isDeleted) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","Model");
					return;
				}
				_defless = true;
			}
			if (isDeleted === true) {
				var deleted = model._deleted;
				var obj = deleted.get(pKey);
				if (obj && obj.data) {
					return obj.data;
				}
			} else {
				var isComp = model.isComp;
				pKey = pKey == undefined ? "" : pKey;
				if (!isComp && model.data._recMap) {
					return model.data._recMap.get(pKey.toString());
				} else {
					var data = model.data,
					    record;
					if (_defless != true) {
						record = data.filter(function (record) {
							if (store.$.comparePk(record, pKey)) {
								return record;
							}
						});
					} else {
						record = data.filter(function (ins) {
							if (ins[model._pK] === pKey) {
								return ins;
							}
						});
					}
					if (record[0]) {
						return record[0];
					}
				}
			}
			return undefined;
		}
	},
	peekAll: {
		value: function value(modelName) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","model ",modelName);
					return;
				}
			}
			arr = model.data;
			//			if(arr.length){
			return arr;
			//			}
			//			return undefined;
		}
	},
	deleteMany: {
		value: function value(modelName, keys) {
			this.$.removeFromStore(store.modelFor(modelName), keys, undefined);
		}
	},
	unloadRecord: {
		value: function value(modelName, key, inherit) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","model ",modelName);
					return;
				}
				_defless = true;
			}
			if (key == undefined) {
				Lyte.warn("LD18", "key");
			}
			var data = store.peekRecord(modelName, key);
			var pkVal;
			if (_defless == true) {
				var ind = store.$.getInd(model.data, model._pK, key);
				if (ind != -1) {
					store.$.handleArrOp(model.data, "removeAt", undefined, ind, 1);
				}
			} else if (data) {
				var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
				inherit = inherit === false ? false : true;
				pkVal = data.$.pK;
				//this.$.removeFromStore(model, pkVal, true, true);
				if (inherit && inhFldLen) {
					var recmp = new Map();
					store.$.removeChildRecords(model, data, recmp, true);
				} else {
					this.$.removeFromStore(model, pkVal, true, true, undefined, undefined, true);
				}
				model._deleted.delete(key);
				var crq = this.model.cachedRecordQueries;
				if (crq && crq[modelName] && crq[modelName][key]) {
					crq[modelName][key] = [];
				}
				var cqueries = store.model.cachedQueries;
				if (cqueries) {
					var Nm = cqueries[modelName],
					    n = modelName;
					if (Nm && Nm.length) {
						for (var i = Nm.length - 1; i >= 0; i--) {
							var obj = Nm[i];
							if (obj && obj.data) {
								var ind = obj.data[modelName].indexOf(data);
								if (ind != -1) {
									Nm.splice(i, 1);
								}
							}
						}
					}
				}
			}
		}
	},
	unloadAll: {
		value: function value(modelName, arr, inherit) {
			var model = this.modelFor(modelName),
			    modelless = store.$.getFromCB("adapter", modelName, "modelless"),
			    _defless;
			model = modelless ? modelName : model;
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			} else if (modelless == true && model) {
				model = store.modelless[model];
				if (!model) {
					// Lyte.error("LD02","model ",modelName);
					return;
				}
				_defless = true;
			}
			var keys = [];
			var data = arr || store.peekAll(modelName);
			if (_defless == true) {
				store.$.handleArrOp(model.data, "removeAt", undefined, 0, model.data.length);
			} else {
				if (data) {
					for (var i = 0; i < data.length; i++) {
						keys.push(data[i].$.pK);
					}
				}
				var inhFldLen = model._fldGrps.inherit && Object.keys(model._fldGrps.inherit).length;
				inherit = inherit === false ? false : true;
				if (inherit && inhFldLen) {
					for (var i = keys.length - 1; i >= 0; i--) {
						var pk = data[i];
						var recmp = new Map();
						store.$.removeChildRecords(model, pk, recmp, true);
					}
				} else {
					this.$.removeFromStore(model, keys, true, true, undefined, undefined, true);
				}
				this.model[modelName].dirty = [];
				this.model[modelName]._deleted = new Map();
				var cq = store.model.cachedQueries;
				if (cq && cq[modelName]) {
					cq[modelName] = [];
				}
				var crq = this.model.cachedRecordQueries;
				if (crq && crq[modelName]) {
					crq[modelName] = [];
				}
			}
		}
	},
	triggerAction: {
		value: function value(modelName, actionName, customData, qP, method, data) {
			var model = store.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			var actions = model.actions,
			    action = actions ? model.actions[actionName] : undefined;
			if (action) {
				return store.adapter.$.handleAction(actionName, model, store.peekAll(modelName), customData, qP, method, data).then(function (data) {
					return data;
				}, function (err) {
					return Promise.reject(err);
				});
			} else {
				return Promise.reject({ code: "ERR18", message: Lyte.errorCodes.ERR18 });
			}
		}
	},
	rollBack: {
		value: function value(modelName) {
			var model = this.modelFor(modelName),
			    rel = model.relations;
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return;
			}
			var pK = model._pK,
			    self = this,
			    dirty = Array.from(model.dirty);
			var len = dirty.length;
			for (var i = 0; i < len; i++) {
				var rec = self.peekRecord(modelName, dirty[i]);
				if (rec && rec.$.isDeleted) {
					continue;
				} else if (rec && rec.$.isNew) {
					self.$.rollBackNew(model, rec, pK);
				} else if (rec && rec.$.isModified) {
					rec.$.rollBackAttributes(rec.$.getDirtyAttributes());
				}
			}
			this.$.rollBackDelete(model, undefined, true);
		}
	},
	create: {
		value: function value(modelName, data, customData, qP, toFilterRecords, mutationName) {
			var model = store.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			if (Array.isArray(data)) {
				var self = this;
				data.forEach(function (item) {
					var resp = self.$.newRecord(modelName, item);
					if (resp.$.isError) {
						return Promise.reject(resp);
					}
				});
			} else if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object") {
				var resp = this.$.newRecord(modelName, data);
				if (resp.$.isError) {
					return Promise.reject(resp);
				}
			}
			var dirty = model.dirty,
			    len = dirty.length,
			    created = [],
			    err;
			for (var i = 0; i < len; i++) {
				var rec = store.peekRecord(modelName, dirty[i]);
				if (rec && rec.$.isNew) {
					if (toFilterRecords && toFilterRecords.indexOf(rec) == -1) {
						continue;
					}
					err = new error1();
					store.$.validateRecord(rec, model.fieldList);
					if (rec.$.isError && Object.keys(rec.$.error).length > 0) {
						return Promise.reject(err);
					}
					created.push(rec);
				}
			}
			if (created.length) {
				return store.adapter.$.create(modelName, created, false, customData, qP, mutationName);
			}
			return Promise.resolve();
		}
	},
	update: {
		value: function value(modelName, customData, qP, toFilterRecords, mutationName) {
			var model = this.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			var changed = [],
			    recordsChanged = [];
			var records = toFilterRecords || store.peekAll(modelName);
			var model = store.model[modelName];
			var rels = model.relations;
			records.forEach(function (item) {
				if (Lyte.isRecord(item) && item.$.model._name == modelName) {
					var rec = item;
					var dirty = store.$.isDirty(rec, rels);
					if (rec && !rec.$.isNew && !rec.$.isDeleted && (rec.$.isModified || dirty && dirty.length)) {
						var obj = store.$.updateJSON(rec, model, dirty);
						changed.push(obj);
						recordsChanged.push(rec);
					}
				}
			});
			if (changed.length) {
				return store.adapter.$.put(modelName, changed, recordsChanged, false, customData, qP, mutationName);
			}
			return Promise.resolve();
		}
	},
	delete: {
		value: function value(modelName, key, customData, qP, toFilterRecords, mutationName) {
			var model = store.modelFor(modelName);
			if (model == undefined) {
				Lyte.warn("LD02", "Model", modelName);
				return Promise.reject({ code: "ERR19", message: Lyte.errorCodes.ERR19, data: modelName });
			}
			if (key) {
				this.deleteRecord(modelName, key);
			}
			var deleted = [];
			model._deleted.forEach(function (itm, idx) {
				deleted.push(itm.data);
			});
			if (toFilterRecords) {
				var newDel = [];
				toFilterRecords.forEach(function (itm) {
					var ind = deleted.indexOf(itm);
					if (ind != -1) {
						newDel.push(itm);
					}
				});
				deleted = newDel;
			}
			// for(var i=0; i<model._deleted.length; i++){
			// 	if(!model._deleted[i].$.isNew){
			// 		deleted.push(model._deleted[i]);					
			// 	}
			// 	else{
			// 		// store.adapter.$.handleResponse(model._deleted[i], model._deleted[i], undefined, undefined, model);
			// 	}
			// }
			if (deleted.length) {
				var prm = store.adapter.$.del(modelName, deleted, undefined, "delete", customData, qP, mutationName);
				return prm.then(function (resp) {
					return resp;
				}, function (e) {
					return Promise.reject(e);
				});
				// return prm;
			}
			return Promise.resolve();
		}
	},
	registerAdapter: {
		value: store.adapter.extends
	},
	registerSerializer: {
		value: store.serializer.extends
	},
	// removeCachedQuery: {
	// 	value: function(obj){
	// 		var modelName = obj.modelName,
	// 		key = obj.key,
	// 		params = obj.params,
	// 		cq;
	// 		if(params === undefined){
	// 			if(key !== undefined){
	// 				if(modelName !== undefined){
	// 					var cq = this.model.cachedQueries;
	// 					var crq = this.model.cachedRecordQueries;
	// 					cq && cq.hasOwnProperty(modelName) ? delete cq[modelName] : undefined;
	// 					crq && crq.hasOwnProperty(modelName) ? ( key ? delete crq[modelName][key] : delete crq[modelName] )  : undefined;	
	// 				}
	// 				else{
	// 					this.model.cachedRecordQueries = {};
	// 					this.model.cachedQueries = {};
	// 				}
	// 			}
	// 			else {

	// 			}
	// 		}
	// 	}
	// },
	clearCachedQuery: {
		value: function value(modelName, key, cacheQuery) {
			var isObj = modelName && (typeof modelName === 'undefined' ? 'undefined' : _typeof(modelName)) == "object" ? true : false,
			    qP,
			    obj;
			if (isObj) {
				obj = modelName;
				modelName = obj.modelName;
				key = obj.key;
				qP = cacheQuery = obj.cacheQuery;
			} else {
				if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) == "object") {
					qP = key;
					key = undefined;
				} else if (cacheQuery && (typeof cacheQuery === 'undefined' ? 'undefined' : _typeof(cacheQuery)) == "object") {
					qP = cacheQuery;
				}
			}
			var cachedQueries = [];
			if (!qP) {
				if (modelName) {
					var cq = this.model.cachedQueries;
					var crq = this.model.cachedRecordQueries;
					cq && cq.hasOwnProperty(modelName) ? delete cq[modelName] : undefined;
					crq && crq.hasOwnProperty(modelName) ? key ? delete crq[modelName][key] : delete crq[modelName] : undefined;
				} else {
					this.model.cachedQueries = [];
					this.model.cachedRecordQueries = {};
				}
				return;
			}
			if (qP) {
				if (key == undefined) {
					var cq = this.model.cachedQueries;
					if (cq && cq[modelName]) {
						cachedQueries = cq[modelName];
					}
				} else {
					var crq = this.model.cachedRecordQueries;
					if (crq && crq[modelName] && crq[modelName][key]) {
						cachedQueries = crq[modelName][key];
					}
				}
				for (var i = 0; i < cachedQueries.length; i++) {
					if (this.adapter.$.compareData(cachedQueries[i].cacheQuery, qP, true)) {
						cachedQueries.splice(i, 1);
						break;
					}
				}
			}
		}
	},
	getErrorMessage: {
		value: function value(code) {
			return Lyte.errorCodes[code];
		}
	},
	setErrorMessages: {
		value: function value(obj) {
			Object.assign(Lyte.errorCodes, obj);
		}
	},
	addEventListener: {
		value: function value(type, func) {
			return store.$.eventListeners.add(store, type, func);
		}
	},
	removeEventListener: {
		value: function value(id) {
			store.$.eventListeners.remove(store, id);
		}
	},
	emit: {
		value: function value(type, args) {
			store.$.eventListeners.emit(store, type, args);
		}
	},
	getPrimaryKey: {
		value: function value(modelName) {
			var model = store.model[modelName];
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			}
			return model._pK;
		}
	},
	getDirtyRecords: {
		value: function value(modelName, filters, deepNest) {
			var model = store.modelFor(modelName);
			if (!model) {
				Lyte.warn("LD02", "Model ", modelName);
				return;
			}
			var DirtyKeys = model.dirty,
			    dirtyRecords = [],
			    dirty = { isNew: [], isModified: [], isDeleted: [] };
			for (var i_dirty = 0; i_dirty < DirtyKeys.length; i_dirty++) {
				var record = store.peekRecord(modelName, DirtyKeys[i_dirty]);
				if (record) {
					record.$.isNew ? dirty.isNew.push(record) : dirty.isModified.push(record);
				}
			}
			if (model._deleted.size) {
				var deletedRecord = model._deleted;
				deletedRecord.forEach(function (value) {
					dirty.isDeleted.push(value.data);
				});
			}
			if (model.dirty || model._deleted.size) {
				if (filters == undefined || filters == true) {
					dirtyRecords = dirtyRecords.concat(dirty.isNew, dirty.isModified, dirty.isDeleted);
				}
				if (Array.isArray(filters)) {
					filters.forEach(function (value) {
						dirtyRecords = dirtyRecords.concat(dirty[value]);
					});
				}
				if (typeof filters == "string") {
					dirtyRecords = dirty[filters];
				}
			}
			if (deepNest) {
				var records = store.peekAll(modelName);
				records.forEach(function (rec) {
					if (rec && !rec.$.isNew && !rec.$.isDeleted && rec.$.isDirty() && !dirtyRecords.includes(rec)) {
						dirtyRecords.push(rec);
					}
				});
			}
			return dirtyRecords;
		}
	}
});

var error1 = function error1(attr, obj, message) {
	Object.defineProperties(this, {
		$: {
			value: { isError: true, error: message ? message : {} }
		}
	});
	if (attr) {
		store.$.setError(this, attr, obj);
	}
};